language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard q.count\
    \ == w.reverse() else { return false }\n    guard q.count == w.reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpptiutfmr.swift:28:1393: error: expected member name following '.'\n\
    \    guard q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                "
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n    guard let last = q.last else { return false }\n \
    \   guard first == last else { return false }\n    guard let first = q.first else\
    \ { return false }\n    guard let last = q.last else { return false }\n    guard\
    \ first == last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard first\
    \ == last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard first == last\
    \ else { return false }\n    guard let first = q.first else { return false }\n\
    \    guard let last = q.last else { return false }\n    guard first == last else\
    \ { return false }\n    guard let first = q.first else { return false }\n    guard\
    \ let last = q.last else { return false }\n    guard first == last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard first == last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard first == last else { return false }\n\
    \    guard let first = q.first else { return false }\n    guard let last = q.last\
    \ else { return false }\n    guard first == last else { return false }\n    guard\
    \ let first = q.first else { return false }\n    guard let last = q.last else\
    \ { return false }\n    guard first == last else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvk1_t3p4.swift:61:15: warning: value 'first' was defined but never\
    \ used; consider replacing with boolean test\n    guard let first = q.first else\
    \ { return false }\n          ~~~~^~~~~~~~\n                              != nil\n\
    /tmp/tmpvk1_t3p4.swift:62:1: error: missing return in global function expected\
    \ to return 'Bool'\n}\n^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdhnjwyzt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014266
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    var maxSum = w\n    for element in q {\n        maxSum -= element\n \
    \       if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpno52l8iq/tmpno52l8iq.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae00aaf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae00a7e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae00a7e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae00a7e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpno52l8iq                        0x000055a10ec494bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae00acdd460 __libc_start_main +
    245

    6    tmpno52l8iq                        0x000055a10ec49129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbkw66dcb/tmpbkw66dcb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2dfbccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2df8c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2df8c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2df8c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbkw66dcb                        0x000055b51074546f <unavailable> + 5231

    5    libc.so.6                          0x00002ab2dfdb8460 __libc_start_main +
    245

    6    tmpbkw66dcb                        0x000055b5107450d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ i = q.index(of: q[0]) else { return false }\n    let j = q.index(of: q[q.count\
    \ - 1])\n    let sum = (q[i..<j]).reduce(0) { $0 + $1 }\n    return sum <= w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe5mrp03d.swift:19:21: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let i = q.index(of: q[0]) else { return false\
    \ }\n                    ^\n/tmp/tmpe5mrp03d.swift:19:21: note: use 'firstIndex(of:)'\
    \ instead\n    guard let i = q.index(of: q[0]) else { return false }\n       \
    \             ^~~~~\n                    firstIndex\n/tmp/tmpe5mrp03d.swift:20:15:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    let j\
    \ = q.index(of: q[q.count - 1])\n              ^\n/tmp/tmpe5mrp03d.swift:20:15:\
    \ note: use 'firstIndex(of:)' instead\n    let j = q.index(of: q[q.count - 1])\n\
    \              ^~~~~\n              firstIndex\n/tmp/tmpe5mrp03d.swift:21:22:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    let sum\
    \ = (q[i..<j]).reduce(0) { $0 + $1 }\n                     ^\n/tmp/tmpe5mrp03d.swift:20:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let j = q.index(of: q[q.count - 1])\n        ^\n \
    \   guard                               else { return <#default value#> }\n/tmp/tmpe5mrp03d.swift:20:15:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let j = q.index(of: q[q.count - 1])\n              ^\n          \
    \                              ?? <#default value#>\n/tmp/tmpe5mrp03d.swift:20:15:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let j = q.index(of: q[q.count - 1])\n              ^\n          \
    \                             !\n/tmp/tmpe5mrp03d.swift:21:22: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let sum = (q[i..<j]).reduce(0) { $0 + $1 }\n                     ^\n       \
    \              ( ?? <#default value#>)\n/tmp/tmpe5mrp03d.swift:21:22: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let sum\
    \ = (q[i..<j]).reduce(0) { $0 + $1 }\n                     ^\n               \
    \       !\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q[0]\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \            maxSum = element\n        }\n    }\n    if maxWeight <= w {\n   \
    \     return true\n    }\n    if maxSum > w {\n        return false\n    }\n \
    \   if maxWeight == w {\n        return true\n    }\n    if maxWeight > w {\n\
    \        return false\n    }\n    if maxSum == w {\n        return true\n    }\n\
    \    if maxSum < w {\n        return false\n    }\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp2kcmw7ty/tmp2kcmw7ty.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62513dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62510d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62510d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62510d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2kcmw7ty                        0x000055d904ebe57b <unavailable> + 5499

    5    libc.so.6                          0x00002b62515cb460 __libc_start_main +
    245

    6    tmp2kcmw7ty                        0x000055d904ebe129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 && q.count == q.count && q.count == w.count\
    \ && w == w.reversed().reduce(0) { $0 + $1 } == w else { return false }\n    return\
    \ q == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuwfo8ods.swift:18:66: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    guard w > 0 && q.count == q.count\
    \ && q.count == w.count && w == w.reversed().reduce(0) { $0 + $1 } == w else {\
    \ return false }\n                                                           \
    \      ^                                     ~~\n/tmp/tmpuwfo8ods.swift:18:104:\
    \ error: binary operator '==' cannot be applied to operands of type 'Bool' and\
    \ 'Int'\n    guard w > 0 && q.count == q.count && q.count == w.count && w == w.reversed().reduce(0)\
    \ { $0 + $1 } == w else { return false }\n                                   \
    \                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpuwfo8ods.swift:18:104:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int, Int)\n    guard w > 0 && q.count == q.count && q.count ==\
    \ w.count && w == w.reversed().reduce(0) { $0 + $1 } == w else { return false\
    \ }\n                                                                        \
    \                               ^\n/tmp/tmpuwfo8ods.swift:18:55: error: value\
    \ of type 'Int' has no member 'count'\n    guard w > 0 && q.count == q.count &&\
    \ q.count == w.count && w == w.reversed().reduce(0) { $0 + $1 } == w else { return\
    \ false }\n                                                    ~ ^~~~~\n/tmp/tmpuwfo8ods.swift:18:71:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard w > 0 && q.count\
    \ == q.count && q.count == w.count && w == w.reversed().reduce(0) { $0 + $1 }\
    \ == w else { return false }\n                                               \
    \                     ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0co2ricr/tmp0co2ricr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63a3c4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63a3943b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63a3943988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63a39427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0co2ricr                        0x00005649697ae3bb <unavailable> + 5051

    5    libc.so.6                          0x00002b63a3e38460 __libc_start_main +
    245

    6    tmp0co2ricr                        0x00005649697adf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.reduce(0, +)\n\
    \    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa931avsy/tmpa931avsy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99de108c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99dddffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99dddff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99dddfe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa931avsy                        0x000055679346243b <unavailable> + 5179

    5    libc.so.6                          0x00002b99de2f4460 __libc_start_main +
    245

    6    tmpa931avsy                        0x0000556793461fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.map { $0 + $1 }.reduce(0)\
    \ { $0 + $1 }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpae2m21n4.swift:19:24: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let maxSum\
    \ = q.map { $0 + $1 }.reduce(0) { $0 + $1 }\n                       ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[1] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[1] == q[2]\
    \ && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] &&\
    \ q[4] == q[5] && q[5] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6]\
    \ && q[6] == q[7] && q[7] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwsqfy073/tmpwsqfy073.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe4e65fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe4e356b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe4e356988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe4e3557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwsqfy073                        0x000055ff1675c3af <unavailable> + 5039

    5    libc.so.6                          0x00002afe4e84b460 __libc_start_main +
    245

    6    tmpwsqfy073                        0x000055ff1675c019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let maxWeight = w *\
    \ w\n    return a.last! >= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvkcc114d.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    var\
    \ maxSum = w\n    for v in q {\n        maxSum -= v\n        if maxSum < 0 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4tihddbu.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqbd6a9m0/tmpqbd6a9m0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e4ae0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e4ab04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e4ab04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e4ab037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbd6a9m0                        0x0000559dfb39d46f <unavailable> + 5231

    5    libc.so.6                          0x00002b3e4aff9460 __libc_start_main +
    245

    6    tmpqbd6a9m0                        0x0000559dfb39d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0co2ricr/tmp0co2ricr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63a3c4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63a3943b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63a3943988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63a39427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0co2ricr                        0x00005649697ae3bb <unavailable> + 5051

    5    libc.so.6                          0x00002b63a3e38460 __libc_start_main +
    245

    6    tmp0co2ricr                        0x00005649697adf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let max = a.max()\n\
    \    return a.count == 1 && a[0] == max && a.first == max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdyz4t139.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumValue\
    \ = 0\n    var maxSumIndex2 = 0\n    var maxSumValue2 = 0\n    var maxSumIndex3\
    \ = 0\n    var maxSumValue3 = 0\n    var maxSumIndex4 = 0\n    var maxSumValue4\
    \ = 0\n    var maxSumIndex5 = 0\n    var maxSumValue5 = 0\n    var maxSumIndex6\
    \ = 0\n    var maxSumValue6 = 0\n    var maxSumIndex7 = 0\n    var maxSumValue7\
    \ = 0\n    var maxSumIndex8 = 0\n    var maxSumValue8 = 0\n    var maxSumIndex9\
    \ = 0\n    var maxSumValue9 = 0\n    var maxSumIndex10 = 0\n    var maxSumValue10\
    \ = 0\n    var maxSumIndex11 = 0\n    var maxSumValue11 = 0\n    var maxSumIndex12\
    \ = 0\n    var maxSumValue12 = 0\n    var maxSumIndex13 = 0\n    var maxSumValue13\
    \ = 0\n    var maxSumIndex14 = 0\n    var maxSumValue14 = 0\n    var maxSumIndex15\
    \ = 0\n    var maxSumValue15 = 0\n    var maxSumIndex16 = 0\n    var maxSumValue16\
    \ = 0\n    var maxSumIndex17 = 0\n    var maxSumValue17 = 0\n    var maxSumIndex18\
    \ = 0\n    var maxSumValue18 = 0\n    var maxSumIndex19 = 0\n    var maxSumValue19\
    \ = 0\n    var maxSumIndex20 = 0\n    var maxSumValue20 = 0\n    var maxSumIndex21\
    \ = 0\n    var maxSumValue21 = 0\n    var maxSumIndex22 = 0\n    var maxSumValue22\
    \ = 0\n    var maxSumIndex23 = 0\n    var maxSumValue23 = 0\n    var maxSumIndex24\
    \ = 0\n    var maxSumValue24 = 0\n    var maxSumIndex25 = 0\n    var maxSumValue25\
    \ = 0\n    var maxSumIndex26 = 0\n    var maxSumValue26 = 0\n    var maxSumIndex27\
    \ = 0\n    var maxSumValue27 = 0\n    var maxSumIndex28 = 0\n    var maxSumValue28\
    \ = 0\n    var maxSumIndex29 = 0\n    var maxSumValue29 = 0\n    var maxSumIndex30\
    \ = 0\n    var maxSumValue30 = 0\n    var maxSumIndex31 = 0\n    var maxSumValue31\
    \ = 0\n    var maxSumIndex32 = 0\n    var maxSumValue32 = 0\n    var maxSumIndex33\
    \ = 0\n    var maxSumValue33 = 0\n    var maxSumIndex34 = 0\n    var maxSumValue34\
    \ = 0\n    var maxSumIndex35 = 0\n    var maxSumValue35 = 0\n    var maxSumIndex36\
    \ = 0\n    var maxSumValue36 = 0\n    var maxSumIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3ho_4641.swift:91:9: error: type annotation missing in pattern\n\
    \    var maxSumIndex\n        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \    }\n    if maxSum < 0 {\n        return false\n    }\n    var sum = 0\n  \
    \  for x in q {\n        sum += x\n    }\n    return sum <= maxSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkhln4pc7/tmpkhln4pc7.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cd9b52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cd9849b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cd9849988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cd98487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhln4pc7                        0x000055dcc309446f <unavailable> + 5231

    5    libc.so.6                          0x00002b9cd9d3e460 __libc_start_main +
    245

    6    tmpkhln4pc7                        0x000055dcc30940d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = 0\n    var isBalanced = true\n    for i := 0; i < len(q); i++ {\n        if\
    \ q[i] > maxSumElement {\n            maxSumElement = q[i]\n            maxSumIndex\
    \ = i\n        }\n    }\n    for i := 0; i < len(q); i++ {\n        if q[i] >\
    \ maxSum {\n            maxSum = q[i]\n            maxSumIndex = i\n        }\n\
    \    }\n    if maxSum < w {\n        isBalanced = false\n    }\n    if isBalanced\
    \ {\n        for i := 0; i < len(q); i++ {\n            if q[i] > maxSum {\n \
    \               maxSum = q[i]\n                maxSumIndex = i\n            }\n\
    \        }\n    }\n    return maxSumIndex == len(q) - 1 && maxSum == w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwsk_ut28.swift:22:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpwsk_ut28.swift:22:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpwsk_ut28.swift:22:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpwsk_ut28.swift:28:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpwsk_ut28.swift:28:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpwsk_ut28.swift:28:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n/tmp/tmpwsk_ut28.swift:38:16: error: expected type\n  \
    \      for i := 0; i < len(q); i++ {\n               ^\n                <#type#>\n\
    /tmp/tmpwsk_ut28.swift:38:16: error: expected 'in' after for-each pattern\n  \
    \      for i := 0; i < len(q); i++ {\n               ^\n/tmp/tmpwsk_ut28.swift:38:16:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < len(q); i++ {\n               ^\n/tmp/tmpwsk_ut28.swift:45:27: error: cannot\
    \ find 'len' in scope\n    return maxSumIndex == len(q) - 1 && maxSum == w\n \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard q.isPalindromic\
    \ else { return false }\n    guard q.sum() <= w else { return false }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9dx19dri.swift:19:13: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    guard q.isPalindromic else { return false }\n         \
    \ ~ ^~~~~~~~~~~~~\n/tmp/tmp9dx19dri.swift:20:13: error: value of type '[Int]'\
    \ has no member 'sum'\n    guard q.sum() <= w else { return false }\n        \
    \  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumIndex2\
    \ = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4 = 0\n    var maxSumIndex5\
    \ = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7 = 0\n    var maxSumIndex8\
    \ = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10 = 0\n    var maxSumIndex11\
    \ = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13 = 0\n    var maxSumIndex14\
    \ = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16 = 0\n    var maxSumIndex17\
    \ = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19 = 0\n    var maxSumIndex20\
    \ = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22 = 0\n    var maxSumIndex23\
    \ = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25 = 0\n    var maxSumIndex26\
    \ = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28 = 0\n    var maxSumIndex29\
    \ = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31 = 0\n    var maxSumIndex32\
    \ = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34 = 0\n    var maxSumIndex35\
    \ = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37 = 0\n    var maxSumIndex38\
    \ = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40 = 0\n    var maxSumIndex41\
    \ = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43 = 0\n    var maxSumIndex44\
    \ = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46 = 0\n    var maxSumIndex47\
    \ = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49 = 0\n    var maxSumIndex50\
    \ = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52 = 0\n    var maxSumIndex53\
    \ = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55 = 0\n    var maxSumIndex56\
    \ = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58 = 0\n    var maxSumIndex59\
    \ = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61 = 0\n    var maxSumIndex62\
    \ = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64 = 0\n    var maxSumIndex65\
    \ = 0\n    var maxSumIndex66 = 0\n    var maxSumIndex67 = 0\n    var maxSumIndex68\
    \ = 0\n    var maxSumIndex69 = 0\n    var maxSumIndex70 = 0\n    var maxSumIndex71\
    \ = 0\n    var maxSumIndex72 = 0\n    var maxSum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpybbdzbkb.swift:91:9: error: type annotation missing in pattern\n\
    \    var maxSum\n        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropFirst(), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoysn4qz2.swift:21:39: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return a == b && will_it_fly(q: q.dropFirst(),\
    \ w: w)\n                                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.fold(0,\
    \ +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpma22ou9e.swift:19:27: error: value of type '[Int]' has no member\
    \ 'fold'\n    let sumOfElements = q.fold(0, +)\n                        ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ r = q.decompose(), r.count == w else { return false }\n    let maxWeight = w\
    \ * w\n    return r.isPalindromic && r.sum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplj_wrmv3.swift:19:21: error: value of type '[Int]' has no member\
    \ 'decompose'\n    guard let r = q.decompose(), r.count == w else { return false\
    \ }\n                  ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    var\
    \ max = 0\n    for x in q {\n        max = max(max, x)\n    }\n    if max < w\
    \ {\n        return false\n    }\n    var sum = 0\n    for x in q {\n        sum\
    \ += x\n    }\n    if sum < w {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphxapd4x1.swift:23:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdhnjwyzt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014266
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfgc_yig8.swift:67:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpfgc_yig8.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpfgc_yig8.swift:19:40: error: value of type 'Int' has no member\
    \ 'reversed'\n    guard q.count == 0 || q.count == w.reversed().count else { return\
    \ false }\n                                     ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:20:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().count else { return false }\n                   \
    \                  ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:21:40: error: value of type\
    \ 'Int' has no member 'reversed'\n    guard q.count == 0 || q.count == w.reversed().count\
    \ else { return false }\n                                     ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:22:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().count else { return false }\n                   \
    \                  ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:23:40: error: value of type\
    \ 'Int' has no member 'reversed'\n    guard q.count == 0 || q.count == w.reversed().count\
    \ else { return false }\n                                     ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:24:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().count else { return false }\n                   \
    \                  ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:25:40: error: value of type\
    \ 'Int' has no member 'reversed'\n    guard q.count == 0 || q.count == w.reversed().count\
    \ else { return false }\n                                     ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:26:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().count else { return false }\n                   \
    \                  ~ ^~~~~~~~\n/tmp/tmpfgc_yig8.swift:27:40: error: value of type\
    \ 'Int' has no member "
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqwfq64_v/tmpqwfq64_v.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b392baa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b392b79db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b392b79d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b392b79c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqwfq64_v                        0x0000562bdea5746f <unavailable> + 5231

    5    libc.so.6                          0x00002b392bc92460 __libc_start_main +
    245

    6    tmpqwfq64_v                        0x0000562bdea570d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbkw66dcb/tmpbkw66dcb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2dfbccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2df8c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2df8c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2df8c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbkw66dcb                        0x000055b51074546f <unavailable> + 5231

    5    libc.so.6                          0x00002ab2dfdb8460 __libc_start_main +
    245

    6    tmpbkw66dcb                        0x000055b5107450d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    let\
    \ maxWeight = w * q[q.count-1]\n    let maxSum = q.map({ $0 + $1 }).reduce({ $0\
    \ + $1 })\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2zzhqntz.swift:22:24: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let maxSum\
    \ = q.map({ $0 + $1 }).reduce({ $0 + $1 })\n                       ^\n/tmp/tmp2zzhqntz.swift:22:55:\
    \ error: missing argument for parameter #2 in call\n    let maxSum = q.map({ $0\
    \ + $1 }).reduce({ $0 + $1 })\n                                              \
    \        ^\n                                                      , <#(@escaping\
    \ (Int, Int) -> Int, Int) throws -> (Int, Int) -> Int#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var sum\
    \ = 0\n    for i in q {\n        sum += i\n    }\n    return sum <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprcq6sdus/tmprcq6sdus.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1608f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1605ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1605ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1605eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprcq6sdus                        0x000055e7123c14bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae160ae1460 __libc_start_main +
    245

    6    tmprcq6sdus                        0x000055e7123c1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = 0\n    for i := 0;\
    \ i < len(q); i++ {\n        maxSum += q[i]\n        if maxSum > maxWeight {\n\
    \            maxSum = maxWeight\n            maxWeight = w\n        }\n    }\n\
    \    if maxSum < w {\n        return false\n    }\n    for i := 0; i < len(q);\
    \ i++ {\n        if q[i] > maxWeight {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnot9q8oa.swift:20:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpnot9q8oa.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpnot9q8oa.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpnot9q8oa.swift:30:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpnot9q8oa.swift:30:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpnot9q8oa.swift:30:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted() else { return false }\n    var\
    \ maxWeight = w\n    var sum = 0\n    for element in q {\n        sum += element\n\
    \        if sum > maxWeight {\n            maxWeight = sum\n        }\n    }\n\
    \    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpid1kltdp.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else { return\
    \ false }\n          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var max\
    \ = 0\n    for i in q {\n        max += i\n    }\n    return max == w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpz4bsn27o/tmpz4bsn27o.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1086a43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b108673ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b108673a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10867397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz4bsn27o                        0x000055f667dc54bf <unavailable> + 5311

    5    libc.so.6                          0x00002b1086c2f460 __libc_start_main +
    245

    6    tmpz4bsn27o                        0x000055f667dc5129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for element in q {\n        maxSum -= element\n        if maxSum <\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb9unit6f/tmpb9unit6f.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5e2dbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5e2ab6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5e2ab6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5e2ab57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9unit6f                        0x000055abfc1374bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae5e2fab460 __libc_start_main +
    245

    6    tmpb9unit6f                        0x000055abfc137129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    if q.count == 0 || w\
    \ == 0 {\n        return true\n    }\n    var maxSum = w\n    for element in q\
    \ {\n        maxSum = maxSum - element\n    }\n    if maxSum < 0 {\n        return\
    \ false\n    }\n    var sum = 0\n    for element in q {\n        sum = sum + element\n\
    \    }\n    if sum == w {\n        return true\n    }\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp2kibd3er/tmp2kibd3er.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af637086c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af636d7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af636d7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af636d7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2kibd3er                        0x000055ca3fcc64bf <unavailable> + 5311

    5    libc.so.6                          0x00002af637272460 __libc_start_main +
    245

    6    tmp2kibd3er                        0x000055ca3fcc6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.reduce(0) { (max,\
    \ v) -> (Int, Int) -> Int in\n        let (max, min) = max\n        return max\
    \ + (v - min) <= maxWeight\n    }.1 == true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpytlwtfsk.swift:20:26: error: cannot convert value of type '(Int,\
    \ Int) -> Int' to specified type '(_, _)'\n        let (max, min) = max\n    \
    \                     ^~~\n/tmp/tmpytlwtfsk.swift:22:7: error: value of type 'Double'\
    \ has no member '1'\n    }.1 == true\n~~~~~ ^\n/tmp/tmpytlwtfsk.swift:19:24: error:\
    \ cannot convert value of type '(@escaping (Int, Int) -> Int, Int) -> (Int, Int)\
    \ -> Int' to expected argument type '(Double, Int) throws -> Double'\n    return\
    \ q.reduce(0) { (max, v) -> (Int, Int) -> Int in\n                       ^\n/tmp/tmpytlwtfsk.swift:19:38:\
    \ error: declared closure result '(Int, Int) -> Int' is incompatible with contextual\
    \ type 'Double'\n    return q.reduce(0) { (max, v) -> (Int, Int) -> Int in\n \
    \                                    ^~~~~~~~~~~~~~~~~\n                     \
    \                Double\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.map({\
    \ $0 + $1 }).reduce(0, +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv5d43x8c.swift:19:31: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let sumOfElements\
    \ = q.map({ $0 + $1 }).reduce(0, +)\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.maxElement()\n\
    \    return q.count == maxSum && q.count == maxWeight && q.sorted() == q.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp47f9gyax.swift:19:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let mid = q.mid(at: 0) else { return false }\n    guard let\
    \ mid2 = q.mid(at: 1) else { return false }\n    guard let mid3 = q.mid(at: 2)\
    \ else { return false }\n    guard let mid4 = q.mid(at: 3) else { return false\
    \ }\n    guard let mid5 = q.mid(at: 4) else { return false }\n    guard let mid6\
    \ = q.mid(at: 5) else { return false }\n    guard let mid7 = q.mid(at: 6) else\
    \ { return false }\n    guard let mid8 = q.mid(at: 7) else { return false }\n\
    \    guard let mid9 = q.mid(at: 8) else { return false }\n    guard let mid10\
    \ = q.mid(at: 9) else { return false }\n    guard let mid11 = q.mid(at: 10) else\
    \ { return false }\n    guard let mid12 = q.mid(at: 11) else { return false }\n\
    \    guard let mid13 = q.mid(at: 12) else { return false }\n    guard let mid14\
    \ = q.mid(at: 13) else { return false }\n    guard let mid15 = q.mid(at: 14) else\
    \ { return false }\n    guard let mid16 = q.mid(at: 15) else { return false }\n\
    \    guard let mid17 = q.mid(at: 16) else { return false }\n    guard let mid18\
    \ = q.mid(at: 17) else { return false }\n    guard let mid19 = q.mid(at: 18) else\
    \ { return false }\n    guard let mid20 = q.mid(at: 19) else { return false }\n\
    \    guard let mid21 = q.mid(at: 20) else { return false }\n    guard let mid22\
    \ = q.mid(at: 21) else { return false }\n    guard let mid23 = q.mid(at: 22) else\
    \ { return false }\n    guard let mid24 = q.mid(at: 23) else { return false }\n\
    \    guard let mid25 = q.mid(at: 24) else { return false }\n    guard let mid26\
    \ = q.mid(at: 25) else { return false }\n    guard let mid27 = q.mid(at: 26) else\
    \ { return false }\n    gu\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe6ymd3rs.swift:21:23: error: value of type '[Int]' has no member\
    \ 'mid'\n    guard let mid = q.mid(at: 0) else { return false }\n            \
    \        ~ ^~~\n/tmp/tmpe6ymd3rs.swift:22:24: error: value of type '[Int]' has\
    \ no member 'mid'\n    guard let mid2 = q.mid(at: 1) else { return false }\n \
    \                    ~ ^~~\n/tmp/tmpe6ymd3rs.swift:23:24: error: value of type\
    \ '[Int]' has no member 'mid'\n    guard let mid3 = q.mid(at: 2) else { return\
    \ false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:24:24: error: value\
    \ of type '[Int]' has no member 'mid'\n    guard let mid4 = q.mid(at: 3) else\
    \ { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:25:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid5 = q.mid(at:\
    \ 4) else { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:26:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid6 = q.mid(at:\
    \ 5) else { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:27:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid7 = q.mid(at:\
    \ 6) else { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:28:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid8 = q.mid(at:\
    \ 7) else { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:29:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid9 = q.mid(at:\
    \ 8) else { return false }\n                     ~ ^~~\n/tmp/tmpe6ymd3rs.swift:30:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid10 = q.mid(at:\
    \ 9) else { return false }\n                      ~ ^~~\n/tmp/tmpe6ymd3rs.swift:31:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid11 = q.mid(at:\
    \ 10) else { return false }\n                      ~ ^~~\n/tmp/tmpe6ymd3rs.swift:32:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid12 = q.mid(at:\
    \ 11) else { return false }\n                      ~ ^~~\n/tmp/tmpe6ymd3rs.swift:33:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid13"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 else { return false }\n    guard q.count\
    \ == 0 || q.count == 1 || q.count == w.count else { return false }\n    guard\
    \ q.count == 0 || q.count == 1 || q.count == w.count else { return false }\n \
    \   guard q.count == 0 || q.count == 1 || q.count == w.count else { return false\
    \ }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else { return\
    \ false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else {\
    \ return false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count\
    \ else { return false }\n    guard q.count == 0 || q.count == 1 || q.count ==\
    \ w.count else { return false }\n    guard q.count == 0 || q.count == 1 || q.count\
    \ == w.count else { return false }\n    guard q.count == 0 || q.count == 1 ||\
    \ q.count == w.count else { return false }\n    guard q.count == 0 || q.count\
    \ == 1 || q.count == w.count else { return false }\n    guard q.count == 0 ||\
    \ q.count == 1 || q.count == w.count else { return false }\n    guard q.count\
    \ == 0 || q.count == 1 || q.count == w.count else { return false }\n    guard\
    \ q.count == 0 || q.count == 1 || q.count == w.count else { return false }\n \
    \   guard q.count == 0 || q.count == 1 || q.count == w.count else { return false\
    \ }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else { return\
    \ false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else {\
    \ return false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count\
    \ else { return false }\n    guard q.count == 0 || q.count == 1 || q.count ==\
    \ w.count else { return false }\n    guard q.count == 0 || q.count == 1 || q.count\
    \ == w.count else { return false }\n    guard q.count == 0 || q.count == 1 ||\
    \ q.count == w.count else { return false }\n    guard q.count == 0 || q.count\
    \ == 1 || q.count == w.count else { return false }\n    guard q.count == 0 ||\
    \ q.count == 1 || q.count == w.count else { return false }\n    guard q.count\
    \ == 0 || q.count == 1 || q.count == w.count else { return false }\n    guard\
    \ q.count == 0 || q.count == 1 || q.count == w.count else { return false }\n \
    \   guard q.count == 0 || q.count == 1 || q.count == w.count else { return false\
    \ }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else { return\
    \ false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count else {\
    \ return false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count\
    \ else { return false \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoli3mtff.swift:67:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpoli3mtff.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpoli3mtff.swift:19:56: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == 0 || q.count == 1 || q.count == w.count else {\
    \ return false }\n                                                     ~ ^~~~~\n\
    /tmp/tmpoli3mtff.swift:20:56: error: value of type 'Int' has no member 'count'\n\
    \    guard q.count == 0 || q.count == 1 || q.count == w.count else { return false\
    \ }\n                                                     ~ ^~~~~\n/tmp/tmpoli3mtff.swift:21:56:\
    \ error: value of type 'Int' has no member 'count'\n    guard q.count == 0 ||\
    \ q.count == 1 || q.count == w.count else { return false }\n                 \
    \                                    ~ ^~~~~\n/tmp/tmpoli3mtff.swift:22:56: error:\
    \ value of type 'Int' has no member 'count'\n    guard q.count == 0 || q.count\
    \ == 1 || q.count == w.count else { return false }\n                         \
    \                            ~ ^~~~~\n/tmp/tmpoli3mtff.swift:23:56: error: value\
    \ of type 'Int' has no member 'count'\n    guard q.count == 0 || q.count == 1\
    \ || q.count == w.count else { return false }\n                              \
    \                       ~ ^~~~~\n/tmp/tmpoli3mtff.swift:24:56: error: value of\
    \ type 'Int' has no member 'count'\n    guard q.count == 0 || q.count == 1 ||\
    \ q.count == w.count else { return false }\n                                 \
    \                    ~ ^~~~~\n/tmp/tmpoli3mtff.swift:25:56: error: value of type\
    \ 'Int' has no member 'count'\n    guard q.count == 0 || q.count == 1 || q.count\
    \ == w.count else { return false }\n                                         \
    \            ~ ^~~~~\n/tmp/tmpoli3mtff.swift:26:56: error: value of type 'Int'\
    \ has no member 'count'\n    guard q.count == 0 || q.count == 1 || q.count ==\
    \ w.count else { return false }\n            "
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    if sum < w {\n        return false\n    }\n    if sum > w {\n       \
    \ return true\n    }\n    if sum == w {\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjuancujb/tmpjuancujb.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81a7bc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81a78bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81a78bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81a78bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjuancujb                        0x000056082c76c46f <unavailable> + 5231

    5    libc.so.6                          0x00002b81a7db2460 __libc_start_main +
    245

    6    tmpjuancujb                        0x000056082c76c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() {\n        return a.count == w && a.reduce(0, +) <= w\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_98861j9.swift:19:30: error: expected 'else' after 'guard' condition\n\
    \    guard let a = q.sorted() {\n                             ^\n            \
    \                 else \n/tmp/tmp_98861j9.swift:20:16: error: cannot find 'a'\
    \ in scope\n        return a.count == w && a.reduce(0, +) <= w\n             \
    \  ^\n/tmp/tmp_98861j9.swift:20:32: error: cannot find 'a' in scope\n        return\
    \ a.count == w && a.reduce(0, +) <= w\n                               ^\n/tmp/tmp_98861j9.swift:19:11:\
    \ error: initializer for conditional binding must have Optional type, not '[Int]'\n\
    \    guard let a = q.sorted() {\n          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q == reverse(q.prefix(q.count))\
    \ && q.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9km1i909.swift:19:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.prefix(q.count)) && q.sum() <= maxWeight\n         \
    \       ^~~~~~~\n/tmp/tmp9km1i909.swift:19:49: error: value of type '[Int]' has\
    \ no member 'sum'\n    return q == reverse(q.prefix(q.count)) && q.sum() <= maxWeight\n\
    \                                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropLast(), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkz8wyggr/tmpkz8wyggr.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8347890c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8347587b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8347587988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83475867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkz8wyggr                        0x000055ba829164ef <unavailable> + 5359

    5    libc.so.6                          0x00002b8347a7c460 __libc_start_main +
    245

    6    tmpkz8wyggr                        0x000055ba82916159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk88j5so1.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpk88j5so1.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpk88j5so1.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpk88j5so1.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpk88j5so1.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpk88j5so1.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpk88j5so1.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpk88j5so1.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpk88j5so1.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpk88j5so1.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpk88j5so1.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum <= 0 {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu2z99n2x/tmpu2z99n2x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b982ef07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b982ebfeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b982ebfe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b982ebfd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu2z99n2x                        0x000055b57fa9552b <unavailable> + 5419

    5    libc.so.6                          0x00002b982f0f3460 __libc_start_main +
    245

    6    tmpu2z99n2x                        0x000055b57fa950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[1] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[1] == q[2]\
    \ && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] &&\
    \ q[4] == q[5] && q[5] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6]\
    \ && q[6] == q[7] && q[7] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwsqfy073/tmpwsqfy073.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe4e65fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe4e356b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe4e356988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe4e3557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwsqfy073                        0x000055ff1675c3af <unavailable> + 5039

    5    libc.so.6                          0x00002afe4e84b460 __libc_start_main +
    245

    6    tmpwsqfy073                        0x000055ff1675c019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted() else {\n        return false\n    }\n    var sum = 0\n    var\
    \ max = 0\n    for x in q {\n        sum += x\n        if sum > max {\n      \
    \      max = sum\n        }\n    }\n    return sum == max && q == q.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1r4isfii.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9kjp3xtm/tmp9kjp3xtm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5386c16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b538690db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b538690d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b538690c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9kjp3xtm                        0x000055a6bb9be52b <unavailable> + 5419

    5    libc.so.6                          0x00002b5386e02460 __libc_start_main +
    245

    6    tmp9kjp3xtm                        0x000055a6bb9be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    let maxSumOfElements\
    \ = q.sumOfElements\n    return maxWeight <= maxSum && maxSumOfElements <= maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpul_rr06i.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpul_rr06i.swift:20:30:\
    \ error: value of type '[Int]' has no member 'sumOfElements'\n    let maxSumOfElements\
    \ = q.sumOfElements\n                           ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reverse() else { return false }\n    guard q.count == 0\
    \ || q.count == w.reverse().reverse() else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reverse().reverse().reverse() else { return false }\n \
    \   guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqrh2kqgc.swift:35:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n/tmp/tmpqrh2kqgc.swift:19:40:\
    \ error: value of type 'Int' has no member 'reverse'\n    guard q.count == 0 ||\
    \ q.count == w.reverse() else { return false }\n                             \
    \        ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:20:40: error: value of type 'Int' has\
    \ no member 'reverse'\n    guard q.count == 0 || q.count == w.reverse().reverse()\
    \ else { return false }\n                                     ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:21:40:\
    \ error: value of type 'Int' has no member 'reverse'\n    guard q.count == 0 ||\
    \ q.count == w.reverse().reverse().reverse() else { return false }\n         \
    \                            ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:22:40: error: value\
    \ of type 'Int' has no member 'reverse'\n    guard q.count == 0 || q.count ==\
    \ w.reverse().reverse().reverse().reverse() else { return false }\n          \
    \                           ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:23:40: error: value\
    \ of type 'Int' has no member 'reverse'\n    guard q.count == 0 || q.count ==\
    \ w.reverse().reverse().reverse().reverse().reverse() else { return false }\n\
    \                                     ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:24:40:\
    \ error: value of type 'Int' has no member 'reverse'\n    guard q.count == 0 ||\
    \ q.count == w.reverse().reverse().reverse().reverse().reverse().reverse() else\
    \ { return false }\n                                     ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:25:40:\
    \ error: value of type 'Int' has no member 'reverse'\n    guard q.count == 0 ||\
    \ q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n                                     ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:26:40:\
    \ error: value of type 'Int' has no member 'reverse'\n    guard q.count == 0 ||\
    \ q.count == w.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse()\
    \ else { return false }\n                                     ~ ^~~~~~~\n/tmp/tmpqrh2kqgc.swift:27:40:\
    \ error: value of type 'Int' h"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for element in q {\n        maxSum -= element\n        if maxSum <\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb9unit6f/tmpb9unit6f.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5e2dbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5e2ab6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5e2ab6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5e2ab57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9unit6f                        0x000055abfc1374bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae5e2fab460 __libc_start_main +
    245

    6    tmpb9unit6f                        0x000055abfc137129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    \n    let maxWeight = w * w\n    \n    return q.reduce(0) { (sum, item)\
    \ -> Bool in\n        return sum + item <= maxWeight\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph9c7bswh.swift:24:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { (sum, item) -> Bool in\n \
    \            ^\n           (\n/tmp/tmph9c7bswh.swift:24:41: error: declared closure\
    \ result 'Bool' is incompatible with contextual type 'Int'\n    return q.reduce(0)\
    \ { (sum, item) -> Bool in\n                                        ^~~~\n   \
    \                                     Int\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    var sum = 0\n    for element in q {\n        sum += element\n    }\n\
    \    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpr0t4hlmw/tmpr0t4hlmw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51edc02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51ed8f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51ed8f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51ed8f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr0t4hlmw                        0x00005566d68be4bf <unavailable> + 5311

    5    libc.so.6                          0x00002b51eddee460 __libc_start_main +
    245

    6    tmpr0t4hlmw                        0x00005566d68be129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let maxSum = maxWeight + w\n\
    \    let sumOfElements = q.sum() // O(n)\n    return maxSum - sumOfElements <=\
    \ maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9dq18cbw.swift:20:27: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sumOfElements = q.sum() // O(n)\n                        ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let maxWeight = w *\
    \ q.reduce(0) { $0 + $1 }\n    return a.count == w && maxWeight <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps9oggbn2.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.filter{ $0 < maxWeight\
    \ }.sum()\n    for element in q {\n        if element > maxWeight {\n        \
    \    maxWeight = element\n            maxSum = element\n        }\n    }\n   \
    \ return maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp416tbz12.swift:19:45: error: value of type '[Int]' has no member\
    \ 'sum'\n    var maxSum = q.filter{ $0 < maxWeight }.sum()\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q.reduce(0) { $0 + ($1 * $1) <= maxWeight }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr0d_f_vv.swift:20:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { $0 + ($1 * $1) <= maxWeight\
    \ }\n             ^\n           (                                           !=\
    \ 0)\n/tmp/tmpr0d_f_vv.swift:20:41: error: cannot convert value of type 'Bool'\
    \ to closure result type 'Int'\n    return q.reduce(0) { $0 + ($1 * $1) <= maxWeight\
    \ }\n                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    guard let a = q.sorted() {\n        return true\n    }\n    return a.sum()\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzx82b7x4.swift:21:30: error: expected 'else' after 'guard' condition\n\
    \    guard let a = q.sorted() {\n                             ^\n            \
    \                 else \n/tmp/tmpzx82b7x4.swift:21:11: error: initializer for\
    \ conditional binding must have Optional type, not '[Int]'\n    guard let a =\
    \ q.sorted() {\n          ^       ~~~~~~~~~~\n/tmp/tmpzx82b7x4.swift:24:14: error:\
    \ value of type '[Int]' has no member 'sum'\n    return a.sum() <= w\n       \
    \    ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    guard a < b else { return false }\n    guard let sum = q.sum() else {\
    \ return false }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbeeft_fz.swift:22:23: error: value of type '[Int]' has no member\
    \ 'sum'\n    guard let sum = q.sum() else { return false }\n                 \
    \   ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0) { $0\
    \ + $1 }\n    for element in q {\n        maxWeight = maxWeight - element\n  \
    \      if maxWeight <= 0 {\n            return false\n        }\n        maxSum\
    \ = maxSum + element\n    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp176zkf1k/tmp176zkf1k.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31a3344c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31a303bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31a303b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31a303a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp176zkf1k                        0x00005565af9b34df <unavailable> + 5343

    5    libc.so.6                          0x00002b31a3530460 __libc_start_main +
    245

    6    tmp176zkf1k                        0x00005565af9b3149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdhnjwyzt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014266
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ r = q.reversed(), r.count == w else { return false }\n    return r.isPalindromic\
    \ && r.sum() <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx70ljlfx.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not 'ReversedCollection<[Int]>'\n    guard let r =\
    \ q.reversed(), r.count == w else { return false }\n          ^       ~~~~~~~~~~~~\n\
    /tmp/tmpx70ljlfx.swift:20:14: error: value of type 'ReversedCollection<[Int]>'\
    \ has no member 'isPalindromic'\n    return r.isPalindromic && r.sum() <= w\n\
    \           ~ ^~~~~~~~~~~~~\n/tmp/tmpx70ljlfx.swift:20:33: error: value of type\
    \ 'ReversedCollection<[Int]>' has no member 'sum'\n    return r.isPalindromic\
    \ && r.sum() <= w\n                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    let maxSumOfElements\
    \ = q.sumOfElements\n    return maxSumOfElements <= maxWeight && maxSum == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnhs0mfbc.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpnhs0mfbc.swift:20:30:\
    \ error: value of type '[Int]' has no member 'sumOfElements'\n    let maxSumOfElements\
    \ = q.sumOfElements\n                           ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let maxWeight = w *\
    \ w\n    return a.count == w && a.last == w && a.first == w && a.dropLast().reduce(0)\
    \ { $0 + $1 } <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6xn728h3.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let maxWeight = w *\
    \ w\n    return a.count == w && a.last == w && a.first == w && a.dropLast().reduce(0)\
    \ { $0 + $1 } <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6xn728h3.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumIndex2\
    \ = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4 = 0\n    var maxSumIndex5\
    \ = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7 = 0\n    var maxSumIndex8\
    \ = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10 = 0\n    var maxSumIndex11\
    \ = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13 = 0\n    var maxSumIndex14\
    \ = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16 = 0\n    var maxSumIndex17\
    \ = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19 = 0\n    var maxSumIndex20\
    \ = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22 = 0\n    var maxSumIndex23\
    \ = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25 = 0\n    var maxSumIndex26\
    \ = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28 = 0\n    var maxSumIndex29\
    \ = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31 = 0\n    var maxSumIndex32\
    \ = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34 = 0\n    var maxSumIndex35\
    \ = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37 = 0\n    var maxSumIndex38\
    \ = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40 = 0\n    var maxSumIndex41\
    \ = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43 = 0\n    var maxSumIndex44\
    \ = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46 = 0\n    var maxSumIndex47\
    \ = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49 = 0\n    var maxSumIndex50\
    \ = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52 = 0\n    var maxSumIndex53\
    \ = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55 = 0\n    var maxSumIndex56\
    \ = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58 = 0\n    var maxSumIndex59\
    \ = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61 = 0\n    var maxSumIndex62\
    \ = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64 = 0\n    var maxSumIndex65\
    \ = 0\n    var maxSumIndex66 = 0\n    var maxSumIndex67 = 0\n    var maxSumIndex68\
    \ = 0\n    var maxSumIndex69 = 0\n    var maxSumIndex70 = 0\n    var maxSumIndex71\
    \ = 0\n    var maxSumIndex72 = 0\n    var maxSum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpybbdzbkb.swift:91:9: error: type annotation missing in pattern\n\
    \    var maxSum\n        ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    let maxWeight = w\
    \ - first - last\n    return q.reduce(0) { $0 + $1 < maxWeight }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl8d5bzd7.swift:28:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { $0 + $1 < maxWeight }\n  \
    \           ^\n           (                                   != 0)\n/tmp/tmpl8d5bzd7.swift:28:34:\
    \ error: cannot convert value of type 'Bool' to closure result type 'Int'\n  \
    \  return q.reduce(0) { $0 + $1 < maxWeight }\n                         ~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q == q.sorted() {\n\
    \        i, j in\n        i < j && q[i] + q[j] <= maxWeight\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb8aae3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb8a7da561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb8a7da286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb8a7da13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb8a7d9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb8a5d9e83 <unavailable> + 188035

    6    tmp5bv8feco                        0x000055e71ff10a25 <unavailable> + 6693

    7    tmp5bv8feco                        0x000055e71ff10e94 <unavailable> + 7828

    8    libswiftCore.so                    0x00002aeb8a8fbc90 MutableCollection<>._insertionSort(within:sortedEnd:by:)
    + 770

    9    libswiftCore.so                    0x00002aeb8a8fc110 MutableCollection<>._insertionSort(within:by:)
    + 356

    10   libswiftCore.so                    0x00002aeb8a8fad30 UnsafeMutableBufferPointer._stableSortImpl(by:)
    + 319

    11   libswiftCore.so                    0x00002aeb8a8fad15 <unavailable> + 2616597

    12   libswiftCore.so                    0x00002aeb8aa2065a <unavailable> + 3819098

    13   libswiftCore.so                    0x00002aeb8a80f720 ContiguousArray.withContiguousMutableStorageIfAvailable<A>(_:)
    + 130

    14   libswiftCore.so                    0x00002aeb8a80f70f <unavailable> + 1652495

    15   libswiftCore.so                    0x00002aeb8a8fa460 MutableCollection<>.sort(by:)
    + 771

    16   libswiftCore.so                    0x00002aeb8a8fa370 Sequence.sorted(by:)
    + 193

    17   tmp5bv8feco                        0x000055e71ff108fa <unavailable> + 6394

    18   tmp5bv8feco                        0x000055e71ff103ba <unavailable> + 5050

    19   libc.so.6                          0x00002aeb8accf460 __libc_start_main +
    245

    20   tmp5bv8feco                        0x000055e71ff10099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    \n    var sum = 0\n    for element in q {\n        sum += element\n \
    \   }\n    \n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpve7tmzgj/tmpve7tmzgj.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6d5545c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6d523cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6d523c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6d523b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpve7tmzgj                        0x0000557b1a1414bf <unavailable> + 5311

    5    libc.so.6                          0x00002ac6d5731460 __libc_start_main +
    245

    6    tmpve7tmzgj                        0x0000557b1a141129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().count else { return false }\n    guard q.count\
    \ == 0 || q.count == w.reversed().reversed().count else { return false }\n   \
    \ guard q.count == 0 || q.count == w.reversed().reversed().reversed().count else\
    \ { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo3fjbsz4.swift:31:160: error: expected member name following '.'\n\
    \    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().\n\
    \                                                                            \
    \                                                                            \
    \       ^\n/tmp/tmpo3fjbsz4.swift:31:161: error: expected 'else' after 'guard'\
    \ condition\n    guard q.count == 0 || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().\n\
    \                                                                            \
    \                                                                            \
    \        ^\n/tmp/tmpo3fjbsz4.swift:19:40: error: value of type 'Int' has no member\
    \ 'reversed'\n    guard q.count == 0 || q.count == w.reversed().count else { return\
    \ false }\n                                     ~ ^~~~~~~~\n/tmp/tmpo3fjbsz4.swift:20:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().reversed().count else { return false }\n        \
    \                             ~ ^~~~~~~~\n/tmp/tmpo3fjbsz4.swift:21:40: error:\
    \ value of type 'Int' has no member 'reversed'\n    guard q.count == 0 || q.count\
    \ == w.reversed().reversed().reversed().count else { return false }\n        \
    \                             ~ ^~~~~~~~\n/tmp/tmpo3fjbsz4.swift:22:40: error:\
    \ value of type 'Int' has no member 'reversed'\n    guard q.count == 0 || q.count\
    \ == w.reversed().reversed().reversed().reversed().reversed().count else { return\
    \ false }\n                                     ~ ^~~~~~~~\n/tmp/tmpo3fjbsz4.swift:23:40:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == 0\
    \ || q.count == w.reversed().reversed().reversed().reversed().reversed().reversed().reversed().count\
    \ else { return false }\n                                     ~ ^~~~~~~~\n/tmp/tmpo3fjbsz4.swift:24:40:\
    \ error: value of type 'Int' has no membe"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    let maxWeight = w * q[0]\n    \n    if q.count == 1 {\n      \
    \  return maxWeight <= w\n    }\n    \n    let maxSum = q.reduce(0, combine: +)\n\
    \    \n    return maxWeight <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4a9l4ss9.swift:28:26: error: extraneous argument label 'combine:'\
    \ in call\n    let maxSum = q.reduce(0, combine: +)\n                        \
    \ ^   ~~~~~~~~~\n                             \n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for element in q {\n        sum += element\n\
    \    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfcafbs76/tmpfcafbs76.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fade0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fadb05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fadb05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fadb047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfcafbs76                        0x0000562c803c452b <unavailable> + 5419

    5    libc.so.6                          0x00002b6fadffa460 __libc_start_main +
    245

    6    tmpfcafbs76                        0x0000562c803c40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    let maxWeight = w *\
    \ w\n    return a.count == w && a.last! >= maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpatt9geq5.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxSum\
    \ = w.reduce(0, combine: +)\n    return q.reduce(0, combine: >) == maxSum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppn593p0g.swift:19:20: error: value of type 'Int' has no member\
    \ 'reduce'\n    let maxSum = w.reduce(0, combine: +)\n                 ~ ^~~~~~\n\
    /tmp/tmppn593p0g.swift:20:20: error: extraneous argument label 'combine:' in call\n\
    \    return q.reduce(0, combine: >) == maxSum\n                   ^   ~~~~~~~~~\n\
    \                       \n/tmp/tmppn593p0g.swift:20:33: error: binary operator\
    \ '>' cannot be applied to operands of type 'AnyHashable' and 'Int'\n    return\
    \ q.reduce(0, combine: >) == maxSum\n                                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'AnyHashable' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\nextension BinaryInteger {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted() else { return false }\n    let maxWeight = q.max()\n    return\
    \ q == q.reversed().prefix(q.count).reversed().suffix(maxWeight)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2h9c7lq3.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else { return\
    \ false }\n          ^       ~~~~~~~~~~\n/tmp/tmp2h9c7lq3.swift:21:64: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   return q == q.reversed().prefix(q.count).reversed().suffix(maxWeight)\n  \
    \                                                             ^\n/tmp/tmp2h9c7lq3.swift:20:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let maxWeight = q.max()\n        ^\n    guard    \
    \               else { return <#default value#> }\n/tmp/tmp2h9c7lq3.swift:20:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let maxWeight = q.max()\n                      ^\n              \
    \              ?? <#default value#>\n/tmp/tmp2h9c7lq3.swift:20:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let maxWeight\
    \ = q.max()\n                      ^\n                           !\n/tmp/tmp2h9c7lq3.swift:21:64:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return q == q.reversed().prefix(q.count).reversed().suffix(maxWeight)\n\
    \                                                               ^\n          \
    \                                                               ?? <#default value#>\n\
    /tmp/tmp2h9c7lq3.swift:21:64: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return q == q.reversed().prefix(q.count).reversed().suffix(maxWeight)\n\
    \                                                               ^\n          \
    \                                                              !\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for x in q {\n        maxSum -= x\n    }\n    return maxSum <= 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpym79lz7s/tmpym79lz7s.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae27003ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae26fd31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae26fd31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae26fd307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpym79lz7s                        0x000055aa745b44bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae270226460 __libc_start_main +
    245

    6    tmpym79lz7s                        0x000055aa745b4129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w\n    var sum = 0\n    for element in q {\n        sum += element\n    }\n\
    \    return sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp64vgp66t/tmp64vgp66t.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae9aa5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae9a752b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae9a752988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae9a7517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64vgp66t                        0x00005601f80984bf <unavailable> + 5311

    5    libc.so.6                          0x00002aae9ac47460 __libc_start_main +
    245

    6    tmp64vgp66t                        0x00005601f8098129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    \n    for index in 1..<q.count {\n        let element = q[index]\n\
    \        let sum = element + maxSumElement\n        if sum > maxSum {\n      \
    \      maxSum = sum\n            maxSumIndex = index\n            maxSumElement\
    \ = element\n        }\n    }\n    \n    if maxSum == w {\n        return true\n\
    \    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpudk7__e7/tmpudk7__e7.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeb965cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeb9353b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeb9353988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeb93527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpudk7__e7                        0x000055a1ab53b5fb <unavailable> + 5627

    5    libc.so.6                          0x00002abeb9848460 __libc_start_main +
    245

    6    tmpudk7__e7                        0x000055a1ab53b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdhnjwyzt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014266
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q.count == maxWeight && q.sorted() == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjbsy3hbm/tmpjbsy3hbm.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abdb9295c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abdb8f8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abdb8f8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abdb8f8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjbsy3hbm                        0x0000560a10fa84bf <unavailable> + 5311

    5    libc.so.6                          0x00002abdb9481460 __libc_start_main +
    245

    6    tmpjbsy3hbm                        0x0000560a10fa8129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        if x > max {\n\
    \            max = x\n        }\n    }\n    if max <= w {\n        return true\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprwa9083j/tmprwa9083j.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a84b99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a84890b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a84890988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a8488f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwa9083j                        0x000055c7b41f852b <unavailable> + 5419

    5    libc.so.6                          0x00002b2a84d85460 __libc_start_main +
    245

    6    tmprwa9083j                        0x000055c7b41f80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqbd6a9m0/tmpqbd6a9m0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e4ae0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e4ab04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e4ab04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e4ab037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbd6a9m0                        0x0000559dfb39d46f <unavailable> + 5231

    5    libc.so.6                          0x00002b3e4aff9460 __libc_start_main +
    245

    6    tmpqbd6a9m0                        0x0000559dfb39d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here.\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7y0u_bl8/tmp7y0u_bl8.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a1baa5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a1b79cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a1b79c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a1b79b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7y0u_bl8                        0x000055b357db33bb <unavailable> + 5051

    5    libc.so.6                          0x00002b0a1bc91460 __libc_start_main +
    245

    6    tmp7y0u_bl8                        0x000055b357db2f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.isPalindromic &&\
    \ q.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxpgou2jh.swift:19:14: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    return q.isPalindromic && q.sum() <= maxWeight\n      \
    \     ~ ^~~~~~~~~~~~~\n/tmp/tmpxpgou2jh.swift:19:33: error: value of type '[Int]'\
    \ has no member 'sum'\n    return q.isPalindromic && q.sum() <= maxWeight\n  \
    \                            ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ maxWeight == 0 || maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpca62f8sc.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum -= q[i]\n        if maxSum < 0 {\n            return false\n  \
    \      }\n    }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjf646_mh.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpjf646_mh.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpjf646_mh.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else { return false }\n    let maxWeight = w * w\n    return\
    \ a.count == w && a.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphexsuziy.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else { return\
    \ false }\n          ^       ~~~~~~~~~~\n/tmp/tmphexsuziy.swift:21:30: error:\
    \ value of type '[Int]' has no member 'sum'\n    return a.count == w && a.sum()\
    \ <= maxWeight\n                           ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count && q.count == q.max() else {\n\
    \        return false\n    }\n    let maxWeight = q.max()\n    let maxSum = q.sum()\n\
    \    return maxWeight <= w && maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsp12pp8j.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else {\n       \
    \              ~ ^~~~~\n/tmp/tmpsp12pp8j.swift:22:20: error: value of type '[Int]'\
    \ has no member 'sum'\n    let maxSum = q.sum()\n                 ~ ^~~\n/tmp/tmpsp12pp8j.swift:23:12:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return maxWeight <= w && maxSum == maxWeight\n           ^\n/tmp/tmpsp12pp8j.swift:23:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return maxWeight <= w && maxSum == maxWeight\n           ^\n    \
    \                 ?? <#default value#>\n/tmp/tmpsp12pp8j.swift:23:12: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ maxWeight <= w && maxSum == maxWeight\n           ^\n                    !\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ maxSum < maxWeight && q.count == (q.count / 2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmwyq8ksa.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \    }\n    if maxSum < 0 {\n        return false\n    }\n    var maxSum2 = w\n\
    \    for x in q {\n        maxSum2 += x\n    }\n    return maxSum == maxSum2\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqe1thx6h/tmpqe1thx6h.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49d6b55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49d684cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49d684c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49d684b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqe1thx6h                        0x0000559472b3446f <unavailable> + 5231

    5    libc.so.6                          0x00002b49d6d41460 __libc_start_main +
    245

    6    tmpqe1thx6h                        0x0000559472b340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum = maxSum * 10 + q[i]\n    }\n    return maxSum <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmn5wuegn.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpmn5wuegn.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpmn5wuegn.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    guard let a = q.sorted() {\n        return true\n    }\n    return a.reduce(0,\
    \ +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpezjggstf.swift:21:30: error: expected 'else' after 'guard' condition\n\
    \    guard let a = q.sorted() {\n                             ^\n            \
    \                 else \n/tmp/tmpezjggstf.swift:21:11: error: initializer for\
    \ conditional binding must have Optional type, not '[Int]'\n    guard let a =\
    \ q.sorted() {\n          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    \n    var maxSum = w\n    var maxSumIndex = 0\n    \n    for i in 0..<q.count\
    \ {\n        let sum = q[i] + q[maxSumIndex]\n        if sum > maxSum {\n    \
    \        maxSum = sum\n            maxSumIndex = i\n        }\n    }\n    \n \
    \   return maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7w7si8ct/tmp7w7si8ct.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53a446cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53a4163b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53a4163988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53a41627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7w7si8ct                        0x00005589ee87b53f <unavailable> + 5439

    5    libc.so.6                          0x00002b53a4658460 __libc_start_main +
    245

    6    tmp7w7si8ct                        0x00005589ee87b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.sorted() else {\n        return false\n    }\n    var sum = 0\n    for\
    \ i in 0..<a.count {\n        sum += a[i]\n    }\n    return sum <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk7pnxa3l.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let a = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count && q.count == q.max() else {\
    \ return false }\n    var sum = 0\n    for i in 0 ..< q.count {\n        sum +=\
    \ q[i]\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd99bxstd.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else { return false\
    \ }\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    let s = q.sum()\n    return s == w && s == q.max() - w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoint8zze.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpoint8zze.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpoint8zze.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpoint8zze.swift:19:15: error: value of type '[Int]' has\
    \ no member 'sum'\n    let s = q.sum()\n            ~ ^~~\n/tmp/tmpoint8zze.swift:20:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return s == w && s == q.max() - w\n                            ^\n/tmp/tmpoint8zze.swift:20:29:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return s == w && s == q.max() - w\n                            ^\n\
    \                          (       ?? <#default value#>)\n/tmp/tmpoint8zze.swift:20:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return s == w && s == q.max() - w\n                            ^\n\
    \                                 !\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    var maxWeight = w\n    var maxSum = q[0]\n    for i := 1; i < q.count;\
    \ i++ {\n        maxWeight = maxWeight - q[i]\n        if maxWeight < 0 {\n  \
    \          return false\n        }\n        maxSum = maxSum + q[i]\n    }\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7sz1e2uy.swift:23:12: error: expected type\n    for i := 1; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmp7sz1e2uy.swift:23:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < q.count; i++\
    \ {\n           ^\n/tmp/tmp7sz1e2uy.swift:23:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.reduce(0, +)\n\
    \    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa931avsy/tmpa931avsy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99de108c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99dddffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99dddff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99dddfe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa931avsy                        0x000055679346243b <unavailable> + 5179

    5    libc.so.6                          0x00002b99de2f4460 __libc_start_main +
    245

    6    tmpa931avsy                        0x0000556793461fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.sum()\
    \ % maxWeight\n    return sumOfElements == 0 || sumOfElements == maxWeight\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphc7vkpz3.swift:19:27: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sumOfElements = q.sum() % maxWeight\n                       \
    \ ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.sum\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \        }\n        maxSum -= element\n    }\n    return maxWeight <= w && maxSum\
    \ >= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqa04g01o.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    var maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ maxWeight <= maxSum && q.count == q.countPalindrome()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2cx0em4c.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmp2cx0em4c.swift:20:48:\
    \ error: value of type '[Int]' has no member 'countPalindrome'\n    return maxWeight\
    \ <= maxSum && q.count == q.countPalindrome()\n                              \
    \               ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = 0\n    for index in 0..<q.count {\n        let element = q[index]\n      \
    \  let sumElement = element + maxSumElement\n        if sumElement > maxSum {\n\
    \            maxSum = sumElement\n            maxSumIndex = index\n          \
    \  maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkbljdvj4/tmpkbljdvj4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c25153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c24e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c24e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c24e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkbljdvj4                        0x0000563ecaf8b5fb <unavailable> + 5627

    5    libc.so.6                          0x00002b1c2533f460 __libc_start_main +
    245

    6    tmpkbljdvj4                        0x0000563ecaf8b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = w.reduce(0, +)\n\
    \    return q.count == q.count && q.count == maxSum && q.maxElement() < maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjd6ot2ph.swift:19:20: error: value of type 'Int' has no member\
    \ 'reduce'\n    let maxSum = w.reduce(0, +)\n                 ~ ^~~~~~\n/tmp/tmpjd6ot2ph.swift:20:57:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    return q.count\
    \ == q.count && q.count == maxSum && q.maxElement() < maxWeight\n            \
    \                                          ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i : Int in stride(from: 0, to:\
    \ q.count, by: 1) {\n        let sum = q[i] + q[q.count - i - 1]\n        if sum\
    \ > maxSum {\n            maxSum = sum\n        }\n    }\n    return maxSum ==\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkcl41dl1/tmpkcl41dl1.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03ae0d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03addcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03addcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03addcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkcl41dl1                        0x0000557799c4a67b <unavailable> + 5755

    5    libc.so.6                          0x00002b03ae2c2460 __libc_start_main +
    245

    6    tmpkcl41dl1                        0x0000557799c4a229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqbd6a9m0/tmpqbd6a9m0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e4ae0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e4ab04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e4ab04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e4ab037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbd6a9m0                        0x0000559dfb39d46f <unavailable> + 5231

    5    libc.so.6                          0x00002b3e4aff9460 __libc_start_main +
    245

    6    tmpqbd6a9m0                        0x0000559dfb39d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count && q.count == q.max() else {\
    \ return false }\n    var sum = 0\n    for i in 0 ..< q.count {\n        sum +=\
    \ q[i]\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd99bxstd.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else { return false\
    \ }\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbkw66dcb/tmpbkw66dcb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2dfbccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2df8c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2df8c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2df8c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbkw66dcb                        0x000055b51074546f <unavailable> + 5231

    5    libc.so.6                          0x00002ab2dfdb8460 __libc_start_main +
    245

    6    tmpbkw66dcb                        0x000055b5107450d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9kjp3xtm/tmp9kjp3xtm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5386c16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b538690db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b538690d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b538690c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9kjp3xtm                        0x000055a6bb9be52b <unavailable> + 5419

    5    libc.so.6                          0x00002b5386e02460 __libc_start_main +
    245

    6    tmp9kjp3xtm                        0x000055a6bb9be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    \n\
    \    if q.count == 1 {\n        return q[0] == w\n    }\n    \n    if w == 0 {\n\
    \        return false\n    }\n    \n    let maxWeight = q.maxElement()\n    \n\
    \    if w < maxWeight {\n        return false\n    }\n    \n    let maxWeightSum\
    \ = q.map { $0 + $1 }.maxElement()\n    \n    return maxWeightSum == w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe1h_l97w.swift:30:23: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxWeight = q.maxElement()\n                    ~ ^~~~~~~~~~\n\
    /tmp/tmpe1h_l97w.swift:36:30: error: contextual closure type '(Int) throws ->\
    \ Int' expects 1 argument, but 2 were used in closure body\n    let maxWeightSum\
    \ = q.map { $0 + $1 }.maxElement()\n                             ^\n/tmp/tmpe1h_l97w.swift:36:42:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    let maxWeightSum\
    \ = q.map { $0 + $1 }.maxElement()\n                       ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let maxSum = maxWeight + w\n\
    \    return q == q.reversed().sorted(by: { $0 + $1 < maxSum }).reversed()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3pu9vybk/tmp3pu9vybk.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a83d75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a83a6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a83a6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a83a6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pu9vybk                        0x0000555f3cc6e79f <unavailable> + 6047

    5    libc.so.6                          0x00002b7a83f61460 __libc_start_main +
    245

    6    tmp3pu9vybk                        0x0000555f3cc6e1b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for element in\
    \ q {\n        sum += element\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprpbx16bk/tmprpbx16bk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83488e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83485dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83485db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83485da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprpbx16bk                        0x000055d53509b52b <unavailable> + 5419

    5    libc.so.6                          0x00002b8348ad0460 __libc_start_main +
    245

    6    tmprpbx16bk                        0x000055d53509b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmph7_nq5bk/tmph7_nq5bk.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9723be3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97238dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97238da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97238d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7_nq5bk                        0x0000555925b523bb <unavailable> + 5051

    5    libc.so.6                          0x00002b9723dcf460 __libc_start_main +
    245

    6    tmph7_nq5bk                        0x0000555925b51f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted() else { return false }\n    let maxWeight = q.max()\n    return\
    \ q.count == maxWeight && q.reduce(0, +) <= maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0oprkny4.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else { return\
    \ false }\n          ^       ~~~~~~~~~~\n/tmp/tmp0oprkny4.swift:21:54: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   return q.count == maxWeight && q.reduce(0, +) <= maxWeight\n             \
    \                                        ^\n/tmp/tmp0oprkny4.swift:21:54: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    return q.count == maxWeight && q.reduce(0, +) <= maxWeight\n            \
    \                                         ^\n                                \
    \                               ?? <#default value#>\n/tmp/tmp0oprkny4.swift:21:54:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return q.count == maxWeight && q.reduce(0, +) <= maxWeight\n    \
    \                                                 ^\n                        \
    \                                      !\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.count == 0 && maxWeight\
    \ <= 0\n        || (q.count == 1 && maxWeight == w) || q.sorted() == q\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwoedk4vw/tmpwoedk4vw.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3d3437c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3d312eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3d312e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3d312d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwoedk4vw                        0x000055925584245f <unavailable> + 5215

    5    libc.so.6                          0x00002ba3d3623460 __libc_start_main +
    245

    6    tmpwoedk4vw                        0x00005592558420c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q == q.reversed().sorted(by:\
    \ <).last(maxWeight)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp33dq1qdl.swift:19:49: error: missing argument label 'where:' in\
    \ call\n    return q == q.reversed().sorted(by: <).last(maxWeight)\n         \
    \                                       ^\n                                  \
    \              where: \n/tmp/tmp33dq1qdl.swift:19:49: error: cannot convert value\
    \ of type 'Int' to expected argument type '(Int) throws -> Bool'\n    return q\
    \ == q.reversed().sorted(by: <).last(maxWeight)\n                            \
    \                    ^\n/tmp/tmp33dq1qdl.swift:19:44: error: cannot convert value\
    \ of type 'Int?' to expected argument type '[Int]'\n    return q == q.reversed().sorted(by:\
    \ <).last(maxWeight)\n                                           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    let maxWeight = w * w\n    let sumOfElements = q.map { $0 + $1 }.reduce(0,\
    \ +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpds75609c.swift:22:31: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let sumOfElements\
    \ = q.map { $0 + $1 }.reduce(0, +)\n                              ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    var maxWeight = w\n    var maxSum = q[0]\n    for i := 1; i <\
    \ q.count; i++ {\n        maxWeight = maxWeight - q[i]\n        maxSum = maxSum\
    \ + q[i]\n        if maxWeight < 0 {\n            return false\n        }\n  \
    \  }\n    \n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpykmamq_b.swift:24:12: error: expected type\n    for i := 1; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpykmamq_b.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < q.count; i++\
    \ {\n           ^\n/tmp/tmpykmamq_b.swift:24:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    for i :=\
    \ 0; i < len(q); i++ {\n        maxSum += q[i]\n        if maxSum > w {\n    \
    \        maxSum -= w\n            maxSumIndex = i\n        }\n    }\n    return\
    \ maxSumIndex == len(q) - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0mgb0lnb.swift:20:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp0mgb0lnb.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp0mgb0lnb.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmp0mgb0lnb.swift:27:27:\
    \ error: cannot find 'len' in scope\n    return maxSumIndex == len(q) - 1\n  \
    \                        ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n    for x in q {\n    \
    \    sum += x\n        if sum > max {\n            max = sum\n        }\n    }\n\
    \    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu2xt9fqm/tmpu2xt9fqm.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c63f54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c63c4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c63c4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c63c4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu2xt9fqm                        0x00005611f1bc452b <unavailable> + 5419

    5    libc.so.6                          0x00002b6c64140460 __libc_start_main +
    245

    6    tmpu2xt9fqm                        0x00005611f1bc40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for v in q {\n        max = max > v\
    \ ? max : v\n    }\n    return max <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1xd6t64q/tmp1xd6t64q.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29da9dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29da6d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29da6d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29da6d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xd6t64q                        0x000055612c59752b <unavailable> + 5419

    5    libc.so.6                          0x00002b29dabcb460 __libc_start_main +
    245

    6    tmp1xd6t64q                        0x000055612c5970d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.maxElement()\n\
    \    return maxWeight == 0 || maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb27ab83c.swift:19:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxWeight <= maxSum && q.allSatisfy(isPalindromic)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7k6ua7m_.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n/tmp/tmp7k6ua7m_.swift:20:48:\
    \ error: cannot find 'isPalindromic' in scope\n    return maxWeight <= maxSum\
    \ && q.allSatisfy(isPalindromic)\n                                           \
    \    ^~~~~~~~~~~~~\n/tmp/tmp7k6ua7m_.swift:20:48: error: converting non-escaping\
    \ value to '(Int) throws -> Bool' may allow it to escape\n    return maxWeight\
    \ <= maxSum && q.allSatisfy(isPalindromic)\n                                 \
    \              ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    let maxWeight = w\n   \
    \ let maxSum = q.maxElement()\n    return maxWeight <= maxSum && will_it_fly(q:\
    \ q.dropLast(), w: maxWeight)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmvk2c3od.swift:25:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.map({\
    \ $0 + $1 }).reduce(0, +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv5d43x8c.swift:19:31: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let sumOfElements\
    \ = q.map({ $0 + $1 }).reduce(0, +)\n                              ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ = maxSum * element + element\n    }\n    return maxSum < w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsbhs1s4j/tmpsbhs1s4j.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd1c7c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd1c4c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd1c4c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd1c4bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsbhs1s4j                        0x0000555ae46a546f <unavailable> + 5231

    5    libc.so.6                          0x00002acd1c9b5460 __libc_start_main +
    245

    6    tmpsbhs1s4j                        0x0000555ae46a50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     let sumElement = element + maxSumElement\n        if sumElement > maxSum\
    \ {\n            maxSum = sumElement\n            maxSumIndex = index\n      \
    \      maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpapsl3vvu/tmpapsl3vvu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b029352dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0293224b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0293224988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02932237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpapsl3vvu                        0x000055e3506c65fb <unavailable> + 5627

    5    libc.so.6                          0x00002b0293719460 __libc_start_main +
    245

    6    tmpapsl3vvu                        0x000055e3506c61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n    for i : Int in q {\n\
    \        sum += i\n        if sum > max {\n            max = sum\n        }\n\
    \    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpopzk3l38/tmpopzk3l38.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc7e218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc7df0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc7df0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc7df0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopzk3l38                        0x000055597eea052b <unavailable> + 5419

    5    libc.so.6                          0x00002abc7e404460 __libc_start_main +
    245

    6    tmpopzk3l38                        0x000055597eea00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else {\n        return false\n\
    \    }\n    guard let maxWeight = maxWeight(weight: w) else {\n        return\
    \ false\n    }\n    let maxSum = maxSum(weight: w)\n    return isBalanced(q: q,\
    \ weight: w) && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr41a8qsj.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else {\n                     ~ ^~~~~\n\
    /tmp/tmpr41a8qsj.swift:21:27: error: cannot find 'maxWeight' in scope\n    guard\
    \ let maxWeight = maxWeight(weight: w) else {\n                          ^~~~~~~~~\n\
    /tmp/tmpr41a8qsj.swift:24:18: error: use of local variable 'maxSum' before its\
    \ declaration\n    let maxSum = maxSum(weight: w)\n                 ^\n/tmp/tmpr41a8qsj.swift:24:9:\
    \ note: 'maxSum' declared here\n    let maxSum = maxSum(weight: w)\n        ^\n\
    /tmp/tmpr41a8qsj.swift:25:12: error: cannot find 'isBalanced' in scope\n    return\
    \ isBalanced(q: q, weight: w) && maxSum < maxWeight\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 else {\n        return false\n\
    \    }\n    \n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    \n    for i in 1..<q.count {\n        let currentSum = q[i] + maxSumElement\n\
    \        if currentSum > maxSum {\n            maxSum = currentSum\n         \
    \   maxSumIndex = i\n            maxSumElement = q[i]\n        }\n    }\n    \n\
    \    return maxSum == w && maxSumIndex == q.count - 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyu2g0z_c/tmpyu2g0z_c.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b32959c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b32650b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b32650988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b3264f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyu2g0z_c                        0x000055bac465653f <unavailable> + 5439

    5    libc.so.6                          0x00002b6b32b45460 __libc_start_main +
    245

    6    tmpyu2g0z_c                        0x000055bac46561a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return is_balanced(q) && is_palindromic(q)\
    \ && q.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0bq7qxy_.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_palindromic(q) && q.sum() <= maxWeight\n    \
    \       ^~~~~~~~~~~\n/tmp/tmp0bq7qxy_.swift:19:30: error: cannot find 'is_palindromic'\
    \ in scope\n    return is_balanced(q) && is_palindromic(q) && q.sum() <= maxWeight\n\
    \                             ^~~~~~~~~~~~~~\n/tmp/tmp0bq7qxy_.swift:19:53: error:\
    \ value of type '[Int]' has no member 'sum'\n    return is_balanced(q) && is_palindromic(q)\
    \ && q.sum() <= maxWeight\n                                                  ~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first,\n        let last = q.last,\n        first == last else { return\
    \ false }\n    guard let first = q.first,\n        let last = q.last,\n      \
    \  first != last else { return false }\n    guard let first = q.first,\n     \
    \   let last = q.last,\n        last - first == 1 else { return false }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpmvps6zr4/tmpmvps6zr4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7129444c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b712913bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b712913b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b712913a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmvps6zr4                        0x000055ff4947b48f <unavailable> + 5263

    5    libc.so.6                          0x00002b7129630460 __libc_start_main +
    245

    6    tmpmvps6zr4                        0x000055ff4947b0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropFirst(), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoysn4qz2.swift:21:39: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return a == b && will_it_fly(q: q.dropFirst(),\
    \ w: w)\n                                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w\n    let maxSum = q.sum\n    return maxWeight == maxSum && q.count == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgi_6eiv3.swift:20:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.reduce(0) { (acc,\
    \ x) -> Bool in\n        let sum = acc + x\n        return sum < maxWeight &&\
    \ sum == sum\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_4brm1lu.swift:19:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { (acc, x) -> Bool in\n    \
    \         ^\n           (\n/tmp/tmp_4brm1lu.swift:19:38: error: declared closure\
    \ result 'Bool' is incompatible with contextual type 'Int'\n    return q.reduce(0)\
    \ { (acc, x) -> Bool in\n                                     ^~~~\n         \
    \                            Int\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted() else {\n        return false\n    }\n    let maxWeight = q.max()\n\
    \    return q.count == maxWeight && q == q.prefix(q.count-1) && q == q.suffix(q.count-1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpohl37rng.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n/tmp/tmpohl37rng.swift:23:36: error: cannot convert\
    \ value of type '[Int]' to expected argument type 'ArraySlice<Int>'\n    return\
    \ q.count == maxWeight && q == q.prefix(q.count-1) && q == q.suffix(q.count-1)\n\
    \                                   ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqwfq64_v/tmpqwfq64_v.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b392baa6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b392b79db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b392b79d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b392b79c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqwfq64_v                        0x0000562bdea5746f <unavailable> + 5231

    5    libc.so.6                          0x00002b392bc92460 __libc_start_main +
    245

    6    tmpqwfq64_v                        0x0000562bdea570d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = w\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \        }\n        if element + maxWeight > maxSum {\n            maxSum = element\
    \ + maxWeight\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp2s682pie/tmp2s682pie.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65f2e82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65f2b79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65f2b79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65f2b787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2s682pie                        0x00005631a685346f <unavailable> + 5231

    5    libc.so.6                          0x00002b65f306e460 __libc_start_main +
    245

    6    tmp2s682pie                        0x00005631a68530d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return false\n \
    \   }\n    \n    let maxWeight = w\n    let maxSum = q.sum\n    \n    if maxSum\
    \ < maxWeight {\n        return false\n    }\n    \n    let maxIndex = q.index(maxElement:\
    \ maxSum)\n    \n    if maxIndex == 0 {\n        return true\n    }\n    \n  \
    \  let firstIndex = q.index(maxElement: q[maxIndex-1]) + maxIndex - 1\n    \n\
    \    return will_it_fly(q[firstIndex..<q.count], w: maxWeight)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpultcdh7w.swift:23:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpultcdh7w.swift:29:22:\
    \ error: no exact matches in call to instance method 'index'\n    let maxIndex\
    \ = q.index(maxElement: maxSum)\n                     ^\n/tmp/tmpultcdh7w.swift:29:22:\
    \ note: found candidate with type '(Int) -> Int'\n    let maxIndex = q.index(maxElement:\
    \ maxSum)\n                     ^\n/tmp/tmpultcdh7w.swift:29:22: note: found candidate\
    \ with type '(Int) -> Int'\n    let maxIndex = q.index(maxElement: maxSum)\n \
    \                    ^\n/tmp/tmpultcdh7w.swift:29:22: note: found candidate with\
    \ type '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let maxIndex\
    \ = q.index(maxElement: maxSum)\n                     ^\n/tmp/tmpultcdh7w.swift:35:24:\
    \ error: no exact matches in call to instance method 'index'\n    let firstIndex\
    \ = q.index(maxElement: q[maxIndex-1]) + maxIndex - 1\n                      \
    \ ^\n/tmp/tmpultcdh7w.swift:35:24: note: found candidate with type '(Int) -> Int'\n\
    \    let firstIndex = q.index(maxElement: q[maxIndex-1]) + maxIndex - 1\n    \
    \                   ^\n/tmp/tmpultcdh7w.swift:35:24: note: found candidate with\
    \ type '(Int) -> Int'\n    let firstIndex = q.index(maxElement: q[maxIndex-1])\
    \ + maxIndex - 1\n                       ^\n/tmp/tmpultcdh7w.swift:37:23: error:\
    \ missing argument label 'q:' in call\n    return will_it_fly(q[firstIndex..<q.count],\
    \ w: maxWeight)\n                      ^\n                       q: \n/tmp/tmpultcdh7w.swift:37:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(q[firstIndex..<q.count], w: maxWeight)\n   \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for element in q {\n        max = max(max,\
    \ element)\n    }\n    return max <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8qd6830v.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, element)\n              ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 0..<q.count {\n        let element = q[index]\n   \
    \     let sum = element + maxSumElement\n        if sum > maxSum {\n         \
    \   maxSum = sum\n            maxSumIndex = index\n            maxSumElement =\
    \ element\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb0212h22/tmpb0212h22.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25a2ceac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25a29e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25a29e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25a29e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0212h22                        0x000055fe333745fb <unavailable> + 5627

    5    libc.so.6                          0x00002b25a2ed6460 __libc_start_main +
    245

    6    tmpb0212h22                        0x000055fe333741a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return false\n \
    \   }\n    \n    var maxSum = w\n    var maxSumIndex = 0\n    \n    for i := 0;\
    \ i < len(q); i++ {\n        var sum = 0\n        for j := 0; j < len(q); j++\
    \ {\n            sum += q[j]\n        }\n        if sum > maxSum {\n         \
    \   maxSum = sum\n            maxSumIndex = i\n        }\n    }\n    \n    return\
    \ maxSum == w && maxSumIndex == len(q) - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3u8o9exu.swift:25:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp3u8o9exu.swift:25:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp3u8o9exu.swift:25:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmp3u8o9exu.swift:27:16:\
    \ error: expected type\n        for j := 0; j < len(q); j++ {\n              \
    \ ^\n                <#type#>\n/tmp/tmp3u8o9exu.swift:27:16: error: expected 'in'\
    \ after for-each pattern\n        for j := 0; j < len(q); j++ {\n            \
    \   ^\n/tmp/tmp3u8o9exu.swift:27:16: error: expected Sequence expression for for-each\
    \ loop\n        for j := 0; j < len(q); j++ {\n               ^\n/tmp/tmp3u8o9exu.swift:36:42:\
    \ error: cannot find 'len' in scope\n    return maxSum == w && maxSumIndex ==\
    \ len(q) - 1\n                                         ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2cjmxbow.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    for i in q {\n        sum +=\
    \ i\n    }\n    return sum == w && is_balanced(q) && is_palindromic(q)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoqoglihm.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpoqoglihm.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpoqoglihm.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpoqoglihm.swift:25:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                       ^~~~~~~~~~~\n/tmp/tmpoqoglihm.swift:25:42:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        if x > max {\n\
    \            max = x\n        }\n    }\n    return is_balanced(q) && is_palindromic(q)\
    \ && is_less_or_equal_to(q, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf8a9umsi.swift:24:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_palindromic(q) && is_less_or_equal_to(q, max)\n\
    \           ^~~~~~~~~~~\n/tmp/tmpf8a9umsi.swift:24:30: error: cannot find 'is_palindromic'\
    \ in scope\n    return is_balanced(q) && is_palindromic(q) && is_less_or_equal_to(q,\
    \ max)\n                             ^~~~~~~~~~~~~~\n/tmp/tmpf8a9umsi.swift:24:51:\
    \ error: cannot find 'is_less_or_equal_to' in scope\n    return is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to(q, max)\n                      \
    \                            ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q == reverse(q.suffix(q.count)).prefix(q.count) && q.count\
    \ == maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzv4kyehj.swift:20:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.suffix(q.count)).prefix(q.count) && q.count == maxWeight\n\
    \                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.isPalindromic &&\
    \ q.sum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdx2w51gv.swift:19:14: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    return q.isPalindromic && q.sum < maxWeight\n         \
    \  ~ ^~~~~~~~~~~~~\n/tmp/tmpdx2w51gv.swift:19:33: error: value of type '[Int]'\
    \ has no member 'sum'\n    return q.isPalindromic && q.sum < maxWeight\n     \
    \                         ~ ^~~\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbkw66dcb/tmpbkw66dcb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2dfbccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2df8c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2df8c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2df8c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbkw66dcb                        0x000055b51074546f <unavailable> + 5231

    5    libc.so.6                          0x00002ab2dfdb8460 __libc_start_main +
    245

    6    tmpbkw66dcb                        0x000055b5107450d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpaiykuy8h/tmpaiykuy8h.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7b0173c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7afe6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7afe6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7afe697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaiykuy8h                        0x000055650166952b <unavailable> + 5419

    5    libc.so.6                          0x00002af7b035f460 __libc_start_main +
    245

    6    tmpaiykuy8h                        0x00005565016690d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    guard let r = q.reversed(), r.count == q.count && r.sum() <= w\
    \ else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqn3g4rfe.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpqn3g4rfe.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpqn3g4rfe.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpqn3g4rfe.swift:19:57: error: value of type 'ReversedCollection<[Int]>'\
    \ has no member 'sum'\n    guard let r = q.reversed(), r.count == q.count && r.sum()\
    \ <= w else { return false }\n                                               \
    \       ~ ^~~\n/tmp/tmpqn3g4rfe.swift:19:11: error: initializer for conditional\
    \ binding must have Optional type, not 'ReversedCollection<[Int]>'\n    guard\
    \ let r = q.reversed(), r.count == q.count && r.sum() <= w else { return false\
    \ }\n          ^       ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.count == q.maxElement()\
    \ && q.maxElement() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5ry81rqy.swift:19:25: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    return q.count == q.maxElement() && q.maxElement() <= maxWeight\n\
    \                      ~ ^~~~~~~~~~\n/tmp/tmp5ry81rqy.swift:19:43: error: value\
    \ of type '[Int]' has no member 'maxElement'\n    return q.count == q.maxElement()\
    \ && q.maxElement() <= maxWeight\n                                        ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    let\
    \ maxWeight = w\n    let maxSum = q.sum\n    return maxWeight <= maxSum && q.count\
    \ == q.maxElements\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpq0xzcfsr.swift:22:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpq0xzcfsr.swift:23:48:\
    \ error: value of type '[Int]' has no member 'maxElements'\n    return maxWeight\
    \ <= maxSum && q.count == q.maxElements\n                                    \
    \         ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ maxSum < maxWeight && q.palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf19uwb0q.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpf19uwb0q.swift:20:36:\
    \ error: value of type '[Int]' has no member 'palindrome'\n    return maxSum <\
    \ maxWeight && q.palindrome\n                                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i in\n        stride(from: q.count, to: q.count, by: -1) {\n        \
    \    let sum = q[i]\n            if sum > maxSum {\n                maxSum = sum\n\
    \                maxWeight = w\n            }\n            if sum == maxSum {\n\
    \                if maxWeight < w {\n                    return false\n      \
    \          }\n                maxWeight -= w\n            }\n        }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb1q6zxlt/tmpb1q6zxlt.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0085ff6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0085cedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0085ced988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0085cec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1q6zxlt                        0x000055bdaada46eb <unavailable> + 5867

    5    libc.so.6                          0x00002b00861e2460 __libc_start_main +
    245

    6    tmpb1q6zxlt                        0x000055bdaada4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum -= q[i]\n        if maxSum < 0 {\n            return false\n  \
    \      }\n    }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjf646_mh.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpjf646_mh.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpjf646_mh.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q[0]\n    for element\
    \ in q {\n        if element > maxSum {\n            maxSum = element\n      \
    \  }\n        if element > maxWeight {\n            maxWeight = element\n    \
    \    }\n    }\n    return maxWeight <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp_6zposrx/tmp_6zposrx.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbdb019c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbdad10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbdad10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbdad0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_6zposrx                        0x00005628986c74bf <unavailable> + 5311

    5    libc.so.6                          0x00002acbdb205460 __libc_start_main +
    245

    6    tmp_6zposrx                        0x00005628986c7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropFirst(), w: w) && will_it_fly(q:\
    \ q.dropLast(), w: w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjm4si1b6.swift:21:39: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return a == b && will_it_fly(q: q.dropFirst(),\
    \ w: w) && will_it_fly(q: q.dropLast(), w: w)\n                              \
    \        ^\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q.count == maxWeight && q == reverse(q.prefix(q.count)).prefix(q.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb_7i_18q.swift:20:41: error: cannot find 'reverse' in scope\n \
    \   return q.count == maxWeight && q == reverse(q.prefix(q.count)).prefix(q.count)\n\
    \                                        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q == reverse(q.suffix(q.count)) && q.sum() <= maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp930q339y.swift:20:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.suffix(q.count)) && q.sum() <= maxWeight\n         \
    \       ^~~~~~~\n/tmp/tmp930q339y.swift:20:49: error: value of type '[Int]' has\
    \ no member 'sum'\n    return q == reverse(q.suffix(q.count)) && q.sum() <= maxWeight\n\
    \                                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ r = q.reversed(), r.count == w else { return false }\n    return r.isPalindromic\
    \ && r.sum() <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx70ljlfx.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not 'ReversedCollection<[Int]>'\n    guard let r =\
    \ q.reversed(), r.count == w else { return false }\n          ^       ~~~~~~~~~~~~\n\
    /tmp/tmpx70ljlfx.swift:20:14: error: value of type 'ReversedCollection<[Int]>'\
    \ has no member 'isPalindromic'\n    return r.isPalindromic && r.sum() <= w\n\
    \           ~ ^~~~~~~~~~~~~\n/tmp/tmpx70ljlfx.swift:20:33: error: value of type\
    \ 'ReversedCollection<[Int]>' has no member 'sum'\n    return r.isPalindromic\
    \ && r.sum() <= w\n                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    var\
    \ maxWeight = w\n    var maxSum = q[0]\n    for i := 1; i < q.count; i++ {\n \
    \       maxWeight -= q[i]\n        if maxWeight < 0 {\n            return false\n\
    \        }\n        maxSum += q[i]\n    }\n    return maxSum < maxWeight\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr8x3m439.swift:23:12: error: expected type\n    for i := 1; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpr8x3m439.swift:23:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < q.count; i++\
    \ {\n           ^\n/tmp/tmpr8x3m439.swift:23:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return true\n    }\n    let\
    \ maxWeight = w\n    let maxSum = q.sum\n    if maxSum > maxWeight {\n       \
    \ return false\n    }\n    let maxIndex = q.index(maxSum)\n    let maxElement\
    \ = q[maxIndex]\n    let maxElementWeight = maxElement * maxWeight\n    return\
    \ maxElementWeight <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7t3oelsv.swift:22:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmp7t3oelsv.swift:26:22:\
    \ error: no exact matches in call to instance method 'index'\n    let maxIndex\
    \ = q.index(maxSum)\n                     ^\n/tmp/tmp7t3oelsv.swift:26:22: note:\
    \ found candidate with type '(Int) -> Int'\n    let maxIndex = q.index(maxSum)\n\
    \                     ^\n/tmp/tmp7t3oelsv.swift:26:22: note: found candidate with\
    \ type '(Int) -> Int'\n    let maxIndex = q.index(maxSum)\n                  \
    \   ^\n/tmp/tmp7t3oelsv.swift:26:22: note: found candidate with type '(Int) ->\
    \ Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let maxIndex = q.index(maxSum)\n\
    \                     ^\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    return q.reduce(0) { $0 + $1 < maxWeight }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnfdekhcb.swift:20:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { $0 + $1 < maxWeight }\n  \
    \           ^\n           (                                   != 0)\n/tmp/tmpnfdekhcb.swift:20:34:\
    \ error: cannot convert value of type 'Bool' to closure result type 'Int'\n  \
    \  return q.reduce(0) { $0 + $1 < maxWeight }\n                         ~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted() else {\n        return false\n    }\n    var sum = 0\n    for\
    \ i in q {\n        sum += i\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp_terpba.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    guard let a = q.first else {\n        return false\n    }\n    guard\
    \ let b = q.last else {\n        return false\n    }\n    if a != b {\n      \
    \  return false\n    }\n    var sum = 0\n    for x in q {\n        sum += x\n\
    \    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps0zd1q_j/tmps0zd1q_j.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58ae3c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58ae0b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58ae0b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58ae0b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0zd1q_j                        0x00005598b18725bf <unavailable> + 5567

    5    libc.so.6                          0x00002b58ae5ae460 __libc_start_main +
    245

    6    tmps0zd1q_j                        0x00005598b1872229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropFirst(), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoysn4qz2.swift:21:39: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return a == b && will_it_fly(q: q.dropFirst(),\
    \ w: w)\n                                      ^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for element in\
    \ q {\n        sum += element\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprpbx16bk/tmprpbx16bk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83488e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83485dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83485db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83485da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprpbx16bk                        0x000055d53509b52b <unavailable> + 5419

    5    libc.so.6                          0x00002b8348ad0460 __libc_start_main +
    245

    6    tmprpbx16bk                        0x000055d53509b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i : Int in stride(from: 0, to:\
    \ q.count, by: 1) {\n        let sum = q[i] + q[q.count - i - 1]\n        if sum\
    \ > maxSum {\n            maxSum = sum\n        }\n    }\n    return maxSum ==\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkcl41dl1/tmpkcl41dl1.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03ae0d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03addcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03addcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03addcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkcl41dl1                        0x0000557799c4a67b <unavailable> + 5755

    5    libc.so.6                          0x00002b03ae2c2460 __libc_start_main +
    245

    6    tmpkcl41dl1                        0x0000557799c4a229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return is_balanced(q) && q.sum()\
    \ <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd0e2bvu8.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && q.sum() <= maxWeight\n           ^~~~~~~~~~~\n/tmp/tmpd0e2bvu8.swift:19:32:\
    \ error: value of type '[Int]' has no member 'sum'\n    return is_balanced(q)\
    \ && q.sum() <= maxWeight\n                             ~ ^~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n    guard let last = q.last else { return false }\n \
    \   guard first == last else { return false }\n    guard let first = q.first else\
    \ { return false }\n    guard let last = q.last else { return false }\n    guard\
    \ first == last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard first\
    \ == last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard first == last\
    \ else { return false }\n    guard let first = q.first else { return false }\n\
    \    guard let last = q.last else { return false }\n    guard first == last else\
    \ { return false }\n    guard let first = q.first else { return false }\n    guard\
    \ let last = q.last else { return false }\n    guard first == last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard first == last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard first == last else { return false }\n\
    \    guard let first = q.first else { return false }\n    guard let last = q.last\
    \ else { return false }\n    guard first == last else { return false }\n    guard\
    \ let first = q.first else { return false }\n    guard let last = q.last else\
    \ { return false }\n    guard first == last else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvk1_t3p4.swift:61:15: warning: value 'first' was defined but never\
    \ used; consider replacing with boolean test\n    guard let first = q.first else\
    \ { return false }\n          ~~~~^~~~~~~~\n                              != nil\n\
    /tmp/tmpvk1_t3p4.swift:62:1: error: missing return in global function expected\
    \ to return 'Bool'\n}\n^\n"
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 else { return false }\n    guard q.count\
    \ == 0 || q.count == 1 || q.count == w else { return false }\n    guard q[0] ==\
    \ q[q.count-1] else { return false }\n    guard let x = q.first,\n        let\
    \ y = q.last,\n        x <= y else { return false }\n    guard let x = q.first,\n\
    \        let y = q.last,\n        x > y else { return false }\n    guard let x\
    \ = q.first,\n        let y = q.last,\n        x > y else { return false }\n \
    \   guard let x = q.first,\n        let y = q.last,\n        x > y else { return\
    \ false }\n    guard let x = q.first,\n        let y = q.last,\n        x > y\
    \ else { return false }\n    guard let x = q.first,\n        let y = q.last,\n\
    \        x > y else { return false }\n    guard let x = q.first,\n        let\
    \ y = q.last,\n        x > y else { return false }\n    guard let x = q.first,\n\
    \        let y = q.last,\n        x > y else { return false }\n    guard let x\
    \ = q.first,\n        let y = q.last,\n        x > y else { return false }\n \
    \   guard let x = q.first,\n        let y = q.last,\n        x > y else { return\
    \ false }\n    guard let x = q.first,\n        let y = q.last,\n        x > y\
    \ else { return false }\n    guard let x = q.first,\n        let y = q.last,\n\
    \        x > y else { return false }\n    guard let x = q.first,\n        let\
    \ y = q.last,\n        x > y else { return false }\n    guard let x = q.first,\n\
    \        let y = q.last,\n        x > y else { return false }\n    guard let x\
    \ = q.first,\n        let y = q.last,\n        x > y else { return false }\n \
    \   guard let x = q.first,\n        let y = q.last,\n        x > y else { return\
    \ false }\n    guard let x = q.first,\n        let y = q.last,\n        x > y\
    \ else { return false }\n    guard let x = q.first,\n        let y = q.last,\n\
    \        x > y else { return false }\n    guard let x = q.first,\n        let\
    \ y = q.last,\n        x > y else { return false }\n    guard let x = q.first,\n\
    \        let y = q.last,\n        x > y else { return false }\n    guard let x\
    \ = q.first,\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpikvmqock.swift:81:27: error: expected expression in conditional\n\
    \    guard let x = q.first,\n                          ^\n/tmp/tmpikvmqock.swift:81:15:\
    \ warning: value 'x' was defined but never used; consider replacing with boolean\
    \ test\n    guard let x = q.first,\n          ~~~~^~~~\n                     \
    \     != nil\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    var\
    \ maxSum = w\n    for i := 0; i < q.count; i++ {\n        maxSum = maxSum - q[i]\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9l8ar0y.swift:22:12: error: expected type\n    for i := 0; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpy9l8ar0y.swift:22:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < q.count; i++\
    \ {\n           ^\n/tmp/tmpy9l8ar0y.swift:22:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.count == q.reduce(0,\
    \ +) && q.reduce(0, +) <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp84gslbsd/tmp84gslbsd.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf33ee8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf33bdfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf33bdf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf33bde7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp84gslbsd                        0x0000557bf42e73cf <unavailable> + 5071

    5    libc.so.6                          0x00002adf340d4460 __libc_start_main +
    245

    6    tmp84gslbsd                        0x0000557bf42e7039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for element in\
    \ q {\n        sum += element\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprpbx16bk/tmprpbx16bk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83488e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83485dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83485db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83485da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprpbx16bk                        0x000055d53509b52b <unavailable> + 5419

    5    libc.so.6                          0x00002b8348ad0460 __libc_start_main +
    245

    6    tmprpbx16bk                        0x000055d53509b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014268
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = w.reduce(0, +)\n\
    \    return q.count == q.count && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyk3fnaiv.swift:19:20: error: value of type 'Int' has no member\
    \ 'reduce'\n    let maxSum = w.reduce(0, +)\n                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    if q.count == 1 {\n        return false\n    }\n    \n    if w\
    \ == 1 {\n        return true\n    }\n    \n    let maxWeight = w * q.count\n\
    \    \n    if maxWeight < q.last {\n        return false\n    }\n    \n    let\
    \ sumOfElements = q.dropLast().reduce(0) { $0 + $1 }\n    \n    return sumOfElements\
    \ <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp9ovn0z1.swift:32:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if maxWeight < q.last {\n       \
    \              ^\n/tmp/tmpp9ovn0z1.swift:32:22: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if maxWeight < q.last\
    \ {\n                     ^\n                          ?? <#default value#>\n\
    /tmp/tmpp9ovn0z1.swift:32:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    if maxWeight < q.last {\n        \
    \             ^\n                         !\n"
  stdout: ''
  timestamp: 1660014269
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum = maxSum\
    \ * x + x\n    }\n    return maxSum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp8a6k8a70/tmp8a6k8a70.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46b7229c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46b6f20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46b6f20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46b6f1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8a6k8a70                        0x000055dc0894346f <unavailable> + 5231

    5    libc.so.6                          0x00002b46b7415460 __libc_start_main +
    245

    6    tmp8a6k8a70                        0x000055dc089430d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014269
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q == q.reversed().sorted(by:\
    \ <).last(where: { $0 >= maxWeight })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpql4kxo34.swift:19:44: error: cannot convert value of type 'Int?'\
    \ to expected argument type '[Int]'\n    return q == q.reversed().sorted(by: <).last(where:\
    \ { $0 >= maxWeight })\n                                           ^\n"
  stdout: ''
  timestamp: 1660014269
