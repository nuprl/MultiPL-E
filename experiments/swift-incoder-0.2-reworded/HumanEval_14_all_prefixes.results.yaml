language: swift
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var i = 0\n    while i < current.count {\n    \
    \    prefixes.append(String(current[i...]))\n        i += 1\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt6s8wj9u.swift:10:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(String(current[i...]))\n                            \
    \   ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpt6s8wj9u.swift:7:9:\
    \ warning: variable 'current' was never mutated; consider changing to 'let' constant\n\
    \    var current = string\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    var longestLen = 0\n\
    \    while current != \"\" {\n        longest = longest.prefix(string: longest)\n\
    \        longestLen = longest.count\n        current = current.suffix(string:\
    \ current)\n    }\n    for _ in 0..<longestLen {\n        prefixes.append(longest)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2d18qy86.swift:11:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        longest = longest.prefix(string: longest)\n       \
    \                   ^\n/tmp/tmp2d18qy86.swift:11:27: note: found candidate with\
    \ type '(Int) -> PrefixSequence<String>'\n        longest = longest.prefix(string:\
    \ longest)\n                          ^\n/tmp/tmp2d18qy86.swift:11:27: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        longest = longest.prefix(string: longest)\n                         \
    \ ^\n/tmp/tmp2d18qy86.swift:11:27: error: no 'prefix' candidates produce the expected\
    \ contextual result type 'String'\n        longest = longest.prefix(string: longest)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\n/tmp/tmp2d18qy86.swift:13:27: error: no\
    \ exact matches in call to instance method 'suffix'\n        current = current.suffix(string:\
    \ current)\n                          ^\n/tmp/tmp2d18qy86.swift:13:27: note: found\
    \ candidate with type '(Int) -> [String.Element]' (aka '(Int) -> Array<Character>')\n\
    \        current = current.suffix(string: current)\n                         \
    \ ^\n/tmp/tmp2d18qy86.swift:13:27: note: found candidate with type '(Int) -> String.SubSequence'\
    \ (aka '(Int) -> Substring')\n        current = current.suffix(string: current)\n\
    \                          ^\n/tmp/tmp2d18qy86.swift:13:27: error: no 'suffix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.suffix(string: current)\n                          ^\nSwift.Sequence:3:40:\
    \ note: 'suffix' produces '[Str"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        if\
    \ prefixes.contains(prefix) {\n            prefixes.append(prefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4vhxlsib.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = String(character) + currentPrefix\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b561cb41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b561c838561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b561c838286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b561c83813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b561c837bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b561c96bec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b561c924660 String.subscript.getter
    + 34

    7    tmp5aoweacw                        0x000055c0e1669cc8 <unavailable> + 7368

    8    tmp5aoweacw                        0x000055c0e16697b7 <unavailable> + 6071

    9    libc.so.6                          0x00002b561cd2d460 __libc_start_main +
    245

    10   tmp5aoweacw                        0x000055c0e16693d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp38l5r4nm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = String(character)\n           \
    \ prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002baa62d5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa62a52561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa62a52286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa62a5213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa62a51bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002baa62b85ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002baa62b3e660 String.subscript.getter
    + 34

    7    tmpstvjnpqp                        0x000055e975cfcc8d <unavailable> + 7309

    8    tmpstvjnpqp                        0x000055e975cfc767 <unavailable> + 5991

    9    libc.so.6                          0x00002baa62f47460 __libc_start_main +
    245

    10   tmpstvjnpqp                        0x000055e975cfc389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4e6vwigl.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4e6vwigl.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n                                         ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_zy3sngd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp_zy3sngd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp_zy3sngd.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi0hlpti7.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\n\
    \        } else {\n            prefixes.append(currentPrefix)\n            currentPrefix\
    \ = character\n        }\n    }\n    prefixes.append(currentPrefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxo74r49b.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxo74r49b.swift:10:42:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = currentPrefix[currentPrefix.count-1]\n                    \
    \        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxo74r49b.swift:13:29: error:\
    \ cannot assign value of type 'Character' to type 'String'\n            currentPrefix\
    \ = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpru856_hj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpru856_hj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpru856_hj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3au0435o.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3au0435o.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    while current != \"\"\
    \ {\n        current = current.prefix(string)\n        longest = longest.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    prefixes.append(longest)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphao9ppea.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmphao9ppea.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmphao9ppea.swift:11:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        longest = longest.prefix(string)\n\
    \                                 ^\n/tmp/tmphao9ppea.swift:11:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        longest\
    \ = longest.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi0hlpti7.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphg0n3c_6.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmphg0n3c_6.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4e6vwigl.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4e6vwigl.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n                                         ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp38l5r4nm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp79gmdssh.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp79gmdssh.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm0hngb7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0hngb7t.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpm0hngb7t.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp79gmdssh.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp79gmdssh.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4t6rhbdg.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp4t6rhbdg.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp79gmdssh.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp79gmdssh.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp38l5r4nm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        }\n        currentPrefix = String(character) + currentPrefix\n    }\n\
    \    prefixes.append(currentPrefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp534hq9c8/tmp534hq9c8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae274f35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae274c2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae274c2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae274c2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp534hq9c8                        0x000055f78c23b78e <unavailable> + 6030

    5    libc.so.6                          0x00002ae275121460 __libc_start_main +
    245

    6    tmp534hq9c8                        0x000055f78c23b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        prefixes.append(s)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi88pliho.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpi88pliho.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current += String(c)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current = current + c\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnvnzm5u8.swift:9:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        current = current + c\n        \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm0hngb7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0hngb7t.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpm0hngb7t.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn3sltkyn.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpn3sltkyn.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpn3sltkyn.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        }\n        currentPrefix = currentPrefix + character\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo9t8qhwn.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo9t8qhwn.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var longest = string\n    var shortest = \"\"\n\
    \    while current != \"\" {\n        shortest = current\n        current = current.prefix(string:\
    \ longest)\n        longest = longest.prefix(string: current)\n        prefixes.append(current)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp60rnxt27.swift:12:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        current = current.prefix(string: longest)\n       \
    \                   ^\n/tmp/tmp60rnxt27.swift:12:27: note: found candidate with\
    \ type '(Int) -> PrefixSequence<String>'\n        current = current.prefix(string:\
    \ longest)\n                          ^\n/tmp/tmp60rnxt27.swift:12:27: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        current = current.prefix(string: longest)\n                         \
    \ ^\n/tmp/tmp60rnxt27.swift:12:27: error: no 'prefix' candidates produce the expected\
    \ contextual result type 'String'\n        current = current.prefix(string: longest)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\n/tmp/tmp60rnxt27.swift:13:27: error: no\
    \ exact matches in call to instance method 'prefix'\n        longest = longest.prefix(string:\
    \ current)\n                          ^\n/tmp/tmp60rnxt27.swift:13:27: note: found\
    \ candidate with type '(Int) -> PrefixSequence<String>'\n        longest = longest.prefix(string:\
    \ current)\n                          ^\n/tmp/tmp60rnxt27.swift:13:27: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        longest = longest.prefix(string: current)\n                         \
    \ ^\n/tmp/tmp60rnxt27.swift:13:27: error: no 'prefix' candidates produce the expected\
    \ contextual result type 'String'\n        longest = longest.prefix(string: current)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1waofdl_.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = String(character) + currentPrefix\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b561cb41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b561c838561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b561c838286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b561c83813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b561c837bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b561c96bec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b561c924660 String.subscript.getter
    + 34

    7    tmp5aoweacw                        0x000055c0e1669cc8 <unavailable> + 7368

    8    tmp5aoweacw                        0x000055c0e16697b7 <unavailable> + 6071

    9    libc.so.6                          0x00002b561cd2d460 __libc_start_main +
    245

    10   tmp5aoweacw                        0x000055c0e16693d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4t6rhbdg.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp4t6rhbdg.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current.characters.count > 0 {\n        prefixes.append(current)\n\
    \        current = String(current.characters.dropLast())\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp21y4jq1l.swift:8:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    while current.characters.count > 0 {\n            \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp21y4jq1l.swift:10:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        current\
    \ = String(current.characters.dropLast())\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for character in string {\n        if character ==\
    \ character {\n            prefixes.append(prefix)\n            prefix = \"\"\n\
    \        } else {\n            prefix += character\n        }\n    }\n    prefixes.append(prefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj_5qgxp_.swift:13:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            prefix += character\n      \
    \                ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphg0n3c_6.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmphg0n3c_6.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        if currentPrefix.hasPrefix(string)\
    \ {\n            prefixes.append(currentPrefix)\n        }\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmppvvy9bs4/tmppvvy9bs4.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b763fa0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b763f705b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b763f705988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b763f7047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvvy9bs4                        0x000055bfd7a7b8d8 <unavailable> + 6360

    5    libc.so.6                          0x00002b763fbfa460 __libc_start_main +
    245

    6    tmppvvy9bs4                        0x000055bfd7a7b339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current.characters.count > 0 {\n        current\
    \ = current.prefix(current.characters.count - 1)\n        prefixes.append(current)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsf12sb9u.swift:8:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    while current.characters.count > 0 {\n            \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsf12sb9u.swift:9:27:\
    \ error: no 'prefix' candidates produce the expected contextual result type 'String'\n\
    \        current = current.prefix(current.characters.count - 1)\n            \
    \              ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var currentPrefix: String = \"\"\n    while current\
    \ != \"\" {\n        current = current.prefix(string)\n        currentPrefix =\
    \ current\n        prefixes.append(currentPrefix)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp93yqwb30.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmp93yqwb30.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string.characters {\n        prefixes.append(String(string[c...]))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbnlwn_mr.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbnlwn_mr.swift:8:38:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Character'\
    \ be equivalent\n        prefixes.append(String(string[c...]))\n             \
    \                        ^\nSwift.Collection:2:23: note: where 'Self.Index' =\
    \ 'String.Index', 'R.Bound' = 'Character'\n    @inlinable public subscript<R>(r:\
    \ R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get\
    \ }\n                      ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpftl2yulm.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpftl2yulm.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for character in string {\n        for prefix in prefixes {\n           \
    \ if character == prefix {\n                break\n            }\n        }\n\
    \        if character == \"\" {\n            prefixes.append(character)\n    \
    \    }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpne_gw25t.swift:9:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if character == prefix\
    \ {\n               ~~~~~~~~~ ^  ~~~~~~\n/tmp/tmpne_gw25t.swift:9:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if character == prefix {\n                   \
    \      ^\n/tmp/tmpne_gw25t.swift:13:22: error: binary operator '==' cannot be\
    \ applied to operands of type 'Character' and 'String'\n        if character ==\
    \ \"\" {\n           ~~~~~~~~~ ^  ~~\n/tmp/tmpne_gw25t.swift:13:22: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if character == \"\" {\n                     ^\n/tmp/tmpne_gw25t.swift:14:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(character)\n                            ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_zy3sngd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp_zy3sngd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp_zy3sngd.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1waofdl_.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwxrzec7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpwxrzec7t.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        }\n        currentPrefix = String(character) + currentPrefix\n    }\n\
    \    prefixes.append(currentPrefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp534hq9c8/tmp534hq9c8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae274f35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae274c2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae274c2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae274c2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp534hq9c8                        0x000055f78c23b78e <unavailable> + 6030

    5    libc.so.6                          0x00002ae275121460 __libc_start_main +
    245

    6    tmp534hq9c8                        0x000055f78c23b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n            prefix = \"\"\n        } else {\n\
    \            prefix += c\n        }\n    }\n    prefixes.append(prefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprcx9cn3h.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmprcx9cn3h.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmprcx9cn3h.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi0hlpti7.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphg0n3c_6.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmphg0n3c_6.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwxrzec7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpwxrzec7t.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1waofdl_.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_zy3sngd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp_zy3sngd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp_zy3sngd.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpymyuk38t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpymyuk38t.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm0hngb7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0hngb7t.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpm0hngb7t.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpftl2yulm.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpftl2yulm.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = current[..<string.count]\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_dbontw3.swift:10:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        current = current[..<string.count]\n                  ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpru856_hj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpru856_hj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpru856_hj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = current[current.startIndex]\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpemt9w_ah.swift:10:26: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        current = current[current.startIndex]\n          \
    \        ~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    var index = 0\n    while index < current.count\
    \ {\n        prefixes.append(String(current[index...]))\n        current = String(current[..<index])\n\
    \        index += 1\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp2w0zi51.swift:10:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(String(current[index...]))\n                        \
    \       ^~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpp2w0zi51.swift:11:26:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n        current = String(current[..<index])\n\
    \                         ^~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        }\n        currentPrefix = String(character) + currentPrefix\n    }\n\
    \    prefixes.append(currentPrefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp534hq9c8/tmp534hq9c8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae274f35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae274c2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae274c2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae274c2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp534hq9c8                        0x000055f78c23b78e <unavailable> + 6030

    5    libc.so.6                          0x00002ae275121460 __libc_start_main +
    245

    6    tmp534hq9c8                        0x000055f78c23b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpftl2yulm.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpftl2yulm.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp38l5r4nm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while !current.isEmpty {\n        prefixes.append(current)\n\
    \        current = current.prefix(string.count)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpang0e0nv.swift:10:27: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        current = current.prefix(string.count)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        currentPrefix =\
    \ currentPrefix + c\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1waofdl_.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpru856_hj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpru856_hj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpru856_hj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string.characters {\n        prefixes.append(String(string[c...]))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbnlwn_mr.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbnlwn_mr.swift:8:38:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Character'\
    \ be equivalent\n        prefixes.append(String(string[c...]))\n             \
    \                        ^\nSwift.Collection:2:23: note: where 'Self.Index' =\
    \ 'String.Index', 'R.Bound' = 'Character'\n    @inlinable public subscript<R>(r:\
    \ R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get\
    \ }\n                      ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4e6vwigl.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4e6vwigl.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + String(character)\n                                         ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwxrzec7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpwxrzec7t.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpwxrzec7t.swift:10:68: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpwxrzec7t.swift:13:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3au0435o.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3au0435o.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpftl2yulm.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpftl2yulm.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = currentPrefix + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphg0n3c_6.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmphg0n3c_6.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi0hlpti7.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = string[string.index(current, offsetBy: 1)]\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw8ue3zqx.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        current = string[string.index(current,\
    \ offsetBy: 1)]\n                                      ^\n/tmp/tmpw8ue3zqx.swift:10:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        current\
    \ = string[string.index(current, offsetBy: 1)]\n                  ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpftl2yulm.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpftl2yulm.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(from:\
    \ current)\n        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_j9akn6i.swift:9:27: error: no exact matches in call to instance\
    \ method 'prefix'\n        current = current.prefix(from: current)\n         \
    \                 ^\n/tmp/tmp_j9akn6i.swift:9:27: note: found candidate with type\
    \ '(Int) -> PrefixSequence<String>'\n        current = current.prefix(from: current)\n\
    \                          ^\n/tmp/tmp_j9akn6i.swift:9:27: note: found candidate\
    \ with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n       \
    \ current = current.prefix(from: current)\n                          ^\n/tmp/tmp_j9akn6i.swift:9:27:\
    \ error: no 'prefix' candidates produce the expected contextual result type 'String'\n\
    \        current = current.prefix(from: current)\n                          ^\n\
    Swift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>', not the\
    \ expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for character in string {\n        current = current\
    \ + String(character)\n        prefixes.append(current)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current.characters.count > 0 {\n        prefixes.append(current)\n\
    \        current = current.prefix(current.characters.count - 1)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxbdu9k8_.swift:8:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    while current.characters.count > 0 {\n            \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpxbdu9k8_.swift:10:27:\
    \ error: no 'prefix' candidates produce the expected contextual result type 'String'\n\
    \        current = current.prefix(current.characters.count - 1)\n            \
    \              ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = \"\"\n        } else {\n            currentPrefix\
    \ = currentPrefix + character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3au0435o.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3au0435o.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpymyuk38t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpymyuk38t.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character) + currentPrefix\n         \
    \   prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4t6rhbdg.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmp4t6rhbdg.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_zy3sngd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp_zy3sngd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp_zy3sngd.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = \"\"\n    for c in string {\n        current = current + c\n\
    \        if current.hasPrefix(string) {\n            prefixes.append(current)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3pgo2fzk.swift:9:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        current = current + c\n        \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpru856_hj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpru856_hj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpru856_hj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = String(character)\n           \
    \ prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002baa62d5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa62a52561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa62a52286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa62a5213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa62a51bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002baa62b85ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002baa62b3e660 String.subscript.getter
    + 34

    7    tmpstvjnpqp                        0x000055e975cfcc8d <unavailable> + 7309

    8    tmpstvjnpqp                        0x000055e975cfc767 <unavailable> + 5991

    9    libc.so.6                          0x00002baa62f47460 __libc_start_main +
    245

    10   tmpstvjnpqp                        0x000055e975cfc389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix {\n            prefixes.append(currentPrefix)\n        } else\
    \ {\n            currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq4qfcayv.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpq4qfcayv.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 0
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        currentPrefix\
    \ = String(currentPrefix) + String(character)\n        prefixes.append(currentPrefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        prefixes.append(s)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi88pliho.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpi88pliho.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + String(character)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp38l5r4nm.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\
    \ + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpru856_hj.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpru856_hj.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpru856_hj.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if c == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + c\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9laefq86.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp9laefq86.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp9laefq86.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbjjqjspp.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpbjjqjspp.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jsje3wy.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.startIndex] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = String(character) + currentPrefix\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b561cb41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b561c838561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b561c838286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b561c83813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b561c837bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b561c96bec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b561c924660 String.subscript.getter
    + 34

    7    tmp5aoweacw                        0x000055c0e1669cc8 <unavailable> + 7368

    8    tmp5aoweacw                        0x000055c0e16697b7 <unavailable> + 6071

    9    libc.so.6                          0x00002b561cd2d460 __libc_start_main +
    245

    10   tmp5aoweacw                        0x000055c0e16693d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n            currentPrefix = currentPrefix\
    \ + character\n        } else {\n            prefixes.append(currentPrefix)\n\
    \            currentPrefix = character\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm0hngb7t.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm0hngb7t.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpm0hngb7t.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for c in string {\n        if currentPrefix\
    \ == \"\" {\n            currentPrefix = c\n        } else {\n            if c\
    \ == currentPrefix[0] {\n                currentPrefix = currentPrefix[1..]\n\
    \            } else {\n                prefixes.append(currentPrefix)\n      \
    \          currentPrefix = c\n            }\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4c3gbhgw.swift:10:29: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            currentPrefix = c\n                          \
    \  ^\n/tmp/tmp4c3gbhgw.swift:12:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if c\
    \ == currentPrefix[0] {\n                    ^~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4c3gbhgw.swift:13:48:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n           \
    \     currentPrefix = currentPrefix[1..]\n                                   \
    \            ^~\n                                               ...\n/tmp/tmp4c3gbhgw.swift:16:33:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      currentPrefix = c\n                                ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string {\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n            prefixes.append(currentPrefix)\n\
    \        } else {\n            currentPrefix = currentPrefix + character\n   \
    \     }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp79gmdssh.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp79gmdssh.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        current = current.prefix(current)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmps_2pwv9o.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(current)\n\
    \                                 ^\n/tmp/tmps_2pwv9o.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(current)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == prefix {\n    \
    \        prefixes.append(prefix)\n        } else {\n            prefix = prefix\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn3sltkyn.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpn3sltkyn.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpn3sltkyn.swift:12:20:\
    \ error: assigning a variable to itself\n            prefix = prefix\n       \
    \     ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: -1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = string\n    while !current.isEmpty {\n        prefixes.append(current)\n\
    \        current = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014197
