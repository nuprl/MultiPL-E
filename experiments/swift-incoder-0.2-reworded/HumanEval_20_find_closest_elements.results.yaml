language: swift
name: HumanEval_20_find_closest_elements
results:
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzcj2g7zy.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double(Int.max)\n    var\
    \ largest = Double(Int.min)\n    for i in 0..<numbers.count {\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpq2du7wps/tmpq2du7wps.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc198e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc195d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc195d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc195d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq2du7wps                        0x000055b82b55a6be <unavailable> + 5822

    5    libc.so.6                          0x00002acc19ace460 __libc_start_main +
    245

    6    tmpq2du7wps                        0x000055b82b55a279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var closest1 = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n  \
    \  for number in sortedNumbers {\n        if number < closest1 {\n           \
    \ closest1 = number\n        } else if number > closest2 {\n            closest2\
    \ = number\n        }\n    }\n    return (closest1, closest2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp55_856fu/tmp55_856fu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01a7754c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01a744bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01a744b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01a744a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55_856fu                        0x000055fde1f1e6ee <unavailable> + 5870

    5    libc.so.6                          0x00002b01a7940460 __libc_start_main +
    245

    6    tmp55_856fu                        0x000055fde1f1e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        } else if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6omqchwe.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp6omqchwe.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp6omqchwe.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp6omqchwe.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    if min2 < min1 {\n        return (min2, max1)\n   \
    \ }\n    if max1 > max2 {\n        return (max1, max2)\n    }\n    if max2 > max1\
    \ {\n        return (max2, max1)\n    }\n    return (min1, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8e8kt5mv.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmp8e8kt5mv.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmp8e8kt5mv.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp8e8kt5mv.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmp8e8kt5mv.swift:22:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min2 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmp8e8kt5mv.swift:23:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max1)\n               ^\n/tmp/tmp8e8kt5mv.swift:25:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp8e8kt5mv.swift:26:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmp8e8kt5mv.swift:28:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max2 > max1 {\n       ~~~~ ^ ~~~~\n/tmp/tmp8e8kt5mv.swift:29:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max2, max1)\n               ^\n/tmp/tmp8e8kt5mv.swift:31:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let cur = numbers[i]\n        if cur < min1 {\n            min1 =\
    \ cur\n        } else if cur > max1 {\n            max1 = cur\n        }\n   \
    \     if cur < min2 {\n            min2 = cur\n        } else if cur > max2 {\n\
    \            max2 = cur\n        }\n    }\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmps33hda37.swift:19:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = cur\n            ^~~~\n/tmp/tmps33hda37.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmps33hda37.swift:21:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = cur\n            ^~~~\n/tmp/tmps33hda37.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmps33hda37.swift:24:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = cur\n            ^~~~\n/tmp/tmps33hda37.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmps33hda37.swift:26:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = cur\n            ^~~~\n/tmp/tmps33hda37.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let sortedNumbers = numbers.sorted()\n    let\
    \ closestToFirst = sortedNumbers[0]\n    let closestToSecond = sortedNumbers[1]\n\
    \    return (closestToFirst, closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpqeyg9rym/tmpqeyg9rym.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b237eeafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b237eba6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b237eba6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b237eba57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqeyg9rym                        0x0000557a1fb1e5de <unavailable> + 5598

    5    libc.so.6                          0x00002b237f09b460 __libc_start_main +
    245

    6    tmpqeyg9rym                        0x0000557a1fb1e199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    guard numbers.count >= 2 else {\n        return\
    \ (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] > largest {\n        \
    \    largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9tr58_sh.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    \n    for number in numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n    }\n    \n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4emzdg_w.swift:18:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp4emzdg_w.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp4emzdg_w.swift:21:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp4emzdg_w.swift:14:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropLast())\n    let max2 = max(numbers.dropFirst())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpcjnj2lfd.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmpcjnj2lfd.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmpcjnj2lfd.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpcjnj2lfd.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpcjnj2lfd.swift:11:38: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropLast())\n             \
    \                        ^\n                                     , <#[Double]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpcjnj2lfd.swift:12:39:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropFirst())\n\
    \                                      ^\n                                   \
    \   , <#DropFirstSequence<[Double]>#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallestDifference = Double.infinity\n\
    \    var smallestDifferenceIndex = -1\n    var smallestDifferenceValue = Double.infinity\n\
    \n    for i in 0..<numbers.count {\n        let difference = abs(numbers[i] -\
    \ numbers[smallestDifferenceIndex])\n        if difference < smallestDifference\
    \ {\n            smallestDifference = difference\n            smallestDifferenceIndex\
    \ = i\n            smallestDifferenceValue = numbers[i]\n        }\n    }\n\n\
    \    return (numbers[smallestDifferenceIndex], numbers[smallestDifferenceIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7f3997c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7f368e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba7f368e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba7f368e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba7f368dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba7f348df44 <unavailable> + 188228

    6    tmpvd0txorq                        0x0000564e5edeffbe <unavailable> + 8126

    7    tmpvd0txorq                        0x0000564e5edef70d <unavailable> + 5901

    8    libc.so.6                          0x00002ba7f3b83460 __libc_start_main +
    245

    9    tmpvd0txorq                        0x0000564e5edef3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt3lkhhxz.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpt3lkhhxz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpt3lkhhxz.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpt3lkhhxz.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpt3lkhhxz.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    \n    for i in 1..numbers.count {\n        if numbers[i] >\
    \ largest {\n            largest = numbers[i]\n        }\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmposajlqhg.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw5lytfbs.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpw5lytfbs.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpw5lytfbs.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpw5lytfbs.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        } else if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6omqchwe.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp6omqchwe.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp6omqchwe.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp6omqchwe.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last() })\n\
    \    return (sortedNumbers[closestIndex], sortedNumbers[sortedNumbers.firstIndex({\
    \ $0 > sortedNumbers[closestIndex] })!])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptgacoh5c.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last()\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmptgacoh5c.swift:10:70: error: cannot\
    \ call value of non-function type 'Double?'\n    let closestIndex = sortedNumbers.firstIndex({\
    \ $0 > sortedNumbers.last() })\n                                             \
    \                        ^   ~~\n                                            \
    \                             \n/tmp/tmptgacoh5c.swift:11:81: error: missing argument\
    \ label 'where:' in call\n    return (sortedNumbers[closestIndex], sortedNumbers[sortedNumbers.firstIndex({\
    \ $0 > sortedNumbers[closestIndex] })!])\n                                   \
    \                                             ^\n                            \
    \                                                    where: \n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw5lytfbs.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpw5lytfbs.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpw5lytfbs.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpw5lytfbs.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.count < 2 {\n        return (sortedNumbers[0], sortedNumbers[1])\n\
    \    }\n    let closestToFirst = sortedNumbers.first\n    let closestToSecond\
    \ = sortedNumbers.last\n    return (closestToFirst, closestToSecond)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2nljdcg7.swift:15:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (closestToFirst,\
    \ closestToSecond)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsfktwe1w.swift:13:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpsfktwe1w.swift:15:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpff7wq2rh.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpff7wq2rh.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpm27umg1g.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpaeee39nv/tmpaeee39nv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1059a90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1059787b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1059787988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10597867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaeee39nv                        0x00005586f6c0e69e <unavailable> + 5790

    5    libc.so.6                          0x00002b1059c7c460 __libc_start_main +
    245

    6    tmpaeee39nv                        0x00005586f6c0e259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_vsa_gmm.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let curr = numbers[i]\n        if curr < min1 {\n            min1\
    \ = curr\n        } else if curr > max1 {\n            max1 = curr\n        }\n\
    \        if curr < min2 {\n            min2 = curr\n        } else if curr > max2\
    \ {\n            max2 = curr\n        }\n    }\n    return (min1, max1)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpg16e621r.swift:19:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = curr\n            ^~~~\n/tmp/tmpg16e621r.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpg16e621r.swift:21:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = curr\n            ^~~~\n/tmp/tmpg16e621r.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpg16e621r.swift:24:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = curr\n            ^~~~\n/tmp/tmpg16e621r.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpg16e621r.swift:26:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = curr\n            ^~~~\n/tmp/tmpg16e621r.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var closest1 = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n  \
    \  for number in sortedNumbers {\n        if number < closest1 {\n           \
    \ closest1 = number\n        } else if number > closest2 {\n            closest2\
    \ = number\n        }\n    }\n    return (closest1, closest2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp55_856fu/tmp55_856fu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01a7754c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01a744bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01a744b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01a744a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55_856fu                        0x000055fde1f1e6ee <unavailable> + 5870

    5    libc.so.6                          0x00002b01a7940460 __libc_start_main +
    245

    6    tmp55_856fu                        0x000055fde1f1e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double(Int.max)\n    var\
    \ largest = Double(Int.min)\n    for number in numbers {\n        if number <\
    \ smallest {\n            smallest = number\n        }\n        if number > largest\
    \ {\n            largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp8vjmswrl/tmp8vjmswrl.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef37c35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef3792cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef3792c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef3792b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8vjmswrl                        0x0000560b009e05fe <unavailable> + 5630

    5    libc.so.6                          0x00002aef37e21460 __libc_start_main +
    245

    6    tmp8vjmswrl                        0x0000560b009e01b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpafv142ul/tmpafv142ul.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b445fb8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445f885b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b445f885988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b445f8847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafv142ul                        0x000056106c57c6be <unavailable> + 5822

    5    libc.so.6                          0x00002b445fd7a460 __libc_start_main +
    245

    6    tmpafv142ul                        0x000056106c57c279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw_ympot4.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpw_ympot4.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw_ympot4.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpw_ympot4.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min2, min1)\n    }\n    if max1 > max2\
    \ {\n        return (max2, max1)\n    }\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpe0z3sseg.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpe0z3sseg.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpe0z3sseg.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpe0z3sseg.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max2, max1)\n               ^\n/tmp/tmpe0z3sseg.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmnh8ec_m.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var closest1 = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n  \
    \  for number in sortedNumbers {\n        if number < closest1 {\n           \
    \ closest1 = number\n        } else if number > closest2 {\n            closest2\
    \ = number\n        }\n    }\n    return (closest1, closest2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp55_856fu/tmp55_856fu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01a7754c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01a744bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01a744b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01a744a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55_856fu                        0x000055fde1f1e6ee <unavailable> + 5870

    5    libc.so.6                          0x00002b01a7940460 __libc_start_main +
    245

    6    tmp55_856fu                        0x000055fde1f1e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropFirst())\n    let max2 = max(numbers.dropFirst())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwaxpxu_j.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmpwaxpxu_j.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmpwaxpxu_j.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpwaxpxu_j.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpwaxpxu_j.swift:11:39: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropFirst())\n            \
    \                          ^\n                                      , <#DropFirstSequence<[Double]>#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpwaxpxu_j.swift:12:39:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropFirst())\n\
    \                                      ^\n                                   \
    \   , <#DropFirstSequence<[Double]>#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsfktwe1w.swift:13:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpsfktwe1w.swift:15:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw_ympot4.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpw_ympot4.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpywf5veq1.swift:13:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpywf5veq1.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpywf5veq1.swift:16:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpywf5veq1.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallestDifference = Double.infinity\n\
    \    var smallestDifferenceIndex = -1\n    var smallestDifferenceValue = Double.infinity\n\
    \    var smallestDifferenceValueIndex = -1\n    var smallestDifferenceValue2 =\
    \ Double.infinity\n    var smallestDifferenceValue2Index = -1\n    var smallestDifferenceValue3\
    \ = Double.infinity\n    var smallestDifferenceValue3Index = -1\n    var smallestDifferenceValue4\
    \ = Double.infinity\n    var smallestDifferenceValue4Index = -1\n    var smallestDifferenceValue5\
    \ = Double.infinity\n    var smallestDifferenceValue5Index = -1\n    var smallestDifferenceValue6\
    \ = Double.infinity\n    var smallestDifferenceValue6Index = -1\n    var smallestDifferenceValue7\
    \ = Double.infinity\n    var smallestDifferenceValue7Index = -1\n    var smallestDifferenceValue8\
    \ = Double.infinity\n    var smallestDifferenceValue8Index = -1\n    var smallestDifferenceValue9\
    \ = Double.infinity\n    var smallestDifferenceValue9Index = -1\n    var smallestDifferenceValue10\
    \ = Double.infinity\n    var smallestDifferenceValue10Index = -1\n    var smallestDifferenceValue11\
    \ = Double.infinity\n    var smallestDifferenceValue11Index = -1\n    var smallestDifferenceValue12\
    \ = Double.infinity\n    var smallestDifferenceValue12Index = -1\n    var smallestDifferenceValue13\
    \ = Double.infinity\n    var smallestDifferenceValue13Index = -1\n    var smallestDifferenceValue14\
    \ = Double.infinity\n    var smallestDifferenceValue14Index = -1\n    var smallestDifferenceValue15\
    \ = Double.infinity\n    var smallestDifferenceValue15Index = -1\n    var smallestDifferenceValue16\
    \ = Double.infinity\n    var smallestDifferenceValue16Index = -1\n    var smallestDifferenceValue17\
    \ = Double.infinity\n    var smallestDifferenceValue17Index = -1\n    var smallestDifferenceValue18\
    \ = Double.infinity\n    var smallestDifferenceValue18Index = -1\n    var smallestDifferenceValue19\
    \ = Double.infinity\n    var smallestDifferenceValue19Index = -1\n    var smallestDifferenceValue20\
    \ = Double.infinity\n    var smallestDifferenceValue20Index = -1\n    var smallestDifferenceValue21\
    \ = Double.infinity\n    var smallestDifferenceValue21Index = -1\n    var smallestDifferenceValue22\
    \ = Double.infinity\n    var smallestDifferenceValue22Index = -1\n    var smallestDifferenceValue23\
    \ = Double.infinity\n    var smallestDifferenceValue23Index = -1\n    var smallestDifferenceValue24\
    \ = Double.infinity\n    var smallestDifferenceValue24Index = -1\n    var smallestDifferenceValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpz11tzpgi.swift:59:9: error: type annotation missing in pattern\n\
    \    var smallestDifferenceValue\n        ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.max\n   \
    \ var largest: Double = Double.min\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnbn92u0d.swift:9:35: error: type 'Double' has no member 'max'\n\
    \    var smallest: Double = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmpnbn92u0d.swift:10:34: error: type 'Double' has no member 'min'\n    var\
    \ largest: Double = Double.min\n                          ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpm27umg1g.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last() })\n\
    \    let closestNumber = sortedNumbers[closestIndex]\n    return (closestNumber,\
    \ sortedNumbers[closestIndex + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1_xjgm1h.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last()\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmp1_xjgm1h.swift:10:70: error: cannot\
    \ call value of non-function type 'Double?'\n    let closestIndex = sortedNumbers.firstIndex({\
    \ $0 > sortedNumbers.last() })\n                                             \
    \                        ^   ~~\n                                            \
    \                             \n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        } else if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj3nn541a.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[2]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[3]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[4]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[5]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[6]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[7]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[8]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[9])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[10]) }\n\
    \    guard numbers.count > 12 else { return (numbers[0], numbers[11]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[12]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[13]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[14]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[15]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[16]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[17]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[18])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[19]) }\n\
    \    guard numbers.count > 21 else { return (numbers[0], numbers[20]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[21]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[22]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[23]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[24]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[25]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[26]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[27])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], number\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpqtk9fhiw.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpqtk9fhiw.swift:37:44: note: to match this opening '('\n    guard numbers.count\
    \ > 29 else { return (numbers[0], number\n                                   \
    \        ^\n/tmp/tmpqtk9fhiw.swift:57:80: error: expected '}' at end of brace\
    \ statement\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == (2.2, 3.1))\n                                                           \
    \                    ^\n/tmp/tmpqtk9fhiw.swift:8:67: note: to match this opening\
    \ '{'\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n \
    \                                                                 ^\n/tmp/tmpqtk9fhiw.swift:37:57:\
    \ error: cannot find 'number' in scope\n    guard numbers.count > 29 else { return\
    \ (numbers[0], number\n                                                      \
    \  ^~~~~~\n/tmp/tmpqtk9fhiw.swift:41:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpns54touz.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmpns54touz.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpns54touz.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpns54touz.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmpns54touz.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpns54touz.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.count < 2 {\n        return (sortedNumbers[0], sortedNumbers[0])\n\
    \    }\n    let closestToFirst = sortedNumbers.first!\n    let closestToSecond\
    \ = sortedNumbers.last!\n    return (closestToFirst, closestToSecond)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4ygu610g/tmp4ygu610g.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63c2686c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63c237db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63c237d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63c237c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ygu610g                        0x000055f3f24037ae <unavailable> + 6062

    5    libc.so.6                          0x00002b63c2872460 __libc_start_main +
    245

    6    tmp4ygu610g                        0x000055f3f2403369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmnh8ec_m.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp537s3me5/tmp537s3me5.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab91f2d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab91efcbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab91efcb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab91efca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp537s3me5                        0x000055ac5ab636be <unavailable> + 5822

    5    libc.so.6                          0x00002ab91f4c0460 __libc_start_main +
    245

    6    tmp537s3me5                        0x000055ac5ab63279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzcj2g7zy.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for number in numbers\
    \ {\n        if number < min1 {\n            min1 = number\n        } else if\
    \ number > max1 {\n            max1 = number\n        }\n        if number < min2\
    \ {\n            min2 = number\n        } else if number > max2 {\n          \
    \  max2 = number\n        }\n    }\n    return (min1, max1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwbg0an8m.swift:15:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = number\n            ^~~~\n/tmp/tmpwbg0an8m.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwbg0an8m.swift:17:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = number\n            ^~~~\n/tmp/tmpwbg0an8m.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwbg0an8m.swift:20:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = number\n            ^~~~\n/tmp/tmpwbg0an8m.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwbg0an8m.swift:22:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = number\n            ^~~~\n/tmp/tmpwbg0an8m.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_vsa_gmm.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  if numbers[i] > largest {\n            largest = numbers[i]\n            largestIndex\
    \ = i\n        }\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5da02e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d9ffdf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5d9ffdf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5d9ffdf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5d9ffdebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5d9fddef44 <unavailable> + 188228

    6    tmprx5mz65m                        0x000055e2d9896fa8 <unavailable> + 8104

    7    tmprx5mz65m                        0x000055e2d98965cd <unavailable> + 5581

    8    libc.so.6                          0x00002b5da04d4460 __libc_start_main +
    245

    9    tmprx5mz65m                        0x000055e2d9896279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd5j4ommd.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4y63591r/tmp4y63591r.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ed210dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ed1e04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ed1e04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ed1e037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4y63591r                        0x000055db1f5316be <unavailable> + 5822

    5    libc.so.6                          0x00002b4ed22f9460 __libc_start_main +
    245

    6    tmp4y63591r                        0x000055db1f531279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (min1, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpk7mpujmv.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpk7mpujmv.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmpk7mpujmv.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpk7mpujmv.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpk7mpujmv.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp80km01pq/tmp80km01pq.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b941633dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9416034b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9416034988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94160337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80km01pq                        0x00005637653fe69e <unavailable> + 5790

    5    libc.so.6                          0x00002b9416529460 __libc_start_main +
    245

    6    tmp80km01pq                        0x00005637653fe259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpff7wq2rh.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpff7wq2rh.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp80km01pq/tmp80km01pq.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b941633dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9416034b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9416034988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94160337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80km01pq                        0x00005637653fe69e <unavailable> + 5790

    5    libc.so.6                          0x00002b9416529460 __libc_start_main +
    245

    6    tmp80km01pq                        0x00005637653fe259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmnh8ec_m.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpm27umg1g.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpaeee39nv/tmpaeee39nv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1059a90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1059787b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1059787988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10597867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaeee39nv                        0x00005586f6c0e69e <unavailable> + 5790

    5    libc.so.6                          0x00002b1059c7c460 __libc_start_main +
    245

    6    tmpaeee39nv                        0x00005586f6c0e259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpafv142ul/tmpafv142ul.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b445fb8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445f885b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b445f885988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b445f8847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafv142ul                        0x000056106c57c6be <unavailable> + 5822

    5    libc.so.6                          0x00002b445fd7a460 __libc_start_main +
    245

    6    tmpafv142ul                        0x000056106c57c279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropLast())\n    let max2 = max(numbers.dropLast())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp51cf4v84.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmp51cf4v84.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmp51cf4v84.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp51cf4v84.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp51cf4v84.swift:11:38: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropLast())\n             \
    \                        ^\n                                     , <#[Double]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp51cf4v84.swift:12:38:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropLast())\n\
    \                                     ^\n                                    \
    \ , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers.min()\n    let max =\
    \ numbers.max()\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpam3vlmmy.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (min,\
    \ max)\n           ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.max\n   \
    \ var largest: Double = Double.min\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnbn92u0d.swift:9:35: error: type 'Double' has no member 'max'\n\
    \    var smallest: Double = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmpnbn92u0d.swift:10:34: error: type 'Double' has no member 'min'\n    var\
    \ largest: Double = Double.min\n                          ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let min2 =\
    \ min(numbers)\n    if min1 < min2 {\n        return (min1, min2)\n    }\n   \
    \ return (min2, min1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpht3faah2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpht3faah2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let min2 = min(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpjws433ao/tmpjws433ao.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7252cb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72529a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72529a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72529a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjws433ao                        0x000055fd179ca64e <unavailable> + 5710

    5    libc.so.6                          0x00002b7252e9e460 __libc_start_main +
    245

    6    tmpjws433ao                        0x000055fd179ca209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] > largest {\n        \
    \    largest = numbers[i]\n        } else if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmps3a972tx.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpjws433ao/tmpjws433ao.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7252cb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72529a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72529a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72529a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjws433ao                        0x000055fd179ca64e <unavailable> + 5710

    5    libc.so.6                          0x00002b7252e9e460 __libc_start_main +
    245

    6    tmpjws433ao                        0x000055fd179ca209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var smallestDifference = Double.infinity\n    var smallestDifferenceIndex\
    \ = -1\n    var largestDifference = Double.infinity\n    var largestDifferenceIndex\
    \ = -1\n    for i in 0..<numbers.count {\n        let difference = sortedNumbers[i]\
    \ - sortedNumbers[smallestDifferenceIndex]\n        if difference < smallestDifference\
    \ {\n            smallestDifference = difference\n            smallestDifferenceIndex\
    \ = i\n        }\n        if difference > largestDifference {\n            largestDifference\
    \ = difference\n            largestDifferenceIndex = i\n        }\n    }\n   \
    \ return (sortedNumbers[smallestDifferenceIndex], sortedNumbers[largestDifferenceIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b42a117ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42a0e71561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b42a0e71286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b42a0e7113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b42a0e70bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b42a0c70f44 <unavailable> + 188228

    6    tmprlhp32hp                        0x000055881deaefed <unavailable> + 8173

    7    tmprlhp32hp                        0x000055881deae6cd <unavailable> + 5837

    8    libc.so.6                          0x00002b42a1366460 __libc_start_main +
    245

    9    tmprlhp32hp                        0x000055881deae379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n\n    var\
    \ smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex =\
    \ -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n        if\
    \ numbers[i] > largest {\n            largest = numbers[i]\n            largestIndex\
    \ = i\n        }\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp5t_1i567/tmp5t_1i567.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba722f8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba722c83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba722c83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba722c827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5t_1i567                        0x000055f393b256be <unavailable> + 5822

    5    libc.so.6                          0x00002ba723178460 __libc_start_main +
    245

    6    tmp5t_1i567                        0x000055f393b25279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpfztpomkx/tmpfztpomkx.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be58fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be55f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be55f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be55f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfztpomkx                        0x000055634b8a369e <unavailable> + 5790

    5    libc.so.6                          0x00002b5be5ae6460 __libc_start_main +
    245

    6    tmpfztpomkx                        0x000055634b8a3259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        let currentNumber = numbers[i]\n        if currentNumber < smallest\
    \ {\n            smallest = currentNumber\n            smallestIndex = i\n   \
    \     }\n        if currentNumber > largest {\n            largest = currentNumber\n\
    \            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bc3ecec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bc3bc5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2bc3bc5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2bc3bc513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2bc3bc4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2bc39c4f44 <unavailable> + 188228

    6    tmp0411vmnr                        0x00005613b5a59f4c <unavailable> + 8012

    7    tmp0411vmnr                        0x00005613b5a595cd <unavailable> + 5581

    8    libc.so.6                          0x00002b2bc40ba460 __libc_start_main +
    245

    9    tmp0411vmnr                        0x00005613b5a59279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpc4y52i4p.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpc4y52i4p.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpc4y52i4p.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpc4y52i4p.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    guard numbers.count > 1 else {\n        return\
    \ (0.0,numbers[0])\n    }\n    guard numbers.count > 2 else {\n        return\
    \ (numbers[0], numbers[1])\n    }\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwamo_dcz.swift:20:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        let currentNumber = numbers[i]\n        if currentNumber < smallest\
    \ {\n            smallest = currentNumber\n            smallestIndex = i\n   \
    \     }\n        if currentNumber > largest {\n            largest = currentNumber\n\
    \            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bc3ecec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bc3bc5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2bc3bc5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2bc3bc513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2bc3bc4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2bc39c4f44 <unavailable> + 188228

    6    tmp0411vmnr                        0x00005613b5a59f4c <unavailable> + 8012

    7    tmp0411vmnr                        0x00005613b5a595cd <unavailable> + 5581

    8    libc.so.6                          0x00002b2bc40ba460 __libc_start_main +
    245

    9    tmp0411vmnr                        0x00005613b5a59279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw_ympot4.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpw_ympot4.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2\
    \ {\n        return (min2, min1)\n    }\n    if min1 < min2 {\n        return\
    \ (min1, max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt3lkhhxz.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpt3lkhhxz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpt3lkhhxz.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpt3lkhhxz.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpt3lkhhxz.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        } else if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmprzz7_q7v/tmprzz7_q7v.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acaeb7f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acaeb4ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acaeb4eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acaeb4ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprzz7_q7v                        0x000055ce47af06be <unavailable> + 5822

    5    libc.so.6                          0x00002acaeb9e0460 __libc_start_main +
    245

    6    tmprzz7_q7v                        0x000055ce47af0279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    if max1 < min1 {\n        return (max1, min1)\n    }\n\
    \    var min2 = numbers[0]\n    var max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let current = numbers[i]\n        if current < min2 {\n         \
    \   min2 = current\n        } else if current > max2 {\n            max2 = current\n\
    \        }\n    }\n    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa6k2rk40.swift:11:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if max1 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpa6k2rk40.swift:12:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (max1, min1)\n               ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 || numbers.count >= 18 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 19 || numbers.count >= 20 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 21 || numbers.count >= 22 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 23 || numbers.count >= 24 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 25 || numbers.count >=\
    \ 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27 ||\
    \ numbers.count >= 28 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 29 || numbers.count >= 30 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 31 || numbers.count >= 32 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 33 || numbers.count >= 34 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 35 || numbers.count >= 36 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 37 || numbers.count >=\
    \ 38 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 39 ||\
    \ numbers.count >= 40 else { return (number\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_4n8wuea.swift:36:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_4n8wuea.swift:35:68: note: to match this opening '('\n    guard numbers.count\
    \ >= 39 || numbers.count >= 40 else { return (number\n                       \
    \                                            ^\n/tmp/tmp_4n8wuea.swift:55:80:\
    \ error: expected '}' at end of brace statement\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n                                \
    \                                               ^\n/tmp/tmp_4n8wuea.swift:8:67:\
    \ note: to match this opening '{'\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n                                                    \
    \              ^\n/tmp/tmp_4n8wuea.swift:35:69: error: cannot find 'number' in\
    \ scope\n    guard numbers.count >= 39 || numbers.count >= 40 else { return (number\n\
    \                                                                    ^~~~~~\n\
    /tmp/tmp_4n8wuea.swift:39:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpns54touz.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmpns54touz.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpns54touz.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    \n    for number in numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n    }\n    \n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpovdbw_8t/tmpovdbw_8t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54ffe31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54ffb28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54ffb28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54ffb277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpovdbw_8t                        0x00005602a86eb69e <unavailable> + 5790

    5    libc.so.6                          0x00002b550001d460 __libc_start_main +
    245

    6    tmpovdbw_8t                        0x00005602a86eb259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers)\n    let max2 = max(numbers)\n   \
    \ if min1 == max1 {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n\
    \        return (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1,\
    \ max2)\n    }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptjkxwxjx.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptjkxwxjx.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmptjkxwxjx.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmptjkxwxjx.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 || numbers.count >= 18 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 19 || numbers.count >= 20 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 21 || numbers.count >= 22 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 23 || numbers.count >= 24 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 25 || numbers.count >=\
    \ 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27 ||\
    \ numbers.count >= 28 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 29 || numbers.count >= 30 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 31 || numbers.count >= 32 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 33 || numbers.count >= 34 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 35 || numbers.count >= 36 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 37 || numbers.count >=\
    \ 38 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 39 ||\
    \ numbers.count >= 40 else { return (number\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_4n8wuea.swift:36:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_4n8wuea.swift:35:68: note: to match this opening '('\n    guard numbers.count\
    \ >= 39 || numbers.count >= 40 else { return (number\n                       \
    \                                            ^\n/tmp/tmp_4n8wuea.swift:55:80:\
    \ error: expected '}' at end of brace statement\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n                                \
    \                                               ^\n/tmp/tmp_4n8wuea.swift:8:67:\
    \ note: to match this opening '{'\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n                                                    \
    \              ^\n/tmp/tmp_4n8wuea.swift:35:69: error: cannot find 'number' in\
    \ scope\n    guard numbers.count >= 39 || numbers.count >= 40 else { return (number\n\
    \                                                                    ^~~~~~\n\
    /tmp/tmp_4n8wuea.swift:39:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpn39s3spl/tmpn39s3spl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00a380ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00a3501b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00a3501988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00a35007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn39s3spl                        0x00005577ee1576be <unavailable> + 5822

    5    libc.so.6                          0x00002b00a39f6460 __libc_start_main +
    245

    6    tmpn39s3spl                        0x00005577ee157279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4y63591r/tmp4y63591r.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ed210dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ed1e04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ed1e04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ed1e037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4y63591r                        0x000055db1f5316be <unavailable> + 5822

    5    libc.so.6                          0x00002b4ed22f9460 __libc_start_main +
    245

    6    tmp4y63591r                        0x000055db1f531279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpm27umg1g.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (smallest,\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let sortedNumbers = numbers.sorted()\n    let\
    \ firstClosest = sortedNumbers.first!\n    let secondClosest = sortedNumbers.last!\n\
    \    return (firstClosest, secondClosest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpeyzbv60w/tmpeyzbv60w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3bc013c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3bbd0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3bbd0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3bbd097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeyzbv60w                        0x000055709a97875e <unavailable> + 5982

    5    libc.so.6                          0x00002ae3bc1ff460 __libc_start_main +
    245

    6    tmpeyzbv60w                        0x000055709a978319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1kgso6vj.swift:16:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp1kgso6vj.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmp1kgso6vj.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmp1kgso6vj.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpafv142ul/tmpafv142ul.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b445fb8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445f885b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b445f885988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b445f8847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafv142ul                        0x000056106c57c6be <unavailable> + 5822

    5    libc.so.6                          0x00002b445fd7a460 __libc_start_main +
    245

    6    tmpafv142ul                        0x000056106c57c279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw5lytfbs.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpw5lytfbs.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpw5lytfbs.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpw5lytfbs.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzcj2g7zy.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpywf5veq1.swift:13:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpywf5veq1.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpywf5veq1.swift:16:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpywf5veq1.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1\
    \ = numbers.max()\n    let min2 = numbers.min()\n    let max2 = numbers.max()\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpns54touz.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmpns54touz.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpns54touz.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpns54touz.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers.min()\n    let max =\
    \ numbers.max()\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpam3vlmmy.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (min,\
    \ max)\n           ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n\
    \    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd63n1ua2.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpd63n1ua2.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    var closestToFirst = sortedNumbers[0]\n    var closestToSecond = sortedNumbers[1]\n\
    \    if sortedNumbers.count > 2 {\n        for number in sortedNumbers[2...] {\n\
    \            let distanceBetween = abs(closestToFirst - number)\n            if\
    \ distanceBetween < abs(closestToSecond - number) {\n                closestToSecond\
    \ = number\n            } else {\n                closestToFirst = number\n  \
    \          }\n        }\n    }\n    return (closestToFirst, closestToSecond)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpymwnavit/tmpymwnavit.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0ae6d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0ae3cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0ae3cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0ae3ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpymwnavit                        0x000055a061a6a99e <unavailable> + 6558

    5    libc.so.6                          0x00002ab0ae8c0460 __libc_start_main +
    245

    6    tmpymwnavit                        0x000055a061a6a559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw5lytfbs.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpw5lytfbs.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpw5lytfbs.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpw5lytfbs.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzcj2g7zy.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.count < 2 {\n        return (sortedNumbers[0], sortedNumbers[0])\n\
    \    }\n    if sortedNumbers.count == 2 {\n        return (sortedNumbers[0], sortedNumbers[1])\n\
    \    }\n    if sortedNumbers.count == 3 {\n        let closest1 = sortedNumbers[0]\n\
    \        let closest2 = sortedNumbers[1]\n        let closest3 = sortedNumbers[2]\n\
    \        let closest4 = sortedNumbers[3]\n        let closest5 = sortedNumbers[4]\n\
    \        let closest6 = sortedNumbers[5]\n        let closest7 = sortedNumbers[6]\n\
    \        let closest8 = sortedNumbers[7]\n        let closest9 = sortedNumbers[8]\n\
    \        let closest10 = sortedNumbers[9]\n        let closest11 = sortedNumbers[10]\n\
    \        let closest12 = sortedNumbers[11]\n        let closest13 = sortedNumbers[12]\n\
    \        let closest14 = sortedNumbers[13]\n        let closest15 = sortedNumbers[14]\n\
    \        let closest16 = sortedNumbers[15]\n        let closest17 = sortedNumbers[16]\n\
    \        let closest18 = sortedNumbers[17]\n        let closest19 = sortedNumbers[18]\n\
    \        let closest20 = sortedNumbers[19]\n        let closest21 = sortedNumbers[20]\n\
    \        let closest22 = sortedNumbers[21]\n        let closest23 = sortedNumbers[22]\n\
    \        let closest24 = sortedNumbers[23]\n        let closest25 = sortedNumbers[24]\n\
    \        let closest26 = sortedNumbers[25]\n        let closest27 = sortedNumbers[26]\n\
    \        let closest28 = sortedNumbers[27]\n        let closest29 = sortedNumbers[28]\n\
    \        let closest30 = sortedNumbers[29]\n        let closest31 = sortedNumbers[30]\n\
    \        let closest32 = sortedNumbers[31]\n        let closest33 = sortedNumbers[32]\n\
    \        let closest34 = sortedNumbers[33]\n        let closest35 = sortedNumbers[34]\n\
    \        let closest36 = sortedNumbers[35]\n        let closest37 = sortedNumbers[36]\n\
    \        let closest38 = sortedNumbers[37]\n        let closest39 = sortedNumbers[38]\n\
    \        let closest40 = sortedNumbers[39]\n        let closest41 = sortedNumbers[40]\n\
    \        let closest42 = sortedNumbers[41]\n        let closest43 = sortedNumbers[42]\n\
    \        let closest44 = sortedNumbers[43]\n        let closest45 = sortedNumbers[44]\n\
    \        let closest46 = sortedNumbers[45]\n        let closest47 = sortedNumbers[46]\n\
    \        let closest48 = sortedNumbers[47]\n        let closest49 = sortedNumbers[48]\n\
    \        let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpavnofgxo.swift:66:12: error: expected pattern\n        let \n \
    \          ^\n/tmp/tmpavnofgxo.swift:86:80: error: expected '}' at end of brace\
    \ statement\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == (2.2, 3.1))\n                                                           \
    \                    ^\n/tmp/tmpavnofgxo.swift:8:67: note: to match this opening\
    \ '{'\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n \
    \                                                                 ^\n/tmp/tmpavnofgxo.swift:70:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpavnofgxo.swift:17:13:\
    \ warning: initialization of immutable value 'closest1' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let closest1 = sortedNumbers[0]\n\
    \        ~~~~^~~~~~~~\n        _\n/tmp/tmpavnofgxo.swift:18:13: warning: initialization\
    \ of immutable value 'closest2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let closest2 = sortedNumbers[1]\n        ~~~~^~~~~~~~\n\
    \        _\n/tmp/tmpavnofgxo.swift:19:13: warning: initialization of immutable\
    \ value 'closest3' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let closest3 = sortedNumbers[2]\n        ~~~~^~~~~~~~\n\
    \        _\n/tmp/tmpavnofgxo.swift:20:13: warning: initialization of immutable\
    \ value 'closest4' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let closest4 = sortedNumbers[3]\n        ~~~~^~~~~~~~\n\
    \        _\n/tmp/tmpavnofgxo.swift:21:13: warning: initialization of immutable\
    \ value 'closest5' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let closest5 = sortedNumbers[4]\n        ~~~~^~~~~~~~\n\
    \        _\n/tmp/tmpavnofgxo.swift:22:13: warning: initialization of immutable\
    \ value 'closest6' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let closest6 = sortedNumbers[5]\n        ~~~~^~~~~~~~\n\
    \       "
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[2]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[3]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[4]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[5]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[6]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[7]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[8]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[9])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[10]) }\n\
    \    guard numbers.count > 12 else { return (numbers[0], numbers[11]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[12]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[13]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[14]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[15]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[16]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[17]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[18])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[19]) }\n\
    \    guard numbers.count > 21 else { return (numbers[0], numbers[20]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[21]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[22]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[23]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[24]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[25]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[26]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[27])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], number\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpqtk9fhiw.swift:38:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpqtk9fhiw.swift:37:44: note: to match this opening '('\n    guard numbers.count\
    \ > 29 else { return (numbers[0], number\n                                   \
    \        ^\n/tmp/tmpqtk9fhiw.swift:57:80: error: expected '}' at end of brace\
    \ statement\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1])\
    \ == (2.2, 3.1))\n                                                           \
    \                    ^\n/tmp/tmpqtk9fhiw.swift:8:67: note: to match this opening\
    \ '{'\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n \
    \                                                                 ^\n/tmp/tmpqtk9fhiw.swift:37:57:\
    \ error: cannot find 'number' in scope\n    guard numbers.count > 29 else { return\
    \ (numbers[0], number\n                                                      \
    \  ^~~~~~\n/tmp/tmpqtk9fhiw.swift:41:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpybgkvcji.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpybgkvcji.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    \n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n    }\n    \n  \
    \  return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplq56yl1q.swift:18:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmplq56yl1q.swift:14:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmplq56yl1q.swift:21:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmplq56yl1q.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    \n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    \n    for number in numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n    }\n    \n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1h1uwedw/tmp1h1uwedw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b58a0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b58704b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b58704988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b587037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1h1uwedw                        0x00005578a2f9369e <unavailable> + 5790

    5    libc.so.6                          0x00002b1b58bf9460 __libc_start_main +
    245

    6    tmp1h1uwedw                        0x00005578a2f93259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  if numbers[i] > largest {\n            largest = numbers[i]\n            largestIndex\
    \ = i\n        }\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpyzrubaih/tmpyzrubaih.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e513e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e510dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e510df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e510de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyzrubaih                        0x000055a3741dd6be <unavailable> + 5822

    5    libc.so.6                          0x00002b9e515d4460 __libc_start_main +
    245

    6    tmpyzrubaih                        0x000055a3741dd279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 8 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 17 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 26 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0])\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_vsa_gmm.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp537s3me5/tmp537s3me5.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab91f2d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab91efcbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab91efcb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab91efca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp537s3me5                        0x000055ac5ab636be <unavailable> + 5822

    5    libc.so.6                          0x00002ab91f4c0460 __libc_start_main +
    245

    6    tmp537s3me5                        0x000055ac5ab63279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0],\
    \ numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > largest {\n            largest = numbers[i]\n   \
    \         largestIndex = i\n        }\n\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n            smallestIndex = i\n        }\n\
    \    }\n\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpee8r8cmb/tmpee8r8cmb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afae3965c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae365cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afae365c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afae365b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpee8r8cmb                        0x000055f2114ae6be <unavailable> + 5822

    5    libc.so.6                          0x00002afae3b51460 __libc_start_main +
    245

    6    tmpee8r8cmb                        0x000055f2114ae279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropLast())\n    let max2 = max(numbers.dropFirst())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpcjnj2lfd.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmpcjnj2lfd.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmpcjnj2lfd.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpcjnj2lfd.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpcjnj2lfd.swift:11:38: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropLast())\n             \
    \                        ^\n                                     , <#[Double]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpcjnj2lfd.swift:12:39:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropFirst())\n\
    \                                      ^\n                                   \
    \   , <#DropFirstSequence<[Double]>#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    guard numbers.count > 1 else {\n        return\
    \ (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphk7ok93u.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers.min()\n    let max =\
    \ numbers.max()\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpam3vlmmy.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (min,\
    \ max)\n           ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    let closestToFirst = sortedNumbers.first!\n    let closestToSecond = sortedNumbers.last!\n\
    \    return (closestToFirst, closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp99vtwtga/tmp99vtwtga.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b439a93cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b439a633b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b439a633988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b439a6327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99vtwtga                        0x000055d002e776fe <unavailable> + 5886

    5    libc.so.6                          0x00002b439ab28460 __libc_start_main +
    245

    6    tmp99vtwtga                        0x000055d002e772b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzcj2g7zy.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 =\
    \ max(numbers)\n    let min2 = min(numbers.dropLast())\n    let max2 = max(numbers.dropLast())\n\
    \    return (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp51cf4v84.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmp51cf4v84.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmp51cf4v84.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp51cf4v84.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp51cf4v84.swift:11:38: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers.dropLast())\n             \
    \                        ^\n                                     , <#[Double]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp51cf4v84.swift:12:38:\
    \ error: missing argument for parameter #2 in call\n    let max2 = max(numbers.dropLast())\n\
    \                                     ^\n                                    \
    \ , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for i in 1..numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpf5lpxpn2.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjgnbhsc7.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpjgnbhsc7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpjgnbhsc7.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpjgnbhsc7.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if numbers[i] < min {\n            min\
    \ = numbers[i]\n        }\n    }\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpw_ympot4.swift:13:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpw_ympot4.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = numbers[i]\n            ^~~\n/tmp/tmpw_ympot4.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
