language: swift
name: HumanEval_132_is_nested
results:
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex - openingBrackets?.startIndex\n\tlet closingBracketsCount\
    \ = closingBrackets?.endIndex - closingBrackets?.startIndex\n\t\n\tif openingBracketsCount\
    \ > closingBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsIndex\
    \ = openingBrackets?.startIndex\n\tlet closingBracketsIndex = closingBrackets?.startIndex\n\
    \t\n\twhile openingBracketsIndex < closingBracketsIndex {\n\t\tlet openingBracketsChar\
    \ = string[openingBracketsIndex].unicodeScalars.first!\n\t\tlet closingBracketsChar\
    \ = string[closingBracketsIndex].unicodeScalars.first!\n\t\t\n\t\tif openingBracketsChar\
    \ == closingBracketsChar {\n\t\t\topeningBracketsIndex += 1\n\t\t\tclosingBracketsIndex\
    \ += 1\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\treturn true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpz7kcr98s.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz7kcr98s.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpz7kcr98s.swift:25:55: error: binary operator '-' cannot be applied to\
    \ two 'Duration?' operands\n        let openingBracketsCount = openingBrackets?.endIndex\
    \ - openingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz7kcr98s.swift:25:55: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (Float, Float), (Float16, Float16), (Float80, Float80),\
    \ (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant,\
    \ Duration), (SuspendingClock.Instant, SuspendingClock.Instant), (UInt, UInt),\
    \ (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n     \
    \   let openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \                                                             ^\n/tmp/tmpz7kcr98s.swift:26:55:\
    \ error: binary operator '-' cannot be applied to two 'Duration?' operands\n \
    \       let closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz7kcr98s.swift:26:55: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant, "
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet openingBrackets = Array<String>()\n\
    \tlet closingBrackets = Array<String>()\n\tlet openingBracketCount = Array<Int>()\n\
    \tlet closingBracketCount = Array<Int>()\n\tlet openingBracketIndex = Array<Int>()\n\
    \tlet closingBracketIndex = Array<Int>()\n\tlet openingBracketCountIndex = Array<Int>()\n\
    \tlet closingBracketCountIndex = Array<Int>()\n\t\n\tlet openingBracketCountIndexMax\
    \ = Array<Int>()\n\tlet closingBracketCountIndexMax = Array<Int>()\n\t\n\tlet\
    \ openingBracketCountIndexMaxIndex = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex\
    \ = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex2 = Array<Int>()\n\
    \tlet closingBracketCountIndexMaxIndex2 = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex3\
    \ = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex3 = Array<Int>()\n\t\n\
    \tlet openingBracketCountIndexMaxIndex4 = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex4\
    \ = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex5 = Array<Int>()\n\
    \tlet closingBracketCountIndexMaxIndex5 = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex6\
    \ = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex6 = Array<Int>()\n\t\n\
    \tlet openingBracketCountIndexMaxIndex7 = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex7\
    \ = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex8 = Array<Int>()\n\
    \tlet closingBracketCountIndexMaxIndex8 = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex9\
    \ = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex9 = Array<Int>()\n\t\n\
    \tlet openingBracketCountIndexMaxIndex10 = Array<Int>()\n\tlet closingBracketCountIndexMaxIndex10\
    \ = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex11 = Array<Int>()\n\
    \tlet closingBracketCountIndexMaxIndex11 = Array<Int>()\n\t\n\tlet openingBracketCountIndexMaxIndex12\
    \ = Array<Int>()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5vs2dqof.swift:18:6: warning: initialization of immutable value\
    \ 'stack' was never used; consider replacing with assignment to '_' or removing\
    \ it\n        let stack = Array<String>()\n        ~~~~^~~~~\n        _\n/tmp/tmp5vs2dqof.swift:19:6:\
    \ warning: initialization of immutable value 'openingBrackets' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let openingBrackets\
    \ = Array<String>()\n        ~~~~^~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:20:6:\
    \ warning: initialization of immutable value 'closingBrackets' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let closingBrackets\
    \ = Array<String>()\n        ~~~~^~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:21:6:\
    \ warning: initialization of immutable value 'openingBracketCount' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let openingBracketCount\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:22:6:\
    \ warning: initialization of immutable value 'closingBracketCount' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let closingBracketCount\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:23:6:\
    \ warning: initialization of immutable value 'openingBracketIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let openingBracketIndex\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:24:6:\
    \ warning: initialization of immutable value 'closingBracketIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let closingBracketIndex\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmp5vs2dqof.swift:25:6:\
    \ warning: initialization of immutable value 'openingBracketCountIndex' was never\
    \ used; consider replacing with assignment to '_' or removing it\n        let\
    \ openingBracketCountIndex = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp5vs2dqof.swift:26:6: warning: init"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount > 1 {\n\t\treturn true\n\t}\n\t\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmf8vfkj5.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmf8vfkj5.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpmf8vfkj5.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpmf8vfkj5.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet openingBrackets = Array<String>()\n\
    \tlet closingBrackets = Array<String>()\n\t\n\tlet openingBracketsCount = 1\n\t\
    let closingBracketsCount = 1\n\t\n\tlet openingBracketsString = \"\"\n\tlet closingBracketsString\
    \ = \"\"\n\t\n\tlet openingBracketsStringCount = 1\n\tlet closingBracketsStringCount\
    \ = 1\n\t\n\tlet openingBracketsStringIndex = 0\n\tlet closingBracketsStringIndex\
    \ = 0\n\t\n\tlet openingBracketsStringCountIndex = 0\n\tlet closingBracketsStringCountIndex\
    \ = 0\n\t\n\tlet openingBracketsStringIndexCount = 0\n\tlet closingBracketsStringIndexCount\
    \ = 0\n\t\n\tlet openingBracketsStringCountIndexCount = 0\n\tlet closingBracketsStringCountIndexCount\
    \ = 0\n\t\n\tlet openingBracketsStringIndexCountIndex = 0\n\tlet closingBracketsStringIndexCountIndex\
    \ = 0\n\t\n\tlet openingBracketsStringCountIndexCountIndex = 0\n\tlet closingBracketsStringCountIndexCountIndex\
    \ = 0\n\t\n\tlet openingBracketsStringIndexCountIndexCount = 0\n\tlet closingBracketsStringIndexCountIndexCount\
    \ = 0\n\t\n\tlet openingBracketsStringCountIndexCountIndexCount = 0\n\tlet closingBracketsStringIndexCountIndexCount\
    \ = 0\n\t\n\tlet openingBracketsStringIndexCountIndexCountIndex = 0\n\tlet closingBracketsStringIndexCountIndexCountIndex\
    \ = 0\n\t\n\tlet openingBracketsStringCountIndexCountIndexCountIndex = 0\n\tlet\
    \ closingBracketsStringIndexCountIndexCountIndex = 0\n\t\n\tlet openingBracketsStringIndexCountIndexCountIndexCount\
    \ = 0\n\tlet closingBracketsStringIndexCountIndexCountIndexCount = 0\n\t\n\tlet\
    \ openingBracketsStringCountIndexCountIndexCountIndexCount = 0\n\tlet closingBracketsStringIndexCountIndexCountIndexCount\
    \ = 0\n\t\n\tlet openingBracketsStringIndexCountIndexCountIndexCountIndexCount\
    \ = 0\n\tlet closingBracketsStringIndexCountIndexCountIndexCountIndexCount = 0\n\
    \t\n\tlet openingBracketsStringCountIndexCountIndexCountIndexCountIndexCount =\
    \ 0\n\tlet closingBracketsStringIndexCountIndexCountIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0mkcd3t2.swift:53:6: error: invalid redeclaration of 'closingBracketsStringIndexCountIndexCount'\n\
    \        let closingBracketsStringIndexCountIndexCount = 0\n            ^\n/tmp/tmp0mkcd3t2.swift:50:6:\
    \ note: 'closingBracketsStringIndexCountIndexCount' previously declared here\n\
    \        let closingBracketsStringIndexCountIndexCount = 0\n            ^\n/tmp/tmp0mkcd3t2.swift:59:6:\
    \ error: invalid redeclaration of 'closingBracketsStringIndexCountIndexCountIndex'\n\
    \        let closingBracketsStringIndexCountIndexCountIndex = 0\n            ^\n\
    /tmp/tmp0mkcd3t2.swift:56:6: note: 'closingBracketsStringIndexCountIndexCountIndex'\
    \ previously declared here\n        let closingBracketsStringIndexCountIndexCountIndex\
    \ = 0\n            ^\n/tmp/tmp0mkcd3t2.swift:65:6: error: invalid redeclaration\
    \ of 'closingBracketsStringIndexCountIndexCountIndexCount'\n        let closingBracketsStringIndexCountIndexCountIndexCount\
    \ = 0\n            ^\n/tmp/tmp0mkcd3t2.swift:62:6: note: 'closingBracketsStringIndexCountIndexCountIndexCount'\
    \ previously declared here\n        let closingBracketsStringIndexCountIndexCountIndexCount\
    \ = 0\n            ^\n/tmp/tmp0mkcd3t2.swift:71:6: error: type annotation missing\
    \ in pattern\n        let closingBracketsStringIndexCountIndexCountIndex\n   \
    \         ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet chars = string.characters\n\t\n\tlet openingBrackets\
    \ = chars.filter({ $0 == \"[\" })\n\tlet closingBrackets = chars.filter({ $0 ==\
    \ \"]\" })\n\t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0hn6oyw_.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = string.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBracketsCount = closeBrackets.characters.count\n\t\n\treturn openBracketsCount\
    \ != closeBracketsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp48r0_o65.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \t\n\tlet openBrackets = string.characters.filter({ $0 == \"[\" }).count\n\tlet\
    \ closeBrackets = string.characters.filter({ $0 == \"]\" }).count\n\t\n\treturn\
    \ bracketsCount == openBrackets + closeBrackets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7lv4t04x.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lv4t04x.swift:21:28: error:\
    \ 'characters' is unavailable: Please use String directly\n        let openBrackets\
    \ = string.characters.filter({ $0 == \"[\" }).count\n                        \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7lv4t04x.swift:22:29: error: 'characters' is unavailable: Please use String\
    \ directly\n        let closeBrackets = string.characters.filter({ $0 == \"]\"\
    \ }).count\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcs9sjvyq.swift:53:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpcs9sjvyq.swift:49:10:\
    \ note: to match this opening '('\n                .reduce(into: [String](), {\
    \ \n                       ^\n/tmp/tmpcs9sjvyq.swift:78:47: error: expected '}'\
    \ at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n\
    \                                              ^\n/tmp/tmpcs9sjvyq.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmpcs9sjvyq.swift:18:17: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        let brackets\
    \ = string.unicodeScalars\n                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcs9sjvyq.swift:53:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013805
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\tlet openingBracketsCount = openingBrackets.count\n\tlet closingBracketsCount\
    \ = closingBrackets.count\n\t\n\tif openingBracketsCount == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tif openingBracketsCount == 1 {\n\t\tif closingBracketsCount == 0 {\n\
    \t\t\treturn true\n\t\t}\n\t\t\n\t\treturn false\n\t}\n\t\n\tif closingBracketsCount\
    \ == 1 {\n\t\treturn false\n\t}\n\t\n\tlet lastOpeningBracket = openingBrackets.last!\n\
    \tlet lastClosingBracket = closingBrackets.last!\n\t\n\tstack.addLast(lastOpeningBracket.value)\n\
    \t\n\tfor lastOpeningBracket in openingBrackets {\n\t\tstack.addLast(lastOpeningBracket.value)\n\
    \t}\n\t\n\tfor lastClosingBracket in closingBrackets {\n\t\tstack.addLast(lastClosingBracket.value)\n\
    \t}\n\t\n\treturn stack.count == 2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvfwgu9o4.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack<String>()\n                    ^~~~~\n/tmp/tmpvfwgu9o4.swift:19:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmpvfwgu9o4.swift:20:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsqe6v8y0.swift:73:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpsqe6v8y0.swift:69:10:\
    \ note: to match this opening '('\n                .filter({ \n              \
    \         ^\n/tmp/tmpsqe6v8y0.swift:98:47: error: expected '}' at end of brace\
    \ statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n              \
    \                                ^\n/tmp/tmpsqe6v8y0.swift:17:40: note: to match\
    \ this opening '{'\nfunc is_nested(string: String) -> Bool {\n               \
    \                        ^\n/tmp/tmpsqe6v8y0.swift:18:17: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsqe6v8y0.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013782
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\tguard openingBrackets.count > 0 && closingBrackets.count > 0 else {\n\t\t\
    return false\n\t}\n\t\n\tguard openingBrackets.count == closingBrackets.count\
    \ else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.count == 1 else {\n\
    \t\treturn false\n\t}\n\t\n\tguard openingBrackets.first!.isNested == true else\
    \ {\n\t\treturn false\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpj9zri8jj.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpj9zri8jj.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\t\n\treturn openBracketsCount != closeBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpt0ilpcf6.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"~\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"^\", with: \"\")\n\t\t.replacingOccurrences(of: \"%\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"*\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \":\", with: \"\")\n\t\t.replacingOccurrences(of: \";\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \"+\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"-\", with: \"\")\n\t\t.replacingOccurrences(of: \"*\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"?\", with: \"\")\n\t\t.replacingOccurrences(of: \"[\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"]\", with: \"\")\n\t\t.replacingOccurrences(of: \"(\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \")\", with: \"\")\n\t\t.replacingOccurrences(of: \"{\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\t\t.replacingOccurrences(of: \"<\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \">\", with: \"\")\n\t\t.replacingOccurrences(of: \"&\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"|\", with: \"\")\n\t\t.replacingOccurrences(of: \"!\", with: \"\")\n\t\t\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw2je9vg5.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet openBrackets = StringBuilder()\n\
    \tlet closeBrackets = StringBuilder()\n\t\n\tfor char in string {\n\t\tif char\
    \ == \"[\" {\n\t\t\tstack.push(char)\n\t\t\topenBrackets.append(char)\n\t\t} else\
    \ if char == \"]\" {\n\t\t\tif stack.count > 0 {\n\t\t\t\tlet lastChar = stack.pop()\n\
    \t\t\t\tif lastChar == \"[\" {\n\t\t\t\t\topenBrackets.append(lastChar)\n\t\t\t\
    \t} else {\n\t\t\t\t\tcloseBrackets.append(lastChar)\n\t\t\t\t}\n\t\t\t} else\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if char == \"]\" && stack.count\
    \ > 0 {\n\t\t\tlet lastChar = stack.pop()\n\t\t\tif lastChar == \"[\" {\n\t\t\t\
    \topenBrackets.append(lastChar)\n\t\t\t} else {\n\t\t\t\tcloseBrackets.append(lastChar)\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn openBrackets.isEmpty && closeBrackets.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkqxff4yj.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack<String>()\n                    ^~~~~\n/tmp/tmpkqxff4yj.swift:19:21:\
    \ error: cannot find 'StringBuilder' in scope\n        let openBrackets = StringBuilder()\n\
    \                           ^~~~~~~~~~~~~\n/tmp/tmpkqxff4yj.swift:20:22: error:\
    \ cannot find 'StringBuilder' in scope\n        let closeBrackets = StringBuilder()\n\
    \                            ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5icc0lb0.swift:73:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmp5icc0lb0.swift:69:10:\
    \ note: to match this opening '('\n                .filter({ \n              \
    \         ^\n/tmp/tmp5icc0lb0.swift:98:47: error: expected '}' at end of brace\
    \ statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n              \
    \                                ^\n/tmp/tmp5icc0lb0.swift:17:40: note: to match\
    \ this opening '{'\nfunc is_nested(string: String) -> Bool {\n               \
    \                        ^\n/tmp/tmp5icc0lb0.swift:18:17: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5icc0lb0.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count > 0 && closingBrackets.count > 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcv_0w33y.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpcv_0w33y.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\tguard openingBrackets.count > 0 && closingBrackets.count > 0 else {\n\t\t\
    return false\n\t}\n\t\n\tlet openingBracket = openingBrackets.first!\n\tlet closingBracket\
    \ = closingBrackets.first!\n\t\n\tguard openingBracket.value == closingBracket.value\
    \ && openingBracket.value == openingBracket.value else {\n\t\treturn false\n\t\
    }\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \tlet closingBracketIndex = string.unicodeScalars.index(closingBracket)\n\t\n\t\
    let openingBracketIndex = string.unicodeScalars.index(openingBracket, offsetBy:\
    \ 1)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 1)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 2)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 2)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 3)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 3)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 4)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 4)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 5)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 5)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 6)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 6)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 7)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 7)\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket,\
    \ offsetBy: 8)\n\tlet closingBracketIndex = string.unicodeScalars.index(closingBracket,\
    \ offsetBy: 8)\n\t\n\tlet openingBracketIndex = string.unicode\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_3fqg0_n.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmp_3fqg0_n.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n/tmp/tmp_3fqg0_n.swift:32:50: error: no exact matches in call\
    \ to instance method 'index'\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmp_3fqg0_n.swift:32:50:\
    \ note: found candidate with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmp_3fqg0_n.swift:32:50:\
    \ note: found candidate with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmp_3fqg0_n.swift:32:50:\
    \ note: found candidate with type '(Unicode.Scalar) -> String.UnicodeScalarView.Index?'\
    \ (aka '(Unicode.Scalar) -> Optional<String.Index>')\n        let openingBracketIndex\
    \ = string.unicodeScalars.index(openingBracket)\n                            \
    \                            ^\n/tmp/tmp_3fqg0_n.swift:33:50: error: no exact\
    \ matches in call to instance method 'index'\n        let closingBracketIndex\
    \ = string.unicodeScalars.index(closingBracket)\n                            \
    \                            ^\n/tmp/tmp_3fqg0_n.swift:33:50: note: found candidate\
    \ with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let closingBracketIndex "
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \tlet openingBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\tlet closingBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closingBracketsCount\
    \ = closingBrackets.count\n\t\n\treturn bracketsCount == (openingBrackets.count\
    \ + closingBracketsCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphghtq_pz.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn (openBrackets != nil) && (closeBrackets\
    \ != nil) && (openBrackets.location != closeBrackets.location)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp88860wab.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp88860wab.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\tif openBrackets == nil || closeBrackets\
    \ == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = openBrackets?.endIndex\n\
    \tlet closeBracketsCount = closeBrackets?.startIndex\n\t\n\tif openBracketsCount\
    \ == nil || closeBracketsCount == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = openBracketsCount! - openBrackets?.startIndex!\n\tlet closeBracketsCount =\
    \ closeBracketsCount! - closeBrackets?.endIndex!\n\t\n\tif openBracketsCount >\
    \ closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\treturn true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxs3flimo.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxs3flimo.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpxs3flimo.swift:25:40: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount = openBrackets?.endIndex\n          \
    \                      ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpxs3flimo.swift:26:42: error:\
    \ type of expression is ambiguous without more context\n        let closeBracketsCount\
    \ = closeBrackets?.startIndex\n                                 ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpxs3flimo.swift:32:45: error: binary operator '-' cannot be applied to\
    \ operands of type 'Duration' and 'Duration?'\n        let openBracketsCount =\
    \ openBracketsCount! - openBrackets?.startIndex!\n                           \
    \     ~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxs3flimo.swift:32:45:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (ContinuousClock.Instant, ContinuousClock.Instant), (ContinuousClock.Instant,\
    \ Duration), (Double, Double), (Duration, Duration), (Float, Float), (Float16,\
    \ Float16), (Float80, Float80), (Int, Int), (Int16, Int16), (Int32, Int32), (Int64,\
    \ Int64), (Int8, Int8), (SuspendingClock.Instant, Duration), (SuspendingClock.Instant,\
    \ SuspendingClock.Instant), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32),\
    \ (UInt64, UInt64), (UInt8, UInt8)\n        let openBracketsCount = openBracketsCount!\
    \ - openBrackets?.startIndex!\n                                              \
    \     ^\n/tmp/tmpxs3flimo.swift:33:47: error: binary operator '-' cannot be applied\
    \ to operands of type 'Duration' and 'Duration?'\n        let closeBracketsCount\
    \ = closeBracketsCount! - closeBrackets?.endIndex!\n                         \
    \        ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxs3flimo.swift:3"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack(string)\n\tlet openingBrackets = stack.countOpeningBrackets()\n\
    \tlet closingBrackets = stack.countClosingBrackets()\n\treturn openingBrackets\
    \ == closingBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl0e5l1ny.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack(string)\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\tlet bracketsCount = openBracketsCount + closeBracketsCount\n\
    \tlet bracketsCount = bracketsCount == 0 ? 0 : bracketsCount\n\treturn bracketsCount\
    \ > 0 && bracketsCount % 2 == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy0rdlxbc.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = 1\n\tlet\
    \ closingBracketsCount = 1\n\tlet openingBracketsCountMax = openingBrackets.count\n\
    \tlet closingBracketsCountMax = closingBrackets.count\n\t\n\tlet openingBracketsIndex\
    \ = 0\n\tlet closingBracketsIndex = 0\n\t\n\twhile openingBracketsIndex < openingBracketsCountMax\
    \ && closingBracketsIndex < closingBracketsCountMax {\n\t\tlet openingBracket\
    \ = string[openingBracketsIndex].unicodeScalars.first!\n\t\tlet closingBracket\
    \ = string[closingBracketsIndex].unicodeScalars.first!\n\t\t\n\t\tif openingBracket.value\
    \ == closingBracket.value {\n\t\t\topeningBrackets.insert(openingBracket)\n\t\t\
    \tclosingBrackets.insert(closingBracket)\n\t\t\topeningBracketsCount += 1\n\t\t\
    \tclosingBracketsCount += 1\n\t\t} else {\n\t\t\tif openingBrackets.contains(openingBracket)\
    \ {\n\t\t\t\topeningBracketsCount -= 1\n\t\t\t\tif openingBracketsCount == 0 {\n\
    \t\t\t\t\topeningBracketsIndex += 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclosingBracketsCount\
    \ -= 1\n\t\t\t\tif closingBracketsCount == 0 {\n\t\t\t\t\tclosingBracketsIndex\
    \ += 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (openingBracketsCount ==\
    \ 0 && closingBracketsCount == 0) || (openingBracketsCount == closingBracketsCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfxmxb_s0.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpfxmxb_s0.swift:30:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let openingBracket = string[openingBracketsIndex].unicodeScalars.first!\n\
    \                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfxmxb_s0.swift:31:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let closingBracket = string[closingBracketsIndex].unicodeScalars.first!\n\
    \                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfxmxb_s0.swift:34:27:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument type\
    \ 'Character'\n                        openingBrackets.insert(openingBracket)\n\
    \                                               ^\n/tmp/tmpfxmxb_s0.swift:34:20:\
    \ error: cannot use mutating member on immutable value: 'openingBrackets' is a\
    \ 'let' constant\n                        openingBrackets.insert(openingBracket)\n\
    \                        ~~~~~~~~~~~~~~~ ^\n/tmp/tmpfxmxb_s0.swift:19:2: note:\
    \ change 'let' to 'var' to make it mutable\n        let openingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpfxmxb_s0.swift:35:20: error: cannot use mutating\
    \ member on immutable value: 'closingBrackets' is a 'let' constant\n         \
    \               closingBrackets.insert(closingBracket)\n                     \
    \   ~~~~~~~~~~~~~~~ ^\n/tmp/tmpfxmxb_s0.swift:20:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let closingBrackets = Set<Character>()\n       \
    \ ^~~\n        var\n/tmp/tmpfxmxb_s0.swift:35:27: error: cannot convert value\
    \ of type 'Unicode."
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu7px4qg4.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpu7px4qg4.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.value\
    \ > 0 })\n\tlet openingBrackets = brackets.filter({ $0.value == 1 })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.value == -1 })\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\treturn (openingBracketsCount\
    \ == closingBracketsCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9i7k3luo.swift:20:54: error: negative integer '-1' overflows when\
    \ stored into unsigned type 'UInt32'\n        let closingBrackets = brackets.filter({\
    \ $0.value == -1 })\n                                                        \
    \    ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\", options: .literal, range: nil)\n\tlet bracketsCount = brackets.characters.count\n\
    \tlet openBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\", options:\
    \ .literal, range: nil)\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBrackets = brackets.replacingOccurrences(of: \"]\", with: \"\", options:\
    \ .literal, range: nil)\n\tlet closeBracketsCount = closeBrackets.characters.count\n\
    \t\n\treturn bracketsCount > openBracketsCount && bracketsCount > closeBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8qb51x3e.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                       ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8qb51x3e.swift:18:74: error: cannot infer contextual\
    \ base in reference to member 'literal'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                       ~^~~~~~~\n/tmp/tmp8qb51x3e.swift:18:90:\
    \ error: 'nil' requires a contextual type\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                        ^\n/tmp/tmp8qb51x3e.swift:20:80:\
    \ error: cannot infer contextual base in reference to member 'literal'\n     \
    \   let openBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\", options:\
    \ .literal, range: nil)\n                                                    \
    \                                 ~^~~~~~~\n/tmp/tmp8qb51x3e.swift:20:96: error:\
    \ 'nil' requires a contextual type\n        let openBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \  ^\n/tmp/tmp8qb51x3e.swift:22:81: error: cannot infer contextual base in reference\
    \ to member 'literal'\n        let closeBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                              ~^~~~~~~\n/tmp/tmp8qb51x3e.swift:22:97:\
    \ error: 'nil' requires a contextual type\n        let closeBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \   ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\n\tlet openBrackets = brackets.filter({ $0 == \"\
    [\" })\n\tlet closeBrackets = brackets.filter({ $0 == \"]\" })\n\t\n\treturn openBrackets.count\
    \ >= closeBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5j4ytmu8.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n                .filter { $0.isBr }\n                    \
    \      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu7px4qg4.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpu7px4qg4.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount < 2 {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBracketsCount / 2\n\t\n\tlet closingBracketsCount = closingBracketsCount\
    \ / 2\n\t\n\tlet openingBracketsCount = openingBracketsCount - 1\n\tlet closingBracketsCount\
    \ = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount\
    \ - 1\n\tlet closingBracketsCount = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount\
    \ = openingBracketsCount - 1\n\tlet closingBracketsCount = closingBracketsCount\
    \ - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount - 1\n\tlet closingBracketsCount\
    \ = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount\
    \ - 1\n\tlet closingBracketsCount = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount\
    \ = openingBracketsCount - 1\n\tlet closingBracketsCount = closingBracketsCount\
    \ - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount - 1\n\tlet closingBracketsCount\
    \ = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount\
    \ - 1\n\tlet closingBracketsCount = closingBracketsCount - 1\n\t\n\tlet openingBracketsCount\
    \ = openingBracketsCount - 1\n\tlet closingBracketsCount = closingBracketsCount\
    \ - 1\n\t\n\tlet openingBracketsCount = openingBracketsCount - 1\n\tlet closingBracketsCount\
    \ = closingBracketsCount - 1\n\t\n\tlet openingBrackets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2jz9qjza.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp2jz9qjza.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp2jz9qjza.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmp2jz9qjza.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp2jz9qjza.swift:72:6: error: type annotation missing in pattern\n     \
    \   let openingBrackets\n            ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack(string)\n\tlet openingBrackets = stack.countOpeningBrackets()\n\
    \tlet closingBrackets = stack.countClosingBrackets()\n\t\n\treturn (openingBrackets\
    \ == closingBrackets)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmprug9mnxr.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack(string)\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets: Set<Character> = Set(\"[\")\n\tlet\
    \ closingBrackets: Set<Character> = Set(\"]\")\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\tlet openingBracketsIndex\
    \ = 0\n\tlet closingBracketsIndex = 0\n\t\n\twhile openingBracketsIndex < openingBracketsCount\
    \ && closingBracketsIndex < closingBracketsCount {\n\t\tlet openingBracket = openingBrackets[openingBracketsIndex]\n\
    \t\tlet closingBracket = closingBrackets[closingBracketsIndex]\n\t\t\n\t\tif openingBracket\
    \ == closingBracket {\n\t\t\topeningBracketsIndex += 1\n\t\t\tclosingBracketsIndex\
    \ += 1\n\t\t} else {\n\t\t\tif openingBracket == \"[\" {\n\t\t\t\tif closingBracket\
    \ == \"[\" {\n\t\t\t\t\topeningBracketsIndex += 1\n\t\t\t\t} else {\n\t\t\t\t\t\
    openingBracketsIndex += 1\n\t\t\t\t\tclosingBracketsIndex += 1\n\t\t\t\t}\n\t\t\
    \t} else {\n\t\t\t\tif closingBracket == \"[\" {\n\t\t\t\t\tclosingBracketsIndex\
    \ += 1\n\t\t\t\t} else {\n\t\t\t\t\topeningBracketsIndex += 1\n\t\t\t\t\tclosingBracketsIndex\
    \ += 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn openingBracketsIndex == openingBracketsCount\
    \ && closingBracketsIndex == closingBracketsCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2mw963t5.swift:27:39: error: no exact matches in call to subscript\
    \ \n                let openingBracket = openingBrackets[openingBracketsIndex]\n\
    \                                                    ^\nSwift.Set:4:23: note:\
    \ candidate expects value of type 'Set<Character>.Index' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(position: Set<Element>.Index) -> Element\
    \ { get }\n                      ^\nSwift.Collection:2:23: note: candidate expects\
    \ value of type 'Range<Set<Character>.Index>' for parameter #1 (got 'Int')\n \
    \   @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp2mw963t5.swift:28:39: error: no exact matches\
    \ in call to subscript \n                let closingBracket = closingBrackets[closingBracketsIndex]\n\
    \                                                    ^\nSwift.Set:4:23: note:\
    \ candidate expects value of type 'Set<Character>.Index' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(position: Set<Element>.Index) -> Element\
    \ { get }\n                      ^\nSwift.Collection:2:23: note: candidate expects\
    \ value of type 'Range<Set<Character>.Index>' for parameter #1 (got 'Int')\n \
    \   @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp2mw963t5.swift:31:25: error: left side of mutating\
    \ operator isn't mutable: 'openingBracketsIndex' is a 'let' constant\n       \
    \                 openingBracketsIndex += 1\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmp2mw963t5.swift:23:2: note: change 'let' to 'var' to make it mutable\n\
    \        l"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0\
    \ != brackets.first })\n\t\t.filter({ $0 != brackets.last })\n\t\t.filter({ $0\
    \ != brackets.first })\n\t\t.filter({ $0 != brackets.last })\n\t\n\treturn brackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphjpadca3.swift:22:4: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n                .filter({ $0 != brackets.last })\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isASCII\
    \ })\n\tlet bracketsCount = brackets.count\n\t\n\tlet openBrackets = brackets.filter({\
    \ $0.isOpen })\n\tlet openBracketsCount = openBrackets.count\n\t\n\tlet closeBrackets\
    \ = brackets.filter({ $0.isClose })\n\tlet closeBracketsCount = closeBrackets.count\n\
    \t\n\tlet openBracketsNestingDepth = openBracketsCount - closeBracketsCount\n\t\
    \n\treturn openBracketsNestingDepth == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcd5df71y.swift:21:42: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = brackets.filter({ $0.isOpen })\n\
    \                                             ~~ ^~~~~~\n/tmp/tmpcd5df71y.swift:24:43:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClose'\n        let closeBrackets\
    \ = brackets.filter({ $0.isClose })\n                                        \
    \      ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isASCII })\n\t\t.filter({\
    \ $0.isASCII })\n\t\t.map({ $0.value })\n\t\t.sorted()\n\t\n\tlet openingBrackets\
    \ = brackets.filter({ $0 == \"[\" })\n\tlet closingBrackets = brackets.filter({\
    \ $0 == \"]\" })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnxqctis4.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n                .filter({ $0.isBr })\n                   \
    \       ~~ ^~~~\n/tmp/tmpnxqctis4.swift:20:16: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n                .filter({ $0.isLetter })\n       \
    \                   ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet chars = string.characters\n\tlet openingBrackets =\
    \ chars.filter({ $0 == \"[\" })\n\tlet closingBrackets = chars.filter({ $0 ==\
    \ \"]\" })\n\tlet openingBracketCount = openingBrackets.count\n\tlet closingBracketCount\
    \ = closingBrackets.count\n\t\n\treturn openingBracketCount == closingBracketCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo7ygkg1t.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = string.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \t\n\treturn bracketsCount > 0 && bracketsCount % 2 == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg_24y9yq.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\", options: .literal, range: nil)\n\tlet bracketsIndex = brackets.characters.count\n\
    \tlet openingBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\", options:\
    \ .literal, range: nil)\n\tlet closingBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n\tlet openingBracketsIndex\
    \ = openingBrackets.characters.count\n\tlet closingBracketsIndex = closingBrackets.characters.count\n\
    \t\n\tlet openingBracketsCount = openingBrackets.characters.count\n\tlet closingBracketsCount\
    \ = closingBrackets.characters.count\n\t\n\tif bracketsIndex == 0 || openingBracketsIndex\
    \ == 0 || closingBracketsIndex == 0 || openingBracketsCount == 0 || closingBracketsCount\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsNestingLevel = openingBracketsIndex\
    \ - closingBracketsIndex\n\tlet closingBracketsNestingLevel = closingBracketsIndex\
    \ - openingBracketsIndex\n\t\n\treturn openingBracketsNestingLevel == closingBracketsNestingLevel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmps6wk7e7y.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                       ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps6wk7e7y.swift:18:74: error: cannot infer contextual\
    \ base in reference to member 'literal'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                       ~^~~~~~~\n/tmp/tmps6wk7e7y.swift:18:90:\
    \ error: 'nil' requires a contextual type\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                        ^\n/tmp/tmps6wk7e7y.swift:20:83:\
    \ error: cannot infer contextual base in reference to member 'literal'\n     \
    \   let openingBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\"\
    , options: .literal, range: nil)\n                                           \
    \                                             ~^~~~~~~\n/tmp/tmps6wk7e7y.swift:20:99:\
    \ error: 'nil' requires a contextual type\n        let openingBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \     ^\n/tmp/tmps6wk7e7y.swift:21:83: error: cannot infer contextual base in\
    \ reference to member 'literal'\n        let closingBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                ~^~~~~~~\n/tmp/tmps6wk7e7y.swift:21:99:\
    \ error: 'nil' requires a contextual type\n        let closingBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \     ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.value\
    \ > 0 })\n\t\n\tlet openBrackets = brackets.filter({ $0.value == 1 })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.value == -1 })\n\t\n\treturn openBrackets.count > 0 &&\
    \ closeBrackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_rpj6627.swift:21:52: error: negative integer '-1' overflows when\
    \ stored into unsigned type 'UInt32'\n        let closeBrackets = brackets.filter({\
    \ $0.value == -1 })\n                                                        \
    \  ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\tlet openBracketsCount = 1\n\tlet closeBracketsCount\
    \ = 1\n\t\n\tlet characters = string.characters\n\t\n\tfor character in characters\
    \ {\n\t\tif character == '[' {\n\t\t\topenBrackets.insert(character)\n\t\t\topenBracketsCount\
    \ += 1\n\t\t} else if character == ']' {\n\t\t\tcloseBrackets.insert(character)\n\
    \t\t\tcloseBracketsCount += 1\n\t\t}\n\t\t\n\t\tif openBracketsCount == closeBracketsCount\
    \ {\n\t\t\tstack.append(character)\n\t\t}\n\t}\n\t\n\treturn stack.count == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu56wnquj.swift:27:19: error: single-quoted string literal found,\
    \ use '\"'\n                if character == '[' {\n                          \
    \      ^~~\n                                \"[\"\n/tmp/tmpu56wnquj.swift:30:26:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if character == ']' {\n                                       ^~~\n        \
    \                               \"]\"\n/tmp/tmpu56wnquj.swift:18:14: error: cannot\
    \ find 'Stack' in scope\n        let stack = Stack()\n                    ^~~~~\n\
    /tmp/tmpu56wnquj.swift:24:26: error: 'characters' is unavailable: Please use String\
    \ directly\n        let characters = string.characters\n                     \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpu56wnquj.swift:28:17: error: cannot use mutating member on immutable value:\
    \ 'openBrackets' is a 'let' constant\n                        openBrackets.insert(character)\n\
    \                        ~~~~~~~~~~~~ ^\n/tmp/tmpu56wnquj.swift:19:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpu56wnquj.swift:29:22: error: left side of mutating\
    \ operator isn't mutable: 'openBracketsCount' is a 'let' constant\n          \
    \              openBracketsCount += 1\n                        ~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpu56wnquj.swift:21:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openBracketsCount = 1\n        ^~~\n        var\n/tmp/tmpu56wnquj.swift:31:18:\
    \ error: cannot use mutating member on immutable value: 'closeBrackets' is a 'let'\
    \ constant\n                        closeBrackets.insert(character)\n        \
    \                ~~~~~~~~~~~~~ ^\n/tmp/tmpu56wnquj.swift:20:2: note: change 'let'\
    \ to 'var' to make it mutable\n        let closeBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpu56wnquj.swift:32:23: error: left side of mutating\
    \ operator isn't mutable: 'closeBracketsCount' is a 'let' constant\n         \
    \               clos"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1cfibiqd.swift:98:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp1cfibiqd.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmp1cfibiqd.swift:18:17: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1cfibiqd.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpikkh3l_w.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1cfibiqd.swift:98:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp1cfibiqd.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmp1cfibiqd.swift:18:17: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1cfibiqd.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\tlet openBracketsCount = 1\n\tlet closeBracketsCount\
    \ = 1\n\t\n\tfor char in string {\n\t\tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\
    \t\t\topenBracketsCount += 1\n\t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\
    \t\t\tcloseBracketsCount += 1\n\t\t}\n\t\t\n\t\tif openBracketsCount == closeBracketsCount\
    \ {\n\t\t\tif openBrackets.isSubset(of: closeBrackets) {\n\t\t\t\treturn true\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\tif openBracketsCount > closeBracketsCount {\n\t\t\t\
    stack.push(char)\n\t\t}\n\t}\n\t\n\treturn false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpb735ac6d.swift:25:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '[' {\n                           ^~~\n\
    \                           \"[\"\n/tmp/tmpb735ac6d.swift:28:21: error: single-quoted\
    \ string literal found, use '\"'\n                } else if char == ']' {\n  \
    \                                ^~~\n                                  \"]\"\n\
    /tmp/tmpb735ac6d.swift:18:14: error: cannot find 'Stack' in scope\n        let\
    \ stack = Stack()\n                    ^~~~~\n/tmp/tmpb735ac6d.swift:26:17: error:\
    \ cannot use mutating member on immutable value: 'openBrackets' is a 'let' constant\n\
    \                        openBrackets.insert(char)\n                        ~~~~~~~~~~~~\
    \ ^\n/tmp/tmpb735ac6d.swift:19:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openBrackets = Set<Character>()\n        ^~~\n        var\n/tmp/tmpb735ac6d.swift:27:22:\
    \ error: left side of mutating operator isn't mutable: 'openBracketsCount' is\
    \ a 'let' constant\n                        openBracketsCount += 1\n         \
    \               ~~~~~~~~~~~~~~~~~ ^\n/tmp/tmpb735ac6d.swift:21:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBracketsCount = 1\n     \
    \   ^~~\n        var\n/tmp/tmpb735ac6d.swift:29:18: error: cannot use mutating\
    \ member on immutable value: 'closeBrackets' is a 'let' constant\n           \
    \             closeBrackets.insert(char)\n                        ~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpb735ac6d.swift:20:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closeBrackets = Set<Character>()\n        ^~~\n        var\n/tmp/tmpb735ac6d.swift:30:23:\
    \ error: left side of mutating operator isn't mutable: 'closeBracketsCount' is\
    \ a 'let' constant\n                        closeBracketsCount += 1\n        \
    \                ~~~~~~~~~~~~~~~~~~ ^\n/tmp/tmpb735ac6d.swift:22:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let closeBracketsCount = 1\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \t\n\tguard brackets.count > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openBrackets\
    \ = brackets.filter({ $0.isBr })\n\tlet closeBrackets = brackets.filter({ !$0.isBr\
    \ })\n\t\n\tguard openBrackets.count > 0 && closeBrackets.count > 0 else {\n\t\
    \treturn false\n\t}\n\t\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\t\n\tguard openBracketsCount == closeBracketsCount else\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex = openBrackets.firstIndex({\
    \ $0.isBr })\n\tlet closeBracketsIndex = closeBrackets.firstIndex({ $0.isBr })\n\
    \t\n\tguard openBracketsIndex != -1 && closeBracketsIndex != -1 else {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openBracketsIndex2 = openBracketsIndex + 1\n\tlet closeBracketsIndex2\
    \ = closeBracketsIndex - 1\n\t\n\tguard openBracketsIndex2 < closeBracketsIndex2\
    \ else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex3 = openBracketsIndex\
    \ + 2\n\tlet closeBracketsIndex3 = closeBracketsIndex - 2\n\t\n\tguard openBracketsIndex3\
    \ < closeBracketsIndex3 else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex4\
    \ = openBracketsIndex + 3\n\tlet closeBracketsIndex4 = closeBracketsIndex - 3\n\
    \t\n\tguard openBracketsIndex4 < closeBracketsIndex4 else {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsIndex5 = openBracketsIndex + 4\n\tlet closeBracketsIndex5\
    \ = closeBracketsIndex - 4\n\t\n\tguard openBracketsIndex5 < closeBracketsIndex5\
    \ else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex6 = openBracketsIndex\
    \ + 5\n\tlet closeBracketsIndex6 = closeBracketsIndex - 5\n\t\n\tguard openBracketsIndex6\
    \ < closeBracketsIndex6 else {\n\t\treturn false\n\t}\n\t\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpadyvclrj.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\t.reduce(into: [:]) {\n\t\t\t$0[$1] = $0[$1]! +\
    \ 1\n\t\t}\n\t\n\tlet openBrackets = brackets.filter { $0.1 == 1 }\n\tlet closeBrackets\
    \ = brackets.filter { $0.1 == -1 }\n\t\n\treturn openBrackets.count > closeBrackets.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzpe1f7kb.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n                .filter { $0.isBr }\n                    \
    \      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openings = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closings = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\topenings.forEach { stack.push(it) }\n\tclosings.forEach { stack.pop() }\n\
    \t\n\treturn stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi776s5mw.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpi776s5mw.swift:19:51:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openings\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                          ~~ ^~~~~~\n/tmp/tmpi776s5mw.swift:20:51: error: value\
    \ of type 'Unicode.Scalar' has no member 'isClosing'\n        let closings = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                      ~~ ^~~~~~~~~\n\
    /tmp/tmpi776s5mw.swift:22:32: error: cannot find 'it' in scope\n        openings.forEach\
    \ { stack.push(it) }\n                                      ^~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.value\
    \ > 0 })\n\tlet openBrackets = brackets.filter({ $0.value == 1 })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.value == -1 })\n\tlet openBracketCount = openBrackets.count\n\
    \tlet closeBracketCount = closeBrackets.count\n\t\n\treturn openBracketCount ==\
    \ closeBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp348kqcyz.swift:20:52: error: negative integer '-1' overflows when\
    \ stored into unsigned type 'UInt32'\n        let closeBrackets = brackets.filter({\
    \ $0.value == -1 })\n                                                        \
    \  ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBracket()\
    \ })\n\tlet openBrackets = brackets.filter({ $0.isOpenBracket() })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.isCloseBracket() })\n\tlet openBracketCount = openBrackets.count\n\
    \tlet closeBracketCount = closeBrackets.count\n\t\n\treturn openBracketCount ==\
    \ closeBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0adsctx2.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBracket'\n        let brackets = string.unicodeScalars.filter({\
    \ $0.isBracket() })\n                                                      ~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.value) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.value) })\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [String](), { \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcs9sjvyq.swift:53:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpcs9sjvyq.swift:49:10:\
    \ note: to match this opening '('\n                .reduce(into: [String](), {\
    \ \n                       ^\n/tmp/tmpcs9sjvyq.swift:78:47: error: expected '}'\
    \ at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n\
    \                                              ^\n/tmp/tmpcs9sjvyq.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmpcs9sjvyq.swift:18:17: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        let brackets\
    \ = string.unicodeScalars\n                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcs9sjvyq.swift:53:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013805
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount < 0 {\n\t\treturn false\n\t}\n\t\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2v2gd1c1.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp2v2gd1c1.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp2v2gd1c1.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmp2v2gd1c1.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\treturn (openingBrackets\
    \ != nil) && (closingBrackets != nil) && (openingBrackets.location == closingBrackets.location)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgumniv2f.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpgumniv2f.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\tguard openingBrackets.count > 0 && closingBrackets.count > 0 else {\n\t\t\
    return false\n\t}\n\t\n\tguard openingBrackets.count == closingBrackets.count\
    \ else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.first!.isNested ==\
    \ closingBrackets.first!.isNested else {\n\t\treturn false\n\t}\n\t\n\treturn\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzb7mirkp.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpzb7mirkp.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet bracketCount\
    \ = brackets.count\n\t\n\tlet openBrackets = brackets.filter{ $0.value == UnicodeScalar(openBracket)\
    \ }\n\tlet closeBrackets = brackets.filter{ $0.value == UnicodeScalar(closeBracket)\
    \ }\n\t\n\tlet openBracketCount = openBrackets.count\n\tlet closeBracketCount\
    \ = closeBrackets.count\n\t\n\tif bracketCount != openBracketCount + closeBracketCount\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketIndex = openBrackets.first!.index\n\
    \tlet closeBracketIndex = closeBrackets.first!.index\n\t\n\tlet openBracketRange\
    \ = string.unicodeScalars.suffix(from: openBracketIndex)\n\tlet closeBracketRange\
    \ = string.unicodeScalars.suffix(from: closeBracketIndex)\n\t\n\tlet openBracketRangeCount\
    \ = openBracketRange.count\n\tlet closeBracketRangeCount = closeBracketRange.count\n\
    \t\n\tif openBracketRangeCount != closeBracketRangeCount {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketRangeIndex = openBracketRange.first!.index\n\tlet closeBracketRangeIndex\
    \ = closeBracketRange.first!.index\n\t\n\tlet openBracketRangeRange = string.unicodeScalars.suffix(from:\
    \ openBracketRangeIndex)\n\tlet closeBracketRangeRange = string.unicodeScalars.suffix(from:\
    \ closeBracketRangeIndex)\n\t\n\tlet openBracketRangeRangeCount = openBracketRangeRange.count\n\
    \tlet closeBracketRangeRangeCount = closeBracketRangeRange.count\n\t\n\tif openBracketRangeRangeCount\
    \ != closeBracketRangeRangeCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketRangeRangeIndex\
    \ = openBracketRangeRange.first!.index\n\tlet closeBracketRangeRangeIndex = closeBracketRangeRange.first!.index\n\
    \t\n\tlet openBracketRangeRangeRange = string.unicodeScalars.suffix(from: openBracketRangeRangeIndex)\n\
    \tlet closeBracketRangeRangeRange = string.unicodeScalars.suffix(from: closeBracketRangeRangeIndex)\n\
    \t\n\tlet openBracketRangeRangeRangeCount = openBracketRangeRangeRange.count\n\
    \tlet closeBracketRangeRangeRangeCount = closeBracketRangeRangeRange.count\n\t\
    \n\tif openBracketRangeRangeRange\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfuvhwbwd.swift:66:31: error: expected '{' after 'if' condition\n\
    \        if openBracketRangeRangeRange\n                                     ^\n\
    /tmp/tmpfuvhwbwd.swift:21:64: error: cannot find 'openBracket' in scope\n    \
    \    let openBrackets = brackets.filter{ $0.value == UnicodeScalar(openBracket)\
    \ }\n                                                                      ^~~~~~~~~~~\n\
    /tmp/tmpfuvhwbwd.swift:22:65: error: cannot find 'closeBracket' in scope\n   \
    \     let closeBrackets = brackets.filter{ $0.value == UnicodeScalar(closeBracket)\
    \ }\n                                                                       ^~~~~~~~~~~~\n\
    /tmp/tmpfuvhwbwd.swift:27:38: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n        if bracketCount != openBracketCount +\
    \ closeBracketCount {\n                                            ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isASCII\
    \ })\n\tlet openBrackets = brackets.filter({ $0.isOpen })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.isClose })\n\t\n\treturn openBrackets.count > 0 && closeBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6bn_o97j.swift:19:42: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = brackets.filter({ $0.isOpen })\n\
    \                                             ~~ ^~~~~~\n/tmp/tmp6bn_o97j.swift:20:43:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClose'\n        let closeBrackets\
    \ = brackets.filter({ $0.isClose })\n                                        \
    \      ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\treturn openBrackets.count\
    \ >= brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpthl8aghu.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn (openBrackets != nil && closeBrackets\
    \ != nil) && (openBrackets.location != closeBrackets.location)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaeg2eyjn.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpaeg2eyjn.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \t\n\treturn bracketsCount > 0 && bracketsCount == brackets.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbsz6em96.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets.location\
    \ == NSNotFound || closingBrackets.location == NSNotFound {\n\t\treturn false\n\
    \t}\n\t\n\tlet openingBracketsLocation = openingBrackets.location\n\tlet closingBracketsLocation\
    \ = closingBrackets.location\n\t\n\tlet openingBracketsLength = openingBrackets.length\n\
    \tlet closingBracketsLength = closingBrackets.length\n\t\n\tlet openingBracketsRange\
    \ = NSMakeRange(openingBracketsLocation, openingBracketsLength)\n\tlet closingBracketsRange\
    \ = NSMakeRange(closingBracketsLocation, closingBracketsLength)\n\t\n\tlet openingBracketsRangeString\
    \ = string.substringWithRange(openingBracketsRange)\n\tlet closingBracketsRangeString\
    \ = string.substringWithRange(closingBracketsRange)\n\t\n\tlet openingBracketsRangeStringLength\
    \ = openingBracketsRangeString.length\n\tlet closingBracketsRangeStringLength\
    \ = closingBracketsRangeString.length\n\t\n\tlet openingBracketsRangeStringRange\
    \ = NSMakeRange(openingBracketsLocation, openingBracketsLength - openingBracketsRangeStringLength)\n\
    \tlet closingBracketsRangeStringRange = NSMakeRange(closingBracketsLocation, closingBracketsLength\
    \ - closingBracketsRangeStringLength)\n\t\n\tlet openingBracketsRangeStringRangeString\
    \ = string.substringWithRange(openingBracketsRangeStringRange)\n\tlet closingBracketsRangeStringRangeString\
    \ = string.substringWithRange(closingBracketsRangeStringRange)\n\t\n\tlet openingBracketsRangeStringRangeStringLength\
    \ = openingBracketsRangeStringRangeString.length\n\tlet closingBracketsRangeStringRangeStringLength\
    \ = closingBracketsRangeStringRangeString.length\n\t\n\tlet openingBracketsRangeStringRangeStringRange\
    \ = NSMakeRange(openingBracketsLocation, openingBracketsLength - openingBracketsRangeStringRangeStringLength)\n\
    \tlet closingBracketsRangeStringRangeStringRange = NSMakeRange(closingBracketsLocation,\
    \ closingBracketsLength - closingBracketsRangeStringRangeStringLength)\n\t\n\t\
    let openingBracketsRangeStringRange\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjkf15hqq.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpjkf15hqq.swift:21:33: error: cannot find 'NSNotFound' in scope\n     \
    \   if openingBrackets.location == NSNotFound || closingBrackets.location == NSNotFound\
    \ {\n                                       ^~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:21:75:\
    \ error: cannot find 'NSNotFound' in scope\n        if openingBrackets.location\
    \ == NSNotFound || closingBrackets.location == NSNotFound {\n                \
    \                                                                 ^~~~~~~~~~\n\
    /tmp/tmpjkf15hqq.swift:31:29: error: cannot find 'NSMakeRange' in scope\n    \
    \    let openingBracketsRange = NSMakeRange(openingBracketsLocation, openingBracketsLength)\n\
    \                                   ^~~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:32:29:\
    \ error: cannot find 'NSMakeRange' in scope\n        let closingBracketsRange\
    \ = NSMakeRange(closingBracketsLocation, closingBracketsLength)\n            \
    \                       ^~~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:34:42: error: value\
    \ of type 'String' has no member 'substringWithRange'\n        let openingBracketsRangeString\
    \ = string.substringWithRange(openingBracketsRange)\n                        \
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:35:42: error:\
    \ value of type 'String' has no member 'substringWithRange'\n        let closingBracketsRangeString\
    \ = string.substringWithRange(closingBracketsRange)\n                        \
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjkf15hqq.swift:40:40: error:\
    \ cannot find 'NSMakeRange' in scope\n        let openingBracketsRangeStringRange\
    \ = NSMakeRange(openingBracketsLocation, openingBracketsLength - openingBracketsRangeStringLength)\n\
    \                                       "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\t\n\treturn openBracketsCount == closeBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxwnk8q5v.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu7px4qg4.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpu7px4qg4.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet chars = string.characters\n\t\n\tlet openingBrackets\
    \ = chars.filter({ $0 == \"[\" })\n\tlet closingBrackets = chars.filter({ $0 ==\
    \ \"]\" })\n\t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0hn6oyw_.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = string.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \t\n\treturn bracketsCount == brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6fqxuqif.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.value\
    \ > 0 })\n\t\n\tguard brackets.count > 0 else {\n\t\treturn false\n\t}\n\t\n\t\
    let openBrackets = brackets.filter({ $0.value == 1 })\n\tlet closeBrackets = brackets.filter({\
    \ $0.value == -1 })\n\t\n\tguard openBrackets.count > 0 else {\n\t\treturn false\n\
    \t}\n\t\n\tguard closeBrackets.count > 0 else {\n\t\treturn false\n\t}\n\t\n\t\
    let openBracketsCount = openBrackets.count\n\tlet closeBracketsCount = closeBrackets.count\n\
    \t\n\tguard openBracketsCount == closeBracketsCount else {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsIndex = openBrackets.firstIndex({ $0.value == -1 })\n\
    \tlet closeBracketsIndex = closeBrackets.firstIndex({ $0.value == -1 })\n\t\n\t\
    guard openBracketsIndex != nil else {\n\t\treturn false\n\t}\n\t\n\tguard closeBracketsIndex\
    \ != nil else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsString = openBrackets[openBracketsIndex!].value\n\
    \tlet closeBracketsString = closeBrackets[closeBracketsIndex!].value\n\t\n\tguard\
    \ openBracketsString == \"[\" else {\n\t\treturn false\n\t}\n\t\n\tguard closeBracketsString\
    \ == \"]\" else {\n\t\treturn false\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpst9eq11v.swift:42:50: error: missing argument label 'where:' in\
    \ call\n        let openBracketsIndex = openBrackets.firstIndex({ $0.value ==\
    \ -1 })\n                                                        ^\n         \
    \                                               where: \n/tmp/tmpst9eq11v.swift:43:52:\
    \ error: missing argument label 'where:' in call\n        let closeBracketsIndex\
    \ = closeBrackets.firstIndex({ $0.value == -1 })\n                           \
    \                               ^\n                                          \
    \                where: \n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 !=\
    \ brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first\
    \ }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\
    \t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t\
    .filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter\
    \ { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter {\
    \ $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0\
    \ != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 !=\
    \ brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last\
    \ }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\
    \t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t\
    .filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter\
    \ { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter {\
    \ $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 !=\
    \ brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first\
    \ }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\
    \t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t\
    .filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter\
    \ { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter {\
    \ $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0\
    \ != brackets.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvkinahmz.swift:64:27: error: expected member name following '.'\n\
    \                .filter { $0 != brackets.\n                                 \
    \       ^\n/tmp/tmpvkinahmz.swift:93:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmpvkinahmz.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmpvkinahmz.swift:68:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \";\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \",\", with: \"\")\n\t\t.replacingOccurrences(of: \" \", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\t\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\n\", with: \"\")\n\t\
    \t.replacingOccurrences(of: \"\\r\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\\"\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\
    \t\t.replacingOccurrences(of: \"^\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"~\", with: \"\")\n\t\t.replacingOccurrences(of: \"*\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"?\", with: \"\")\n\t\t.replacingOccurrences(of: \"!\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"=\", with: \"\")\n\t\t.replacingOccurrences(of: \"%\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"#\", with: \"\")\n\t\t.replacingOccurrences(of: \"$\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"%\", with: \"\")\n\t\t.replacingOccurrences(of: \"&\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"*\", with: \"\")\n\t\t.replacingOccurrences(of: \"+\", with: \"\")\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp60s43019.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = 0\n\tlet\
    \ closeBracketsIndex = 0\n\t\n\tlet openBracketsCountIndex = 0\n\tlet closeBracketsCountIndex\
    \ = 0\n\t\n\twhile openBracketsIndex < openBracketsCount && closeBracketsIndex\
    \ < closeBracketsCount {\n\t\tlet openBracket = string[openBracketsIndex].unicodeScalars.first!\n\
    \t\tlet closeBracket = string[closeBracketsIndex].unicodeScalars.first!\n\t\t\n\
    \t\tif openBracket.value == openBracket.value {\n\t\t\topenBracketsIndex += 1\n\
    \t\t\topenBracketsCountIndex += 1\n\t\t\topenBracketsCount += 1\n\t\t\topenBracketsIndex\
    \ += 1\n\t\t\topenBracketsCount += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif closeBracket.value\
    \ == closeBracket.value {\n\t\t\tcloseBracketsIndex += 1\n\t\t\tcloseBracketsCountIndex\
    \ += 1\n\t\t\tcloseBracketsCount += 1\n\t\t\tcloseBracketsIndex += 1\n\t\t\tcloseBracketsCount\
    \ += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif openBracket.value == closeBracket.value\
    \ {\n\t\t\topenBracketsCount -= 1\n\t\t\tcloseBracketsCount -= 1\n\t\t\topenBracketsIndex\
    \ += 1\n\t\t\tcloseBracketsIndex += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif openBracket.value\
    \ == openBracket.value {\n\t\t\topenBracketsCount -= 1\n\t\t\topenBracketsIndex\
    \ += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif closeBracket.value == closeBracket.value\
    \ {\n\t\t\tcloseBracketsCount -= 1\n\t\t\tcloseBracketsIndex += 1\n\t\t\tcontinue\n\
    \t\t}\n\t\t\n\t\tif openBracket.value == openBracket.value {\n\t\t\topenBracketsCount\
    \ -= 1\n\t\t\topenBracketsIndex += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif closeBracket.value\
    \ == closeBracket.value {\n\t\t\tcloseBracketsCount -= 1\n\t\t\tcloseBracketsIndex\
    \ += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif openBracket.value == closeBracket.value\
    \ {\n\t\t\topenBracketsCount -= 1\n\t\t\topenBracketsIndex += 1\n\t\t\t\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp497uphlw.swift:116:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp497uphlw.swift:30:89: note: to match this opening\
    \ '{'\n        while openBracketsIndex < openBracketsCount && closeBracketsIndex\
    \ < closeBracketsCount {\n                                                   \
    \                                            ^\n/tmp/tmp497uphlw.swift:116:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmp497uphlw.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmp497uphlw.swift:18:14: error:\
    \ cannot find 'Stack' in scope\n        let stack = Stack()\n                \
    \    ^~~~~\n/tmp/tmp497uphlw.swift:31:21: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       let openBracket = string[openBracketsIndex].unicodeScalars.first!\n  \
    \                                ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp497uphlw.swift:32:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let closeBracket = string[closeBracketsIndex].unicodeScalars.first!\n\
    \                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp497uphlw.swift:35:22:\
    \ error: left side of mutating operator isn't mutable: 'openBracketsIndex' is\
    \ a 'let' constant\n                        openBracketsIndex += 1\n         \
    \               ~~~~~~~~~~~~~~~~~ ^\n/tmp/tmp497uphlw.swift:24:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBracketsIndex = 0\n     \
    \   "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn (openBrackets != nil) && (closeBrackets\
    \ != nil) && (openBrackets.location != closeBrackets.location)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp88860wab.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp88860wab.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openings = Array<String>()\n\
    \tlet closings = Array<String>()\n\tlet openings_count = Array<Int>()\n\tlet closings_count\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_count_min = Array<Int>()\n\tlet closings_count_min\
    \ = Array<Int>()\n\tlet openings_count_max = Array<Int>()\n\tlet closings_count_max\
    \ = Array<Int>()\n\tlet openings_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxg1zwzco.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpxg1zwzco.swift:27:6:\
    \ error: invalid redeclaration of 'openings_count_min'\n        let openings_count_min\
    \ = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:25:6: note: 'openings_count_min'\
    \ previously declared here\n        let openings_count_min = Array<Int>()\n  \
    \          ^\n/tmp/tmpxg1zwzco.swift:28:6: error: invalid redeclaration of 'closings_count_min'\n\
    \        let closings_count_min = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:26:6:\
    \ note: 'closings_count_min' previously declared here\n        let closings_count_min\
    \ = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:29:6: error: invalid redeclaration\
    \ of 'openings_count_max'\n        let openings_count_max = Array<Int>()\n   \
    \         ^\n/tmp/tmpxg1zwzco.swift:23:6: note: 'openings_count_max' previously\
    \ declared here\n        let openings_count_max = Array<Int>()\n            ^\n\
    /tmp/tmpxg1zwzco.swift:30:6: error: invalid redeclaration of 'closings_count_max'\n\
    \        let closings_count_max = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:24:6:\
    \ note: 'closings_count_max' previously declared here\n        let closings_count_max\
    \ = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:31:6: error: invalid redeclaration\
    \ of 'openings_count_min'\n        let openings_count_min = Array<Int>()\n   \
    \         ^\n/tmp/tmpxg1zwzco.swift:25:6: note: 'openings_count_min' previously\
    \ declared here\n        let openings_count_min = Array<Int>()\n            ^\n\
    /tmp/tmpxg1zwzco.swift:32:6: error: invalid redeclaration of 'closings_count_min'\n\
    \        let closings_count_min = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:26:6:\
    \ note: 'closings_count_min' previously declared here\n        let closings_count_min\
    \ = Array<Int>()\n            ^\n/tmp/tmpxg1zwzco.swift:33:6: error: invalid redeclaration\
    \ of 'openings_count_max'\n        let openings_count_max = Array<Int>()\n   \
    \         ^\n/tmp/tmpxg1zwzco.swift:23:6: note: 'openings_count_max' previously\
    \ declared here\n       "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.map({ $0.value })\n\t\t.reduce({ $0 }, { $0 + 1 })\n\treturn brackets\
    \ == 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3lb23au5.swift:21:21: error: cannot convert value of type '(_)\
    \ -> _' to expected argument type 'Int'\n                .reduce({ $0 }, { $0\
    \ + 1 })\n                                  ^\n/tmp/tmp3lb23au5.swift:19:16: error:\
    \ value of type 'Unicode.Scalar' has no member 'isBr'\n                .filter({\
    \ $0.isBr })\n                          ~~ ^~~~\n/tmp/tmp3lb23au5.swift:21:19:\
    \ error: contextual closure type '(@escaping (_) -> _, UInt32) throws -> (_) ->\
    \ _' expects 2 arguments, but 1 was used in closure body\n                .reduce({\
    \ $0 }, { $0 + 1 })\n                                ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = 1\n\tlet\
    \ closingBracketsCount = 1\n\tlet openingBracketsIndex = 0\n\tlet closingBracketsIndex\
    \ = 0\n\tlet openingBracketsCountLimit = openingBracketsCount\n\tlet closingBracketsCountLimit\
    \ = closingBracketsCount\n\tlet openingBracketsCountLimitIndex = openingBracketsIndex\n\
    \tlet closingBracketsCountLimitIndex = closingBracketsIndex\n\tlet openingBracketsCountLimitLimit\
    \ = openingBracketsCountLimit\n\tlet closingBracketsCountLimitLimit = closingBracketsCountLimit\n\
    \tlet openingBracketsCountLimitLimitIndex = openingBracketsCountLimitIndex\n\t\
    let closingBracketsCountLimitLimitIndex = closingBracketsCountLimitIndex\n\t\n\
    \tlet openingBracketsCountLimitLimitLimit = openingBracketsCountLimitLimit\n\t\
    let closingBracketsCountLimitLimit = closingBracketsCountLimitLimit\n\t\n\tlet\
    \ openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \tlet closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \t\n\tlet open\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4394yens.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmp4394yens.swift:35:6:\
    \ error: invalid redeclaration of 'closingBracketsCountLimitLimit'\n        let\
    \ closingBracketsCountLimitLimit = closingBracketsCountLimitLimit\n          \
    \  ^\n/tmp/tmp4394yens.swift:30:6: note: 'closingBracketsCountLimitLimit' previously\
    \ declared here\n        let closingBracketsCountLimitLimit = closingBracketsCountLimit\n\
    \            ^\n/tmp/tmp4394yens.swift:38:6: error: invalid redeclaration of 'closingBracketsCountLimitLimitIndex'\n\
    \        let closingBracketsCountLimitLimitIndex = closingBracketsCountLimitLimitIndex\n\
    \            ^\n/tmp/tmp4394yens.swift:32:6: note: 'closingBracketsCountLimitLimitIndex'\
    \ previously declared here\n        let closingBracketsCountLimitLimitIndex =\
    \ closingBracketsCountLimitIndex\n            ^\n/tmp/tmp4394yens.swift:40:6:\
    \ error: invalid redeclaration of 'openingBracketsCountLimitLimitLimitIndex'\n\
    \        let openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \            ^\n/tmp/tmp4394yens.swift:37:6: note: 'openingBracketsCountLimitLimitLimitIndex'\
    \ previously declared here\n        let openingBracketsCountLimitLimitLimitIndex\
    \ = openingBracketsCountLimitLimitIndex\n            ^\n/tmp/tmp4394yens.swift:43:6:\
    \ error: invalid redeclaration of 'openingBracketsCountLimitLimitLimitIndex'\n\
    \        let openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \            ^\n/tmp/tmp4394yens.swift:37:6: note: 'openingBracketsCountLimitLimitLimitIndex'\
    \ previously declared here\n        let openingBracketsCountLimitLimitLimitIndex\
    \ = openingBracketsCountLimitLimitIndex\n            ^\n/tmp/tmp4394yens.swift:46:6:\
    \ error: invalid redeclaration of 'openingBracketsCountLimitLimitLimitIndex'\n\
    \        let openingBracketsCountLimitLimitLimitIndex = openingBracketsCountLimitLimitIndex\n\
    \            ^\n/tmp/tmp4394yens.swift:37:6: note: 'openingBracketsCountLimitLimitLimitIndex'\
    \ previously declared here\n        let openingBracketsC"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet open = string.rangeOfString(\"[\")\n\tlet close = string.rangeOfString(\"\
    ]\")\n\t\n\tif open < 0 || close < 0 {\n\t\treturn false\n\t}\n\t\n\tlet openCount\
    \ = 1\n\tlet closeCount = 1\n\t\n\tfor openIndex in 0..<open {\n\t\tlet openBracket\
    \ = string[openIndex..<openIndex+1]\n\t\t\n\t\tif openBracket == \"[\" {\n\t\t\
    \topenCount++\n\t\t} else if openBracket == \"]\" {\n\t\t\topenCount--\n\t\t}\n\
    \t\t\n\t\tif openCount < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\tfor closeIndex\
    \ in 0..<close {\n\t\tlet closeBracket = string[closeIndex..<closeIndex+1]\n\t\
    \t\n\t\tif closeBracket == \"[\" {\n\t\t\tcloseCount++\n\t\t} else if closeBracket\
    \ == \"]\" {\n\t\t\tcloseCount--\n\t\t}\n\t\t\n\t\tif closeCount < 0 {\n\t\t\t\
    return false\n\t\t}\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsy7y4wp7.swift:18:20: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let open = string.rangeOfString(\"[\")\n          \
    \         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpsy7y4wp7.swift:19:21: error: value of\
    \ type 'String' has no member 'rangeOfString'\n        let close = string.rangeOfString(\"\
    ]\")\n                    ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isWhitespace\
    \ }\n\t\t.filter { $0.isPunctuation }\n\t\t.filter { $0.isSymbol }\n\t\t.filter\
    \ { $0.isControl }\n\t\t.filter { $0.isCombiningMarker }\n\t\t.filter { $0.isExtender\
    \ }\n\t\t.filter { $0.isNonSpacing }\n\t\t.filter { $0.isSpacing }\n\t\t.filter\
    \ { $0.isCombiningDiacriticalMarks }\n\t\t.filter { $0.isCombiningDiacriticalMarksAcute\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksGrave }\n\t\t.filter { $0.isCombiningDiacriticalMarksOpen\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksClose }\n\t\t.filter { $0.isCombiningDiacriticalMarksNon\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksTilde }\n\t\t.filter { $0.isCombiningDiacriticalMarksOther\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksVertical }\n\t\t.filter { $0.isCombiningDiacriticalMarksBelow\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksAbove }\n\t\t.filter { $0.isCombiningDiacriticalMarksLeft\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksRight }\n\t\t.filter { $0.isCombiningDiacriticalMarksDoubleLeft\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksDoubleRight }\n\t\t.filter {\
    \ $0.isCombiningDiacriticalMarksTripleLeft }\n\t\t.filter { $0.isCombiningDiacriticalMarksTripleRight\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksQuadLeft }\n\t\t.filter { $0.isCombiningDiacriticalMarksQuadRight\
    \ }\n\t\t.filter { $0.isCombiningDiacriticalMarksDoubleQuadLeft }\n\t\t.filter\
    \ { $0.isCombiningDiacriticalMarksDouble\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphfu_6z0d.swift:79:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmphfu_6z0d.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmphfu_6z0d.swift:18:17: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphfu_6z0d.swift:54:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013780
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = 1\n\tlet\
    \ closingBracketsCount = 1\n\t\n\tfor char in string {\n\t\tif char == '[' {\n\
    \t\t\topeningBrackets.insert(char)\n\t\t\topeningBracketsCount += 1\n\t\t} else\
    \ if char == ']' {\n\t\t\tclosingBrackets.insert(char)\n\t\t\tclosingBracketsCount\
    \ += 1\n\t\t}\n\t\t\n\t\tif openingBracketsCount == closingBracketsCount {\n\t\
    \t\tstack.append(char)\n\t\t}\n\t}\n\t\n\treturn stack.count == 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnnqo9r0s.swift:25:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '[' {\n                           ^~~\n\
    \                           \"[\"\n/tmp/tmpnnqo9r0s.swift:28:21: error: single-quoted\
    \ string literal found, use '\"'\n                } else if char == ']' {\n  \
    \                                ^~~\n                                  \"]\"\n\
    /tmp/tmpnnqo9r0s.swift:18:14: error: cannot find 'Stack' in scope\n        let\
    \ stack = Stack()\n                    ^~~~~\n/tmp/tmpnnqo9r0s.swift:26:20: error:\
    \ cannot use mutating member on immutable value: 'openingBrackets' is a 'let'\
    \ constant\n                        openingBrackets.insert(char)\n           \
    \             ~~~~~~~~~~~~~~~ ^\n/tmp/tmpnnqo9r0s.swift:19:2: note: change 'let'\
    \ to 'var' to make it mutable\n        let openingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpnnqo9r0s.swift:27:25: error: left side of mutating\
    \ operator isn't mutable: 'openingBracketsCount' is a 'let' constant\n       \
    \                 openingBracketsCount += 1\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpnnqo9r0s.swift:21:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openingBracketsCount = 1\n        ^~~\n        var\n/tmp/tmpnnqo9r0s.swift:29:20:\
    \ error: cannot use mutating member on immutable value: 'closingBrackets' is a\
    \ 'let' constant\n                        closingBrackets.insert(char)\n     \
    \                   ~~~~~~~~~~~~~~~ ^\n/tmp/tmpnnqo9r0s.swift:20:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let closingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpnnqo9r0s.swift:30:25: error: left side of mutating\
    \ operator isn't mutable: 'closingBracketsCount' is a 'let' constant\n       \
    \                 closingBracketsCount += 1\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpnnqo9r0s.swift:22:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closingBracketsCount = 1\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0\
    \ != brackets.first })\n\t\t.filter({ $0 != brackets.last })\n\t\t.filter({ $0\
    \ != brackets.first && $0 != brackets.last })\n\treturn brackets.count > 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo9_4wb3_.swift:21:4: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n                .filter({ $0 != brackets.first && $0\
    \ != brackets.last })\n                 ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n\t\n\tlet openBracketsCount = stack.count\n\
    \tlet closeBracketsCount = stack.count\n\t\n\tlet openBracketsIndex = stack.index\n\
    \tlet closeBracketsIndex = stack.index\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplwszhibc.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openingBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closingBrackets = brackets.filter({\
    \ $0.isClosing })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1p2od4uc.swift:19:45: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n                                                ~~ ^~~~~~\n/tmp/tmp1p2od4uc.swift:20:45:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter({ $0.isClosing })\n                      \
    \                          ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut stack_size = stack.size()\n\
    \tlet mut open_brackets = 0\n\tlet mut close_brackets = 0\n\tlet mut open_brackets_count\
    \ = 0\n\tlet mut close_brackets_count = 0\n\tlet mut open_brackets_count_max =\
    \ 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_max\
    \ = 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_max\
    \ = 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_max\
    \ = 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_max\
    \ = 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_max\
    \ = 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdu9j7vz2.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut stack_size\
    \ = stack.size()\n                ^\n/tmp/tmpdu9j7vz2.swift:19:10: note: join\
    \ the identifiers together\n        let mut stack_size = stack.size()\n      \
    \      ~~~~^~~~~~~~~~\n            mutstack_size\n/tmp/tmpdu9j7vz2.swift:19:10:\
    \ note: join the identifiers together with camel-case\n        let mut stack_size\
    \ = stack.size()\n            ~~~~^~~~~~~~~~\n            mutStack_size\n/tmp/tmpdu9j7vz2.swift:20:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets = 0\n                ^\n\
    /tmp/tmpdu9j7vz2.swift:20:10: note: join the identifiers together\n        let\
    \ mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n            mutopen_brackets\n\
    /tmp/tmpdu9j7vz2.swift:20:10: note: join the identifiers together with camel-case\n\
    \        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n          \
    \  mutOpen_brackets\n/tmp/tmpdu9j7vz2.swift:21:10: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \       let mut close_brackets = 0\n                ^\n/tmp/tmpdu9j7vz2.swift:21:10:\
    \ note: join the identifiers together\n        let mut close_brackets = 0\n  \
    \          ~~~~^~~~~~~~~~~~~~\n            mutclose_brackets\n/tmp/tmpdu9j7vz2.swift:21:10:\
    \ note: join the identifiers together with camel-case\n        let mut close_brackets\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~\n            mutClose_brackets\n/tmp/tmpdu9j7vz2.swift:22:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets_count = 0\n            \
    \    ^\n/tmp/tmpdu9j7vz2.swift:22:10: note: join the identifiers together\n  \
    \      let mut open_brackets_count = 0\n            ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \            mutopen_brackets_count\n/tmp/tmpdu9j7vz2.swift:22:10: note: join\
    \ the identifiers together with camel-case\n        let mut open_brackets_coun"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut open_brackets = 0\n\tlet\
    \ mut closed_brackets = 0\n\tlet mut open_brackets_count = 0\n\tlet mut closed_brackets_count\
    \ = 0\n\tlet mut open_brackets_stack = Stack()\n\tlet mut closed_brackets_stack\
    \ = Stack()\n\tlet mut open_brackets_stack_count = Stack()\n\tlet mut closed_brackets_stack_count\
    \ = Stack()\n\tlet mut open_brackets_stack_string = Stack()\n\tlet mut closed_brackets_stack_string\
    \ = Stack()\n\tlet mut open_brackets_stack_string_count = Stack()\n\tlet mut closed_brackets_stack_string_count\
    \ = Stack()\n\tlet mut open_brackets_stack_string_string = Stack()\n\tlet mut\
    \ closed_brackets_stack_string_string = Stack()\n\tlet mut open_brackets_stack_string_string_count\
    \ = Stack()\n\tlet mut closed_brackets_stack_string_string_count = Stack()\n\t\
    let mut open_brackets_stack_string_string_string = Stack()\n\tlet mut closed_brackets_stack_string_string_string\
    \ = Stack()\n\tlet mut open_brackets_stack_string_string_string_count = Stack()\n\
    \tlet mut closed_brackets_stack_string_string_string_count = Stack()\n\tlet mut\
    \ open_brackets_stack_string_string_string_string = Stack()\n\tlet mut closed_brackets_stack_string_string_string_string\
    \ = Stack()\n\tlet mut open_brackets_stack_string_string_string_string_count =\
    \ Stack()\n\tlet mut closed_brackets_stack_string_string_string_string_count =\
    \ Stack()\n\tlet mut open_brackets_stack_string_string_string_string_string =\
    \ Stack()\n\tlet mut closed_brackets_stack_string_string_string_string = Stack()\n\
    \tlet mut open_brackets_stack_string_string_string_string_count = Stack()\n\t\
    let mut closed_brackets_stack_string_string_string_string_count = Stack()\n\t\
    let mut open_brackets_stack_string_string_string_string_string = Stack()\n\tlet\
    \ mut closed_brackets_stack_string_string_string_string_string = Stack()\n\tlet\
    \ mut open_brackets_stack_string_string_string_string_string_count = Stack()\n\
    \tlet mut closed_brackets_stack_string_string_string_string_string_count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp26lace4w.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut open_brackets\
    \ = 0\n                ^\n/tmp/tmp26lace4w.swift:19:10: note: join the identifiers\
    \ together\n        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n\
    \            mutopen_brackets\n/tmp/tmp26lace4w.swift:19:10: note: join the identifiers\
    \ together with camel-case\n        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n\
    \            mutOpen_brackets\n/tmp/tmp26lace4w.swift:20:10: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \       let mut closed_brackets = 0\n                ^\n/tmp/tmp26lace4w.swift:20:10:\
    \ note: join the identifiers together\n        let mut closed_brackets = 0\n \
    \           ~~~~^~~~~~~~~~~~~~~\n            mutclosed_brackets\n/tmp/tmp26lace4w.swift:20:10:\
    \ note: join the identifiers together with camel-case\n        let mut closed_brackets\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~~\n            mutClosed_brackets\n/tmp/tmp26lace4w.swift:21:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets_count = 0\n            \
    \    ^\n/tmp/tmp26lace4w.swift:21:10: note: join the identifiers together\n  \
    \      let mut open_brackets_count = 0\n            ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \            mutopen_brackets_count\n/tmp/tmp26lace4w.swift:21:10: note: join\
    \ the identifiers together with camel-case\n        let mut open_brackets_count\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~~~~~~\n            mutOpen_brackets_count\n\
    /tmp/tmp26lace4w.swift:22:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut closed_brackets_count\
    \ = 0\n                ^\n/tmp/tmp26lace4w.swift:22:10: note: join the identifiers\
    \ together\n        let mut closed_brackets_count = 0\n            ~~~~^~~~~~~~~~~~~~~~~~~~~\n\
    \            mutclosed_brackets_count\n/tmp/tmp26lace4w.swift:22:10: note: join\
    \ the identifiers together with "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBracket()\
    \ })\n\t\t.map({ $0.value })\n\t\t.reduce({ $0 }, { $0 + 1 })\n\treturn brackets\
    \ == 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpekmw6yuo.swift:21:21: error: cannot convert value of type '(_)\
    \ -> _' to expected argument type 'Int'\n                .reduce({ $0 }, { $0\
    \ + 1 })\n                                  ^\n/tmp/tmpekmw6yuo.swift:19:16: error:\
    \ value of type 'Unicode.Scalar' has no member 'isBracket'\n                .filter({\
    \ $0.isBracket() })\n                          ~~ ^~~~~~~~~\n/tmp/tmpekmw6yuo.swift:21:19:\
    \ error: contextual closure type '(@escaping (_) -> _, UInt32) throws -> (_) ->\
    \ _' expects 2 arguments, but 1 was used in closure body\n                .reduce({\
    \ $0 }, { $0 + 1 })\n                                ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = 1\n\tlet\
    \ closingBracketsCount = 1\n\tlet openingBracketsString = \"\"\n\tlet closingBracketsString\
    \ = \"\"\n\tlet openingBracketsCountString = \"\"\n\tlet closingBracketsCountString\
    \ = \"\"\n\t\n\tfor char in string {\n\t\tif char == \"[\" {\n\t\t\topeningBrackets.insert(char)\n\
    \t\t\topeningBracketsCount += 1\n\t\t\topeningBracketsString += String(char)\n\
    \t\t} else if char == \"]\" {\n\t\t\tclosingBrackets.insert(char)\n\t\t\tclosingBracketsCount\
    \ += 1\n\t\t\tclosingBracketsString += String(char)\n\t\t} else if char == \"\
    {\" {\n\t\t\topeningBracketsCount += 1\n\t\t\topeningBracketsCountString += String(char)\n\
    \t\t} else if char == \"}\" {\n\t\t\tclosingBracketsCount += 1\n\t\t\tclosingBracketsCountString\
    \ += String(char)\n\t\t}\n\t}\n\t\n\tif openingBracketsCount > 1 {\n\t\treturn\
    \ false\n\t} else if openingBracketsCount == 1 {\n\t\tif openingBrackets.isSubset(of:\
    \ closingBrackets) {\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\tif openingBracketsCount\
    \ == 0 {\n\t\tif closingBrackets.isSubset(of: openingBrackets) {\n\t\t\treturn\
    \ true\n\t\t}\n\t}\n\t\n\tif openingBracketsCount == closingBracketsCount {\n\t\
    \tif openingBrackets.isSubset(of: closingBrackets) {\n\t\t\treturn true\n\t\t\
    }\n\t}\n\t\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmppfsrt5ls.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmppfsrt5ls.swift:30:20:\
    \ error: cannot use mutating member on immutable value: 'openingBrackets' is a\
    \ 'let' constant\n                        openingBrackets.insert(char)\n     \
    \                   ~~~~~~~~~~~~~~~ ^\n/tmp/tmppfsrt5ls.swift:19:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmppfsrt5ls.swift:31:25: error: left side of mutating\
    \ operator isn't mutable: 'openingBracketsCount' is a 'let' constant\n       \
    \                 openingBracketsCount += 1\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmppfsrt5ls.swift:21:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openingBracketsCount = 1\n        ^~~\n        var\n/tmp/tmppfsrt5ls.swift:32:26:\
    \ error: left side of mutating operator isn't mutable: 'openingBracketsString'\
    \ is a 'let' constant\n                        openingBracketsString += String(char)\n\
    \                        ~~~~~~~~~~~~~~~~~~~~~ ^\n/tmp/tmppfsrt5ls.swift:23:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let openingBracketsString\
    \ = \"\"\n        ^~~\n        var\n/tmp/tmppfsrt5ls.swift:34:20: error: cannot\
    \ use mutating member on immutable value: 'closingBrackets' is a 'let' constant\n\
    \                        closingBrackets.insert(char)\n                      \
    \  ~~~~~~~~~~~~~~~ ^\n/tmp/tmppfsrt5ls.swift:20:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let closingBrackets = Set<Character>()\n       \
    \ ^~~\n        var\n/tmp/tmppfsrt5ls.swift:35:25: error: left side of mutating\
    \ operator isn't mutable: 'closingBracketsCount' is a 'let' constant\n       \
    \                 closingBracketsCount += 1\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmppfsrt5ls.swift:22:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closingBracketsCount = 1\n        ^~~\n        var\n/tmp/tmppfsrt5ls.swift:36:26:\
    \ error: left side of mutating operator isn't mutable: 'closingBracketsStrin"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet chars = string.characters\n\tlet openingBrackets =\
    \ chars.filter({ $0 == \"[\" })\n\tlet closingBrackets = chars.filter({ $0 ==\
    \ \"]\" })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count >\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") ==\
    \ true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsuq9ys6u.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = string.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpikkh3l_w.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isASCII\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isPlus })\n\t\t.filter({ $0.isMinus\
    \ })\n\t\t.filter({ $0.isLeftBracket })\n\t\t.filter({ $0.isRightBracket })\n\t\
    \t.filter({ $0.isLeftBrace })\n\t\t.filter({ $0.isRightBrace })\n\t\t.filter({\
    \ $0.isLeftCurly })\n\t\t.filter({ $0.isRightCurly })\n\t\t.filter({ $0.isLeftSquare\
    \ })\n\t\t.filter({ $0.isRightSquare })\n\t\t.filter({ $0.isLeftParenthesis })\n\
    \t\t.filter({ $0.isRightParenthesis })\n\t\t.filter({ $0.isComma })\n\t\t.filter({\
    \ $0.isColon })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon })\n\
    \t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon\
    \ })\n\t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({\
    \ $0.isColon })\n\t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicolon })\n\
    \t\t.filter({ $0.isColon })\n\t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicolon\
    \ })\n\t\t.filter({ $0.isColon })\n\t\t.filter({ $0.isComma })\n\t\t.filter({\
    \ $0.isSemicolon })\n\t\t.filter({ $0.isColon })\n\t\t.filter({ $0.isComma })\n\
    \t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon })\n\t\t.filter({ $0.isComma\
    \ })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon })\n\t\t.filter({\
    \ $0.isComma })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon })\n\
    \t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicolon })\n\t\t.filter({ $0.isColon\
    \ })\n\t\t.filter({ $0.isComma })\n\t\t.filter({ $0.isSemicol\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpq1i8mccu.swift:69:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpq1i8mccu.swift:65:10:\
    \ note: to match this opening '('\n                .filter({ $0.isSemicol\n  \
    \                     ^\n/tmp/tmpq1i8mccu.swift:94:47: error: expected '}' at\
    \ end of brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n \
    \                                             ^\n/tmp/tmpq1i8mccu.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmpq1i8mccu.swift:18:17: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        let brackets\
    \ = string.unicodeScalars\n                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpq1i8mccu.swift:69:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013785
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\tlet openingBracketCount = openingBrackets.count\n\tlet closingBracketCount\
    \ = closingBrackets.count\n\t\n\tguard openingBracketCount > 0 else {\n\t\treturn\
    \ false\n\t}\n\t\n\tguard closingBracketCount > 0 else {\n\t\treturn false\n\t\
    }\n\t\n\tguard openingBracketCount == closingBracketCount else {\n\t\treturn false\n\
    \t}\n\t\n\tguard openingBracketCount == 1 else {\n\t\treturn false\n\t}\n\t\n\t\
    guard closingBracketCount == 1 else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.first\
    \ == closingBrackets.first else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.first\
    \ == openingBrackets.last.value + 1 else {\n\t\treturn false\n\t}\n\t\n\tguard\
    \ closingBrackets.first == closingBrackets.last.value + 1 else {\n\t\treturn false\n\
    \t}\n\t\n\tguard openingBrackets.last.value == closingBrackets.last.value + 1\
    \ else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.last.value == openingBracketCount\
    \ - 1 else {\n\t\treturn false\n\t}\n\t\n\tguard closingBrackets.last.value ==\
    \ closingBracketCount - 1 else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.last.value\
    \ == openingBrackets.last.value + 1 else {\n\t\treturn false\n\t}\n\t\n\tguard\
    \ closingBrackets.last.value == closingBrackets.last.value + 1 else {\n\t\treturn\
    \ false\n\t}\n\t\n\tguard openingBrackets.last.value == openingBrackets.last.value\
    \ + 1 else {\n\t\treturn false\n\t}\n\t\n\tguard closingBrackets.last.value ==\
    \ closingBrackets.last.value + 1 else {\n\t\treturn false\n\t}\n\t\n\tguard openingBrackets.last.value\
    \ == openingBrackets.last.value + 1 else {\n\t\treturn false\n\t}\n\t\n\tguard\
    \ closingBrackets.last.value == closingBrackets.last.value + 1 else {\n\t\treturn\
    \ false\n\t}\n\t\n\tguard openingBrackets.last.\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzap1gv8u.swift:92:28: error: expected member name following '.'\n\
    \        guard openingBrackets.last.\n                                  ^\n/tmp/tmpzap1gv8u.swift:92:29:\
    \ error: expected 'else' after 'guard' condition\n        guard openingBrackets.last.\n\
    \                                   ^\n/tmp/tmpzap1gv8u.swift:18:14: error: cannot\
    \ find 'Stack' in scope\n        let stack = Stack()\n                    ^~~~~\n\
    /tmp/tmpzap1gv8u.swift:19:58: error: value of type 'Unicode.Scalar' has no member\
    \ 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n                                                             ~~ ^~~~~~\n\
    /tmp/tmpzap1gv8u.swift:20:58: error: value of type 'Unicode.Scalar' has no member\
    \ 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n                                                             ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketCount = brackets.count\n\
    \t\n\treturn bracketCount > 0 && bracketCount % 2 == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx0q7fji0.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = stack.count\n\
    \tlet closingBracketsCount = stack.count\n\t\n\tlet openingBracketsIndex = 0\n\
    \tlet closingBracketsIndex = 0\n\t\n\tlet openingBracketsCountIndex = 0\n\tlet\
    \ closingBracketsCountIndex = 0\n\t\n\tlet openingBracketsCountMax = openingBracketsCount\n\
    \tlet closingBracketsCountMax = closingBracketsCount\n\t\n\tlet openingBracketsCountMaxIndex\
    \ = 0\n\tlet closingBracketsCountMaxIndex = 0\n\t\n\tlet openingBracketsCountMin\
    \ = openingBracketsCount\n\tlet closingBracketsCountMin = closingBracketsCount\n\
    \t\n\tlet openingBracketsCountMinIndex = 0\n\tlet closingBracketsCountMinIndex\
    \ = 0\n\t\n\tlet openingBracketsCountMaxIndex = openingBracketsCountMax\n\tlet\
    \ closingBracketsCountMaxIndex = closingBracketsCountMax\n\t\n\tlet openingBracketsCountMinIndex\
    \ = openingBracketsCountMin\n\tlet closingBracketsCountMinIndex = closingBracketsCountMin\n\
    \t\n\tlet openingBracketsCountMinIndex = openingBracketsCountMin\n\tlet closingBracketsCountMinIndex\
    \ = closingBracketsCountMin\n\t\n\tlet openingBracketsCountMinIndex = openingBracketsCountMin\n\
    \tlet closingBracketsCountMinIndex = closingBracketsCountMin\n\t\n\tlet openingBracketsCountMinIndex\
    \ = openingBracketsCountMin\n\tlet closingBracketsCountMinIndex = closingBracketsCountMin\n\
    \t\n\tlet openingBracketsCountMinIndex = openingBracketsCountMin\n\tlet closingBracketsCountMinIndex\
    \ = closingBracketsCountMin\n\t\n\tlet openingBracketsCountMinIndex = openingBracketsCountMin\n\
    \tlet closingBracketsCountMinIndex = closingBracketsCountMin\n\t\n\tlet openingBracketsCountMinIndex\
    \ = openingBracketsCountMin\n\tlet closingBracketsCountMinIndex = closingBracketsCountMin\n\
    \t\n\tlet openingBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5snkzm1v.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmp5snkzm1v.swift:66:6:\
    \ error: type annotation missing in pattern\n        let openingBrackets\n   \
    \         ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\", options: .literal, range: nil)\n\tlet bracketsCount = brackets.characters.count\n\
    \tlet bracketsNestings = brackets.replacingOccurrences(of: \"]\", with: \"\",\
    \ options: .literal, range: nil)\n\tlet bracketsNestingsCount = bracketsNestings.characters.count\n\
    \tlet bracketsNestingsNestings = bracketsNestings.replacingOccurrences(of: \"\
    [\", with: \"\", options: .literal, range: nil)\n\tlet bracketsNestingsNestingsCount\
    \ = bracketsNestingsNestings.characters.count\n\treturn bracketsCount == bracketsNestingsCount\
    \ && bracketsNestingsNestingsCount == bracketsNestingsCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0tdr5dw6.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                       ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0tdr5dw6.swift:18:74: error: cannot infer contextual\
    \ base in reference to member 'literal'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                       ~^~~~~~~\n/tmp/tmp0tdr5dw6.swift:18:90:\
    \ error: 'nil' requires a contextual type\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                        ^\n/tmp/tmp0tdr5dw6.swift:20:84:\
    \ error: cannot infer contextual base in reference to member 'literal'\n     \
    \   let bracketsNestings = brackets.replacingOccurrences(of: \"]\", with: \"\"\
    , options: .literal, range: nil)\n                                           \
    \                                              ~^~~~~~~\n/tmp/tmp0tdr5dw6.swift:20:100:\
    \ error: 'nil' requires a contextual type\n        let bracketsNestings = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \      ^\n/tmp/tmp0tdr5dw6.swift:22:100: error: cannot infer contextual base in\
    \ reference to member 'literal'\n        let bracketsNestingsNestings = bracketsNestings.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \     ~^~~~~~~\n/tmp/tmp0tdr5dw6.swift:22:116: error: 'nil' requires a contextual\
    \ type\n        let bracketsNestingsNestings = bracketsNestings.replacingOccurrences(of:\
    \ \"[\", with: \"\", options: .literal, range: nil)\n                        \
    \                                                                            \
    \     "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \tlet openBrackets = brackets.replacingOccurrences(of: \"(\", with: \"\").replacingOccurrences(of:\
    \ \")\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \treturn bracketsCount == openBracketsCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4e9p7m_0.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \tlet openBrackets = brackets.filter({ $0.isBr && $0.isBr })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.isBr && !$0.isBr })\n\tlet openBracketsCount = openBrackets.count\n\
    \tlet closeBracketsCount = closeBrackets.count\n\tlet bracketsCount = brackets.count\n\
    \t\n\treturn openBracketsCount == closeBracketsCount && bracketsCount == openBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpm0exn4fd.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \t\n\tlet openingBrackets = brackets.filter({ $0.isBr && $0.isBr })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.isBr && !$0.isBr })\n\t\n\treturn openingBrackets.count\
    \ > 0 || closingBrackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpptddw53q.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \t\n\treturn bracketsCount > 0 && bracketsCount % 2 == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg_24y9yq.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \t\n\tlet openBrackets = brackets.filter({ $0.isBr && $0.isOpen })\n\tlet closeBrackets\
    \ = brackets.filter({ $0.isBr && !$0.isOpen })\n\t\n\treturn openBrackets.count\
    \ >= closeBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3vdl78ag.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1cfibiqd.swift:98:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp1cfibiqd.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmp1cfibiqd.swift:18:17: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1cfibiqd.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets.location != NSNotFound ? openingBrackets.location - string.startIndex\
    \ : 0\n\tlet closingBracketsCount = closingBrackets.location != NSNotFound ? closingBrackets.location\
    \ - string.startIndex : 0\n\t\n\treturn openingBracketsCount > 0 && closingBracketsCount\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9vfc10_u.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp9vfc10_u.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp9vfc10_u.swift:21:57: error: cannot find 'NSNotFound' in scope\n     \
    \   let openingBracketsCount = openingBrackets.location != NSNotFound ? openingBrackets.location\
    \ - string.startIndex : 0\n                                                  \
    \             ^~~~~~~~~~\n/tmp/tmp9vfc10_u.swift:21:104: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        let openingBracketsCount\
    \ = openingBrackets.location != NSNotFound ? openingBrackets.location - string.startIndex\
    \ : 0\n                                                                      \
    \                                        ^\n/tmp/tmp9vfc10_u.swift:22:57: error:\
    \ cannot find 'NSNotFound' in scope\n        let closingBracketsCount = closingBrackets.location\
    \ != NSNotFound ? closingBrackets.location - string.startIndex : 0\n         \
    \                                                      ^~~~~~~~~~\n/tmp/tmp9vfc10_u.swift:22:104:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let closingBracketsCount = closingBrackets.location != NSNotFound\
    \ ? closingBrackets.location - string.startIndex : 0\n                       \
    \                                                                            \
    \           ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn openBrackets.location != NSNotFound\
    \ && closeBrackets.location != NSNotFound && openBrackets.location < closeBrackets.location\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_x9_y4z3.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp_x9_y4z3.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp_x9_y4z3.swift:21:34: error: cannot find 'NSNotFound' in scope\n     \
    \   return openBrackets.location != NSNotFound && closeBrackets.location != NSNotFound\
    \ && openBrackets.location < closeBrackets.location\n                        \
    \                ^~~~~~~~~~\n/tmp/tmp_x9_y4z3.swift:21:74: error: cannot find\
    \ 'NSNotFound' in scope\n        return openBrackets.location != NSNotFound &&\
    \ closeBrackets.location != NSNotFound && openBrackets.location < closeBrackets.location\n\
    \                                                                            \
    \    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \t\n\treturn bracketsCount == 0 || bracketsCount == string.count - bracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpegzgapo7.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount > 1 {\n\t\treturn true\n\t}\n\t\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmf8vfkj5.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmf8vfkj5.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpmf8vfkj5.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpmf8vfkj5.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount > 1 {\n\t\treturn true\n\t}\n\t\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmf8vfkj5.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmf8vfkj5.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpmf8vfkj5.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpmf8vfkj5.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet openBrackets = Array<String>()\n\
    \tlet closeBrackets = Array<String>()\n\tlet openBracketsCount = Array<Int>()\n\
    \tlet closeBracketsCount = Array<Int>()\n\tlet openBracketsCountStack = Array<Int>()\n\
    \tlet closeBracketsCountStack = Array<Int>()\n\tlet openBracketsCountStackCount\
    \ = Array<Int>()\n\tlet closeBracketsCountStackCount = Array<Int>()\n\t\n\tlet\
    \ openBracketsCountStackIndex = Array<Int>()\n\tlet closeBracketsCountStackIndex\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount = Array<Int>()\n\t\
    let closeBracketsCountStackIndexCount = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount2\
    \ = Array<Int>()\n\tlet closeBracketsCountStackIndexCount2 = Array<Int>()\n\t\n\
    \tlet openBracketsCountStackIndexCount3 = Array<Int>()\n\tlet closeBracketsCountStackIndexCount3\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount4 = Array<Int>()\n\
    \tlet closeBracketsCountStackIndexCount4 = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount5\
    \ = Array<Int>()\n\tlet closeBracketsCountStackIndexCount5 = Array<Int>()\n\t\n\
    \tlet openBracketsCountStackIndexCount6 = Array<Int>()\n\tlet closeBracketsCountStackIndexCount6\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount7 = Array<Int>()\n\
    \tlet closeBracketsCountStackIndexCount7 = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount8\
    \ = Array<Int>()\n\tlet closeBracketsCountStackIndexCount8 = Array<Int>()\n\t\n\
    \tlet openBracketsCountStackIndexCount9 = Array<Int>()\n\tlet closeBracketsCountStackIndexCount9\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount10 = Array<Int>()\n\
    \tlet closeBracketsCountStackIndexCount10 = Array<Int>()\n\t\n\tlet openBracketsCountStackIndexCount11\
    \ = Array<Int>()\n\tlet closeBracketsCountStackIndexCount11 = Array<Int>()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi4k6ksr2.swift:18:6: warning: initialization of immutable value\
    \ 'stack' was never used; consider replacing with assignment to '_' or removing\
    \ it\n        let stack = Array<String>()\n        ~~~~^~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:19:6:\
    \ warning: initialization of immutable value 'openBrackets' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let openBrackets =\
    \ Array<String>()\n        ~~~~^~~~~~~~~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:20:6:\
    \ warning: initialization of immutable value 'closeBrackets' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let closeBrackets =\
    \ Array<String>()\n        ~~~~^~~~~~~~~~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:21:6:\
    \ warning: initialization of immutable value 'openBracketsCount' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let openBracketsCount\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:22:6:\
    \ warning: initialization of immutable value 'closeBracketsCount' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let closeBracketsCount\
    \ = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:23:6:\
    \ warning: initialization of immutable value 'openBracketsCountStack' was never\
    \ used; consider replacing with assignment to '_' or removing it\n        let\
    \ openBracketsCountStack = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpi4k6ksr2.swift:24:6: warning: initialization of immutable\
    \ value 'closeBracketsCountStack' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let closeBracketsCountStack = Array<Int>()\n\
    \        ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpi4k6ksr2.swift:25:6:\
    \ warning: initialization of immutable value 'openBracketsCountStackCount' was\
    \ never used; consider replacing with assignment to '_' or removing it\n     \
    \   let openBracketsCountStackCount = Array<Int>()\n        ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpi4k6ksr2.swift:26:6: warning"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut index = 0\n\tlet mut open\
    \ = 0\n\tlet mut close = 0\n\tlet mut open_bracket = 0\n\tlet mut close_bracket\
    \ = 0\n\tlet mut open_brackets = 0\n\tlet mut close_brackets = 0\n\tlet mut open_brackets_count\
    \ = 0\n\tlet mut close_brackets_count = 0\n\tlet mut open_brackets_count_max =\
    \ 0\n\tlet mut close_brackets_count_max = 0\n\tlet mut open_brackets_count_min\
    \ = 0\n\tlet mut close_brackets_count_min = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_brackets_count_max_index\
    \ = 0\n\tlet mut close_brackets_count_max_index = 0\n\tlet mut open_brackets_count_min_index\
    \ = 0\n\tlet mut close_brackets_count_min_index = 0\n\tlet mut open_b\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqcruyabu.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut index\
    \ = 0\n                ^\n/tmp/tmpqcruyabu.swift:19:10: note: join the identifiers\
    \ together\n        let mut index = 0\n            ~~~~^~~~~\n            mutindex\n\
    /tmp/tmpqcruyabu.swift:19:10: note: join the identifiers together with camel-case\n\
    \        let mut index = 0\n            ~~~~^~~~~\n            mutIndex\n/tmp/tmpqcruyabu.swift:20:9:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ mut open = 0\n               ^\n               ;\n/tmp/tmpqcruyabu.swift:21:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut close = 0\n                ^\n/tmp/tmpqcruyabu.swift:21:10:\
    \ note: join the identifiers together\n        let mut close = 0\n           \
    \ ~~~~^~~~~\n            mutclose\n/tmp/tmpqcruyabu.swift:21:10: note: join the\
    \ identifiers together with camel-case\n        let mut close = 0\n          \
    \  ~~~~^~~~~\n            mutClose\n/tmp/tmpqcruyabu.swift:22:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut open_bracket = 0\n                ^\n/tmp/tmpqcruyabu.swift:22:10:\
    \ note: join the identifiers together\n        let mut open_bracket = 0\n    \
    \        ~~~~^~~~~~~~~~~~\n            mutopen_bracket\n/tmp/tmpqcruyabu.swift:22:10:\
    \ note: join the identifiers together with camel-case\n        let mut open_bracket\
    \ = 0\n            ~~~~^~~~~~~~~~~~\n            mutOpen_bracket\n/tmp/tmpqcruyabu.swift:23:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut close_bracket = 0\n                ^\n\
    /tmp/tmpqcruyabu.swift:23:10: note: join the identifiers together\n        let\
    \ mut close_bracket = 0\n            ~~~~^~~~~~~~~~~~~\n            mutclose_bracket\n\
    /tmp/tmpqcruyabu.swift:23:10: note: join the identifiers together with camel-case\n\
    \        let mut close_bracket = 0\n         "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter { $0.value\
    \ == Bracket.value }\n\t\n\tguard brackets.count > 0 else {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBrackets = brackets.filter({ $0.value == OpenBracket.value\
    \ })\n\tlet closeBrackets = brackets.filter({ $0.value == CloseBracket.value })\n\
    \t\n\tguard openBrackets.count > 0 && closeBrackets.count > 0 else {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\t\n\tguard openBracketsCount > closeBracketsCount else\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex = openBrackets.firstIndex({\
    \ $0.value == OpenBracket.value })\n\tlet closeBracketsIndex = closeBrackets.firstIndex({\
    \ $0.value == CloseBracket.value })\n\t\n\tguard openBracketsIndex != nil && closeBracketsIndex\
    \ != nil else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = openBrackets.count\n\
    \tlet closeBracketsCount = closeBrackets.count\n\t\n\tguard openBracketsCount\
    \ > closeBracketsCount else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex\
    \ = openBrackets.firstIndex({ $0.value == OpenBracket.value })\n\tlet closeBracketsIndex\
    \ = closeBrackets.firstIndex({ $0.value == CloseBracket.value })\n\t\n\tguard\
    \ openBracketsIndex != nil && closeBracketsIndex != nil else {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\t\n\tguard openBracketsCount > closeBracketsCount else\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex = openBrackets.firstIndex({\
    \ $0.value == OpenBracket.value })\n\tlet closeBracketsIndex = closeBrackets.firstIndex({\
    \ $0.value == CloseBracket.value })\n\t\n\tguard openBracketsIndex != nil && closeBracketsIndex\
    \ != nil else {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = openBrackets.count\n\
    \tlet closeBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl6tofedd.swift:18:60: error: cannot find 'Bracket' in scope\n \
    \       let brackets = string.unicodeScalars.filter { $0.value == Bracket.value\
    \ }\n                                                                  ^~~~~~~\n\
    /tmp/tmpl6tofedd.swift:24:51: error: cannot find 'OpenBracket' in scope\n    \
    \    let openBrackets = brackets.filter({ $0.value == OpenBracket.value })\n \
    \                                                        ^~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:25:52:\
    \ error: cannot find 'CloseBracket' in scope\n        let closeBrackets = brackets.filter({\
    \ $0.value == CloseBracket.value })\n                                        \
    \                  ^~~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:38:64: error: cannot find\
    \ 'OpenBracket' in scope\n        let openBracketsIndex = openBrackets.firstIndex({\
    \ $0.value == OpenBracket.value })\n                                         \
    \                             ^~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:39:66: error:\
    \ cannot find 'CloseBracket' in scope\n        let closeBracketsIndex = closeBrackets.firstIndex({\
    \ $0.value == CloseBracket.value })\n                                        \
    \                                ^~~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:52:64: error:\
    \ cannot find 'OpenBracket' in scope\n        let openBracketsIndex = openBrackets.firstIndex({\
    \ $0.value == OpenBracket.value })\n                                         \
    \                             ^~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:53:66: error:\
    \ cannot find 'CloseBracket' in scope\n        let closeBracketsIndex = closeBrackets.firstIndex({\
    \ $0.value == CloseBracket.value })\n                                        \
    \                                ^~~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:66:64: error:\
    \ cannot find 'OpenBracket' in scope\n        let openBracketsIndex = openBrackets.firstIndex({\
    \ $0.value == OpenBracket.value })\n                                         \
    \                             ^~~~~~~~~~~\n/tmp/tmpl6tofedd.swift:67:66: error:\
    \ cannot find 'CloseBracket' in scope\n        let closeBracketsIndex = closeBrackets.firstIndex({\
    \ $0.value "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\t\n\tlet openBracketsCount = countOpenBrackets(string:\
    \ string, openBrackets: &openBrackets)\n\tlet closeBracketsCount = countCloseBrackets(string:\
    \ string, closeBrackets: &closeBrackets)\n\t\n\treturn openBracketsCount == closeBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpd7dhdwx5.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpd7dhdwx5.swift:22:26:\
    \ error: cannot find 'countOpenBrackets' in scope\n        let openBracketsCount\
    \ = countOpenBrackets(string: string, openBrackets: &openBrackets)\n         \
    \                       ^~~~~~~~~~~~~~~~~\n/tmp/tmpd7dhdwx5.swift:22:74: error:\
    \ cannot pass immutable value as inout argument: 'openBrackets' is a 'let' constant\n\
    \        let openBracketsCount = countOpenBrackets(string: string, openBrackets:\
    \ &openBrackets)\n                                                           \
    \                     ^~~~~~~~~~~~~\n/tmp/tmpd7dhdwx5.swift:19:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpd7dhdwx5.swift:23:27: error: cannot find 'countCloseBrackets'\
    \ in scope\n        let closeBracketsCount = countCloseBrackets(string: string,\
    \ closeBrackets: &closeBrackets)\n                                 ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd7dhdwx5.swift:23:77: error: cannot pass immutable value as inout argument:\
    \ 'closeBrackets' is a 'let' constant\n        let closeBracketsCount = countCloseBrackets(string:\
    \ string, closeBrackets: &closeBrackets)\n                                   \
    \                                                ^~~~~~~~~~~~~~\n/tmp/tmpd7dhdwx5.swift:20:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let closeBrackets =\
    \ Set<Character>()\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isLetter\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1cfibiqd.swift:98:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp1cfibiqd.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmp1cfibiqd.swift:18:17: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1cfibiqd.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\tguard openingBrackets.count > 0 && closingBrackets.count > 0 else {\n\t\t\
    return false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\t\
    let closingBracketsCount = closingBrackets.count\n\t\n\tguard openingBracketsCount\
    \ > 0 && closingBracketsCount > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsIndex\
    \ = openingBrackets.firstIndex(where: { $0.isOpen })\n\tlet closingBracketsIndex\
    \ = closingBrackets.firstIndex(where: { $0.isClosing })\n\t\n\tguard openingBracketsIndex\
    \ != -1 && closingBracketsIndex != -1 else {\n\t\treturn false\n\t}\n\t\n\tlet\
    \ openingBracketsRange = openingBrackets[openingBracketsIndex..<openingBracketsIndex\
    \ + openingBracketsCount]\n\tlet closingBracketsRange = closingBrackets[closingBracketsIndex..<closingBracketsIndex\
    \ + closingBracketsCount]\n\t\n\tguard openingBracketsRange.count > 0 && closingBracketsRange.count\
    \ > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsRangeCount = openingBracketsRange.count\n\
    \tlet closingBracketsRangeCount = closingBracketsRange.count\n\t\n\tguard openingBracketsRangeCount\
    \ > 0 && closingBracketsRangeCount > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet\
    \ openingBracketsRangeIndex = openingBracketsRange.firstIndex(where: { $0.isOpen\
    \ })\n\tlet closingBracketsRangeIndex = closingBracketsRange.firstIndex(where:\
    \ { $0.isClosing })\n\t\n\tguard openingBracketsRangeIndex != -1 && closingBracketsRangeIndex\
    \ != -1 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsRangeRange = openingBracketsRange[openingBracketsRangeIndex..<openingBracketsRangeIndex\
    \ + openingBracketsRangeCount]\n\tlet closingBracketsRangeRange = closingBracketsRange[closingBracketsRange\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn0k1y9ja.swift:62:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpn0k1y9ja.swift:61:54: note: to match this opening '['\n        let\
    \ closingBracketsRangeRange = closingBracketsRange[closingBracketsRange\n    \
    \                                                        ^\n/tmp/tmpn0k1y9ja.swift:18:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmpn0k1y9ja.swift:19:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = stack.countOpenBrackets()\n\
    \tlet closeBrackets = stack.countCloseBrackets()\n\t\n\tlet openBracketsCount\
    \ = stack.countOpenBrackets()\n\tlet closeBracketsCount = stack.countCloseBrackets()\n\
    \t\n\tif openBracketsCount > closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\
    \tlet openBracketsCount = stack.countOpenBrackets()\n\tlet closeBracketsCount\
    \ = stack.countCloseBrackets()\n\t\n\tif openBracketsCount < closeBracketsCount\
    \ {\n\t\treturn true\n\t}\n\t\n\tlet openBracketsCount = stack.countOpenBrackets()\n\
    \tlet closeBracketsCount = stack.countCloseBrackets()\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = stack.countOpenBrackets()\n\tlet closeBracketsCount = stack.countCloseBrackets()\n\
    \t\n\tif openBracketsCount != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\
    \tlet openBracketsCount = stack.countOpenBrackets()\n\tlet closeBracketsCount\
    \ = stack.countCloseBrackets()\n\t\n\tif openBracketsCount != closeBracketsCount\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = stack.countOpenBrackets()\n\
    \tlet closeBracketsCount = stack.countCloseBrackets()\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = stack.countOpenBrackets()\n\tlet closeBracketsCount = stack.countCloseBrackets()\n\
    \t\n\tif openBracketsCount != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\
    \tlet openBracketsCount = stack.countOpenBrackets()\n\tlet closeBracketsCount\
    \ = stack.countCloseBrackets()\n\t\n\tif openBracketsCount != closeBracketsCount\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = stack.countOpenBrackets()\n\
    \tlet closeBracketsCount = stack.countCloseBrackets()\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = stack.countOpenBrackets()\n\tlet closeBra\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpf4pjovqo.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpf4pjovqo.swift:86:6:\
    \ error: type annotation missing in pattern\n        let closeBra\n          \
    \  ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \",\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \" \", with: \"\")\n\t\t.replacingOccurrences(of: \"\\t\", with: \"\")\n\t\t\
    .replacingOccurrences(of: \"\\n\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\r\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\t\
    \t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"^\", with: \"\")\n\t\t.replacingOccurrences(of: \"~\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"*\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"%\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"[\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfr0xhkea.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet openingBrackets = Set<String>()\n\
    \tlet closingBrackets = Set<String>()\n\tlet openingBracketsCount = stack.count\n\
    \tlet closingBracketsCount = stack.count\n\t\n\tlet openingBracketsString = \"\
    [\"\n\tlet closingBracketsString = \"[\"\n\t\n\tlet openingBracketsIndex = string.index(of:\
    \ openingBracketsString)\n\tlet closingBracketsIndex = string.index(of: closingBracketsString)\n\
    \t\n\tlet openingBracketsLength = openingBracketsIndex!.distanceTo(openingBracketsIndex)\n\
    \tlet closingBracketsLength = closingBracketsIndex!.distanceTo(closingBracketsIndex)\n\
    \t\n\tlet openingBracketsString = string[openingBracketsIndex!]\n\tlet closingBracketsString\
    \ = string[closingBracketsIndex!]\n\t\n\tlet openingBracketsCount = stack.count\n\
    \t\n\twhile openingBracketsCount > 0 || closingBracketsCount > 0 {\n\t\t\n\t\t\
    if openingBracketsCount > 0 {\n\t\t\tlet openingBracketsString = string[openingBracketsIndex!]\n\
    \t\t\tlet openingBracketsIndex = string.index(of: openingBracketsString)\n\t\t\
    \tlet openingBracketsLength = openingBracketsIndex!.distanceTo(openingBracketsIndex)\n\
    \t\t\t\n\t\t\tif openingBracketsLength == 0 {\n\t\t\t\topeningBracketsCount -=\
    \ 1\n\t\t\t\topeningBracketsIndex = string.index(of: openingBracketsString)\n\t\
    \t\t\topeningBracketsLength = openingBracketsIndex!.distanceTo(openingBracketsIndex)\n\
    \t\t\t}\n\t\t\t\n\t\t\tlet openingBracketsString = string[openingBracketsIndex!]\n\
    \t\t\tlet openingBracketsIndex = string.index(of: openingBracketsString)\n\t\t\
    \tlet openingBracketsLength = openingBracketsIndex!.distanceTo(openingBracketsIndex)\n\
    \t\t\t\n\t\t\tif openingBracketsLength == 0 {\n\t\t\t\topeningBracketsCount -=\
    \ 1\n\t\t\t\topeningBracketsIndex = string.index(of: openingBracketsString)\n\t\
    \t\t\topeningBracketsLength = openingBracketsIndex!.distanceTo(openingBracketsIndex)\n\
    \t\t\t}\n\t\t\t\n\t\t\tlet open\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphjos_sqz.swift:90:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmphjos_sqz.swift:38:61: note: to match this opening\
    \ '{'\n        while openingBracketsCount > 0 || closingBracketsCount > 0 {\n\
    \                                                                   ^\n/tmp/tmphjos_sqz.swift:90:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmphjos_sqz.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmphjos_sqz.swift:18:14: error:\
    \ cannot find 'Stack' in scope\n        let stack = Stack<String>()\n        \
    \            ^~~~~\n/tmp/tmphjos_sqz.swift:27:46: error: cannot convert value\
    \ of type 'String' to expected argument type 'String.Element' (aka 'Character')\n\
    \        let openingBracketsIndex = string.index(of: openingBracketsString)\n\
    \                                                    ^\n/tmp/tmphjos_sqz.swift:28:46:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let closingBracketsIndex = string.index(of: closingBracketsString)\n\
    \                                                    ^\n/tmp/tmphjos_sqz.swift:61:8:\
    \ error: type annotation missing in pattern\n                        let open\n\
    \                            ^\n/tmp/tmphjos_sqz.swift:65:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"^\", with: \"\")\n\t\t.replacingOccurrences(of: \"~\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \";\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \",\", with: \"\")\n\t\t.replacingOccurrences(of: \" \", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\t\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\n\", with: \"\")\n\t\
    \t.replacingOccurrences(of: \"\\r\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\\"\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\
    \t\t.replacingOccurrences(of: \"'\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"%\", with: \"\")\n\t\t.replacingOccurrences(of: \"#\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"$\", with: \"\")\n\t\t.replacingOccurrences(of: \"%\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"*\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"+\", with: \"\")\n\t\t.replacingOccurrences(of: \"-\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \";\", with: \"\")\n\t\t\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0xmep07l.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\tlet bracketsCount = brackets.count\n\t\n\treturn openBracketsCount\
    \ == closeBracketsCount && openBracketsCount > 0 && closeBracketsCount > 0 &&\
    \ bracketsCount > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuha2ytdd.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closeBrackets = brackets.filter({ $0.isClosing\
    \ })\n\t\n\treturn openBrackets.count > closeBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuxbyd01u.swift:19:42: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = brackets.filter({ $0.isOpen })\n\
    \                                             ~~ ^~~~~~\n/tmp/tmpuxbyd01u.swift:20:43:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closeBrackets = brackets.filter({ $0.isClosing })\n                        \
    \                      ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isASCII\
    \ })\n\t\t.filter({ $0.isBr })\n\t\t.filter({ $0.isPunct })\n\t\t.filter({ $0.isCr\
    \ })\n\t\t.filter({ $0.isLf })\n\t\t.filter({ $0.isZl })\n\t\t.filter({ $0.isZp\
    \ })\n\t\t.filter({ $0.isCc })\n\t\t.filter({ $0.isCf })\n\t\t.filter({ $0.isZs\
    \ })\n\t\t.filter({ $0.isZl })\n\t\t.filter({ $0.isZp })\n\t\t.filter({ $0.isCn\
    \ })\n\t\t.filter({ $0.isCs })\n\t\t.filter({ $0.isPc })\n\t\t.filter({ $0.isPd\
    \ })\n\t\t.filter({ $0.isPs })\n\t\t.filter({ $0.isPe })\n\t\t.filter({ $0.isPf\
    \ })\n\t\t.filter({ $0.isPa })\n\t\t.filter({ $0.isPb })\n\t\t.filter({ $0.isPe\
    \ })\n\t\t.filter({ $0.isPf })\n\t\t.filter({ $0.isPi })\n\t\t.filter({ $0.isPo\
    \ })\n\t\t.filter({ $0.isPs })\n\t\t.filter({ $0.isPt })\n\t\t.filter({ $0.isPu\
    \ })\n\t\t.filter({ $0.isPv })\n\t\t.filter({ $0.isPw })\n\t\t.filter({ $0.isPx\
    \ })\n\t\t.filter({ $0.isPy })\n\t\t.filter({ $0.isPz })\n\t\t.filter({ $0.isPa\
    \ })\n\t\t.filter({ $0.isPb })\n\t\t.filter({ $0.isPc })\n\t\t.filter({ $0.isPd\
    \ })\n\t\t.filter({ $0.isPe })\n\t\t.filter({ $0.isPf })\n\t\t.filter({ $0.isPg\
    \ })\n\t\t.filter({ $0.isPh })\n\t\t.filter({ $0.isPi })\n\t\t.filter({ $0.isPj\
    \ })\n\t\t.filter({ $0.isPk })\n\t\t.filter({ $0.isPl })\n\t\t.filter({ $0.isPm\
    \ })\n\t\t.filter({ $0.isPn })\n\t\t.filter({ $0.isPo })\n\t\t.filter({ $0.isPp\
    \ })\n\t\t.filter({ $0.isPq })\n\t\t.filter({ \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8ctx4dp4.swift:73:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmp8ctx4dp4.swift:69:10:\
    \ note: to match this opening '('\n                .filter({ \n              \
    \         ^\n/tmp/tmp8ctx4dp4.swift:98:47: error: expected '}' at end of brace\
    \ statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n              \
    \                                ^\n/tmp/tmp8ctx4dp4.swift:17:40: note: to match\
    \ this opening '{'\nfunc is_nested(string: String) -> Bool {\n               \
    \                        ^\n/tmp/tmp8ctx4dp4.swift:18:17: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8ctx4dp4.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013786
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isASCII\
    \ })\n\t\t.filter({ $0.isBidiControl })\n\t\t.filter({ $0.isBidiFormatting })\n\
    \t\t.filter({ $0.isBidiMirrored })\n\t\t.filter({ $0.isBidiOverride })\n\t\t.filter({\
    \ $0.isBidiPrivate })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered\
    \ })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\
    \t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t\
    .filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({\
    \ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered\
    \ })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\
    \t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t\
    .filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({\
    \ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered\
    \ })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\
    \t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t\
    .filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({\
    \ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered\
    \ })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\
    \t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t\
    .filter({ $0.isBidiUnordered })\n\t\t.filter({ $0.isBidiUnordered })\n\t\t.filter({\
    \ $0.isBidiUnordered })\n\t\t.filter({ $\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp55fs2fm2.swift:61:13: error: '$' is not an identifier; use backticks\
    \ to escape it\n                .filter({ $\n                          ^\n   \
    \                       `$`\n/tmp/tmp55fs2fm2.swift:65:1: error: expected ')'\
    \ in expression list\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n^\n/tmp/tmp55fs2fm2.swift:61:10: note: to match this opening '('\n      \
    \          .filter({ $\n                       ^\n/tmp/tmp55fs2fm2.swift:90:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmp55fs2fm2.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmp55fs2fm2.swift:61:13: error:\
    \ cannot find '$' in scope\n                .filter({ $\n                    \
    \      ^\n/tmp/tmp55fs2fm2.swift:65:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut stack_string = string\n\t\
    let mut open_brackets = 0\n\tlet mut close_brackets = 0\n\twhile let c = stack_string.chars().next()\
    \ {\n\t\tswitch c {\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\
    \t\t\tclose_brackets += 1\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\t\
    case '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\t\
    open_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets +=\
    \ 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_bracket\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp92lkrhlm.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut stack_string\
    \ = string\n                ^\n/tmp/tmp92lkrhlm.swift:19:10: note: join the identifiers\
    \ together\n        let mut stack_string = string\n            ~~~~^~~~~~~~~~~~\n\
    \            mutstack_string\n/tmp/tmp92lkrhlm.swift:19:10: note: join the identifiers\
    \ together with camel-case\n        let mut stack_string = string\n          \
    \  ~~~~^~~~~~~~~~~~\n            mutStack_string\n/tmp/tmp92lkrhlm.swift:20:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets = 0\n                ^\n\
    /tmp/tmp92lkrhlm.swift:20:10: note: join the identifiers together\n        let\
    \ mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n            mutopen_brackets\n\
    /tmp/tmp92lkrhlm.swift:20:10: note: join the identifiers together with camel-case\n\
    \        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n          \
    \  mutOpen_brackets\n/tmp/tmp92lkrhlm.swift:21:10: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \       let mut close_brackets = 0\n                ^\n/tmp/tmp92lkrhlm.swift:21:10:\
    \ note: join the identifiers together\n        let mut close_brackets = 0\n  \
    \          ~~~~^~~~~~~~~~~~~~\n            mutclose_brackets\n/tmp/tmp92lkrhlm.swift:21:10:\
    \ note: join the identifiers together with camel-case\n        let mut close_brackets\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~\n            mutClose_brackets\n/tmp/tmp92lkrhlm.swift:24:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp92lkrhlm.swift:27:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp92lkrhlm.swift:30:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp92lkrhlm."
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0\
    \ >= 0x5B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x7D })\n\t\t.filter({\
    \ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t\
    .filter({ $0 >= 0x5B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x7D\
    \ })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0\
    \ <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x7B\
    \ && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0\
    \ >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({\
    \ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t\
    .filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D\
    \ })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0\
    \ <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x5B\
    \ && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({ $0\
    \ >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t.filter({\
    \ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D })\n\t\t\
    .filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x5D\
    \ })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B && $0\
    \ <= 0x5D })\n\t\t.filter({ $0 >= 0x5B && $0 <= 0x7D })\n\t\t.filter({ $0 >= 0x7B\
    \ && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpszd6040q.swift:51:21: error: '\n' is not a valid hexadecimal digit\
    \ (0-9, A-F) in integer literal\n                .filter({ $0 >= 0x\n        \
    \                          ^\n/tmp/tmpszd6040q.swift:55:1: error: expected ')'\
    \ in expression list\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n^\n/tmp/tmpszd6040q.swift:51:10: note: to match this opening '('\n      \
    \          .filter({ $0 >= 0x\n                       ^\n/tmp/tmpszd6040q.swift:80:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmpszd6040q.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmpszd6040q.swift:55:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut index = 0\n\tlet mut open\
    \ = 0\n\tlet mut close = 0\n\tlet mut opening_brackets = false\n\tlet mut closing_brackets\
    \ = false\n\tlet mut opening_square_brackets = false\n\tlet mut closing_square_brackets\
    \ = false\n\tlet mut opening_curly_brackets = false\n\tlet mut closing_curly_brackets\
    \ = false\n\tlet mut opening_curly_braces = false\n\tlet mut closing_curly_braces\
    \ = false\n\tlet mut opening_square_braces = false\n\tlet mut closing_square_braces\
    \ = false\n\tlet mut opening_square_brackets_count = 0\n\tlet mut closing_square_brackets_count\
    \ = 0\n\tlet mut opening_curly_brackets_count = 0\n\tlet mut closing_curly_brackets_count\
    \ = 0\n\tlet mut opening_curly_braces_count = 0\n\tlet mut closing_curly_braces_count\
    \ = 0\n\tlet mut opening_square_braces_count = 0\n\tlet mut closing_square_braces_count\
    \ = 0\n\tlet mut opening_square_brackets_count = 0\n\tlet mut closing_square_brackets_count\
    \ = 0\n\tlet mut opening_curly_brackets_count = 0\n\tlet mut closing_curly_brackets_count\
    \ = 0\n\tlet mut opening_curly_braces_count = 0\n\tlet mut closing_curly_braces_count\
    \ = 0\n\tlet mut opening_square_braces_count = 0\n\tlet mut closing_square_braces_count\
    \ = 0\n\tlet mut opening_square_brackets_count = 0\n\tlet mut closing_square_brackets_count\
    \ = 0\n\tlet mut opening_curly_brackets_count = 0\n\tlet mut closing_curly_brackets_count\
    \ = 0\n\tlet mut opening_curly_braces_count = 0\n\tlet mut closing_curly_braces_count\
    \ = 0\n\tlet mut opening_square_braces_count = 0\n\tlet mut closing_square_braces_count\
    \ = 0\n\tlet mut opening_square_brackets_count = 0\n\tlet mut closing_square_brackets_count\
    \ = 0\n\tlet mut opening_curly_brackets_count = 0\n\tlet mut closing_curly_brackets_count\
    \ = 0\n\tlet mut opening_curly_braces_count = 0\n\tlet mut closing_curly_braces_count\
    \ = 0\n\tlet mut \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpugio0frr.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut index\
    \ = 0\n                ^\n/tmp/tmpugio0frr.swift:19:10: note: join the identifiers\
    \ together\n        let mut index = 0\n            ~~~~^~~~~\n            mutindex\n\
    /tmp/tmpugio0frr.swift:19:10: note: join the identifiers together with camel-case\n\
    \        let mut index = 0\n            ~~~~^~~~~\n            mutIndex\n/tmp/tmpugio0frr.swift:20:9:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ mut open = 0\n               ^\n               ;\n/tmp/tmpugio0frr.swift:21:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut close = 0\n                ^\n/tmp/tmpugio0frr.swift:21:10:\
    \ note: join the identifiers together\n        let mut close = 0\n           \
    \ ~~~~^~~~~\n            mutclose\n/tmp/tmpugio0frr.swift:21:10: note: join the\
    \ identifiers together with camel-case\n        let mut close = 0\n          \
    \  ~~~~^~~~~\n            mutClose\n/tmp/tmpugio0frr.swift:22:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut opening_brackets = false\n                ^\n/tmp/tmpugio0frr.swift:22:10:\
    \ note: join the identifiers together\n        let mut opening_brackets = false\n\
    \            ~~~~^~~~~~~~~~~~~~~~\n            mutopening_brackets\n/tmp/tmpugio0frr.swift:22:10:\
    \ note: join the identifiers together with camel-case\n        let mut opening_brackets\
    \ = false\n            ~~~~^~~~~~~~~~~~~~~~\n            mutOpening_brackets\n\
    /tmp/tmpugio0frr.swift:23:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut closing_brackets\
    \ = false\n                ^\n/tmp/tmpugio0frr.swift:23:10: note: join the identifiers\
    \ together\n        let mut closing_brackets = false\n            ~~~~^~~~~~~~~~~~~~~~\n\
    \            mutclosing_brackets\n/tmp/tmpugio0frr.swift:23:10: note: join the\
    \ identifiers together"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex - openingBrackets?.startIndex\n\tlet closingBracketsCount\
    \ = closingBrackets?.endIndex - closingBrackets?.startIndex\n\t\n\tif openingBracketsCount\
    \ != closingBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsString\
    \ = string.substringWithRange(openingBrackets!)\n\tlet closingBracketsString =\
    \ string.substringWithRange(closingBrackets!)\n\t\n\tlet openingBracketsStringCount\
    \ = openingBracketsString.rangeOfString(\"[\")\n\tlet closingBracketsStringCount\
    \ = closingBracketsString.rangeOfString(\"]\")\n\t\n\tif openingBracketsStringCount\
    \ != closingBracketsStringCount {\n\t\treturn false\n\t}\n\t\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpb880a5wq.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpb880a5wq.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpb880a5wq.swift:25:55: error: binary operator '-' cannot be applied to\
    \ two 'Duration?' operands\n        let openingBracketsCount = openingBrackets?.endIndex\
    \ - openingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb880a5wq.swift:25:55: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (Float, Float), (Float16, Float16), (Float80, Float80),\
    \ (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant,\
    \ Duration), (SuspendingClock.Instant, SuspendingClock.Instant), (UInt, UInt),\
    \ (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n     \
    \   let openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \                                                             ^\n/tmp/tmpb880a5wq.swift:26:55:\
    \ error: binary operator '-' cannot be applied to two 'Duration?' operands\n \
    \       let closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb880a5wq.swift:26:55: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant, "
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.unicodeScalars\n\t\t.filter({\
    \ $0.isASCII })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .LTR })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .RTL })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .NEUTRAL })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .ONE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .TWO })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .THREE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .FOUR })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .FIVE })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .SIX })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .EIGHT })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .NINE })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .ONE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .TWO })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .THREE })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .FOUR })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .FIVE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .SIX })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .EIGHT })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .NINE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .ONE })\n\t\t.filter({\
    \ $0.isBidi && $0.bidiLevel == .TWO })\n\t\t.filter({ $0.isBidi && $0.bidiLevel\
    \ == .THREE })\n\t\t.filter({ $0.isBidi && $0.bidiLevel == .FOUR })\n\t\t.filter({\
    \ $0.is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpci4xja96.swift:49:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpci4xja96.swift:45:10:\
    \ note: to match this opening '('\n                .filter({ $0.is\n         \
    \              ^\n/tmp/tmpci4xja96.swift:74:47: error: expected '}' at end of\
    \ brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n        \
    \                                      ^\n/tmp/tmpci4xja96.swift:17:40: note:\
    \ to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n      \
    \                                 ^\n/tmp/tmpci4xja96.swift:18:17: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n        let brackets = string\n\
    \                       ^~~~~~\n/tmp/tmpci4xja96.swift:49:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013750
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count > 0 && closingBrackets.count > 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcv_0w33y.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpcv_0w33y.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\\\\", with: \"\")\n\t\t.replacingOccurrences(of: \"^\", with: \"\")\n\t\t\
    .replacingOccurrences(of: \"$\", with: \"\")\n\t\t.replacingOccurrences(of: \"\
    *\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"|\", with: \"\")\n\t\t.replacingOccurrences(of: \"!\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"%\", with: \"\")\n\t\t.replacingOccurrences(of: \"(\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \")\", with: \"\")\n\t\t.replacingOccurrences(of: \"[\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"]\", with: \"\")\n\t\t.replacingOccurrences(of: \"{\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\t\t.replacingOccurrences(of: \"<\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \">\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\t\t\
    .replacingOccurrences(of: \"^\", with: \"\")\n\t\t.replacingOccurrences(of: \"\
    $\", with: \"\")\n\t\t.replacingOccurrences(of: \"*\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"?\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"%\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.repla\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3nq6rc7b.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet chars = string.characters\n\t\n\tlet openingBrackets\
    \ = chars.filter({ $0 == \"[\" })\n\tlet closingBrackets = chars.filter({ $0 ==\
    \ \"]\" })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count >\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") ==\
    \ true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbv9zyrh3.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = string.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu7px4qg4.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpu7px4qg4.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isNumber })\n\t\t.filter({\
    \ $0.isPunctuation })\n\t\t.filter({ $0.isSymbol })\n\t\t.filter({ $0.isWhiteSpace\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({\
    \ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\
    \t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl })\n\t\t.filter({ $0.isControl\
    \ })\n\t\t.filter({ $0.isControl })\n\t\t.filter(\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi1bxp7ih.swift:75:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpi1bxp7ih.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013785
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.replacingOccurrences(of: \"\
    [\", with: \"\")\n\t\t.replacingOccurrences(of: \"]\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"(\", with: \"\")\n\t\t.replacingOccurrences(of: \")\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"{\", with: \"\")\n\t\t.replacingOccurrences(of: \"}\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\t\t.replacingOccurrences(of: \">\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"&\", with: \"\")\n\t\t.replacingOccurrences(of: \"|\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t.replacingOccurrences(of: \",\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \";\", with: \"\")\n\t\t.replacingOccurrences(of: \":\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \" \", with: \"\")\n\t\t.replacingOccurrences(of: \"\\t\", with: \"\")\n\t\t\
    .replacingOccurrences(of: \"\\n\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"\\r\", with: \"\")\n\t\t.replacingOccurrences(of: \"\\\\\", with: \"\")\n\t\
    \t.replacingOccurrences(of: \"^\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"%\", with: \"\")\n\t\t.replacingOccurrences(of: \"~\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"*\", with: \"\")\n\t\t.replacingOccurrences(of: \"?\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"!\", with: \"\")\n\t\t.replacingOccurrences(of: \"-\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"+\", with: \"\")\n\t\t.replacingOccurrences(of: \"=\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"%\", with: \"\")\n\t\t.replacingOccurrences(of: \"&\", with: \"\")\n\t\t.replacingOccurrences(of:\
    \ \"*\", with: \"\")\n\t\t.replacingOccurrences(of: \"(\", with: \"\")\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0_z90trs.swift:19:4: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                .replacingOccurrences(of: \"[\", with:\
    \ \"\")\n                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \t\n\tlet openBrackets = brackets.filter({ $0.isOpen })\n\tlet closeBrackets =\
    \ brackets.filter({ $0.isClose })\n\t\n\treturn openBrackets.count >= closeBrackets.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplsmlkx1z.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openings = Set<Character>()\n\
    \tlet closings = Set<Character>()\n\tlet openings_count = stack.count\n\tlet closings_count\
    \ = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\
    \tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet\
    \ openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count\
    \ = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\
    \tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet\
    \ closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count\
    \ = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\
    \tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet\
    \ openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count\
    \ = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\
    \tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet\
    \ closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count\
    \ = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\
    \tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet\
    \ openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count\
    \ = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\
    \tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet\
    \ closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count\
    \ = stack.count\n\tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\
    \tlet openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet\
    \ openings_count = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count\
    \ = stack.count\n\tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\
    \tlet closings_count = stack.count\n\tlet openings_count = stack.count\n\tlet\
    \ closings_count = stack.count\n\tlet openings_count = stack.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpppq1mv_e.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.endIndex }\n\t\t.map { $0.value }\n\t\t.reduce(into: []) {\n\t\t\
    \tif $0.last == brackets.endIndex {\n\t\t\t\t$0.append($0.last)\n\t\t\t} else\
    \ {\n\t\t\t\t$0.append(brackets.first!)\n\t\t\t}\n\t\t}\n\t\n\tlet nestedBrackets\
    \ = brackets.filter { brackets.contains($0) }\n\treturn nestedBrackets.count ==\
    \ brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1r_pb4ex.swift:21:4: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n                .reduce(into: []) {\n             \
    \    ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut chars = string.characters\n\
    \tlet mut openings = Stack()\n\tlet mut closings = Stack()\n\tlet mut openings_count\
    \ = 0\n\tlet mut closings_count = 0\n\tlet mut openings_stack = Stack()\n\tlet\
    \ mut closings_stack = Stack()\n\tlet mut openings_stack_size = openings_stack.len()\n\
    \tlet mut closings_stack_size = closings_stack.len()\n\tlet mut openings_stack_ptr\
    \ = &mut openings_stack[openings_stack_size]\n\tlet mut closings_stack_ptr = &mut\
    \ closings_stack[closings_stack_size]\n\t\n\tfor i in 0..chars.len() {\n\t\tif\
    \ chars[i] == '[' {\n\t\t\topenings_count += 1\n\t\t\topenings_stack.push(chars[i])\n\
    \t\t\topenings_stack_ptr = &mut openings_stack[openings_stack_size]\n\t\t} else\
    \ if chars[i] == ']' {\n\t\t\tclosings_count += 1\n\t\t\tclosings_stack.push(chars[i])\n\
    \t\t\tclosings_stack_ptr = &mut closings_stack[closings_stack_size]\n\t\t} else\
    \ if chars[i] == '{' {\n\t\t\topenings_stack.push(chars[i])\n\t\t\topenings_stack_ptr\
    \ = &mut openings_stack[openings_stack_size]\n\t\t} else if chars[i] == '}' {\n\
    \t\t\tclosings_stack.push(chars[i])\n\t\t\tclosings_stack_ptr = &mut closings_stack[closings_stack_size]\n\
    \t\t}\n\t}\n\t\n\tif openings_count > closings_count {\n\t\treturn false\n\t}\n\
    \t\n\twhile openings_count > 0 && closings_count > 0 {\n\t\tif openings_stack_ptr\
    \ == closings_stack_ptr {\n\t\t\topenings_stack_ptr = &mut openings_stack[openings_stack_size]\n\
    \t\t\tclosings_stack_ptr = &mut closings_stack[closings_stack_size]\n\t\t} else\
    \ {\n\t\t\topenings_stack_ptr = &mut openings_stack[openings_stack_size]\n\t\t\
    \tclosings_stack_ptr = &mut closings_stack[closings_stack_size]\n\t\t\topenings_stack_ptr\
    \ = &mut openings_stack[openings_stack_size]\n\t\t\tclosings_stack_ptr = &mut\
    \ closings_stack[closings_stack_size]\n\t\t}\n\t\t\n\t\tif openings_stack_ptr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqk1p7e88.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut chars\
    \ = string.characters\n                ^\n/tmp/tmpqk1p7e88.swift:19:10: note:\
    \ join the identifiers together\n        let mut chars = string.characters\n \
    \           ~~~~^~~~~\n            mutchars\n/tmp/tmpqk1p7e88.swift:19:10: note:\
    \ join the identifiers together with camel-case\n        let mut chars = string.characters\n\
    \            ~~~~^~~~~\n            mutChars\n/tmp/tmpqk1p7e88.swift:20:10: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut openings = Stack()\n                ^\n/tmp/tmpqk1p7e88.swift:20:10:\
    \ note: join the identifiers together\n        let mut openings = Stack()\n  \
    \          ~~~~^~~~~~~~\n            mutopenings\n/tmp/tmpqk1p7e88.swift:20:10:\
    \ note: join the identifiers together with camel-case\n        let mut openings\
    \ = Stack()\n            ~~~~^~~~~~~~\n            mutOpenings\n/tmp/tmpqk1p7e88.swift:21:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut closings = Stack()\n                ^\n\
    /tmp/tmpqk1p7e88.swift:21:10: note: join the identifiers together\n        let\
    \ mut closings = Stack()\n            ~~~~^~~~~~~~\n            mutclosings\n\
    /tmp/tmpqk1p7e88.swift:21:10: note: join the identifiers together with camel-case\n\
    \        let mut closings = Stack()\n            ~~~~^~~~~~~~\n            mutClosings\n\
    /tmp/tmpqk1p7e88.swift:22:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut openings_count\
    \ = 0\n                ^\n/tmp/tmpqk1p7e88.swift:22:10: note: join the identifiers\
    \ together\n        let mut openings_count = 0\n            ~~~~^~~~~~~~~~~~~~\n\
    \            mutopenings_count\n/tmp/tmpqk1p7e88.swift:22:10: note: join the identifiers\
    \ together with camel-case\n        let mut openings_count = 0\n            ~~~~^~~~~~~~~~~~~~\n\
    \            mutOpenings_count\n/tmp/tmpqk1p7e88.sw"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn openBrackets.location == closeBrackets.location\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpj0yknqb2.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpj0yknqb2.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.map { $0.value }\n\t\t.filter { $0 != '[' }\n\t\t\
    .filter { $0 != ']' }\n\t\t.map { $0 }\n\t\n\treturn brackets.count > 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbh7fv0kt.swift:21:19: error: single-quoted string literal found,\
    \ use '\"'\n                .filter { $0 != '[' }\n                          \
    \      ^~~\n                                \"[\"\n/tmp/tmpbh7fv0kt.swift:22:19:\
    \ error: single-quoted string literal found, use '\"'\n                .filter\
    \ { $0 != ']' }\n                                ^~~\n                       \
    \         \"]\"\n/tmp/tmpbh7fv0kt.swift:23:4: error: failed to produce diagnostic\
    \ for expression; please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n                .map { $0 }\n                 ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\tlet openingBracketCount = openingBrackets.count\n\tlet closingBracketCount\
    \ = closingBrackets.count\n\t\n\tif openingBracketCount == 0 || closingBracketCount\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openingBracket = openingBrackets.first!\n\
    \tlet closingBracket = closingBrackets.first!\n\t\n\tstack.push(openingBracket)\n\
    \t\n\twhile stack.count > 0 {\n\t\tlet currentBracket = stack.last!\n\t\t\n\t\t\
    if currentBracket.isOpen {\n\t\t\tstack.pop()\n\t\t} else {\n\t\t\tbreak\n\t\t\
    }\n\t}\n\t\n\treturn stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbdsrzvpk.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpbdsrzvpk.swift:19:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmpbdsrzvpk.swift:20:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openings = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closings\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openings_count = openings.characters.count\n\tlet\
    \ closings_count = closings.characters.count\n\treturn (openings_count == closings_count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphcygqjrt.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openingBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closingBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openingBracketsCount = openingBrackets.characters.count\n\
    \tlet closingBracketsCount = closingBrackets.characters.count\n\tlet bracketsCount\
    \ = brackets.characters.count\n\t\n\treturn (openingBracketsCount == closingBracketsCount)\
    \ && (openingBracketsCount > 0) && bracketsCount > 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjixtl5if.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn openBrackets != nil && closeBrackets\
    \ != nil && openBrackets.location != closeBrackets.location\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsuzorby8.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpsuzorby8.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketCount = brackets.characters.count\n\
    \tlet openBracketCount = brackets.replacingOccurrences(of: \"[\", with: \"\").characters.count\n\
    \tlet closeBracketCount = brackets.replacingOccurrences(of: \"]\", with: \"\"\
    ).characters.count\n\treturn bracketCount > 0 && openBracketCount > 0 && closeBracketCount\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjsjdc89p.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.map({ $0.value })\n\t\t.filter({ $0 == \"[\" || $0 == \"{\" || $0 ==\
    \ \"(\" || $0 == \"}\" || $0 == \"[\" })\n\t\n\treturn brackets.count > 0 && brackets.contains(where:\
    \ { $0 == \"[\" || $0 == \"{\" || $0 == \"(\" || $0 == \"}\" })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn8q0roqh.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpn8q0roqh.swift:23:9: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        return brackets.count\
    \ > 0 && brackets.contains(where: { $0 == \"[\" || $0 == \"{\" || $0 == \"(\"\
    \ || $0 == \"}\" })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013925
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \t\n\tguard brackets.count > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet lastIndex\
    \ = brackets.count - 1\n\t\n\tlet firstIndex = brackets.firstIndex({ $0.isBr })\n\
    \t\n\tguard firstIndex != lastIndex else {\n\t\treturn false\n\t}\n\t\n\tlet lastBracket\
    \ = brackets[lastIndex]\n\t\n\tlet firstBracket = brackets[firstIndex]\n\t\n\t\
    guard lastBracket.value == firstBracket.value else {\n\t\treturn false\n\t}\n\t\
    \n\tlet lastBracketIndex = brackets.index(lastBracket)\n\t\n\tlet firstBracketIndex\
    \ = brackets.index(firstBracket)\n\t\n\tlet lastBracketIndex = brackets.index(lastBracket,\
    \ offsetBy: -1)\n\t\n\tlet firstBracketIndex = brackets.index(firstBracket, offsetBy:\
    \ -1)\n\t\n\tlet firstBracketIndex = brackets.index(firstBracket, offsetBy: -1)\n\
    \t\n\tlet lastBracketIndex = brackets.index(lastBracket, offsetBy: -1)\n\t\n\t\
    let firstBracketIndex = brackets.index(firstBracket, offsetBy: -1)\n\t\n\tlet\
    \ lastBracketIndex = brackets.index(lastBracket, offsetBy: -1)\n\t\n\tlet firstBracketIndex\
    \ = brackets.index(firstBracket, offsetBy: -1)\n\t\n\tlet lastBracketIndex = brackets.index(lastBracket,\
    \ offsetBy: -1)\n\t\n\tlet firstBracketIndex = brackets.index(firstBracket, offsetBy:\
    \ -1)\n\t\n\tlet lastBracketIndex = brackets.index(lastBracket, offsetBy: -1)\n\
    \t\n\tlet firstBracketIndex = brackets.index(firstBracket, offsetBy: -1)\n\t\n\
    \tlet lastBracketIndex = brackets.index(lastBracket, offsetBy: -1)\n\t\n\tlet\
    \ firstBracketIndex = brackets.index(firstBracket, offsetBy: -1)\n\t\n\tlet lastBracketIndex\
    \ = brackets.index(lastBracket, offsetBy: -1)\n\t\n\tlet firstBracketIndex = brackets.index(firstBracket,\
    \ offsetBy: -1)\n\t\n\tlet lastBracketIndex = brackets.index(lastBracket, offsetBy:\
    \ -1)\n\t\n\tlet firstBracketIndex = brackets.index(firstBracket, offsetBy: -1)\n\
    \t\n\tlet lastBracketIndex = brackets.index(lastBracket, offsetBy: -1)\n\t\n\t\
    let firstBracketIndex = brackets.index(firstBra\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2gftzp7e.swift:81:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp2gftzp7e.swift:80:40: note: to match this opening '('\n        let\
    \ firstBracketIndex = brackets.index(firstBra\n                              \
    \                ^\n/tmp/tmp2gftzp7e.swift:18:51: error: value of type 'Unicode.Scalar'\
    \ has no member 'isBr'\n        let brackets = string.unicodeScalars.filter({\
    \ $0.isBr })\n                                                      ~~ ^~~~\n\
    /tmp/tmp2gftzp7e.swift:80:41: error: cannot find 'firstBra' in scope\n       \
    \ let firstBracketIndex = brackets.index(firstBra\n                          \
    \                     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\n\tlet openBrackets = brackets.filter({ $0 == \"\
    [\" })\n\tlet closeBrackets = brackets.filter({ $0 == \"]\" })\n\t\n\treturn openBrackets.count\
    \ >= closeBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5j4ytmu8.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n                .filter { $0.isBr }\n                    \
    \      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet openBrackets = Array<String>()\n\
    \tlet closeBrackets = Array<String>()\n\t\n\tlet openBracketsCount = Array<Int>()\n\
    \tlet closeBracketsCount = Array<Int>()\n\t\n\tlet openBracketsCountIndex = Array<Int>()\n\
    \tlet closeBracketsCountIndex = Array<Int>()\n\t\n\tlet openBracketsCountIndexCount\
    \ = Array<Int>()\n\tlet closeBracketsCountIndexCount = Array<Int>()\n\t\n\tlet\
    \ openBracketsCountIndexCountIndex = Array<Int>()\n\tlet closeBracketsCountIndexCountIndex\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountIndexCountIndexCount = Array<Int>()\n\
    \tlet closeBracketsCountIndexCountIndexCount = Array<Int>()\n\t\n\tlet openBracketsCountIndexCountIndexCountIndex\
    \ = Array<Int>()\n\tlet closeBracketsCountIndexCountIndexCountIndex = Array<Int>()\n\
    \t\n\tlet openBracketsCountIndexCountIndexCountIndexCount = Array<Int>()\n\tlet\
    \ closeBracketsCountIndexCountIndexCountIndexCount = Array<Int>()\n\t\n\tlet openBracketsCountIndexCountIndexCountIndexCountIndex\
    \ = Array<Int>()\n\tlet closeBracketsCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \t\n\tlet openBracketsCountIndexCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \tlet closeBracketsCountIndexCountIndexCountIndexCountIndex = Array<Int>()\n\t\
    \n\tlet openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex = Array<Int>()\n\
    \tlet closeBracketsCountIndexCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \t\n\tlet openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex = Array<Int>()\n\
    \tlet closeBracketsCountIndexCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \t\n\tlet openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n\tlet closeBracketsCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = Array<Int>()\n\t\n\tlet openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n\tlet closeBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3bc78_mr.swift:44:6: error: invalid redeclaration of 'closeBracketsCountIndexCountIndexCountIndexCount'\n\
    \        let closeBracketsCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \            ^\n/tmp/tmp3bc78_mr.swift:41:6: note: 'closeBracketsCountIndexCountIndexCountIndexCount'\
    \ previously declared here\n        let closeBracketsCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n            ^\n/tmp/tmp3bc78_mr.swift:52:6: error: invalid redeclaration\
    \ of 'openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex'\n      \
    \  let openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex = Array<Int>()\n\
    \            ^\n/tmp/tmp3bc78_mr.swift:49:6: note: 'openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex'\
    \ previously declared here\n        let openBracketsCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = Array<Int>()\n            ^\n/tmp/tmp3bc78_mr.swift:53:6: error: invalid redeclaration\
    \ of 'closeBracketsCountIndexCountIndexCountIndexCountIndexCount'\n        let\
    \ closeBracketsCountIndexCountIndexCountIndexCountIndexCount = Array<Int>()\n\
    \            ^\n/tmp/tmp3bc78_mr.swift:50:6: note: 'closeBracketsCountIndexCountIndexCountIndexCountIndexCount'\
    \ previously declared here\n        let closeBracketsCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n            ^\n/tmp/tmp3bc78_mr.swift:58:6: error: invalid redeclaration\
    \ of 'openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount'\n \
    \       let openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n            ^\n/tmp/tmp3bc78_mr.swift:55:6: note: 'openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount'\
    \ previously declared here\n        let openBracketsCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = Array<Int>()\n            ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \tlet openBrackets = brackets.replacingOccurrences(of: \"(\", with: \"\").replacingOccurrences(of:\
    \ \")\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\treturn bracketsCount\
    \ == openBracketsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcyku9a_w.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \t\n\treturn bracketsCount > 0 && bracketsCount % 2 == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_yu6e6zt.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openingBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closingBrackets = brackets.filter({\
    \ $0.isClosing })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1p2od4uc.swift:19:45: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n                                                ~~ ^~~~~~\n/tmp/tmp1p2od4uc.swift:20:45:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter({ $0.isClosing })\n                      \
    \                          ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closeBrackets = brackets.filter({ $0.isClosing\
    \ })\n\t\n\treturn openBrackets.count > closeBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuxbyd01u.swift:19:42: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = brackets.filter({ $0.isOpen })\n\
    \                                             ~~ ^~~~~~\n/tmp/tmpuxbyd01u.swift:20:43:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closeBrackets = brackets.filter({ $0.isClosing })\n                        \
    \                      ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\topeningBrackets.forEach { stack.push(true) }\n\tclosingBrackets.forEach\
    \ { stack.push(false) }\n\t\n\twhile stack.count > 0 {\n\t\tlet opening = stack.pop()\n\
    \t\tlet closing = stack.pop()\n\t\t\n\t\tif opening && closing {\n\t\t\treturn\
    \ false\n\t\t}\n\t\t\n\t\tif opening {\n\t\t\topening = false\n\t\t}\n\t\t\n\t\
    \tif closing {\n\t\t\tclosing = false\n\t\t}\n\t}\n\t\n\treturn true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpz3biohas.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpz3biohas.swift:19:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmpz3biohas.swift:20:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount < 2 {\n\t\treturn false\n\t}\n\t\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbr9hvkj7.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbr9hvkj7.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpbr9hvkj7.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpbr9hvkj7.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = [String]()\n\t\
    let closeBrackets = [String]()\n\tlet openBracketCount = 1\n\tlet closeBracketCount\
    \ = 1\n\t\n\tlet characters = string.characters\n\t\n\tfor character in characters\
    \ {\n\t\tif character == \"[\" {\n\t\t\topenBrackets.append(character)\n\t\t\t\
    openBracketCount += 1\n\t\t} else if character == \"]\" {\n\t\t\tcloseBrackets.append(character)\n\
    \t\t\tcloseBracketCount += 1\n\t\t}\n\t\t\n\t\tif openBracketCount == closeBracketCount\
    \ {\n\t\t\tstack.pop()\n\t\t\tif stack.count < 1 {\n\t\t\t\treturn false\n\t\t\
    \t}\n\t\t\topenBracketCount = 1\n\t\t\tcloseBracketCount = 1\n\t\t}\n\t}\n\t\n\
    \treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn2hqdvgi.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpn2hqdvgi.swift:24:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ characters = string.characters\n                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpn2hqdvgi.swift:28:17:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \          openBrackets.append(character)\n                                  \
    \   ^\n/tmp/tmpn2hqdvgi.swift:28:17: note: found candidate with type '(__owned\
    \ String) -> ()'\n                        openBrackets.append(character)\n   \
    \                                  ^\n/tmp/tmpn2hqdvgi.swift:29:21: error: left\
    \ side of mutating operator isn't mutable: 'openBracketCount' is a 'let' constant\n\
    \                        openBracketCount += 1\n                        ~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpn2hqdvgi.swift:21:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openBracketCount = 1\n        ^~~\n        var\n/tmp/tmpn2hqdvgi.swift:31:18:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \          closeBrackets.append(character)\n                                 \
    \     ^\n/tmp/tmpn2hqdvgi.swift:31:18: note: found candidate with type '(__owned\
    \ String) -> ()'\n                        closeBrackets.append(character)\n  \
    \                                    ^\n/tmp/tmpn2hqdvgi.swift:32:22: error: left\
    \ side of mutating operator isn't mutable: 'closeBracketCount' is a 'let' constant\n\
    \                        closeBracketCount += 1\n                        ~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpn2hqdvgi.swift:22:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closeBracketCount = 1\n        ^~~\n        var\n/tmp/tmpn2hqdvgi.swift:40:4:\
    \ error: cannot assign to value: 'openBracketCount' is a 'let' constant\n    \
    \                    openBracketCount = 1\n                        ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpn2"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\topeningBrackets.forEach { stack.push(it) }\n\tclosingBrackets.forEach\
    \ { stack.pop() }\n\t\n\treturn stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8ndbb5x6.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmp8ndbb5x6.swift:19:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmp8ndbb5x6.swift:20:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n/tmp/tmp8ndbb5x6.swift:22:39:\
    \ error: cannot find 'it' in scope\n        openingBrackets.forEach { stack.push(it)\
    \ }\n                                             ^~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBracket()\
    \ })\n\t\t.filter({ !$0.isWhitespace() })\n\t\t.filter({ !$0.isNewline() })\n\t\
    \n\treturn brackets.count > 0 && brackets.contains(where: { $0.isNesting() })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpchc1caai.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBracket'\n                .filter({ $0.isBracket() })\n       \
    \                   ~~ ^~~~~~~~~\n/tmp/tmpchc1caai.swift:20:17: error: value of\
    \ type 'Unicode.Scalar' has no member 'isWhitespace'\n                .filter({\
    \ !$0.isWhitespace() })\n                           ~~ ^~~~~~~~~~~~\n/tmp/tmpchc1caai.swift:21:17:\
    \ error: cannot call value of non-function type 'Bool'\n                .filter({\
    \ !$0.isNewline() })\n                              ^        ~~\n            \
    \                           \n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet open = Array<String>()\n\
    \tlet closed = Array<String>()\n\tlet openCount = Array<Int>()\n\tlet closedCount\
    \ = Array<Int>()\n\tlet openCounts = Array<Int>()\n\tlet closedCounts = Array<Int>()\n\
    \tlet openCountMax = Array<Int>()\n\tlet closedCountMax = Array<Int>()\n\tlet\
    \ openCountMaxs = Array<Int>()\n\tlet closedCountMaxs = Array<Int>()\n\tlet openCountMaxsNest\
    \ = Array<Int>()\n\tlet closedCountMaxsNest = Array<Int>()\n\tlet openCountMaxsNests\
    \ = Array<Int>()\n\tlet closedCountMaxsNests = Array<Int>()\n\tlet openCountMaxsNestsNest\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNest = Array<Int>()\n\tlet openCountMaxsNestsNests\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNests = Array<Int>()\n\tlet openCountMaxsNestsNestsNest\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNestsNest = Array<Int>()\n\tlet openCountMaxsNestsNestsNests\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNestsNests = Array<Int>()\n\tlet openCountMaxsNestsNestsNestsNest\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNestsNestsNest = Array<Int>()\n\t\
    let openCountMaxsNestsNestsNestsNests = Array<Int>()\n\tlet closedCountMaxsNestsNestsNestsNests\
    \ = Array<Int>()\n\tlet openCountMaxsNestsNestsNestsNestsNest = Array<Int>()\n\
    \tlet closedCountMaxsNestsNestsNestsNestsNest = Array<Int>()\n\tlet openCountMaxsNestsNestsNestsNestsNests\
    \ = Array<Int>()\n\tlet closedCountMaxsNestsNestsNestsNestsNests = Array<Int>()\n\
    \tlet openCountMaxsNestsNestsNe\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy7vzopdj.swift:49:6: error: type annotation missing in pattern\n\
    \        let openCountMaxsNestsNestsNe\n            ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBracketsCount = closeBrackets.characters.count\n\tlet bracketsCount\
    \ = brackets.characters.count\n\treturn openBracketsCount == closeBracketsCount\
    \ && openBracketsCount > 0 && closeBracketsCount > 0 && bracketsCount > 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_7k5y7gm.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Array<String>()\n\tlet openingBrackets = Array<String>()\n\
    \tlet closingBrackets = Array<String>()\n\t\n\tlet openingBracketsCount = 1\n\t\
    let closingBracketsCount = 1\n\t\n\tlet openingBracketsIndex = 0\n\tlet closingBracketsIndex\
    \ = 0\n\t\n\tlet openingBracketsCountIndex = 0\n\tlet closingBracketsCountIndex\
    \ = 0\n\t\n\tlet openingBracketsIndex2 = 0\n\tlet closingBracketsIndex2 = 0\n\t\
    \n\tlet openingBracketsCountIndex2 = 0\n\tlet closingBracketsCountIndex2 = 0\n\
    \t\n\tlet openingBracketsIndex3 = 0\n\tlet closingBracketsIndex3 = 0\n\t\n\tlet\
    \ openingBracketsCountIndex3 = 0\n\tlet closingBracketsCountIndex3 = 0\n\t\n\t\
    let openingBracketsIndex4 = 0\n\tlet closingBracketsIndex4 = 0\n\t\n\tlet openingBracketsCountIndex4\
    \ = 0\n\tlet closingBracketsCountIndex4 = 0\n\t\n\tlet openingBracketsIndex5 =\
    \ 0\n\tlet closingBracketsIndex5 = 0\n\t\n\tlet openingBracketsCountIndex5 = 0\n\
    \tlet closingBracketsCountIndex5 = 0\n\t\n\tlet openingBracketsIndex6 = 0\n\t\
    let closingBracketsIndex6 = 0\n\t\n\tlet openingBracketsCountIndex6 = 0\n\tlet\
    \ closingBracketsCountIndex6 = 0\n\t\n\tlet openingBracketsIndex7 = 0\n\tlet closingBracketsIndex7\
    \ = 0\n\t\n\tlet openingBracketsCountIndex7 = 0\n\tlet closingBracketsCountIndex7\
    \ = 0\n\t\n\tlet openingBracketsIndex8 = 0\n\tlet closingBracketsIndex8 = 0\n\t\
    \n\tlet openingBracketsCountIndex8 = 0\n\tlet closingBracketsCountIndex8 = 0\n\
    \t\n\tlet openingBracketsIndex9 = 0\n\tlet closingBracketsIndex9 = 0\n\t\n\tlet\
    \ openingBracketsCountIndex9 = 0\n\tlet closingBracketsCountIndex9 = 0\n\t\n\t\
    let openingBracketsIndex10 = 0\n\tlet closingBracketsIndex10 = 0\n\t\n\tlet openingBracket\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpm5azu2c7.swift:82:6: error: type annotation missing in pattern\n\
    \        let openingBracket\n            ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketCount = brackets.characters.count\n\
    \tlet openBracketCount = brackets.replacingOccurrences(of: \"[\", with: \"\").characters.count\n\
    \tlet closeBracketCount = brackets.replacingOccurrences(of: \"]\", with: \"\"\
    ).characters.count\n\t\n\treturn bracketCount > openBracketCount && bracketCount\
    \ > closeBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn5p3pl5o.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closeBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\t\
    \n\tlet openBracketCount = openBrackets.count\n\tlet closeBracketCount = closeBrackets.count\n\
    \t\n\treturn openBracketCount == closeBracketCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp86kojz38.swift:18:55: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                          ~~ ^~~~~~\n\
    /tmp/tmp86kojz38.swift:19:56: error: value of type 'Unicode.Scalar' has no member\
    \ 'isClosing'\n        let closeBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n                                                           ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet open = string[string.startIndex]\n\tlet close = string[string.endIndex]\n\
    \t\n\tlet openCount = string.characters.filter({ $0 == open }).count\n\tlet closeCount\
    \ = string.characters.filter({ $0 == close }).count\n\t\n\treturn openCount ==\
    \ closeCount && openCount > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvqyek0_g.swift:21:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        let openCount = string.characters.filter({ $0 ==\
    \ open }).count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvqyek0_g.swift:22:26: error: 'characters'\
    \ is unavailable: Please use String directly\n        let closeCount = string.characters.filter({\
    \ $0 == close }).count\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\n\tlet openBrackets = brackets.filter({ $0 == \"\
    [\" })\n\tlet closeBrackets = brackets.filter({ $0 == \"]\" })\n\t\n\treturn openBrackets.count\
    \ > 0 && closeBrackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkmkhexts.swift:19:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n                .filter { $0.isBr }\n                    \
    \      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0.isBr })\n\
    \tlet openingBrackets = brackets.filter({ $0.isBr && $0.value == 1 })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.isBr && $0.value == -1 })\n\t\n\treturn openingBrackets.count\
    \ > 0 && closingBrackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5z2wifjj.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0 != bracketOpenCharacter\
    \ && $0 != bracketCloseCharacter })\n\t\n\tlet openBrackets = brackets.filter({\
    \ $0 == bracketOpenCharacter })\n\tlet closeBrackets = brackets.filter({ $0 ==\
    \ bracketCloseCharacter })\n\t\n\treturn openBrackets.count > 0 && closeBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdm0pd_gn.swift:18:54: error: cannot find 'bracketOpenCharacter'\
    \ in scope\n        let brackets = string.unicodeScalars.filter({ $0 != bracketOpenCharacter\
    \ && $0 != bracketCloseCharacter })\n                                        \
    \                    ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdm0pd_gn.swift:18:84: error:\
    \ cannot find 'bracketCloseCharacter' in scope\n        let brackets = string.unicodeScalars.filter({\
    \ $0 != bracketOpenCharacter && $0 != bracketCloseCharacter })\n             \
    \                                                                            \
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdm0pd_gn.swift:20:45: error: cannot find 'bracketOpenCharacter'\
    \ in scope\n        let openBrackets = brackets.filter({ $0 == bracketOpenCharacter\
    \ })\n                                                   ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdm0pd_gn.swift:21:46: error: cannot find 'bracketCloseCharacter' in scope\n\
    \        let closeBrackets = brackets.filter({ $0 == bracketCloseCharacter })\n\
    \                                                    ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \tlet openingBracketsCount = brackets.replacingOccurrences(of: \"[\", with: \"\
    \").characters.count\n\tlet closingBracketsCount = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\").characters.count\n\t\n\treturn bracketsCount > 0 && openingBracketsCount\
    \ > 0 && closingBracketsCount > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmin3av81.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter { $0.isBr }\n\
    \tlet opens = brackets.map { $0.value }\n\tlet closes = brackets.map { $0.value\
    \ }\n\tlet openCount = opens.count\n\tlet closeCount = closes.count\n\t\n\treturn\
    \ openCount == closeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7pfmc8cu.swift:18:51: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n        let brackets = string.unicodeScalars.filter { $0.isBr\
    \ }\n                                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.map { $0 }\n\t\t.map { String($0) }\n\t\t.filter {\
    \ $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first }\n\t\t.map { String($0)\
    \ }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first }\n\
    \t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($0) }\n\t\t.filter { $0.count > 0 }\n\t\t.map { $0.first!.unicodeScalars.first\
    \ }\n\t\t.map { String($\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjtdrec6w.swift:66:17: error: '$' is not an identifier; use backticks\
    \ to escape it\n                .map { String($\n                            \
    \  ^\n                              `$`\n/tmp/tmpjtdrec6w.swift:67:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpjtdrec6w.swift:66:16: note: to match this\
    \ opening '('\n                .map { String($\n                             ^\n\
    /tmp/tmpjtdrec6w.swift:95:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmpjtdrec6w.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmpjtdrec6w.swift:66:17: error: cannot find '$' in scope\n\
    \                .map { String($\n                              ^\n/tmp/tmpjtdrec6w.swift:70:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openingBrackets\
    \ = brackets.filter{ $0.isOpen }\n\tlet closingBrackets = brackets.filter{ $0.isClosing\
    \ }\n\tlet openingBracketCount = openingBrackets.count\n\tlet closingBracketCount\
    \ = closingBrackets.count\n\t\n\treturn openingBracketCount == closingBracketCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwg__uqx7.swift:19:44: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter{ $0.isOpen\
    \ }\n                                               ~~ ^~~~~~\n/tmp/tmpwg__uqx7.swift:20:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter{ $0.isClosing }\n                        \
    \                       ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.characters.count\n\
    \tlet openBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \treturn bracketsCount == openBracketsCount && bracketsCount > 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3sfxbavg.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openingBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closingBrackets = brackets.filter({\
    \ $0.isClosing })\n\t\n\treturn openingBrackets.count > 0 && closingBrackets.count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1p2od4uc.swift:19:45: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n                                                ~~ ^~~~~~\n/tmp/tmp1p2od4uc.swift:20:45:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter({ $0.isClosing })\n                      \
    \                          ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets = Stack()\n\tlet\
    \ closeBrackets = Stack()\n\tlet openBracketsCount = Stack()\n\tlet closeBracketsCount\
    \ = Stack()\n\tlet openBracketsCount2 = Stack()\n\tlet closeBracketsCount2 = Stack()\n\
    \tlet openBracketsCount3 = Stack()\n\tlet closeBracketsCount3 = Stack()\n\tlet\
    \ openBracketsCount4 = Stack()\n\tlet closeBracketsCount4 = Stack()\n\tlet openBracketsCount5\
    \ = Stack()\n\tlet closeBracketsCount5 = Stack()\n\tlet openBracketsCount6 = Stack()\n\
    \tlet closeBracketsCount6 = Stack()\n\tlet openBracketsCount7 = Stack()\n\tlet\
    \ closeBracketsCount7 = Stack()\n\tlet openBracketsCount8 = Stack()\n\tlet closeBracketsCount8\
    \ = Stack()\n\tlet openBracketsCount9 = Stack()\n\tlet closeBracketsCount9 = Stack()\n\
    \tlet openBracketsCount10 = Stack()\n\tlet closeBracketsCount10 = Stack()\n\t\
    let openBracketsCount11 = Stack()\n\tlet closeBracketsCount11 = Stack()\n\tlet\
    \ openBracketsCount12 = Stack()\n\tlet closeBracketsCount12 = Stack()\n\tlet openBracketsCount13\
    \ = Stack()\n\tlet closeBracketsCount13 = Stack()\n\tlet openBracketsCount14 =\
    \ Stack()\n\tlet closeBracketsCount14 = Stack()\n\tlet openBracketsCount15 = Stack()\n\
    \tlet closeBracketsCount15 = Stack()\n\tlet openBracketsCount16 = Stack()\n\t\
    let closeBracketsCount16 = Stack()\n\tlet openBracketsCount17 = Stack()\n\tlet\
    \ closeBracketsCount17 = Stack()\n\tlet openBracketsCount18 = Stack()\n\tlet closeBracketsCount18\
    \ = Stack()\n\tlet openBracketsCount19 = Stack()\n\tlet closeBracketsCount19 =\
    \ Stack()\n\tlet openBracketsCount20 = Stack()\n\tlet closeBracketsCount20 = Stack()\n\
    \tlet openBracketsCount21 = Stack()\n\tlet closeBracketsCount21 = Stack()\n\t\
    let openBracketsCount22 = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpypr_tvf6.swift:63:27: error: expected initial value after '='\n\
    \        let openBracketsCount22 = \n                                 ^\n/tmp/tmpypr_tvf6.swift:18:14:\
    \ error: cannot find 'Stack' in scope\n        let stack = Stack()\n         \
    \           ^~~~~\n/tmp/tmpypr_tvf6.swift:19:21: error: cannot find 'Stack' in\
    \ scope\n        let openBrackets = Stack()\n                           ^~~~~\n\
    /tmp/tmpypr_tvf6.swift:20:22: error: cannot find 'Stack' in scope\n        let\
    \ closeBrackets = Stack()\n                            ^~~~~\n/tmp/tmpypr_tvf6.swift:21:26:\
    \ error: cannot find 'Stack' in scope\n        let openBracketsCount = Stack()\n\
    \                                ^~~~~\n/tmp/tmpypr_tvf6.swift:22:27: error: cannot\
    \ find 'Stack' in scope\n        let closeBracketsCount = Stack()\n          \
    \                       ^~~~~\n/tmp/tmpypr_tvf6.swift:23:27: error: cannot find\
    \ 'Stack' in scope\n        let openBracketsCount2 = Stack()\n               \
    \                  ^~~~~\n/tmp/tmpypr_tvf6.swift:24:28: error: cannot find 'Stack'\
    \ in scope\n        let closeBracketsCount2 = Stack()\n                      \
    \            ^~~~~\n/tmp/tmpypr_tvf6.swift:25:27: error: cannot find 'Stack' in\
    \ scope\n        let openBracketsCount3 = Stack()\n                          \
    \       ^~~~~\n/tmp/tmpypr_tvf6.swift:26:28: error: cannot find 'Stack' in scope\n\
    \        let closeBracketsCount3 = Stack()\n                                 \
    \ ^~~~~\n/tmp/tmpypr_tvf6.swift:27:27: error: cannot find 'Stack' in scope\n \
    \       let openBracketsCount4 = Stack()\n                                 ^~~~~\n\
    /tmp/tmpypr_tvf6.swift:28:28: error: cannot find 'Stack' in scope\n        let\
    \ closeBracketsCount4 = Stack()\n                                  ^~~~~\n/tmp/tmpypr_tvf6.swift:29:27:\
    \ error: cannot find 'Stack' in scope\n        let openBracketsCount5 = Stack()\n\
    \                                 ^~~~~\n/tmp/tmpypr_tvf6.swift:30:28: error:\
    \ cannot find 'Stack' in scope\n        let closeBracketsCount5 = Stack()\n  \
    \                                ^~~~~\n/tmp/tmpypr_tvf6.swift:31:27: error: cannot\
    \ find 'St"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\treturn (openingBrackets\
    \ != nil) && (closingBrackets != nil) && (openingBrackets.location != closingBrackets.location)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv031n5g9.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpv031n5g9.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\tlet openBrackets\
    \ = brackets.filter({ $0.isOpen })\n\tlet closeBrackets = brackets.filter({ $0.isClosing\
    \ })\n\t\n\treturn openBrackets.count > 0 && closeBrackets.count > 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2madocfa.swift:19:42: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openBrackets = brackets.filter({ $0.isOpen })\n\
    \                                             ~~ ^~~~~~\n/tmp/tmp2madocfa.swift:20:43:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closeBrackets = brackets.filter({ $0.isClosing })\n                        \
    \                      ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu7px4qg4.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpu7px4qg4.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet openingBrackets = [\
    \ \"[\", \"{\", \"(\", \"<\", \">\" ]\n\tlet closingBrackets = [ \"]\", \"}\"\
    , \")\", \">\" ]\n\tlet openingBracketsCount = openingBrackets.count\n\tlet closingBracketsCount\
    \ = closingBrackets.count\n\tlet openingBracketsIndex = openingBrackets.startIndex\n\
    \tlet closingBracketsIndex = closingBrackets.startIndex\n\tlet stringIndex = string.startIndex\n\
    \t\n\twhile stringIndex < string.endIndex {\n\t\tlet character = string[stringIndex]\n\
    \t\t\n\t\tif character == \"[\" {\n\t\t\tstack.push(character)\n\t\t} else if\
    \ character == \"]\" {\n\t\t\tif stack.count < openingBracketsCount {\n\t\t\t\t\
    return false\n\t\t\t}\n\t\t\t\n\t\t\tlet openingBracket = stack.pop()\n\t\t\t\n\
    \t\t\tif openingBracket != \"]\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else\
    \ if character == \"{\" {\n\t\t\tif stack.count < openingBracketsCount {\n\t\t\
    \t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\tlet openingBracket = stack.pop()\n\t\t\
    \t\n\t\t\tif openingBracket != \"}\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else\
    \ if character == \"(\" {\n\t\t\tif stack.count < openingBracketsCount {\n\t\t\
    \t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\tlet openingBracket = stack.pop()\n\t\t\
    \t\n\t\t\tif openingBracket != \")\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else\
    \ if character == \"<\" {\n\t\t\tif stack.count < openingBracketsCount {\n\t\t\
    \t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\tlet openingBracket = stack.pop()\n\t\t\
    \t\n\t\t\tif openingBracket != \">\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else\
    \ if character == \">\" {\n\t\t\tif stack.count < openingBracketsCount {\n\t\t\
    \t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\tlet openingBracket = stack.pop()\n\t\t\
    \t\n\t\t\tif openingBracket != \">\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\
    \t\t\n\t\tstringIndex += 1\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsrc5et5z.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack<String>()\n                    ^~~~~\n/tmp/tmpsrc5et5z.swift:84:3:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n                stringIndex += 1\n                ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.filter { $0.isBidi }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isBidi\
    \ }\n\t\t.filter { $0.isASCII }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpikkh3l_w.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex - openingBrackets?.startIndex\n\tlet closingBracketsCount\
    \ = closingBrackets?.endIndex - closingBrackets?.startIndex\n\t\n\tif openingBracketsCount\
    \ > closingBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBracketsCount - 1\n\tlet closingBracketsCount = closingBracketsCount\
    \ - 1\n\t\n\tlet openingBracketsIndex = string.startIndex\n\tlet closingBracketsIndex\
    \ = string.startIndex\n\t\n\twhile openingBracketsIndex < string.endIndex && closingBracketsIndex\
    \ < string.endIndex {\n\t\tlet openingBracket = string[openingBracketsIndex].unicodeScalars.first!\n\
    \t\tlet closingBracket = string[closingBracketsIndex].unicodeScalars.first!\n\t\
    \t\n\t\tif openingBracket == closingBracket {\n\t\t\topeningBracketsIndex = openingBracketsIndex\
    \ + 1\n\t\t\tclosingBracketsIndex = closingBracketsIndex + 1\n\t\t} else {\n\t\
    \t\treturn false\n\t\t}\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpinx74hbb.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpinx74hbb.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpinx74hbb.swift:25:55: error: binary operator '-' cannot be applied to\
    \ two 'Duration?' operands\n        let openingBracketsCount = openingBrackets?.endIndex\
    \ - openingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpinx74hbb.swift:25:55: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (Float, Float), (Float16, Float16), (Float80, Float80),\
    \ (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant,\
    \ Duration), (SuspendingClock.Instant, SuspendingClock.Instant), (UInt, UInt),\
    \ (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n     \
    \   let openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \                                                             ^\n/tmp/tmpinx74hbb.swift:26:55:\
    \ error: binary operator '-' cannot be applied to two 'Duration?' operands\n \
    \       let closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpinx74hbb.swift:26:55: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant, "
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut chars = string.characters\n\
    \tlet mut nesting = false\n\tlet mut open_brackets = 0\n\tlet mut close_brackets\
    \ = 0\n\twhile chars.next() != nil {\n\t\tswitch chars.next() {\n\t\tcase '[':\n\
    \t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\t\tcase '[':\n\t\t\t\
    close_brackets += 1\n\t\t\tif open_brackets > close_brackets {\n\t\t\t\tnesting\
    \ = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\
    \t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\tif open_brackets > close_brackets\
    \ {\n\t\t\t\tnesting = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\
    \t\t\tstack.push(chars.next())\n\t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\
    \tif open_brackets > close_brackets {\n\t\t\t\tnesting = true\n\t\t\t}\n\t\tcase\
    \ '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\t\tcase '[':\n\
    \t\t\tclose_brackets += 1\n\t\t\tif open_brackets > close_brackets {\n\t\t\t\t\
    nesting = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\
    \t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\tif open_brackets > close_brackets\
    \ {\n\t\t\t\tnesting = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\
    \t\t\tstack.push(chars.next())\n\t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\
    \tif open_brackets > close_brackets {\n\t\t\t\tnesting = true\n\t\t\t}\n\t\tcase\
    \ '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\t\tcase '[':\n\
    \t\t\tclose_brackets += 1\n\t\t\tif open_brackets > close_brackets {\n\t\t\t\t\
    nesting = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(chars.next())\n\
    \t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\tif open_brackets > close_brackets\
    \ {\n\t\t\t\tnesting = true\n\t\t\t}\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\
    \t\t\tstack.push(chars.next())\n\t\tcase '[':\n\t\t\tclose_brackets += 1\n\t\t\
    \tif open_brackets > close_brackets {\n\t\t\t\t\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmptrsv_v5b.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut chars\
    \ = string.characters\n                ^\n/tmp/tmptrsv_v5b.swift:19:10: note:\
    \ join the identifiers together\n        let mut chars = string.characters\n \
    \           ~~~~^~~~~\n            mutchars\n/tmp/tmptrsv_v5b.swift:19:10: note:\
    \ join the identifiers together with camel-case\n        let mut chars = string.characters\n\
    \            ~~~~^~~~~\n            mutChars\n/tmp/tmptrsv_v5b.swift:20:10: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut nesting = false\n                ^\n/tmp/tmptrsv_v5b.swift:20:10:\
    \ note: join the identifiers together\n        let mut nesting = false\n     \
    \       ~~~~^~~~~~~\n            mutnesting\n/tmp/tmptrsv_v5b.swift:20:10: note:\
    \ join the identifiers together with camel-case\n        let mut nesting = false\n\
    \            ~~~~^~~~~~~\n            mutNesting\n/tmp/tmptrsv_v5b.swift:21:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets = 0\n                ^\n\
    /tmp/tmptrsv_v5b.swift:21:10: note: join the identifiers together\n        let\
    \ mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n            mutopen_brackets\n\
    /tmp/tmptrsv_v5b.swift:21:10: note: join the identifiers together with camel-case\n\
    \        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n          \
    \  mutOpen_brackets\n/tmp/tmptrsv_v5b.swift:22:10: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \       let mut close_brackets = 0\n                ^\n/tmp/tmptrsv_v5b.swift:22:10:\
    \ note: join the identifiers together\n        let mut close_brackets = 0\n  \
    \          ~~~~^~~~~~~~~~~~~~\n            mutclose_brackets\n/tmp/tmptrsv_v5b.swift:22:10:\
    \ note: join the identifiers together with camel-case\n        let mut close_brackets\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~\n            mutClose_brackets\n/tmp/tmptrsv_v5"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\treturn (openingBrackets\
    \ != nil && closingBrackets != nil && openingBrackets.location != closingBrackets.location)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4yb3ti_7.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4yb3ti_7.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = stack.count\n\
    \tlet closingBracketsCount = stack.count\n\t\n\tfor char in string {\n\t\tif char\
    \ == '[' {\n\t\t\topeningBrackets.insert(char)\n\t\t\tstack.push(char)\n\t\t}\
    \ else if char == ']' {\n\t\t\tclosingBrackets.insert(char)\n\t\t\tstack.push(char)\n\
    \t\t} else if char == '[' && stack.count > openingBracketsCount {\n\t\t\topeningBracketsCount\
    \ -= 1\n\t\t} else if char == ']' && stack.count > closingBracketsCount {\n\t\t\
    \tclosingBracketsCount -= 1\n\t\t}\n\t}\n\t\n\treturn openingBrackets.isSubset(of:\
    \ closingBrackets)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxvsirqpj.swift:25:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '[' {\n                           ^~~\n\
    \                           \"[\"\n/tmp/tmpxvsirqpj.swift:28:21: error: single-quoted\
    \ string literal found, use '\"'\n                } else if char == ']' {\n  \
    \                                ^~~\n                                  \"]\"\n\
    /tmp/tmpxvsirqpj.swift:31:21: error: single-quoted string literal found, use '\"\
    '\n                } else if char == '[' && stack.count > openingBracketsCount\
    \ {\n                                  ^~~\n                                 \
    \ \"[\"\n/tmp/tmpxvsirqpj.swift:33:21: error: single-quoted string literal found,\
    \ use '\"'\n                } else if char == ']' && stack.count > closingBracketsCount\
    \ {\n                                  ^~~\n                                 \
    \ \"]\"\n/tmp/tmpxvsirqpj.swift:18:14: error: cannot find 'Stack' in scope\n \
    \       let stack = Stack()\n                    ^~~~~\n/tmp/tmpxvsirqpj.swift:26:20:\
    \ error: cannot use mutating member on immutable value: 'openingBrackets' is a\
    \ 'let' constant\n                        openingBrackets.insert(char)\n     \
    \                   ~~~~~~~~~~~~~~~ ^\n/tmp/tmpxvsirqpj.swift:19:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp/tmpxvsirqpj.swift:29:20: error: cannot use mutating\
    \ member on immutable value: 'closingBrackets' is a 'let' constant\n         \
    \               closingBrackets.insert(char)\n                        ~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpxvsirqpj.swift:20:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closingBrackets = Set<Character>()\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isNumber })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1vnyy_hv.swift:69:13: error: '$' is not an identifier; use backticks\
    \ to escape it\n                .filter({ $\n                          ^\n   \
    \                       `$`\n/tmp/tmp1vnyy_hv.swift:73:1: error: expected ')'\
    \ in expression list\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n^\n/tmp/tmp1vnyy_hv.swift:69:10: note: to match this opening '('\n      \
    \          .filter({ $\n                       ^\n/tmp/tmp1vnyy_hv.swift:98:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmp1vnyy_hv.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmp1vnyy_hv.swift:69:13: error:\
    \ cannot find '$' in scope\n                .filter({ $\n                    \
    \      ^\n/tmp/tmp1vnyy_hv.swift:73:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBracketsCount = closeBrackets.characters.count\n\t\n\treturn openBracketsCount\
    \ == closeBracketsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6oh9m26w.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string\n\t\t.unicodeScalars\n\t\t\
    .filter({ $0.isOpen })\n\t\t.count\n\tlet closingBrackets = string\n\t\t.unicodeScalars\n\
    \t\t.filter({ $0.isClosing })\n\t\t.count\n\treturn openingBrackets == closingBrackets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpetgnbxk7.swift:20:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n                .filter({ $0.isOpen })\n               \
    \           ~~ ^~~~~~\n/tmp/tmpetgnbxk7.swift:24:16: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n                .filter({ $0.isClosing })\n     \
    \                     ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.filter { $0.isLetter }\n\t\t.filter { $0.isASCII }\n\t\t.filter { $0.isASCII\
    \ }\n\t\t.map { String($0) }\n\t\t.reduce(into: [String](), { $0.append($1.first!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.last!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.first!) })\n\t\t.reduce(into: [String](), { $0.append($1.last!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.first!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.last!) })\n\t\t.reduce(into: [String](), { $0.append($1.first!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.last!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.first!) })\n\t\t.reduce(into: [String](), { $0.append($1.last!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.first!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.last!) })\n\t\t.reduce(into: [String](), { $0.append($1.first!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.last!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.first!) })\n\t\t.reduce(into: [String](), { $0.append($1.last!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.first!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.last!) })\n\t\t.reduce(into: [String](), { $0.append($1.first!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.last!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.first!) })\n\t\t.reduce(into: [String](), { $0.append($1.last!)\
    \ })\n\t\t.reduce(into: [String](), { $0.append($1.first!) })\n\t\t.reduce(into:\
    \ [String](), { $0.append($1.last!) })\n\t\t.reduce(into: [String](), { $0.append($1.first!)\
    \ })\n\t\t.reduce(into: [String]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0knsgk6l.swift:50:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp0knsgk6l.swift:49:10: note: to match this opening '('\n           \
    \     .reduce(into: [String]\n                       ^\n/tmp/tmp0knsgk6l.swift:18:17:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        let brackets\
    \ = string.unicodeScalars\n                       ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013793
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0\
    \ >= 0x5B && $0 <= 0x5D })\n\t\t.filter({ $0 >= 0x7B && $0 <= 0x7D })\n\treturn\
    \ brackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplh955v8p.swift:19:16: error: referencing operator function '>='\
    \ on 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \                .filter({ $0 >= 0x5B && $0 <= 0x5D })\n                     \
    \        ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'Unicode.Scalar'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmplh955v8p.swift:19:30: error: referencing\
    \ operator function '<=' on 'BinaryInteger' requires that 'Unicode.Scalar' conform\
    \ to 'BinaryInteger'\n                .filter({ $0 >= 0x5B && $0 <= 0x5D })\n\
    \                                           ^\nSwift.BinaryInteger:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n          ^\n/tmp/tmplh955v8p.swift:20:16:\
    \ error: referencing operator function '>=' on 'BinaryInteger' requires that 'Unicode.Scalar'\
    \ conform to 'BinaryInteger'\n                .filter({ $0 >= 0x7B && $0 <= 0x7D\
    \ })\n                             ^\nSwift.BinaryInteger:1:11: note: where 'Self'\
    \ = 'Unicode.Scalar'\nextension BinaryInteger {\n          ^\n/tmp/tmplh955v8p.swift:20:30:\
    \ error: referencing operator function '<=' on 'BinaryInteger' requires that 'Unicode.Scalar'\
    \ conform to 'BinaryInteger'\n                .filter({ $0 >= 0x7B && $0 <= 0x7D\
    \ })\n                                           ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.map { $0 }\n\t\t.map { String($0) }\n\t\t.filter {\
    \ $0.isNotEmpty }\n\t\t.map { $0.unicodeScalars.filter { $0 != brackets.first\
    \ } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter { $0.count > 1 }\n\t\t\
    .map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter { $0\
    \ != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter { $0.count\
    \ > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.count > 1 }\n\t\t.map { $0.joined(separator: \"\") }\n\t\t.map { $0.unicodeScalars.filter\
    \ { $0 != brackets.first } }\n\t\t.map { $0.map { String($0) } }\n\t\t.filter\
    \ { $0.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3w9dem_y.swift:57:15: error: expected member name following '.'\n\
    \                .filter { $0.\n                            ^\n/tmp/tmp3w9dem_y.swift:86:47:\
    \ error: expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmp3w9dem_y.swift:17:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmp3w9dem_y.swift:61:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\treturn (openingBrackets.location\
    \ != NSNotFound) && (closingBrackets.location != NSNotFound)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxb6xtann.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxb6xtann.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpxb6xtann.swift:21:38: error: cannot find 'NSNotFound' in scope\n     \
    \   return (openingBrackets.location != NSNotFound) && (closingBrackets.location\
    \ != NSNotFound)\n                                            ^~~~~~~~~~\n/tmp/tmpxb6xtann.swift:21:82:\
    \ error: cannot find 'NSNotFound' in scope\n        return (openingBrackets.location\
    \ != NSNotFound) && (closingBrackets.location != NSNotFound)\n               \
    \                                                                         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketsCount = brackets.count\n\
    \tlet openingBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n\tlet closingBrackets = brackets.replacingOccurrences(of:\
    \ \"]\", with: \"\").replacingOccurrences(of: \"[\", with: \"\")\n\tlet openingBracketsCount\
    \ = openingBrackets.count\n\tlet closingBracketsCount = closingBrackets.count\n\
    \t\n\treturn bracketsCount == openingBracketsCount && bracketsCount == closingBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkgarfcdj.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing })\n\
    \t\n\tguard openingBrackets.count >= 1 && closingBrackets.count >= 1 else {\n\t\
    \treturn false\n\t}\n\t\n\tlet openingBracket = openingBrackets.first!\n\tlet\
    \ closingBracket = closingBrackets.first!\n\t\n\tguard openingBracket.value ==\
    \ closingBracket.value && openingBracket.value == openingBracket.value else {\n\
    \t\treturn false\n\t}\n\t\n\tlet openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \tlet closingBracketIndex = string.unicodeScalars.index(closingBracket)\n\t\n\t\
    let openingBracketsCount = openingBrackets.count\n\tlet closingBracketsCount =\
    \ closingBrackets.count\n\t\n\tguard openingBracketIndex < closingBracketIndex\
    \ else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\tguard openingBracketsCount\
    \ > 0 && closingBracketsCount > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets.count\n\tlet closingBracketsCount = closingBrackets.count\n\
    \t\n\tguard openingBracketsCount != closingBracketsCount else {\n\t\treturn false\n\
    \t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\tlet closingBracketsCount\
    \ = closingBrackets.count\n\t\n\tguard openingBracketsCount > 0 && closingBracketsCount\
    \ > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\tguard openingBracketsCount\
    \ != closingBracketsCount else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets.count\n\tlet closingBracketsCount = closingBrackets.count\n\
    \t\n\tguard openingBracketsCount > 0 && closingBracketsCount > 0 else {\n\t\t\
    return false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmppp32x1yh.swift:18:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmppp32x1yh.swift:19:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n/tmp/tmppp32x1yh.swift:32:50: error: no exact matches in call\
    \ to instance method 'index'\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmppp32x1yh.swift:32:50:\
    \ note: found candidate with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmppp32x1yh.swift:32:50:\
    \ note: found candidate with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let openingBracketIndex = string.unicodeScalars.index(openingBracket)\n\
    \                                                        ^\n/tmp/tmppp32x1yh.swift:32:50:\
    \ note: found candidate with type '(Unicode.Scalar) -> String.UnicodeScalarView.Index?'\
    \ (aka '(Unicode.Scalar) -> Optional<String.Index>')\n        let openingBracketIndex\
    \ = string.unicodeScalars.index(openingBracket)\n                            \
    \                            ^\n/tmp/tmppp32x1yh.swift:33:50: error: no exact\
    \ matches in call to instance method 'index'\n        let closingBracketIndex\
    \ = string.unicodeScalars.index(closingBracket)\n                            \
    \                            ^\n/tmp/tmppp32x1yh.swift:33:50: note: found candidate\
    \ with type '(String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index'\
    \ (aka '(String.Index) -> String.Index')\n        let closingBracketIndex "
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 !=\
    \ brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first\
    \ }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\
    \t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t\
    .filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter\
    \ { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter {\
    \ $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0\
    \ != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 !=\
    \ brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last\
    \ }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\
    \t\t.filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t\
    .filter { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter\
    \ { $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter {\
    \ $0 != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0\
    \ != brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 !=\
    \ brackets.first }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first\
    \ }\n\t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\
    \t\t.filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t\
    .filter { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter\
    \ { $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter {\
    \ $0 != brackets.last }\n\t\t.filter { $0 != brackets.first }\n\t\t.filter { $0\
    \ != brackets.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvkinahmz.swift:64:27: error: expected member name following '.'\n\
    \                .filter { $0 != brackets.\n                                 \
    \       ^\n/tmp/tmpvkinahmz.swift:93:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmpvkinahmz.swift:17:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmpvkinahmz.swift:68:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex - openingBrackets?.startIndex\n\tlet closingBracketsCount\
    \ = closingBrackets?.endIndex - closingBrackets?.startIndex\n\t\n\tif openingBracketsCount\
    \ > 0 && closingBracketsCount > 0 {\n\t\treturn true\n\t}\n\t\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbcltmzre.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbcltmzre.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpbcltmzre.swift:25:55: error: binary operator '-' cannot be applied to\
    \ two 'Duration?' operands\n        let openingBracketsCount = openingBrackets?.endIndex\
    \ - openingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbcltmzre.swift:25:55: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (Float, Float), (Float16, Float16), (Float80, Float80),\
    \ (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant,\
    \ Duration), (SuspendingClock.Instant, SuspendingClock.Instant), (UInt, UInt),\
    \ (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n     \
    \   let openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \                                                             ^\n/tmp/tmpbcltmzre.swift:26:55:\
    \ error: binary operator '-' cannot be applied to two 'Duration?' operands\n \
    \       let closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbcltmzre.swift:26:55: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant, "
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string\n\t\t.unicodeScalars\n\t\t\
    .filter({ $0.isOpen })\n\t\t.count\n\tlet closingBrackets = string\n\t\t.unicodeScalars\n\
    \t\t.filter({ $0.isClosing })\n\t\t.count\n\treturn (openingBrackets > 0 && closingBrackets\
    \ > 0) || (openingBrackets == 0 && closingBrackets == 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpssjz72sh.swift:20:16: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n                .filter({ $0.isOpen })\n               \
    \           ~~ ^~~~~~\n/tmp/tmpssjz72sh.swift:24:16: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n                .filter({ $0.isClosing })\n     \
    \                     ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet bracketCount = brackets.characters.count\n\
    \t\n\treturn bracketCount > 0 && bracketCount < string.length\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5x3tz97g.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5x3tz97g.swift:21:51: error:\
    \ value of type 'String' has no member 'length'\n        return bracketCount >\
    \ 0 && bracketCount < string.length\n                                        \
    \          ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\tif openBrackets == nil || closeBrackets\
    \ == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount = openBrackets?.endIndex\n\
    \tlet closeBracketsCount = closeBrackets?.startIndex\n\t\n\tif openBracketsCount\
    \ == nil || closeBracketsCount == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = openBracketsCount! - openBrackets?.startIndex!\n\tlet closeBracketsCount =\
    \ closeBracketsCount! - closeBrackets?.endIndex!\n\t\n\tif openBracketsCount !=\
    \ closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\treturn true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpapbbfe2b.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpapbbfe2b.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpapbbfe2b.swift:25:40: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount = openBrackets?.endIndex\n          \
    \                      ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpapbbfe2b.swift:26:42: error:\
    \ type of expression is ambiguous without more context\n        let closeBracketsCount\
    \ = closeBrackets?.startIndex\n                                 ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpapbbfe2b.swift:32:45: error: binary operator '-' cannot be applied to\
    \ operands of type 'Duration' and 'Duration?'\n        let openBracketsCount =\
    \ openBracketsCount! - openBrackets?.startIndex!\n                           \
    \     ~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpapbbfe2b.swift:32:45:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (ContinuousClock.Instant, ContinuousClock.Instant), (ContinuousClock.Instant,\
    \ Duration), (Double, Double), (Duration, Duration), (Float, Float), (Float16,\
    \ Float16), (Float80, Float80), (Int, Int), (Int16, Int16), (Int32, Int32), (Int64,\
    \ Int64), (Int8, Int8), (SuspendingClock.Instant, Duration), (SuspendingClock.Instant,\
    \ SuspendingClock.Instant), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32),\
    \ (UInt64, UInt64), (UInt8, UInt8)\n        let openBracketsCount = openBracketsCount!\
    \ - openBrackets?.startIndex!\n                                              \
    \     ^\n/tmp/tmpapbbfe2b.swift:33:47: error: binary operator '-' cannot be applied\
    \ to operands of type 'Duration' and 'Duration?'\n        let closeBracketsCount\
    \ = closeBracketsCount! - closeBrackets?.endIndex!\n                         \
    \        ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpapbbfe2b.swift:3"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBracketsCount = closeBrackets.characters.count\n\tlet bracketsCount\
    \ = brackets.characters.count\n\t\n\treturn openBracketsCount == closeBracketsCount\
    \ && openBracketsCount > 0 && closeBracketsCount > 0 && bracketsCount > 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuv3oje_7.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0\
    \ != CharacterSet.openParenthesis })\n\t\t.filter({ $0 != CharacterSet.closeParenthesis\
    \ })\n\t\t.filter({ $0 != CharacterSet.openBracket})\n\t\t.filter({ $0 != CharacterSet.closeBracket})\n\
    \treturn brackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplnxkviyp.swift:19:19: error: cannot find 'CharacterSet' in scope\n\
    \                .filter({ $0 != CharacterSet.openParenthesis })\n           \
    \                     ^~~~~~~~~~~~\n/tmp/tmplnxkviyp.swift:20:19: error: cannot\
    \ find 'CharacterSet' in scope\n                .filter({ $0 != CharacterSet.closeParenthesis\
    \ })\n                                ^~~~~~~~~~~~\n/tmp/tmplnxkviyp.swift:21:19:\
    \ error: cannot find 'CharacterSet' in scope\n                .filter({ $0 !=\
    \ CharacterSet.openBracket})\n                                ^~~~~~~~~~~~\n/tmp/tmplnxkviyp.swift:22:19:\
    \ error: cannot find 'CharacterSet' in scope\n                .filter({ $0 !=\
    \ CharacterSet.closeBracket})\n                                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars.filter({ $0 >= 0x5B\
    \ && $0 <= 0x5D })\n\tlet openingBrackets = brackets.filter({ $0 >= 0x5B && $0\
    \ <= 0x7B })\n\tlet closingBrackets = brackets.filter({ $0 >= 0x7B && $0 <= 0x5D\
    \ })\n\t\n\treturn openingBrackets.count > 0 || closingBrackets.count > 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpld4xhsao.swift:18:51: error: referencing operator function '>='\
    \ on 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \        let brackets = string.unicodeScalars.filter({ $0 >= 0x5B && $0 <= 0x5D\
    \ })\n                                                         ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n/tmp/tmpld4xhsao.swift:18:65: error: referencing operator function '<=' on\
    \ 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \        let brackets = string.unicodeScalars.filter({ $0 >= 0x5B && $0 <= 0x5D\
    \ })\n                                                                       ^\n\
    Swift.BinaryInteger:1:11: note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger\
    \ {\n          ^\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string\n\t\t.unicodeScalars\n\t\t.filter({\
    \ $0.isASCII })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t\
    .filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\
    \t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi })\n\t\t.filter({ $0.isBidi\
    \ })\n\t\t.filter({ $0.isBidi\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5wd8ekre.swift:69:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmp5wd8ekre.swift:65:10:\
    \ note: to match this opening '('\n                .filter({ $0.isBidi\n     \
    \                  ^\n/tmp/tmp5wd8ekre.swift:94:47: error: expected '}' at end\
    \ of brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n     \
    \                                         ^\n/tmp/tmp5wd8ekre.swift:17:40: note:\
    \ to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n      \
    \                                 ^\n/tmp/tmp5wd8ekre.swift:18:17: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n        let brackets = string\n\
    \                       ^~~~~~\n/tmp/tmp5wd8ekre.swift:69:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013785
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet mut stack_string = string\n\t\
    let mut open_brackets = 0\n\tlet mut closed_brackets = 0\n\twhile let c = stack_string.chars().next()\
    \ {\n\t\tswitch c {\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\tclosed_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\
    \t\t\tclosed_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets\
    \ += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\
    \t\tcase '[':\n\t\t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '[':\n\t\
    \t\topen_brackets += 1\n\t\t\tstack.push(c)\n\t\tcase '['\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5t8fnky4.swift:19:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut stack_string\
    \ = string\n                ^\n/tmp/tmp5t8fnky4.swift:19:10: note: join the identifiers\
    \ together\n        let mut stack_string = string\n            ~~~~^~~~~~~~~~~~\n\
    \            mutstack_string\n/tmp/tmp5t8fnky4.swift:19:10: note: join the identifiers\
    \ together with camel-case\n        let mut stack_string = string\n          \
    \  ~~~~^~~~~~~~~~~~\n            mutStack_string\n/tmp/tmp5t8fnky4.swift:20:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut open_brackets = 0\n                ^\n\
    /tmp/tmp5t8fnky4.swift:20:10: note: join the identifiers together\n        let\
    \ mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n            mutopen_brackets\n\
    /tmp/tmp5t8fnky4.swift:20:10: note: join the identifiers together with camel-case\n\
    \        let mut open_brackets = 0\n            ~~~~^~~~~~~~~~~~~\n          \
    \  mutOpen_brackets\n/tmp/tmp5t8fnky4.swift:21:10: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \       let mut closed_brackets = 0\n                ^\n/tmp/tmp5t8fnky4.swift:21:10:\
    \ note: join the identifiers together\n        let mut closed_brackets = 0\n \
    \           ~~~~^~~~~~~~~~~~~~~\n            mutclosed_brackets\n/tmp/tmp5t8fnky4.swift:21:10:\
    \ note: join the identifiers together with camel-case\n        let mut closed_brackets\
    \ = 0\n            ~~~~^~~~~~~~~~~~~~~\n            mutClosed_brackets\n/tmp/tmp5t8fnky4.swift:24:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp5t8fnky4.swift:27:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp5t8fnky4.swift:30:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '[':\n\
    \                     ^~~\n                     \"[\"\n/tmp/tmp5t"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets == nil\
    \ || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex\n\tlet closingBracketsCount = closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount == 0 || closingBracketsCount == 0 {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBracketsCount! - closingBracketsCount!\n\
    \t\n\tif openingBracketsCount > 1 {\n\t\treturn true\n\t}\n\t\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmf8vfkj5.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmf8vfkj5.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpmf8vfkj5.swift:25:46: error: type of expression is ambiguous without more\
    \ context\n        let openingBracketsCount = openingBrackets?.endIndex\n    \
    \                               ~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpmf8vfkj5.swift:26:46:\
    \ error: type of expression is ambiguous without more context\n        let closingBracketsCount\
    \ = closingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\topeningBrackets.forEach { stack.push(it) }\n\tclosingBrackets.forEach\
    \ { stack.push(it) }\n\t\n\treturn stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8mdx4a6f.swift:18:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmp8mdx4a6f.swift:19:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmp8mdx4a6f.swift:20:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n/tmp/tmp8mdx4a6f.swift:22:39:\
    \ error: cannot find 'it' in scope\n        openingBrackets.forEach { stack.push(it)\
    \ }\n                                             ^~\n/tmp/tmp8mdx4a6f.swift:23:39:\
    \ error: cannot find 'it' in scope\n        closingBrackets.forEach { stack.push(it)\
    \ }\n                                             ^~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets\
    \ = string.rangeOfString(\"]\")\n\t\n\treturn openBrackets.location == closeBrackets.location\
    \ && openBrackets.length == closeBrackets.length\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpiwi85xcz.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpiwi85xcz.swift:19:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter({ $0.isBr\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({\
    \ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\
    \t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ $0.isLetter\
    \ })\n\t\t.filter({ $0.isLetter })\n\t\t.filter({ \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsqe6v8y0.swift:73:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpsqe6v8y0.swift:69:10:\
    \ note: to match this opening '('\n                .filter({ \n              \
    \         ^\n/tmp/tmpsqe6v8y0.swift:98:47: error: expected '}' at end of brace\
    \ statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n              \
    \                                ^\n/tmp/tmpsqe6v8y0.swift:17:40: note: to match\
    \ this opening '{'\nfunc is_nested(string: String) -> Bool {\n               \
    \                        ^\n/tmp/tmpsqe6v8y0.swift:18:17: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        let brackets = string.unicodeScalars\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsqe6v8y0.swift:73:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013782
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet\
    \ closingBrackets = string.rangeOfString(\"]\")\n\t\n\treturn (openingBrackets\
    \ != nil) && (closingBrackets != nil) && (openingBrackets.location != closingBrackets.location)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv031n5g9.swift:18:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpv031n5g9.swift:19:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets = Set<Character>()\n\
    \tlet closingBrackets = Set<Character>()\n\tlet openingBracketsCount = 1\n\tlet\
    \ closingBracketsCount = 1\n\t\n\tlet characters = string.characters\n\t\n\tfor\
    \ character in characters {\n\t\tswitch character {\n\t\tcase '[':\n\t\t\topeningBrackets.insert(character)\n\
    \t\t\topeningBracketsCount += 1\n\t\tcase '(':\n\t\t\topeningBrackets.insert(character)\n\
    \t\t\topeningBracketsCount += 1\n\t\tcase ']':\n\t\t\topeningBrackets.insert(character)\n\
    \t\t\topeningBracketsCount += 1\n\t\tcase ')':\n\t\t\topeningBrackets.insert(character)\n\
    \t\t\topeningBracketsCount += 1\n\t\tcase '.':\n\t\t\topeningBrackets.insert(character)\n\
    \t\t\topeningBracketsCount += 1\n\t\tcase '[':\n\t\t\tclosingBrackets.insert(character)\n\
    \t\t\tclosingBracketsCount += 1\n\t\tcase ']':\n\t\t\tclosingBrackets.insert(character)\n\
    \t\t\tclosingBracketsCount += 1\n\t\tcase ')':\n\t\t\tclosingBrackets.insert(character)\n\
    \t\t\tclosingBracketsCount += 1\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t\
    if openingBracketsCount > closingBracketsCount {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyl90veif.swift:28:8: error: single-quoted string literal found,\
    \ use '\"'\n                case '[':\n                     ^~~\n            \
    \         \"[\"\n/tmp/tmpyl90veif.swift:31:8: error: single-quoted string literal\
    \ found, use '\"'\n                case '(':\n                     ^~~\n     \
    \                \"(\"\n/tmp/tmpyl90veif.swift:34:8: error: single-quoted string\
    \ literal found, use '\"'\n                case ']':\n                     ^~~\n\
    \                     \"]\"\n/tmp/tmpyl90veif.swift:37:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ')':\n                \
    \     ^~~\n                     \")\"\n/tmp/tmpyl90veif.swift:40:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '.':\n                \
    \     ^~~\n                     \".\"\n/tmp/tmpyl90veif.swift:43:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '[':\n                \
    \     ^~~\n                     \"[\"\n/tmp/tmpyl90veif.swift:46:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ']':\n                \
    \     ^~~\n                     \"]\"\n/tmp/tmpyl90veif.swift:49:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ')':\n                \
    \     ^~~\n                     \")\"\n/tmp/tmpyl90veif.swift:18:14: error: cannot\
    \ find 'Stack' in scope\n        let stack = Stack()\n                    ^~~~~\n\
    /tmp/tmpyl90veif.swift:24:26: error: 'characters' is unavailable: Please use String\
    \ directly\n        let characters = string.characters\n                     \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpyl90veif.swift:29:20: error: cannot use mutating member on immutable value:\
    \ 'openingBrackets' is a 'let' constant\n                        openingBrackets.insert(character)\n\
    \                        ~~~~~~~~~~~~~~~ ^\n/tmp/tmpyl90veif.swift:19:2: note:\
    \ change 'let' to 'var' to make it mutable\n        let openingBrackets = Set<Character>()\n\
    \        ^~~\n        var\n/tmp"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet open = string.rangeOfString(\"[\")\n\tlet close = string.rangeOfString(\"\
    ]\")\n\t\n\tif open < 0 || close < 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketCount\
    \ = string.countSubstrings(of: \"[\")\n\tlet closeBracketCount = string.countSubstrings(of:\
    \ \"]\")\n\t\n\treturn openBracketCount == closeBracketCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2kodtyz8.swift:18:20: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let open = string.rangeOfString(\"[\")\n          \
    \         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp2kodtyz8.swift:19:21: error: value of\
    \ type 'String' has no member 'rangeOfString'\n        let close = string.rangeOfString(\"\
    ]\")\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp2kodtyz8.swift:25:32:\
    \ error: value of type 'String' has no member 'countSubstrings'\n        let openBracketCount\
    \ = string.countSubstrings(of: \"[\")\n                               ~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp2kodtyz8.swift:26:33: error: value of type 'String' has no member 'countSubstrings'\n\
    \        let closeBracketCount = string.countSubstrings(of: \"]\")\n         \
    \                       ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\t\t.filter { $0.isBr\
    \ }\n\t\t.map { $0.value }\n\t\t.reduce(into: [String](), { $0.append($1.value)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], { $0.append($1)\
    \ })\n\t\t.reduce(into: [], { $0.append($1) })\n\t\t.reduce(into: [], \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyrfcpein.swift:56:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpyrfcpein.swift:18:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let brackets = string.unicodeScalars\n            \
    \           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013875
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
    \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
    /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
    )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
    \ String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of: \"[\", with:\
    \ \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.count\n\tlet closeBracketsCount\
    \ = closeBrackets.count\n\tlet bracketsCount = openBracketsCount + closeBracketsCount\n\
    \tlet bracketsCountInString = string.count\n\treturn bracketsCount == bracketsCountInString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6aolm9h0.swift:18:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013743
