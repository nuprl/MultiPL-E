language: swift
name: HumanEval_143_words_in_sentence
results:
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    var result = \"\"\n    for char\
    \ in sentence.characters {\n        if isPrime(Int(char)) {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpegaeu6br.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpegaeu6br.swift:20:12: error: cannot find 'isPrime' in scope\n        if\
    \ isPrime(Int(char)) {\n           ^~~~~~~\n/tmp/tmpegaeu6br.swift:20:20: error:\
    \ no exact matches in call to initializer \n        if isPrime(Int(char)) {\n\
    \                   ^\n/tmp/tmpegaeu6br.swift:20:20: note: found candidate with\
    \ type '(Float16) -> Int'\n        if isPrime(Int(char)) {\n                 \
    \  ^\n/tmp/tmpegaeu6br.swift:20:20: note: found candidate with type '(Float) ->\
    \ Int'\n        if isPrime(Int(char)) {\n                   ^\n/tmp/tmpegaeu6br.swift:20:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(char))\
    \ {\n                   ^\n/tmp/tmpegaeu6br.swift:20:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(char)) {\n            \
    \       ^\n/tmp/tmpegaeu6br.swift:20:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(char)) {\n                   ^\n/tmp/tmpegaeu6br.swift:20:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(char))\
    \ {\n                   ^\n/tmp/tmpegaeu6br.swift:20:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(char)) {\n            \
    \       ^\n/tmp/tmpegaeu6br.swift:21:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzdyj63j5.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzdyj63j5.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb9ixuqx.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnfr_wg8a.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnfr_wg8a.swift:17:65: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \      ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkwrqajm_.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpbihk28cs/tmpbihk28cs.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af86140ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af861101b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af861101988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8611007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbihk28cs                        0x00005606d216a307 <unavailable> + 4871

    5    libc.so.6                          0x00002af8615f6460 __libc_start_main +
    245

    6    tmpbihk28cs                        0x00005606d2169f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], maxLength: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_koez10k.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], maxLength:\
    \ 0)\n                            ^\n/tmp/tmp_koez10k.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        let length = prime_number(word:\
    \ word)\n        if length == 0 {\n            continue\n        }\n        result\
    \ += \" \" + word\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyiiy3q8k.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpyiiy3q8k.swift:20:22: error: cannot\
    \ find 'prime_number' in scope\n        let length = prime_number(word: word)\n\
    \                     ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1njya2jm.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrimeNumber(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4qkokg9f.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_sii9bnn.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1s6w47f.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsyjm58qz.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpgk8d4icg/tmpgk8d4icg.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b2b11ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b2ae15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b2ae15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b2ae147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgk8d4icg                        0x000055eccd7b1307 <unavailable> + 4871

    5    libc.so.6                          0x00002b1b2b30a460 __libc_start_main +
    245

    6    tmpgk8d4icg                        0x000055eccd7b0f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1s6w47f.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ words: [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ppc_dei.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, words: [],\
    \ index: 0)\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence.characters {\n        if primes.contains(char.count) {\n       \
    \     primes.append(char.count)\n        } else {\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvmkt4s0t.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvmkt4s0t.swift:20:33: error: value of type 'Character' has no member 'count'\n\
    \        if primes.contains(char.count) {\n                           ~~~~ ^~~~~\n\
    /tmp/tmpvmkt4s0t.swift:21:32: error: value of type 'Character' has no member 'count'\n\
    \            primes.append(char.count)\n                          ~~~~ ^~~~~\n\
    /tmp/tmpvmkt4s0t.swift:23:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsyjm58qz.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrimeNumber(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4qkokg9f.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], maxLength: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_koez10k.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], maxLength:\
    \ 0)\n                            ^\n/tmp/tmp_koez10k.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfcqi8ln8.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: nil)\n     \
    \      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfcqi8ln8.swift:17:58: error: 'nil' requires\
    \ a contextual type\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n                                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrimeNumber(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4qkokg9f.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptlk3to4s.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], result:\
    \ \"\")\n                            ^\n/tmp/tmptlk3to4s.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpbihk28cs/tmpbihk28cs.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af86140ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af861101b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af861101988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8611007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbihk28cs                        0x00005606d216a307 <unavailable> + 4871

    5    libc.so.6                          0x00002af8615f6460 __libc_start_main +
    245

    6    tmpbihk28cs                        0x00005606d2169f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        let prime = prime_number(word:\
    \ word)\n        if prime > 0 {\n            result += \" \" + word\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvu_ir_z0.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvu_ir_z0.swift:20:21: error: cannot\
    \ find 'prime_number' in scope\n        let prime = prime_number(word: word)\n\
    \                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnfr_wg8a.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnfr_wg8a.swift:17:65: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \      ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb9ixuqx.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, primes:\
    \ primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpduisu69j.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpduisu69j.swift:17:62: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_aux(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkwrqajm_.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ words: [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4s990_4d.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, words: [],\
    \ result: \"\")\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordsInSentence = sentence.components(separatedBy:\
    \ \" \")\n    return wordsInSentence.filter { wordLength in\n        return isPrime(wordLength)\n\
    \    }.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1suiajre.swift:17:36: error: value of type 'String' has no member\
    \ 'components'\n    let wordsInSentence = sentence.components(separatedBy: \"\
    \ \")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1suiajre.swift:19:16:\
    \ error: cannot find 'isPrime' in scope\n        return isPrime(wordLength)\n\
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, primes:\
    \ primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpduisu69j.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpduisu69j.swift:17:62: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_aux(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkwrqajm_.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_sii9bnn.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzacm28p_.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, words: [], index:\
    \ 0)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ result: [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpizoh2grc.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, result: [])\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpx6z0npet.swift:17:60: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    \                                                           ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnfr_wg8a.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnfr_wg8a.swift:17:65: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_helper(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \      ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], maxLength: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_koez10k.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], maxLength:\
    \ 0)\n                            ^\n/tmp/tmp_koez10k.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkwrqajm_.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkwrqajm_.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzdyj63j5.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjvenujfw.swift:17:60: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type 'String'\n    return words_in_sentence(sentence:\
    \ sentence.characters.split(separator: \" \"))\n                             \
    \                              ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfcqi8ln8.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: nil)\n     \
    \      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfcqi8ln8.swift:17:58: error: 'nil' requires\
    \ a contextual type\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n                                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, primes:\
    \ primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpduisu69j.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, primes: primes)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpduisu69j.swift:17:62: error: cannot\
    \ find 'primes' in scope\n    return words_in_sentence_aux(sentence: sentence,\
    \ primes: primes)\n                                                          \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_sii9bnn.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjb9ixuqx.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpw0ktxzgh.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence, \"\")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvzyunkpb.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzdyj63j5.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrimeNumber(word:\
    \ word) {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4qkokg9f.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for word\
    \ in sentence.split(separator: \" \") {\n        if primes.contains(word.characters.count)\
    \ {\n            primes.append(word.characters.count)\n            result += \"\
    \ \" + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfxms3gzg.swift:20:33: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        if primes.contains(word.characters.count) {\n\
    \                                ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmpfxms3gzg.swift:21:32: error: 'characters' is unavailable:\
    \ Please use Substring directly\n            primes.append(word.characters.count)\n\
    \                               ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1njya2jm.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4eny_cv.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsyjm58qz.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppj5ak38c.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    let primes = words.compactMap { Int($0) }\n    return primes.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpldi3q2uz.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprjqbdizc.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpbihk28cs/tmpbihk28cs.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af86140ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af861101b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af861101988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8611007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbihk28cs                        0x00005606d216a307 <unavailable> + 4871

    5    libc.so.6                          0x00002af8615f6460 __libc_start_main +
    245

    6    tmpbihk28cs                        0x00005606d2169f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1njya2jm.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
