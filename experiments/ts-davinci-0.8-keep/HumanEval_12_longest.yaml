name: HumanEval_12_longest
language: ts
prompt: "//Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n// strings of the same length. Return None in case the input\
  \ list is empty.\n// >>> longest([])\n// >>> longest(['a', 'b', 'c'])\n// 'a'\n\
  // >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\nfunction longest(strings: string[]):\
  \ string | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n\
  \  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"
completions: ["    if (strings.length == 0) {\n        return undefined;\n    }\n\
    \    let maxLen = 0;\n    let longestStr = \"\";\n    for (let s of strings) {\n\
    \        if (s.length > maxLen) {\n            maxLen = s.length;\n          \
    \  longestStr = s;\n        }\n    }\n    return longestStr;\n}\n", "  let long\
    \ = undefined;\n  strings.forEach(str => {\n    if (str.length > (long ? long.length\
    \ : 0)) {\n      long = str;\n    }\n  });\n  return long;\n}\nconsole.log(longest([\"\
    a\", \"bb\", \"ccc\"]));\n", "  let longest = \"\";\n  strings.forEach((str) =>\
    \ {\n    if (str.length > longest.length) {\n      longest = str;\n    }\n  });\n\
    \  return longest;\n}\n", "    if (strings.length === 0) {\n        return undefined;\n\
    \    }\n    let result = strings[0];\n    for (let i = 1; i < strings.length;\
    \ i++) {\n        const string = strings[i];\n        if (string.length > result.length)\
    \ {\n            result = string;\n        }\n    }\n    return result;\n}\n",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  let longest: string\
    \ = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length\
    \ > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n\
    }\n", "    if (strings.length === 0) {\n        return undefined;\n    }\n   \
    \ else {\n        return strings.reduce((longest: string, current: string) =>\
    \ current.length > longest.length ? current : longest);\n    }\n}\n", "    let\
    \ current = strings[0];\n    for (let s of strings) {\n        if (s.length >\
    \ current.length) {\n            current = s;\n        }\n    }\n    return current;\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  let longest\
    \ = strings[0];\n  for (let index = 1; index < strings.length; index++) {\n  \
    \  if (strings[index].length > longest.length) {\n      longest = strings[index];\n\
    \    }\n  }\n  return longest;\n}\n", "    if (strings.length == 0) {\n      \
    \  return undefined;\n    }\n    let answer = strings[0];\n    for (let i = 1;\
    \ i < strings.length; i++) {\n        if (strings[i].length > answer.length) {\n\
    \            answer = strings[i];\n        }\n    }\n    return answer;\n}\n",
  "    let maxString = undefined;\n    let maxLength = 0;\n    for (let s of strings)\
    \ {\n        if (s.length > maxLength) {\n            maxString = s;\n       \
    \     maxLength = s.length;\n        }\n    }\n    return maxString;\n}\n", " \
    \   if (strings.length === 0) {\n        return undefined;\n    }\n    let longestString\
    \ = strings[0];\n    for (let i = 1; i < strings.length; i++) {\n        if (strings[i].length\
    \ > longestString.length) {\n            longestString = strings[i];\n       \
    \ }\n    }\n    return longestString;\n}\n", "  let longest = strings[0];\n  for\
    \ (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length)\
    \ {\n      longest = strings[i];\n    }\n  }\n  return longest;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  let longest = strings[0];\n  for (let\
    \ i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length)\
    \ {\n      longest = strings[i];\n    }\n  }\n  return longest;\n}\n", "  let\
    \ longestString = strings[0];\n  for (let i = 0; i < strings.length; i++) {\n\
    \    if (strings[i].length > longestString.length) {\n      longestString = strings[i];\n\
    \    }\n  }\n  return longestString;\n}\n", "  if (strings.length === 0) {\n \
    \   return undefined;\n  }\n  let longest = strings[0];\n  for (let i = 1; i <\
    \ strings.length; i++) {\n    if (strings[i].length > longest.length) {\n    \
    \  longest = strings[i];\n    }\n  }\n  return longest;\n}\n", "    if (strings.length\
    \ === 0) {\n        return undefined;\n    }\n    let result = strings[0];\n \
    \   for (let i = 1; i < strings.length; i++) {\n        if (strings[i].length\
    \ > result.length) {\n            result = strings[i];\n        }\n    }\n   \
    \ return result;\n}\n", "  let result = undefined;\n  let resultLen = 0;\n  for\
    \ (let i = 0; i < strings.length; i++) {\n    const thisLen = strings[i].length;\n\
    \    if (thisLen > resultLen) {\n      result = strings[i];\n      resultLen =\
    \ thisLen;\n    }\n  }\n  return result;\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  let longestString = strings[0];\n  for (let i =\
    \ 1; i < strings.length; i++) {\n    const currentString = strings[i];\n    if\
    \ (currentString.length > longestString.length) {\n      longestString = currentString;\n\
    \    }\n  }\n  return longestString;\n}\n", "    if (!strings.length) {\n    \
    \    return undefined;\n    }\n    if (strings.length === 1) {\n        return\
    \ strings[0];\n    }\n    const best = strings.reduce((bestSoFar, current) =>\
    \ {\n        if (current.length > bestSoFar.length) {\n            return current;\n\
    \        }\n        return bestSoFar;\n    });\n    return best;\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n  const longestStr = strings.reduce((a,\
    \ b) => {\n    return a.length > b.length ? a : b;\n  });\n  return longestStr;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
