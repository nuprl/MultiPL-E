name: HumanEval_128_prod_signs
language: ts
prompt: "//You are given an array arr of integers and you need to return\n// sum of\
  \ magnitudes of integers multiplied by product of all signs\n// of each number in\
  \ the array, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n//\
  \ Example:\n// >>> prod_signs([1, 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) ==\
  \ 0\n// >>> prod_signs([]) == None\nfunction prod_signs(arr: number[]): number |\
  \ undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = prod_signs;\n  assert.deepEqual(candidate([1, 2, 2,\
  \ -4]),-9);\n  assert.deepEqual(candidate([0, 1]),0);\n  assert.deepEqual(candidate([1,\
  \ 1, 1, 2, 3, -1, 1]),-10);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 2, -1, -1, 9]),20);\n  assert.deepEqual(candidate([-1, 1, -1, 1]),4);\n\
  \  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);\n  assert.deepEqual(candidate([-1,\
  \ 1, 1, 0]),0);\n}\n\ntest();"
completions: ["  let arr2 = arr.map(i => (i < 0 ? -1 : i > 0 ? 1 : 0));\n  let product\
    \ = arr2.reduce((acc, i) => acc * i, 1);\n  let magnitudes = arr.map(i => Math.abs(i));\n\
    \  let sum = magnitudes.reduce((acc, i) => acc + i, 0);\n  if (arr.length ===\
    \ 0) {\n    return undefined;\n  }\n  return sum * product;\n}\n", "    if (arr.length\
    \ == 0) {\n        return undefined;\n    }\n    let sign_arr = arr.map(function\
    \ (el: number) {\n        if (el == 0) {\n            return 0;\n        } else\
    \ if (el > 0) {\n            return 1;\n        } else {\n            return -1;\n\
    \        }\n    });\n    let num_arr = arr.map(function (el: number) {\n     \
    \   return Math.abs(el);\n    });\n    let sign_prod = sign_arr.reduce(function\
    \ (a: number, b: number) {\n        return a * b;\n    });\n    let num_sum =\
    \ num_arr.reduce(function (a: number, b: number) {\n        return a + b;\n  \
    \  });\n    return num_sum * sign_prod;\n}\n", "    let result: number = 0;\n\
    \    for (let i: number = 0; i < arr.length; i++) {\n        result += Math.abs(arr[i])\
    \ * Math.sign(arr[i]);\n    }\n    return result;\n}\n\n", "  const sign = arr.reduce((a,\
    \ b) => a * b, 1);\n  const mag = arr.map(v => Math.abs(v)).reduce((a, b) => a\
    \ + b, 0);\n  return arr.length ? sign * mag : undefined;\n}\n", "    if (arr.length\
    \ == 0) {\n        return undefined;\n    }\n    let sum = 0;\n    let prod =\
    \ 1;\n    for (let i = 0; i < arr.length; i++) {\n        sum += Math.abs(arr[i]);\n\
    \        if (arr[i] > 0) {\n            prod *= 1;\n        } else if (arr[i]\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n    }\n    return sum * prod;\n}\n", "    if (arr.length === 0) return\
    \ undefined;\n    let signs = 1;\n    let numbers = 0;\n    for (let i = 0; i\
    \ < arr.length; i++) {\n        if (arr[i] === 0) continue;\n        signs *=\
    \ Math.sign(arr[i]);\n        numbers += Math.abs(arr[i]);\n    }\n    return\
    \ signs * numbers;\n}\n", "  if (arr.length === 0) {\n    return undefined;\n\
    \  }\n  const prod = arr.reduce((acc, x) => {\n    return acc * (x >= 0 ? 1 :\
    \ -1);\n  }, 1);\n  const mag = arr.reduce((acc, x) => {\n    return acc + Math.abs(x);\n\
    \  }, 0);\n  return prod * mag;\n}\n", "    let result = 0;\n    let product =\
    \ 1;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < 0) {\n\
    \            result += arr[i] * (-1);\n            product *= -1;\n        } else\
    \ if (arr[i] > 0) {\n            result += arr[i];\n            product *= 1;\n\
    \        } else {\n            product *= 0;\n        }\n    }\n    return result\
    \ * product;\n}\n", "  if (arr.length === 0) {\n    return undefined;\n  }\n \
    \ const abs_prod = arr.reduce((acc: number, x: number) => {\n    return acc *\
    \ Math.abs(x);\n  }, 1);\n  const sign_sum = arr.reduce((acc: number, x: number)\
    \ => {\n    if (x === 0) {\n      return acc;\n    }\n    return acc + Math.sign(x);\n\
    \  }, 0);\n  return abs_prod * sign_sum;\n}\n", "    if (arr.length === 0) return\
    \ undefined;\n    let res = 1;\n    let sum = 0;\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        let sign = Math.sign(arr[i]);\n        sum += Math.abs(arr[i]);\n\
    \        res *= sign;\n    }\n    return res * sum;\n}\n", "    const signs: number[]\
    \ = arr.map(num => num > 0 ? 1 : num < 0 ? -1 : 0);\n    if (signs.length ===\
    \ 0) {\n        return undefined;\n    }\n    const signProduct = signs.reduce((signProduct,\
    \ sign) => signProduct * sign, 1);\n    const magnitudeSum = arr.reduce((magnitudeSum,\
    \ num) => magnitudeSum + Math.abs(num), 0);\n    return magnitudeSum * signProduct;\n\
    }", "    if (arr.length === 0) {\n        return undefined;\n    }\n    let sum\
    \ = 0;\n    let mult_signs = 1;\n    for (let i = 0; i < arr.length; i++) {\n\
    \        sum += Math.abs(arr[i]);\n        mult_signs *= Math.sign(arr[i]);\n\
    \    }\n    return sum * mult_signs;\n}\nconsole.log(prod_signs([1, 2, 2, -4]));\n\
    console.log(prod_signs([0, 1]));\nconsole.log(prod_signs([]));", "  return arr.length\
    \ == 0 ? undefined : arr.reduce((x, y) => x + Math.abs(y), 0) * arr.reduce((x,\
    \ y) => x * Math.sign(y), 1);\n}", "  if (arr.length === 0) {\n    return undefined;\n\
    \  }\n  let sum: number = 0;\n  let sign: number = 1;\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] === 0) {\n      continue;\n    }\n    sum += Math.abs(arr[i]);\n\
    \    sign *= Math.sign(arr[i]);\n  }\n  return sum * sign;\n}\n", "  if (arr.length\
    \ == 0) return undefined;\n  let _product: number = 1;\n  let _sum: number = 0;\n\
    \  for (let i = 0; i < arr.length; i++) {\n    let _sign: number = Math.sign(arr[i]);\n\
    \    _product *= _sign;\n    _sum += Math.abs(arr[i]);\n  }\n  return _sum * _product;\n\
    }\n\nexport { prod_signs };", "    let prod = 1;\n    let sum = 0;\n    for (let\
    \ n of arr) {\n        if (n < 0) {\n            prod *= -1;\n        } else if\
    \ (n > 0) {\n            prod *= 1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += Math.abs(n);\n    }\n    if (arr.length === 0) {\n\
    \        return undefined;\n    }\n    return prod * sum;\n}\n", "    if (arr.length\
    \ === 0) {\n        return undefined;\n    }\n    const sumOfMagnitudes = arr.reduce((acc,\
    \ curr) => {\n        return acc + Math.abs(curr);\n    }, 0);\n    const prodOfSigns\
    \ = arr.reduce((acc, curr) => {\n        if (curr > 0) {\n            return acc\
    \ * 1;\n        } else if (curr < 0) {\n            return acc * -1;\n       \
    \ } else {\n            return acc * 0;\n        }\n    }, 1);\n    return sumOfMagnitudes\
    \ * prodOfSigns;\n}\n", "  let sum = 0;\n  let prod = 1;\n  for (let i = 0; i\
    \ < arr.length; i++) {\n    if (arr[i] === 0) {\n      prod = 0;\n      continue;\n\
    \    }\n    prod *= arr[i] / Math.abs(arr[i]);\n    sum += Math.abs(arr[i]);\n\
    \  }\n  return prod === 0 ? prod : prod * sum;\n}\n", "    if (arr.length > 0)\
    \ {\n        let sum = 0;\n        let product = 1;\n        for (let num of arr)\
    \ {\n            sum += Math.abs(num);\n            product *= Math.sign(num);\n\
    \        }\n        return sum * product;\n    }\n    return undefined;\n}\n\n\
    console.log(prod_signs([1, 2, 2, -4]));\nconsole.log(prod_signs([0, 1]));\nconsole.log(prod_signs([]));",
  "  if (arr.length === 0) {\n    return undefined;\n  }\n\n  let sumMagnitudes =\
    \ 0;\n  let prodSigns = 1;\n\n  for (let i = 0; i < arr.length; i++) {\n    sumMagnitudes\
    \ += Math.abs(arr[i]);\n    prodSigns *= Math.sign(arr[i]);\n  }\n\n  return sumMagnitudes\
    \ * prodSigns;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
