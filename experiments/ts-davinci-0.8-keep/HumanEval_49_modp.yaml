name: HumanEval_49_modp
language: ts
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n: number, p: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["  var f = function (i, p) {\n    if (i === 0) {\n      return 1;\n\
    \    } else if (i === 1) {\n      return n % p;\n    } else {\n      var m = f(i\
    \ / 2, p);\n      if (i % 2 === 0) {\n        return (m * m) % p;\n      } else\
    \ {\n        return (((m * m) % p) * n) % p;\n      }\n    }\n  };\n  return f(n,\
    \ p);\n}\n", "    return 0;\n}\n\ntest('modp', () => {\n    expect(modp(3, 5)).toBe(3);\n\
    \    expect(modp(1101, 101)).toBe(2);\n    expect(modp(0, 101)).toBe(1);\n   \
    \ expect(modp(3, 11)).toBe(8);\n    expect(modp(100, 101)).toBe(1);\n});\n", " \
    \   let r = 1;\n    let e = n;\n    while (e > 0) {\n        if (e & 1) {\n  \
    \          r = (r * n) % p;\n        }\n        n = (n * n) % p;\n        e >>=\
    \ 1;\n    }\n    return r;\n}\n", "  let mask = 1;\n  let result = 1;\n  while\
    \ (mask <= n) {\n    if ((n & mask) !== 0) {\n      result = (result * mask) %\
    \ p;\n    }\n    mask = mask << 1;\n  }\n  return result;\n}\n", "  if (n ===\
    \ 0) {\n    return 1;\n  } else if (n === 1) {\n    return 2 % p;\n  }\n  const\
    \ even = (n % 2 === 0);\n  const res = modp(Math.floor(n / 2), p);\n  if (even)\
    \ {\n    return (res * res) % p;\n  } else {\n    return (2 * res * res) % p;\n\
    \  }\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return\
    \ n;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2, p) ** 2 % p;\n  }\n  return\
    \ (modp(n - 1, p) * modp(n, p)) % p;\n}\n", "  if (n === 0) {\n    return 1;\n\
    \  }\n  if (n % 2 === 0) {\n    return Math.pow(modp(n / 2, p), 2) % p;\n  }\n\
    \  return (n % p) * modp(n - 1, p) % p;\n}\n", "  var res = 1n;\n  for (var i\
    \ = 0; i < n; i++) {\n    res = (res * 2n) % p;\n  }\n  return Number(res);\n\
    }\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    const v\
    \ = modp(n / 2, p);\n    return (v * v) % p;\n  }\n  return (modp(n - 1, p) *\
    \ n) % p;\n}\n", "    if (n == 0) {\n        return 1;\n    } else if (n % 2 ==\
    \ 0) {\n        let t = modp(n / 2, p);\n        return t * t % p;\n    } else\
    \ {\n        return modp(n - 1, p) * n % p;\n    }\n}\n", "  let res = 1;\n  const\
    \ m = p - 2;\n  while (m > 0) {\n    if (m % 2 === 1) {\n      res = (res * n)\
    \ % p;\n    }\n    n = (n * n) % p;\n    m = Math.floor(m / 2);\n  }\n  return\
    \ res;\n}\n", "  if (n < 0) {\n    n = n % p + p;\n  }\n  return n % p;\n}\n",
  "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return (modp(n/2,\
    \ p) ** 2) % p;\n  }\n  return (modp(n - 1, p) * n) % p;\n}\n", "  return Math.pow(2,\
    \ n) % p;\n}\n", "  return Math.pow(2, n) % p;\n}\n", "  // Use B\xE9zout's identity\
    \ (which follows from the extended Euclidean algorithm):\n  //   a^2 + b^2 = GCD(a,\
    \ b)\n  //   a^3 + b^3 = 3ab + ab = GCD(a, b) * (a + b)\n  //   a^4 + b^4 = a^2b^2\
    \ + b^2a^2 = (a^2 + b^2)^2 - 2ab^2 = (GCD(a, b))^2\n  //   ...\n  //   a^n + b^n\
    \ = (a^n - b^n) + 2b^n\n  // but replace addition with subtraction and multiplication\
    \ by addition.\n  let result = 1;\n  let base = n % p;\n  while (n > 0) {\n  \
    \  if (n % 2 === 1) {\n      result = (result * base) % p;\n    }\n    n = Math.floor(n\
    \ / 2);\n    base = (base * base) % p;\n  }\n  return result;\n}\n", "  var r\
    \ = 1;\n  var c = n;\n  while (c > 0) {\n    if (c % 2 === 1) {\n      r = (r\
    \ * n) % p;\n    }\n    c = Math.floor(c / 2);\n    n = (n * n) % p;\n  }\n  return\
    \ r;\n}\n", "  // $FlowFixMe\n  let r = n % p;\n  return r < 0 ? r + p : r;\n\
    }\n", "  var res = 1;\n  for (var i = 0; i < n; i++) {\n    res = (res * 2) %\
    \ p;\n  }\n  return res;\n}\n", "    //TODO: implement me\n    return 0;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
