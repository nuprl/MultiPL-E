name: HumanEval_136_largest_smallest_integers
language: ts
prompt: "//Create a function that returns a tuple (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n\
  // If there is no negative or positive integers, return them as None.\n// Examples:\n\
  // largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([])\
  \ == (None, None)\n// largest_smallest_integers([0]) == (None, None)\nfunction largest_smallest_integers(lst:\
  \ number[]): [number | undefined, number | undefined] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["    let smallest: number | undefined = undefined;\n    let largest:\
    \ number | undefined = undefined;\n    for (let i = 0; i < lst.length; i++) {\n\
    \        if (lst[i] < 0) {\n            if (largest === undefined || lst[i] >\
    \ largest) {\n                largest = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (smallest === undefined || lst[i] < smallest)\
    \ {\n                smallest = lst[i];\n            }\n        }\n    }\n   \
    \ return [largest, smallest];\n}\n", "    let smallest = Math.min(...lst.filter(x\
    \ => x > 0));\n    let largest = Math.max(...lst.filter(x => x < 0));\n    return\
    \ [largest, smallest];\n}", "    let largest = undefined;\n    let smallest =\
    \ undefined;\n    for (let num of lst) {\n        if (num < 0) {\n           \
    \ if (largest === undefined || num > largest) {\n                largest = num;\n\
    \            }\n        } else if (num > 0) {\n            if (smallest === undefined\
    \ || num < smallest) {\n                smallest = num;\n            }\n     \
    \   }\n    }\n    return [largest, smallest];\n}\n", "  const [pos, neg] = lst.reduce(\n\
    \    ([pos, neg], num) => [num > 0 ? Math.min(pos || num, num) : pos, num < 0\
    \ ? Math.max(neg || num, num) : neg],\n    [undefined, undefined]\n  );\n  return\
    \ [neg, pos];\n}\n\nconsole.log(largest_smallest_integers([2, 4, 1, 3, 5, 7]));\
    \ // [undefined, 1]\nconsole.log(largest_smallest_integers([])); // [undefined,\
    \ undefined]\nconsole.log(largest_smallest_integers([0])); // [undefined, undefined]\n\
    console.log(largest_smallest_integers([-1, -2, -3, -4, -5])); // [-1, -5]\nconsole.log(largest_smallest_integers([1,\
    \ 2, 3, 4, 5])); // [undefined, 1]\nconsole.log(largest_smallest_integers([-1,\
    \ 1, 2, 3, 4, 5])); // [-1, 1]\nconsole.log(largest_smallest_integers([-1, -2,\
    \ -3, -4, -5, 1, 2, 3, 4, 5])); // [-1, -5]\n\nexport { largest_smallest_integers\
    \ };", "  if (lst.length < 1) {\n    return [undefined, undefined];\n  }\n\n \
    \ let negs: number[] = lst.filter(e => e < 0);\n  let poss: number[] = lst.filter(e\
    \ => e > 0);\n\n  let a: number | undefined = negs.length ? Math.max(...negs)\
    \ : undefined;\n  let b: number | undefined = poss.length ? Math.min(...poss)\
    \ : undefined;\n\n  return [a, b];\n}\n", "    return undefined;\n}\n\n", "  let\
    \ smallest = undefined;\n  let largest = undefined;\n  let pos_count = 0;\n  let\
    \ neg_count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0)\
    \ {\n      neg_count++;\n      if (largest === undefined || lst[i] > largest)\
    \ {\n        largest = lst[i];\n      }\n    } else if (lst[i] > 0) {\n      pos_count++;\n\
    \      if (smallest === undefined || lst[i] < smallest) {\n        smallest =\
    \ lst[i];\n      }\n    }\n  }\n  if (neg_count === 0) {\n    largest = undefined;\n\
    \  }\n  if (pos_count === 0) {\n    smallest = undefined;\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largestNegativeNumber: number | undefined;\n  let smallestPositiveNumber:\
    \ number | undefined;\n  for (let number of lst) {\n    if (number > 0) {\n  \
    \    if (smallestPositiveNumber === undefined || number < smallestPositiveNumber)\
    \ {\n        smallestPositiveNumber = number;\n      }\n    } else if (number\
    \ < 0) {\n      if (largestNegativeNumber === undefined || number > largestNegativeNumber)\
    \ {\n        largestNegativeNumber = number;\n      }\n    }\n  }\n  return [largestNegativeNumber,\
    \ smallestPositiveNumber];\n}\n", "  let smallest_positive: number | undefined\
    \ = Number.MAX_VALUE;\n  let largest_negative: number | undefined = Number.MIN_VALUE;\n\
    \  lst.forEach(num => {\n    if (num < 0 && num > largest_negative) {\n      largest_negative\
    \ = num;\n    } else if (num > 0 && num < smallest_positive) {\n      smallest_positive\
    \ = num;\n    }\n  });\n  return [largest_negative, smallest_positive];\n}\n",
  "    if (lst.length === 0) {\n        return [undefined, undefined];\n    }\n\n\
    \    let negative_numbers: number[] = [];\n    let positive_numbers: number[]\
    \ = [];\n\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0)\
    \ {\n            negative_numbers.push(lst[i]);\n        } else if (lst[i] > 0)\
    \ {\n            positive_numbers.push(lst[i]);\n        }\n    }\n\n    if (negative_numbers.length\
    \ > 0) {\n        negative_numbers.sort((a, b) => a - b);\n    }\n    if (positive_numbers.length\
    \ > 0) {\n        positive_numbers.sort((a, b) => a - b);\n    }\n\n    return\
    \ [negative_numbers[0], positive_numbers[0]];\n}\n", "  let min: number | undefined\
    \ = undefined;\n  let max: number | undefined = undefined;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (max === undefined ||\
    \ lst[i] > max) {\n        max = lst[i];\n      }\n    } else if (lst[i] > 0)\
    \ {\n      if (min === undefined || lst[i] < min) {\n        min = lst[i];\n \
    \     }\n    }\n  }\n  return [max, min];\n}\n\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    return [Math.max(...lst.filter(i => i < 0)), Math.min(...lst.filter(i => i\
    \ > 0))];\n}\n", "    if (lst.length == 0) return [undefined, undefined];\n  \
    \  let neg = lst.filter(x => x < 0);\n    let pos = lst.filter(x => x > 0);\n\
    \    if (neg.length == 0) neg = [undefined];\n    if (pos.length == 0) pos = [undefined];\n\
    \    return [Math.max(...neg), Math.min(...pos)];\n}\n", "    let biggest_neg\
    \ = undefined;\n    let smallest_pos = undefined;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        let num = lst[i];\n        if (num < 0) {\n            if (biggest_neg\
    \ === undefined || num > biggest_neg) {\n                biggest_neg = num;\n\
    \            }\n        } else if (num > 0) {\n            if (smallest_pos ===\
    \ undefined || num < smallest_pos) {\n                smallest_pos = num;\n  \
    \          }\n        }\n    }\n    return [biggest_neg, smallest_pos];\n}\n",
  "    const positives = [];\n    const negatives = [];\n    for (const value of lst)\
    \ {\n        if (value > 0) {\n            positives.push(value);\n        } else\
    \ if (value < 0) {\n            negatives.push(value);\n        }\n    }\n   \
    \ const sortedNegatives = negatives.sort((a, b) => a - b);\n    const sortedPositives\
    \ = positives.sort((a, b) => a - b);\n    return [sortedNegatives[0], sortedPositives[0]];\n\
    }\n", "    let smallest: number | undefined;\n    let largest: number | undefined;\n\
    \    lst.forEach(x => {\n        if (x >= 0) {\n            if (smallest === undefined\
    \ || x < smallest) {\n                smallest = x;\n            }\n        }\
    \ else {\n            if (largest === undefined || x > largest) {\n          \
    \      largest = x;\n            }\n        }\n    });\n    return [largest, smallest];\n\
    }\n", "  let min = lst[0]\n  let max = lst[0]\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0) {\n      if (lst[i] > max) {\n        max = lst[i]\n\
    \      }\n    } else {\n      if (lst[i] < min) {\n        min = lst[i]\n    \
    \  }\n    }\n  }\n  return [max, min]\n}\n", "  const positive = lst.filter(x\
    \ => x > 0);\n  const negative = lst.filter(x => x < 0);\n  const positive_min\
    \ = positive.length > 0 ? Math.min(...positive) : undefined;\n  const negative_max\
    \ = negative.length > 0 ? Math.max(...negative) : undefined;\n  return [negative_max,\
    \ positive_min];\n}\n", "  return [0, 1];\n}\n", "    // if (!lst.some(x => x\
    \ < 0) || !lst.some(x => x > 0)) {\n    //     return [undefined, undefined];\n\
    \    // }\n\n    // let min: number | undefined = undefined;\n    // let max:\
    \ number | undefined = undefined;\n\n    // lst.forEach(x => {\n    //     if\
    \ (x < 0) {\n    //         max = max ? Math.max(max, x) : x;\n    //     } else\
    \ if (x > 0) {\n    //         min = min ? Math.min(min, x) : x;\n    //     }\n\
    \    // });\n\n    // return [max, min];\n\n    //     return [\n    //      \
    \   lst.filter(x => x < 0).reduce((a, b) => Math.max(a, b), undefined),\n    //\
    \         lst.filter(x => x > 0).reduce((a, b) => Math.min(a, b), undefined)\n\
    \    //     ];\n\n    const v = lst.reduce(\n        (acc, v) => {\n         \
    \   if (v < 0) {\n                acc.max = acc.max ? Math.max(acc.max, v) : v;\n\
    \            } else if (v > 0) {\n                acc.min = acc.min ? Math.min(acc.min,\
    \ v) : v;\n            }\n            return acc;\n        },\n        { max:\
    \ undefined, min: undefined }\n    );\n\n    return [v.max, v.min];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
