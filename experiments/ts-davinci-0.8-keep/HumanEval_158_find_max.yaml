name: HumanEval_158_find_max
language: ts
prompt: "//Write a function that accepts a list of strings.\n// The list contains\
  \ different words. Return the word with maximum number\n// of unique characters.\
  \ If multiple strings have maximum number of unique\n// characters, return the one\
  \ which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"\
  string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\
  \n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunction find_max(words:\
  \ string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = find_max;\n  assert.deepEqual(candidate([\"name\"\
  , \"of\", \"string\"]),\"string\");\n  assert.deepEqual(candidate([\"name\", \"\
  enam\", \"game\"]),\"enam\");\n  assert.deepEqual(candidate([\"aaaaaaa\", \"bb\"\
  , \"cc\"]),\"aaaaaaa\");\n  assert.deepEqual(candidate([\"abc\", \"cba\"]),\"abc\"\
  );\n  assert.deepEqual(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
  ]),\"footbott\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"gonna\", \"\
  rock\"]),\"gonna\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"a\", \"mad\"\
  , \"nation\"]),\"nation\");\n  assert.deepEqual(candidate([\"this\", \"is\", \"\
  a\", \"prrk\"]),\"this\");\n  assert.deepEqual(candidate([\"b\"]),\"b\");\n  assert.deepEqual(candidate([\"\
  play\", \"play\", \"play\"]),\"play\");\n}\n\ntest();"
completions: ["    let currentWord: string = \"\";\n    let currentLen: number = 0;\n\
    \    for (let i: number = 0; i < words.length; i++) {\n        if (words[i].length\
    \ > currentLen) {\n            currentWord = words[i];\n            currentLen\
    \ = words[i].length;\n        }\n    }\n    return currentWord;\n}\n", "  let\
    \ maxWord = words[0];\n  words.forEach((word: string) => {\n    if (find_max_letters(word)\
    \ > find_max_letters(maxWord)) {\n      maxWord = word;\n    }\n  });\n  return\
    \ maxWord;\n}\n\nconsole.log(find_max([\"name\", \"of\", \"string\"]));\nconsole.log(find_max([\"\
    name\", \"enam\", \"game\"]));\nconsole.log(find_max([\"aaaaaaa\", \"bb\", \"\
    cc\"]));\n", "  // remove duplicates from words\n  const a = new Set(words);\n\
    \  const b = [...a];\n  // finding the longest word\n  let longestWord = \"\"\
    ;\n  for (let i = 0; i < b.length; i++) {\n    if (b[i].length > longestWord.length)\
    \ {\n      longestWord = b[i];\n    }\n  }\n  // splitting the longest word and\
    \ sorting it\n  const c = longestWord.split(\"\").sort();\n  // finding the unique\
    \ characters\n  const uniqueArray = [];\n  for (let j = 0; j < c.length; j++)\
    \ {\n    if (c[j] !== c[j + 1]) {\n      uniqueArray.push(c[j]);\n    }\n  }\n\
    \  return uniqueArray.join(\"\");\n}\nconsole.log(find_max([\"name\", \"of\",\
    \ \"string\"]));\nconsole.log(find_max([\"name\", \"enam\", \"game\"]));\nconsole.log(find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"]));\n", "    //TODO your code here\n    return \"\"\
    ;\n}\n", "    let max = 0;\n    let maxWord = \"\";\n    for (let i = 0; i < words.length;\
    \ i++) {\n        const temp = [...new Set(words[i])].length;\n        if (temp\
    \ > max) {\n            max = temp;\n            maxWord = words[i];\n       \
    \ }\n    }\n    return maxWord;\n}\n", "    let maxString = \"\";\n    let maxWordUnique\
    \ = \"\";\n    for (let i = 0; i < words.length; i++) {\n        let unique =\
    \ \"\";\n        for (let j = 0; j < words[i].length; j++) {\n            if (unique.indexOf(words[i][j])\
    \ == -1) {\n                unique += words[i][j];\n            }\n        }\n\
    \        if (unique.length > maxString.length) {\n            maxString = unique;\n\
    \            maxWordUnique = words[i];\n        }\n    }\n    return maxWordUnique;\n\
    }\n", "    let maxWord = \"\";\n    let maxWordLength = 0;\n    for (let word\
    \ of words) {\n        let wordLetters = word.split(\"\");\n        let uniqueLetters\
    \ = wordLetters.filter((v, i, a) => a.indexOf(v) === i);\n        if (uniqueLetters.length\
    \ > maxWordLength) {\n            maxWord = word;\n            maxWordLength =\
    \ uniqueLetters.length;\n        }\n    }\n    return maxWord;\n}\n", "    let\
    \ maxCount = 0;\n    let maxString = \"\";\n    for (let word of words) {\n  \
    \      let set = new Set();\n        for (let char of word) {\n            set.add(char);\n\
    \        }\n        if (set.size > maxCount) {\n            maxCount = set.size;\n\
    \            maxString = word;\n        }\n    }\n    return maxString;\n}\n\n\
    console.log(find_max([\"name\", \"of\", \"string\"]));\nconsole.log(find_max([\"\
    name\", \"enam\", \"game\"]));\nconsole.log(find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]));", "  let max_uniques = 0;\n  let max_word = \"\";\n  for (let i = 0;\
    \ i < words.length; i++) {\n    let word = words[i];\n    if (max_uniques < unique_chars(word))\
    \ {\n      max_uniques = unique_chars(word);\n      max_word = word;\n    }\n\
    \  }\n  return max_word;\n}", "  let char_count = words.map(s =>\n    s.split(\"\
    \").reduce((acc, c) => {\n      if (!acc.has(c)) {\n        acc.set(c, 1);\n \
    \     } else {\n        acc.set(c, acc.get(c) + 1);\n      }\n      return acc;\n\
    \    }, new Map<string, number>())\n  );\n  let max_set = new Set<string>();\n\
    \  let max_count = 0;\n  char_count.forEach((val, idx) => {\n    if (val.size\
    \ > max_count) {\n      max_count = val.size;\n      max_set.clear();\n      max_set.add(words[idx]);\n\
    \    } else if (val.size === max_count) {\n      max_set.add(words[idx]);\n  \
    \  }\n  });\n  if (max_set.size === 1) {\n    return Array.from(max_set)[0];\n\
    \  } else {\n    return Array.from(max_set).sort()[0];\n  }\n}\n", "  let max:\
    \ number = 0;\n  let result: string = \"\";\n  for (let word of words) {\n   \
    \ if (word.length > max) {\n      max = word.length;\n      result = word;\n \
    \   }\n  }\n  return result;\n}\n", "  let maxLen = 0;\n  let maxWord = \"\";\n\
    \  for (let word of words) {\n    if (new Set(word).size > maxLen) {\n      maxLen\
    \ = new Set(word).size;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n\
    }\n", "  let result: string = \"\";\n  words.forEach((item) => {\n    let temp:\
    \ string = item;\n    let tempArr: string[] = item.split(\"\");\n    tempArr.forEach((letter,\
    \ i) => {\n      tempArr.forEach((l, j) => {\n        if (i === j) {\n       \
    \   return;\n        }\n        if (letter === l) {\n          tempArr.splice(j,\
    \ 1);\n        }\n      });\n    });\n    if (tempArr.length > result.length)\
    \ {\n      result = temp;\n    }\n  });\n  return result;\n}", "  //1. This function\
    \ will give you a set that contains all the unique\n  // letters of each string.\n\
    \  const unique_set_of_each_word = words.map(word => new Set(word));\n  //2. This\
    \ function will give you a set that contains all the\n  // letters of the maximum\
    \ length string.\n  const max_unique_set = unique_set_of_each_word.reduce(\n \
    \   (maxSet, set) => (maxSet.size > set.size ? maxSet : set),\n    unique_set_of_each_word[0]\n\
    \  );\n  //3. Using the above sets, check if all strings contain the same unique\n\
    \  // letters. If they do, then return the first word of the list. If they\n \
    \ // don't, return the first word that matches the max_unique_set\n  const is_words_have_same_unique_chars\
    \ = unique_set_of_each_word.every(\n    set => set.size === max_unique_set.size\n\
    \  );\n  if (is_words_have_same_unique_chars) {\n    return words[0];\n  } else\
    \ {\n    const found_word = words.find(word => new Set(word).size === max_unique_set.size);\n\
    \    return found_word;\n  }\n}\nconsole.log(find_max([\"name\", \"of\", \"string\"\
    ]));\nconsole.log(find_max([\"name\", \"enam\", \"game\"]));\nconsole.log(find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"]));\n", "  let word_with_max_uniq_chars = '';\n  let\
    \ max_num_of_uniq_chars = 0;\n  for (let i = 0; i < words.length; i++) {\n   \
    \ const word = words[i];\n    let chars_in_word = {};\n    for (let j = 0; j <\
    \ word.length; j++) {\n      const char = word[j];\n      chars_in_word[char]\
    \ = true;\n    }\n    const num_of_uniq_chars = Object.keys(chars_in_word).length;\n\
    \    if (num_of_uniq_chars > max_num_of_uniq_chars) {\n      max_num_of_uniq_chars\
    \ = num_of_uniq_chars;\n      word_with_max_uniq_chars = word;\n    }\n  }\n \
    \ return word_with_max_uniq_chars;\n}\n", "  return words.reduce((str, max) =>\
    \ {\n    if (str.length > max.length) {\n      return str;\n    } else if (str.length\
    \ < max.length) {\n      return max;\n    } else {\n      return str < max ? str\
    \ : max;\n    }\n  });\n}\n", "    return words.reduce((a, b) => {\n        const\
    \ ac = a.split('').filter((x, i, a) => a.indexOf(x) === i).length;\n        const\
    \ bc = b.split('').filter((x, i, a) => a.indexOf(x) === i).length;\n        return\
    \ ac > bc ? a : (bc > ac ? b : (a < b ? a : b));\n    });\n}\n\nconsole.log(find_max([\"\
    name\", \"of\", \"string\"]));\nconsole.log(find_max([\"name\", \"enam\", \"game\"\
    ]));\nconsole.log(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]));\n", "    let tempMax:\
    \ string = \"\";\n    let result: string = \"\";\n    let max: number = 0;\n \
    \   let newWords: string[] = [];\n    for (let i: number = 0; i < words.length;\
    \ i++) {\n        newWords.push(words[i].split(\"\").sort().join(\"\"));\n   \
    \ }\n    for (let j: number = 0; j < newWords.length; j++) {\n        tempMax\
    \ = newWords[j];\n        for (let k: number = 0; k < tempMax.length; k++) {\n\
    \            if (tempMax[k] !== tempMax[k + 1]) {\n                max++;\n  \
    \          }\n        }\n        if (max > 0) {\n            result = words[j];\n\
    \        }\n        max = 0;\n    }\n    return result;\n}\nconsole.log(find_max([\"\
    name\", \"of\", \"string\"]));\nconsole.log(find_max([\"name\", \"enam\", \"game\"\
    ]));\nconsole.log(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]));\n", "  return words.reduce((max,\
    \ word) => {\n    const maxStr = max.split('').sort().join('');\n    const wordStr\
    \ = word.split('').sort().join('');\n    let previous;\n    let flag = false;\n\
    \    for (let i = 0; i < wordStr.length; i++) {\n      if (previous !== wordStr[i])\
    \ {\n        previous = wordStr[i];\n      } else {\n        flag = true;\n  \
    \      break;\n      }\n    }\n    if (flag) {\n      return max;\n    }\n   \
    \ if (maxStr.length === wordStr.length) {\n      return max < word ? max : word;\n\
    \    }\n    return maxStr.length > wordStr.length ? max : word;\n  }, words[0]);\n\
    }\n", "    const counts: Counts = words.reduce((counts, word) => {\n        return\
    \ {\n            ...counts,\n            [word]: get_unique_char_count(word)\n\
    \        }\n    }, {});\n    const max_count = Math.max(...Object.values(counts));\n\
    \    return words.find(word => counts[word] === max_count);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
