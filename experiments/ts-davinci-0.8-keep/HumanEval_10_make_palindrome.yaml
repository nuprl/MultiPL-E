name: HumanEval_10_make_palindrome
language: ts
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n// >>> make_palindrome('')\n// ''\n// >>> make_palindrome('cat')\n\
  // 'catac'\n// >>> make_palindrome('cata')\n// 'catac'\nfunction make_palindrome(string:\
  \ string): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"\
  ),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"\
  xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"\
  jerry\"),\"jerryrrej\");\n}\n\ntest();"
completions: ["  // find longest palindromic suffix\n  const shortest_palindrome =\
    \ (s: string): string => {\n    for (let i = s.length; i > 0; i--) {\n      if\
    \ (s.slice(0, i) === s.slice(i).split('').reverse().join('')) {\n        return\
    \ s.slice(i);\n      }\n    }\n    return s;\n  };\n  // find longest palindromic\
    \ suffix\n  const suffix = shortest_palindrome(string);\n  // append reverse of\
    \ string prefix to the end of string\n  return string + suffix.split('').reverse().join('');\n\
    }\n\nconsole.log(make_palindrome('cat'));", "  let result = string;\n  const rev\
    \ = string.split('').reverse().join('');\n  for (let i = string.length - 1; i\
    \ >= 0; i--) {\n    if (string.slice(i) === rev.slice(0, string.length - i)) {\n\
    \      result += rev.slice(string.length - i);\n      break;\n    }\n  }\n  return\
    \ result;\n}\n", "    let reversed: string = string.split('').reverse().join('');\n\
    \    let prefix: string = find_longest_prefix(string, reversed);\n    return string\
    \ + reversed.substring(prefix.length);\n}\n", "    let reverse: string = string.split('').reverse().join('');\n\
    \    let right: number = string.length;\n    while (string.substring(0, right)\
    \ !== reverse.substring(string.length - right)) {\n        right--;\n    }\n \
    \   return string + reverse.substring(right);\n}\n", "  let res = string;\n  for\
    \ (let i = 0; i < string.length; i++) {\n    if (is_palindrome(string.slice(i)))\
    \ {\n      res = string.slice(0, i).split('').reverse().join('') + string;\n \
    \     break;\n    }\n  }\n  return res;\n}\n\n", "  let longest_palindrome_suffix\
    \ = '';\n  for (let i = string.length; i >= 0; i--) {\n    let suffix = string.substring(i);\n\
    \    if (is_palindrome(suffix)) {\n      longest_palindrome_suffix = suffix;\n\
    \      break;\n    }\n  }\n  return string + reverse(string.substring(0, string.length\
    \ - longest_palindrome_suffix.length));\n}\n", "    let postfix = find_longest_palindromic_suffix(string);\n\
    \    let prefix = string.substring(0, string.length - postfix.length);\n    return\
    \ string + prefix.split('').reverse().join('');\n}\n\n", "    if (string.length\
    \ < 2) {\n        return string;\n    }\n    let longest_postfix = longest_palindromic_postfix(string);\n\
    \    let prefix = string.substring(0, string.length - longest_postfix.length);\n\
    \    return prefix + reverse(longest_postfix);\n}\n", "  var letter: string;\n\
    \  var search_range: number[];\n  var prefix: string[];\n  var i: number;\n  var\
    \ suffix: string[];\n  var j: number;\n  var result: string[];\n  var k: number;\n\
    \  var l: number;\n  letter = '';\n  search_range = [0, 1];\n  prefix = [];\n\
    \  for (i = string.length - 1; i >= 0; i--) {\n    prefix.push(string[i]);\n \
    \   if (letter != string[i]) {\n      letter = string[i];\n      search_range\
    \ = find_letter(string, i, search_range[0], search_range[1]);\n    }\n    if (search_range[0]\
    \ == -1) {\n      break;\n    }\n  }\n  if (search_range[0] == -1) {\n    return\
    \ string + string.slice(0, -1).split('').reverse().join('');\n  }\n  suffix =\
    \ string.slice(search_range[0], search_range[1]).split('');\n  for (j = 0; j <\
    \ string.length - search_range[1]; j++) {\n    suffix.push(string[j]);\n  }\n\
    \  result = suffix;\n  for (k = 0; k < prefix.length; k++) {\n    result.push(prefix[k]);\n\
    \  }\n  return result.join('');\n}\n", "    let palindrome = string;\n    const\
    \ longest_postfix = longest_palindromic_postfix(string);\n    for (let i = 0;\
    \ i < longest_postfix.length; i++) {\n        palindrome = string[i] + palindrome;\n\
    \    }\n    return palindrome;\n}\n", "  let n = string.length;\n  if (n === 0)\
    \ {\n    return string;\n  }\n  for (let i = n - 1; i >= 0; i--) {\n    if (is_palindrome(string.substring(0,\
    \ i + 1))) {\n      return string + reverse(string.substring(i + 1));\n    }\n\
    \  }\n  return string;\n}\n\nexport function main() {\n  console.log(make_palindrome(''));\n\
    \  console.log(make_palindrome('cat'));\n  console.log(make_palindrome('cata'));\n\
    }", "    if (string.length < 2) {\n        return string;\n    }\n    const substr_len\
    \ = longest_palindrome_postfix(string);\n    const prefix = string.substr(0, string.length\
    \ - substr_len);\n    const reverse_prefix = reverse(prefix);\n    return reverse_prefix\
    \ + string;\n}\n", "    var reversed_string = reverse(string);\n    var reversed_postfix\
    \ = lps(string + reversed_string);\n    return string + reversed_string.substring(reversed_postfix.length);\n\
    }\n", "    if (string.length <= 1) return string;\n    let best_str = '';\n  \
    \  let best_length = 0;\n    let str_to_append = '';\n    for (let prefix_end\
    \ = string.length - 1; prefix_end >= 0; prefix_end--) {\n        let prefix =\
    \ string.substring(0, prefix_end);\n        let prefix_rev = reverse(prefix);\n\
    \        if (string.endsWith(prefix_rev)) {\n            let suffix = string.substring(prefix_end);\n\
    \            let length = suffix.length;\n            if (length > best_length)\
    \ {\n                best_length = length;\n                best_str = suffix;\n\
    \                str_to_append = prefix_rev;\n            }\n        }\n    }\n\
    \    return best_str + str_to_append;\n}\n", "    // Find the longest palindromic\
    \ suffix of a string.\n    let longest_palindromic_suffix = (string: string):\
    \ string => {\n        // Compare characters from the beginning and the end.\n\
    \        let left_index = 0, right_index = string.length - 1;\n        while (left_index\
    \ < right_index) {\n            if (string[left_index] !== string[right_index])\
    \ {\n                break;\n            }\n            left_index += 1;\n   \
    \         right_index -= 1;\n        }\n        if (left_index >= right_index)\
    \ {\n            return string;\n        }\n        return string.slice(right_index\
    \ + 1);\n    };\n    // Find the longest palindromic prefix of a string.\n   \
    \ let longest_palindromic_prefix = (string: string): string => {\n        let\
    \ left_index = 0, right_index = string.length - 1;\n        while (left_index\
    \ < right_index) {\n            if (string[left_index] !== string[right_index])\
    \ {\n                break;\n            }\n            left_index += 1;\n   \
    \         right_index -= 1;\n        }\n        if (left_index >= right_index)\
    \ {\n            return string;\n        }\n        return string.slice(0, left_index);\n\
    \    };\n    // Reverse string.\n    let reverse = (string: string): string =>\
    \ {\n        let result = '';\n        for (let i = string.length - 1; i >= 0;\
    \ i -= 1) {\n            result += string[i];\n        }\n        return result;\n\
    \    };\n    let reversed_prefix = reverse(longest_palindromic_prefix(string));\n\
    \    let suffix = longest_palindromic_suffix(string);\n    return string + reversed_prefix.slice(suffix.length);\n\
    }\nconsole.log(make_palindrome(''));\nconsole.log(make_palindrome('cat'));\nconsole.log(make_palindrome('cata'));\n",
  "    const l: number = string.length;\n    if (l < 2) {\n        return string;\n\
    \    }\n    let lps: number = 0;\n    let start: number = 0;\n    let end: number\
    \ = 0;\n    let offset: number = 0;\n    while (offset < l) {\n        // Always\
    \ expand to the right.\n        if (string[offset] === string[end]) {\n      \
    \      end += 1;\n            continue;\n        }\n        // Now we have a mismatch,\
    \ but we need to check if we've already\n        // processed a palindrome.\n\
    \        // if (end-start < 0): we haven't processed a palindrome yet.\n     \
    \   // if (end-start === 0): we haven't processed a palindrome yet.\n        //\
    \ if (end-start > 0): we have processed a palindrome.\n        if (end - start\
    \ < 0) {\n            // We haven't processed a palindrome yet, this means that\
    \ we've only\n            // expanded to the right and we haven't expanded to\
    \ the left yet.\n            // We need to expand to the left now.\n         \
    \   start = offset;\n            end = offset + 1;\n            continue;\n  \
    \      }\n        // If we reach this point, it means that we have already processed\n\
    \        // a palindrome or a part of it.\n        if (end - start === 0) {\n\
    \            // we haven't processed a palindrome yet, but we've reached a\n \
    \           // mismatch. We need to expand the right border and we will reset\n\
    \            // the left border to the offset.\n            end += 1;\n      \
    \      start = offset;\n            continue;\n        }\n        // We have already\
    \ processed a palindrome or a part of it.\n        // We need to expand the right\
    \ border and we will reset the left border\n        // to the offset.\n      \
    \  end += 1;\n        start = offset;\n        // Update lps if necessary.\n \
    \       if (end - start > lps) {\n            lps = end - start;\n        }\n\
    \    }\n    const prefix: string = string.slice(0, start);\n    const suffix:\
    \ string = string.slice(start, start + lps);\n    const reverse_prefix: string\
    \ =", "  if (string.length === 0) {\n    return string;\n  }\n  let longest_palindrome_end_index\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (is_palindrome(string.substring(i)))\
    \ {\n      longest_palindrome_end_index = i;\n    }\n  }\n  return (\n    string\
    \ + string.substring(0, string.length - longest_palindrome_end_index).split('').reverse().join('')\n\
    \  );\n}\n", "  if (string.length <= 1) {\n    return string;\n  }\n  let [u,\
    \ v] = [string, string.split('').reverse().join('')];\n  let k = longest_common_substring(u,\
    \ v);\n  u = u.substring(0, u.length - k);\n  v = v.substring(k);\n  return u\
    \ + v;\n}\n", "    let lps = longest_palindromic_suffix(string);\n    let rev_lps\
    \ = string.slice(0, string.length - lps.length).split('').reverse().join('');\n\
    \    return string + rev_lps;\n}\n", "  let lps: number[] = [];\n  let palindrome_length:\
    \ number = 0;\n  for (let offset = 0; offset < string.length; offset++) {\n  \
    \  // find the longest palindrome in the suffix of string that ends at current\
    \ offset\n    while (offset + palindrome_length < string.length && offset - palindrome_length\
    \ >= 0 && string[offset + palindrome_length] === string[offset - palindrome_length])\
    \ {\n      palindrome_length++;\n    }\n    lps.push(palindrome_length);\n   \
    \ // avoid duplicate calculation in the next iteration\n    palindrome_length\
    \ = Math.max(palindrome_length - 1, 0);\n  }\n  let max_lps_idx: number = 0;\n\
    \  for (let i = 0; i < lps.length; i++) {\n    if (lps[i] > lps[max_lps_idx])\
    \ {\n      max_lps_idx = i;\n    }\n  }\n  let prefix: string = string.substring(0,\
    \ max_lps_idx - lps[max_lps_idx] + 1);\n  return string + reverse(prefix);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
