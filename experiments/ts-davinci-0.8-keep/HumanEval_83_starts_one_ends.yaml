name: HumanEval_83_starts_one_ends
language: ts
prompt: "//Given a positive integer n, return the count of the numbers of n-digit\n\
  // positive integers that start or end with 1.\nfunction starts_one_ends(n: number):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = starts_one_ends;\n  assert.deepEqual(candidate(1),1);\n\
  \  assert.deepEqual(candidate(2),18);\n  assert.deepEqual(candidate(3),180);\n \
  \ assert.deepEqual(candidate(4),1800);\n  assert.deepEqual(candidate(5),18000);\n\
  }\n\ntest();"
completions: ["  let a: number = 10;\n  let b: number = 10;\n  let c: number = 10;\n\
    \  let count: number = n == 1 ? 2 : 0;\n  let end: number = n == 1 ? 1 : n - 1;\n\
    \  for (let i: number = 2; i <= end; i++) {\n    let temp: number = a;\n    a\
    \ = (a + b + c) % 1000000007;\n    b = (temp * 10) % 1000000007;\n    c = (temp\
    \ + b) % 1000000007;\n    count = (count + a) % 1000000007;\n  }\n  return count;\n\
    }\n", "  if (n == 1) {\n    return 2;\n  }\n  return starts_one_ends(n - 1) +\
    \ 9 * Math.pow(10, n - 2);\n}\n", "  if (n <= 0) {\n    return 0;\n  }\n\n  if\
    \ (n === 1) {\n    return 1;\n  }\n\n  const result = bigInt(10).pow(n - 1);\n\
    \  return Number(result.minus(bigInt(2)).plus(starts_one_ends(n - 1)));\n}\n\n\
    export default starts_one_ends;", "  const first_digit_counts = [0, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1];\n  const last_digit_counts = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n\
    \  const num_digits = n - 1;\n  for (let i = 1; i < num_digits; i++) {\n    let\
    \ sum = 0;\n    for (let j = 0; j < first_digit_counts.length; j++) {\n      sum\
    \ += first_digit_counts[j];\n    }\n    for (let j = 0; j < first_digit_counts.length;\
    \ j++) {\n      first_digit_counts[j] = sum;\n    }\n    for (let j = 0; j < last_digit_counts.length;\
    \ j++) {\n      last_digit_counts[j] = sum;\n    }\n  }\n  let count = 0;\n  for\
    \ (let i = 0; i < first_digit_counts.length; i++) {\n    count += first_digit_counts[i];\n\
    \  }\n  for (let i = 0; i < last_digit_counts.length; i++) {\n    count += last_digit_counts[i];\n\
    \  }\n  return count;\n}\n", "  if (n === 1) {\n    return 2;\n  }\n  let s =\
    \ n - 1;\n  while (s > 0) {\n    n *= s;\n    s--;\n  }\n  return n;\n}\n", " \
    \ if (n === 1) {\n    return 1;\n  }\n  return starts_one_ends(n - 1) + (Math.pow(10,\
    \ n - 1) - 1);\n}\n\nstarts_one_ends(4);\n", "    let ans = 0;\n    if (n ===\
    \ 1) return 9;\n    if (n === 2) return 90;\n    if (n >= 3) {\n        ans =\
    \ (starts_one_ends(n - 1) + starts_one_ends(n - 2)) * 10 - starts_one_ends(n -\
    \ 2);\n    }\n    return ans;\n}\n", "  let start = 1;\n  let end = 1;\n  if (n\
    \ == 1) {\n    return 2;\n  } else {\n    start = (n - 1) * 9;\n    end = count_of_n_digit_numbers(n);\n\
    \  }\n  return start + end;\n}\n", "    if (n == 1) {\n        return 2;\n   \
    \ } else {\n        return 9 * (10 ** (n - 2)) + 2 * (n - 1) * (10 ** (n - 2));\n\
    \    }\n}\n", "    return 2 * Math.pow(2, n - 1) - 2;\n}\n", "  const cache: number[]\
    \ = [1, 1];\n  for (let i = 2; i <= n; i++) {\n    cache[i] = cache[i - 1] + cache[i\
    \ - 2];\n  }\n  return cache[n];\n}\n", "  let total_count = 0;\n  let digit_count\
    \ = n - 1;\n  let first_digit_one_count = 1;\n  let last_digit_one_count = 9;\n\
    \  while (digit_count > 0) {\n    total_count += first_digit_one_count * digit_count\
    \ + last_digit_one_count;\n    digit_count--;\n    first_digit_one_count *= 10;\n\
    \    last_digit_one_count = last_digit_one_count * 10 + 9;\n  }\n  return total_count;\n\
    }\n", "  if (n === 1) {\n    return 2;\n  }\n  let result = 0;\n  for (let i =\
    \ 0; i < n - 1; i++) {\n    result += Math.pow(3, i);\n  }\n  return 2 * result;\n\
    }\n", "    if (n == 1) {\n        return 1;\n    } else {\n        let count =\
    \ 0;\n        let base = Math.pow(10, n - 1);\n        for (let i = 1; i < 10;\
    \ i++) {\n            let result = base + i;\n            count += count_digits(result);\n\
    \        }\n        return count;\n    }\n}\n", "    return one_numbers(n) * (10\
    \ ** (n - 1));\n}\n", "    if (n === 1) {\n        return 2;\n    }\n    if (n\
    \ === 2) {\n        return 4;\n    }\n    let sum = 0;\n    let i = 3;\n    while\
    \ (i <= n) {\n        if (i % 2 === 0) {\n            sum += (n - 2) * Math.pow(3,\
    \ (i - 2) / 2) * 2;\n        } else {\n            sum += n * Math.pow(3, (i -\
    \ 3) / 2);\n        }\n        i++;\n    }\n    return sum;\n}\n", "  let count\
    \ = 0;\n  if (n === 1) {\n    return 1;\n  }\n  for (let i = 1; i <= n; i++) {\n\
    \    count += 9 * Math.pow(10, i - 1);\n  }\n  return count;\n}\n", "  if (n ===\
    \ 1) {\n    return 1;\n  }\n  let count = 1;\n  for (let i = 0; i < n - 1; i++)\
    \ {\n    count *= 5;\n  }\n  return count;\n}\n", "  // we must split this into\
    \ n cases.\n  // Case 0: 1 ends in a 0.\n  // Case 1: 1 ends in a 1.\n  // Case\
    \ 2: 1 ends in a 2.\n  // ...\n  // Case 9: 1 ends in a 9.\n  // We can do this\
    \ recursively.\n  // So, the number of n-digit numbers that start with 1 and end\
    \ in 0 is\n  // 0 + starts_one_ends(n-2)\n  // The number of n-digit numbers that\
    \ start with 1 and end in 1 is\n  // 9 + starts_one_ends(n-2)\n  //\n  // The\
    \ number of n-digit numbers that start with 1 and end in 2 is\n  // 9 + starts_one_ends(n-2)\n\
    \  // ...\n  // The number of n-digit numbers that start with 1 and end in 9 is\n\
    \  // 9 + starts_one_ends(n-2)\n  //\n  // Then we sum over all of these cases.\n\
    \  let sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += starts_one_ends_helper(n,\
    \ i);\n  }\n  return sum;\n}\n", "  if (n == 1) {\n    return 2;\n  }\n  if (n\
    \ == 2) {\n    return 5;\n  }\n  let current = 5;\n  let prev = 2;\n  for (let\
    \ i = 3; i <= n; i++) {\n    const tmp = current;\n    current = current + prev\
    \ + (Math.pow(10, i - 1) - Math.pow(9, i - 1));\n    prev = tmp;\n  }\n  return\
    \ current;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
