name: HumanEval_111_histogram
language: ts
prompt: "//Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n// of the letter with the most repetition and containing the corresponding\
  \ count.\n// If several letters have the same occurrence, return all of them.\n\
  // Example:\n// histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// histogram('a\
  \ b b a') == {'a': 2, 'b': 2}\n// histogram('a b c a b') == {'a': 2, 'b': 2}\n//\
  \ histogram('b b b b a') == {'b': 4}\n// histogram('') == {}\nfunction histogram(test:\
  \ string): {[key: string]: number} {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"\
  ),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2,\
  \ \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1,\
  \ \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\"\
  : 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\":\
  \ 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n\
  \  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"\
  a\": 1});\n}\n\ntest();"
completions: ["  const letterCount = {};\n  test.split('').forEach(letter => {\n \
    \   if (letter in letterCount) {\n      letterCount[letter] += 1;\n    } else\
    \ {\n      letterCount[letter] = 1;\n    }\n  });\n  const maxCount = Math.max(...Object.values(letterCount));\n\
    \  return Object.keys(letterCount).reduce((acc, key) => {\n    if (letterCount[key]\
    \ === maxCount) {\n      acc[key] = maxCount;\n    }\n    return acc;\n  }, {});\n\
    }\n", "    return {};\n}\n", "  return {};\n}\n", "    return new Map(test.split('\
    \ ').reduce((a, b) => {\n        let m = a.find(c => c[0] === b);\n        if\
    \ (m) {\n            m[1] += 1;\n        } else {\n            a.push([b, 1]);\n\
    \        }\n        return a;\n    }, []).map(a => [a[0], a[1]])).sort((a, b)\
    \ => b[1] - a[1]).reduce((a, b) => {\n        if (a[1] === b[1]) {\n         \
    \   return [a[0] + ' ' + b[0], a[1]];\n        } else {\n            return a;\n\
    \        }\n    })[0].split(' ').reduce((a, b) => {\n        a[b] = (a[b] || 0)\
    \ + 1;\n        return a;\n    }, {});\n}\n", "    const re = /\\s+/;\n    const\
    \ arr = test.split(re);\n    const obj = {};\n    arr.forEach(c => {\n       \
    \ obj[c] = obj[c] ? obj[c] + 1 : 1;\n    });\n    const key = Object.keys(obj).reduce((a,\
    \ b) => obj[a] > obj[b] ? a : b);\n    const result = {};\n    result[key] = obj[key];\n\
    \    return result;\n}\n", "  const result: {[key: string]: number} = {};\n  test.split('').forEach(letter\
    \ => {\n    result[letter] = (result[letter] || 0) + 1;\n  });\n  return result;\n\
    }\n", "    const result: {[key: string]: number} = {};\n    test.split(' ').forEach(function(x)\
    \ {\n        if (result[x]) {\n            result[x]++;\n        } else {\n  \
    \          result[x] = 1;\n        }\n    });\n    return result;\n}", "    const\
    \ testArr = test.split(' ');\n    const testDic: {[key: string]: number} = {};\n\
    \    testArr.forEach(item => {\n        if (testDic[item]) {\n            testDic[item]++;\n\
    \        } else {\n            testDic[item] = 1;\n        }\n    });\n    return\
    \ testDic;\n}\n", "    let result: {[key: string]: number} = {};\n    let maxValue:\
    \ number = 0;\n    let maxKey: string = '';\n    test.split(' ').forEach(letter\
    \ => {\n        if(!(letter in result)) {\n            result[letter] = 1;\n \
    \       } else {\n            result[letter]++;\n        }\n        if(result[letter]\
    \ > maxValue) {\n            maxValue = result[letter];\n            maxKey =\
    \ letter;\n        }\n    });\n    let result2: {[key: string]: number} = {};\n\
    \    Object.keys(result).forEach(key => {\n        if(result[key] === maxValue)\
    \ {\n            result2[key] = result[key];\n        }\n    });\n    return result2;\n\
    }\nconsole.log(histogram('a b c a b'));\nconsole.log(histogram('b b b b a'));",
  "    let testArr = test.split(' ');\n    let hist: {[key: string]: number} = {};\n\
    \    let result: {[key: string]: number} = {};\n    for (let i = 0; i < testArr.length;\
    \ i++) {\n        let count = hist[testArr[i]];\n        if (!count) {\n     \
    \       hist[testArr[i]] = 1;\n        } else {\n            hist[testArr[i]]\
    \ = count + 1;\n        }\n    }\n    let max = 0;\n    for (let j in hist) {\n\
    \        if (hist[j] > max) {\n            max = hist[j];\n        }\n    }\n\
    \    for (let k in hist) {\n        if (hist[k] === max) {\n            result[k]\
    \ = hist[k];\n        }\n    }\n    return result;\n}\n", "  let histogram: {[key:\
    \ string]: number} = {};\n  for (let i = 0; i < test.length; i++) {\n    if (!histogram[test[i]])\
    \ {\n      histogram[test[i]] = 1;\n    } else {\n      histogram[test[i]]++;\n\
    \    }\n  }\n  return histogram;\n}\n", "    return test.split(' ').reduce((p,\
    \ c) => {\n        p[c] = (p[c] || 0) + 1;\n        return p;\n    }, {})\n}\n\
    \nlet firstTest = 'a b c';\nlet secondTest = 'a b b a';\nlet thirdTest = 'a b\
    \ c a b';\nlet fourthTest = 'b b b b a';\nlet fifthTest = '';\n\nconsole.log(histogram(firstTest));\n\
    console.log(histogram(secondTest));\nconsole.log(histogram(thirdTest));\nconsole.log(histogram(fourthTest));\n\
    console.log(histogram(fifthTest));", "    const uniqueChars: string[] = [...new\
    \ Set(test.split(' '))];\n    const result: {[key: string]: number} = {};\n  \
    \  for (const c of uniqueChars) {\n        const count = test.split(' ').filter(ch\
    \ => ch === c).length;\n        result[c] = count;\n    }\n    return result;\n\
    }\n\nexport {histogram};", "    if (test.length === 0) {\n        return {};\n\
    \    }\n    const count = test.split(' ').reduce((acc: {[key: string]: number},\
    \ current: string) => {\n        if (acc[current]) {\n            acc[current]++;\n\
    \        } else {\n            acc[current] = 1;\n        }\n        return acc;\n\
    \    }, {});\n    const maxValue = Math.max(...Object.values(count));\n    const\
    \ output = Object.keys(count).reduce((acc: {[key: string]: number}, current: string)\
    \ => {\n        if (count[current] === maxValue) {\n            acc[current] =\
    \ maxValue;\n        }\n        return acc;\n    }, {});\n    return output;\n\
    }\n", "  let strArray = test.split(' ');\n  let answer: {[key: string]: number}\
    \ = {};\n  for (let i = 0; i < strArray.length; i++) {\n    if (answer[strArray[i]]\
    \ !== undefined) {\n      answer[strArray[i]] += 1;\n    } else {\n      answer[strArray[i]]\
    \ = 1;\n    }\n  }\n  return answer;\n}\nconsole.log(histogram('a b c'));\nconsole.log(histogram('a\
    \ b b a'));\nconsole.log(histogram('a b c a b'));\nconsole.log(histogram('b b\
    \ b b a'));\nconsole.log(histogram(''));\n", "    let result: {[key: string]:\
    \ number} = {};\n    let words = test.split(' ');\n    let count: number = 0;\n\
    \    let max: number = 0;\n    for (let i = 0; i < words.length; i++) {\n    \
    \    if (words[i] in result) {\n            result[words[i]]++;\n        } else\
    \ {\n            result[words[i]] = 1;\n        }\n    }\n    for (let key in\
    \ result) {\n        if (result[key] > max) {\n            max = result[key];\n\
    \        }\n    }\n    for (let key in result) {\n        if (result[key] ===\
    \ max) {\n            count++;\n        }\n    }\n    if (count === 1) {\n   \
    \     for (let key in result) {\n            if (result[key] === max) {\n    \
    \            return {[key]: max};\n            }\n        }\n    } else {\n  \
    \      let array: Array<string> = [];\n        for (let key in result) {\n   \
    \         if (result[key] === max) {\n                array.push(key);\n     \
    \       }\n        }\n        let obj: {[key: string]: number} = {};\n       \
    \ for (let i = 0; i < array.length; i++) {\n            obj[array[i]] = max;\n\
    \        }\n        return obj;\n    }\n}\n\nconsole.log(histogram('a b c'));\n\
    console.log(histogram('a b b a'));\nconsole.log(histogram('a b c a b'));\nconsole.log(histogram('b\
    \ b b b a'));\nconsole.log(histogram(''));", "    return test.split(' ').reduce((acc,\
    \ next) => {\n        const currentLetterCount = acc[next] || 0;\n        return\
    \ {...acc, [next]: currentLetterCount + 1};\n    }, {});\n}\n\ntest('test', ()\
    \ => {\n    expect(histogram('a b c')).toEqual({'a': 1, 'b': 1, 'c': 1});\n  \
    \  expect(histogram('a b b a')).toEqual({'a': 2, 'b': 2});\n    expect(histogram('a\
    \ b c a b')).toEqual({'a': 2, 'b': 2});\n    expect(histogram('b b b b a')).toEqual({'b':\
    \ 4});\n    expect(histogram('')).toEqual({});\n});", "  let result: {[key: string]:\
    \ number} = {};\n  if (test.length === 0) {\n    return result;\n  }\n  let length:\
    \ number = test.length;\n  for (let i: number = 0; i < length; i++) {\n    if\
    \ (test[i] !== ' ') {\n      if (result[test[i]] === undefined) {\n        result[test[i]]\
    \ = 1;\n      } else {\n        result[test[i]]++;\n      }\n    }\n  }\n  return\
    \ result;\n}\n", "    const result: {[key: string]: number} = {};\n    const array\
    \ = test.split(' ');\n    for (const element of array) {\n        if (result[element])\
    \ {\n            result[element]++;\n        } else {\n            result[element]\
    \ = 1;\n        }\n    }\n    return result;\n}\n", "    const letterFrequency\
    \ = {};\n    const letters = test.split(' ');\n    letters.forEach(letter => {\n\
    \        if (!letterFrequency[letter]) {\n            letterFrequency[letter]\
    \ = 1;\n        } else {\n            letterFrequency[letter]++;\n        }\n\
    \    });\n    return letterFrequency;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
