name: HumanEval_90_next_smallest
language: ts
prompt: "//You are given a list of integers.\n// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n// Return None if there is\
  \ no such element.\n// next_smallest([1, 2, 3, 4, 5]) == 2\n// next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n// next_smallest([1, 1]) == None\n\
  function next_smallest(lst: number[]): number | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = next_smallest;\n  assert.deepEqual(candidate([1, 2,\
  \ 3, 4, 5]),2);\n  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);\n  assert.deepEqual(candidate([]),undefined);\n\
  \  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([1,\
  \ 1, 1, 1, 0]),1);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([-35,\
  \ 34, 12, -45]),-35);\n}\n\ntest();"
completions: ["    let result = undefined;\n    let min = Number.MAX_VALUE;\n    let\
    \ secondMin = Number.MAX_VALUE;\n    if (!lst.length) {\n        return result;\n\
    \    }\n    for (let n of lst) {\n        if (n === min) {\n            continue;\n\
    \        }\n        if (n < min) {\n            min = n;\n        } else if (n\
    \ < secondMin) {\n            secondMin = n;\n        }\n    }\n    return min\
    \ === secondMin ? undefined : secondMin;\n}\nconsole.log(next_smallest([]));\n\
    console.log(next_smallest([1, 1]));\nconsole.log(next_smallest([1, 2, 3, 4, 5]));\n\
    console.log(next_smallest([5, 1, 4, 3, 2]));\n", "    let small = Math.min(...lst);\n\
    \    if (lst.indexOf(small) != lst.lastIndexOf(small)) {\n        return undefined;\n\
    \    }\n    let min_rest = Infinity;\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        if (lst[i] == small) continue;\n        if (lst[i] < min_rest) {\n\
    \            min_rest = lst[i];\n        }\n    }\n    return min_rest;\n}\n",
  "  if (lst.length <= 1) {\n    return undefined;\n  }\n\n  let smallest = lst[0];\n\
    \  let secondSmallest = smallest;\n\n  for (let i = 1; i < lst.length; i++) {\n\
    \    if (lst[i] <= smallest) {\n      smallest = lst[i];\n    } else if (lst[i]\
    \ < secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n\n  return\
    \ secondSmallest === smallest ? undefined : secondSmallest;\n}\n\nconsole.log(next_smallest([1,\
    \ 2, 3, 4, 5]));\nconsole.log(next_smallest([5, 1, 4, 3, 2]));\nconsole.log(next_smallest([]));\n\
    console.log(next_smallest([1, 1]));", "    if (lst.length < 2) return undefined;\n\
    \    const sorted = lst.sort((a, b) => a - b);\n    return sorted[1];\n}\n", " \
    \   if (lst.length < 2) {\n        return undefined;\n    }\n\n    let smallest\
    \ = lst[0];\n    let secondSmallest = lst[1];\n\n    for (let i = 1; i < lst.length;\
    \ i++) {\n        if (lst[i] < smallest) {\n            secondSmallest = smallest;\n\
    \            smallest = lst[i];\n        }\n        else if (lst[i] < secondSmallest)\
    \ {\n            secondSmallest = lst[i];\n        }\n    }\n\n    return secondSmallest;\n\
    }\n", "  if (lst.length < 2) {\n    return undefined;\n  }\n  lst.sort((a, b)\
    \ => a - b);\n  let min = lst[0];\n  let min2 = min;\n  for (let i = 1; i < lst.length;\
    \ i++) {\n    if (lst[i] != min) {\n      min2 = lst[i];\n      break;\n    }\n\
    \  }\n  return min2;\n}\n\nconsole.log(next_smallest([]));\nconsole.log(next_smallest([1,\
    \ 1]));\nconsole.log(next_smallest([1, 2, 3, 4, 5]));\nconsole.log(next_smallest([5,\
    \ 1, 4, 3, 2]));\n", "    if (lst.length < 2) return undefined;\n    let sm =\
    \ lst[0];\n    let nsm = lst[1];\n    for (let i = 1; i < lst.length; i++) {\n\
    \        if (lst[i] < sm) {\n            nsm = sm;\n            sm = lst[i];\n\
    \        } else if (lst[i] < nsm) {\n            nsm = lst[i];\n        }\n  \
    \  }\n    return nsm;\n}\n", "  if (lst.length === 0) {\n    return undefined;\n\
    \  }\n\n  let min = Infinity;\n  let smol = Infinity;\n\n  for (let i = 0; i <\
    \ lst.length; i++) {\n    const curr = lst[i];\n    if (curr < min) {\n      smol\
    \ = min;\n      min = curr;\n    } else if (curr < smol) {\n      smol = curr;\n\
    \    }\n  }\n\n  return smol;\n}\n", "    if (lst.length < 2) return undefined;\n\
    \    let min = lst[0];\n    let minPos = 0;\n    let secondMin = lst[1];\n   \
    \ for (let i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n      \
    \      min = lst[i];\n            minPos = i;\n        }\n    }\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (i != minPos && lst[i] < secondMin)\
    \ {\n            secondMin = lst[i];\n        }\n    }\n    return secondMin;\n\
    }\n", "  let first = Number.MAX_VALUE;\n  let second = Number.MAX_VALUE;\n  lst.forEach(num\
    \ => {\n    if (num < first) {\n      second = first;\n      first = num;\n  \
    \  } else if (num < second && num !== first) {\n      second = num;\n    }\n \
    \ });\n  return second === Number.MAX_VALUE ? undefined : second;\n}\n", "   \
    \ return lst.sort((a, b) => a - b)[1];\n}\n", "  const sorted = [...lst].sort((a,\
    \ b) => a - b);\n  const distinct = [...new Set(sorted)];\n  if (distinct.length\
    \ <= 1) {\n    return undefined;\n  }\n  return distinct[1];\n}\n", "  let smallest:\
    \ number | undefined;\n  let second_smallest: number | undefined;\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    if (second_smallest === undefined) {\n  \
    \    second_smallest = lst[i];\n    } else if (lst[i] < second_smallest) {\n \
    \     second_smallest = lst[i];\n    }\n\n    if (smallest === undefined) {\n\
    \      smallest = lst[i];\n    } else if (lst[i] < smallest) {\n      second_smallest\
    \ = smallest;\n      smallest = lst[i];\n    }\n  }\n  return second_smallest;\n\
    }\n", "  if (lst.length === 0) {\n    return undefined;\n  }\n\n  const sortedLst\
    \ = lst.sort((a, b) => a - b);\n  let nextSmallest = sortedLst[0];\n  let result\
    \ = 0;\n\n  for (let i = 1; i < sortedLst.length; i++) {\n    if (sortedLst[i]\
    \ === nextSmallest) {\n      continue;\n    }\n\n    if (sortedLst[i] > nextSmallest)\
    \ {\n      result = sortedLst[i];\n      break;\n    }\n  }\n\n  return result;\n\
    }\n", "    let first = Number.MAX_VALUE;\n    let second = Number.MAX_VALUE;\n\
    \    for (let n of lst) {\n        if (n < first) {\n            second = first;\n\
    \            first = n;\n        } else if (n < second && n != first) {\n    \
    \        second = n;\n        }\n    }\n    return second == Number.MAX_VALUE\
    \ ? undefined : second;\n}\n", "  let sm1: number;\n  let sm2: number;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (i === 0) {\n      sm1 = lst[i];\n\
    \    } else if (i === 1) {\n      if (lst[i] < sm1) {\n        sm2 = sm1;\n  \
    \      sm1 = lst[i];\n      } else {\n        sm2 = lst[i];\n      }\n    } else\
    \ {\n      if (lst[i] < sm1) {\n        sm2 = sm1;\n        sm1 = lst[i];\n  \
    \    } else if (lst[i] > sm1 && lst[i] < sm2) {\n        sm2 = lst[i];\n     \
    \ }\n    }\n  }\n  return sm2;\n}\n\nconsole.log(next_smallest([1, 2, 3, 4, 5]));\n\
    console.log(next_smallest([5, 1, 4, 3, 2]));\nconsole.log(next_smallest([]));\n\
    console.log(next_smallest([1, 1]));\n", "    if (lst.length < 2) {\n        return\
    \ undefined;\n    }\n    let smallest = lst[0];\n    let secondSmallest = lst[1];\n\
    \    if (smallest > secondSmallest) {\n        [smallest, secondSmallest] = [secondSmallest,\
    \ smallest];\n    }\n    for (let i = 2; i < lst.length; i++) {\n        if (lst[i]\
    \ < smallest) {\n            secondSmallest = smallest;\n            smallest\
    \ = lst[i];\n        } else if (lst[i] < secondSmallest) {\n            secondSmallest\
    \ = lst[i];\n        }\n    }\n    return secondSmallest;\n}\n\nexport { next_smallest\
    \ };", "    if (lst.length === 0) {\n        return undefined;\n    }\n    lst.sort((x,\
    \ y) => x - y);\n    let i = 0;\n    while (i < lst.length - 1 && lst[i] === lst[i\
    \ + 1]) {\n        i++;\n    }\n    if (i === lst.length - 1) {\n        return\
    \ undefined;\n    }\n    return lst[i + 1];\n}\n", "    if (lst.length < 2) {\n\
    \        return undefined;\n    }\n    let [first, second, ...rest] = lst;\n \
    \   for (let i = 0; i < rest.length; i++) {\n        if (rest[i] < first) {\n\
    \            if (rest[i] < second) {\n                second = rest[i];\n    \
    \        }\n            first = rest[i];\n        } else if (rest[i] < second)\
    \ {\n            second = rest[i];\n        }\n    }\n    return second;\n}\n\n\
    console.log(next_smallest([5, 1, 4, 3, 2]));\nconsole.log(next_smallest([1, 2,\
    \ 3, 4, 5]));\nconsole.log(next_smallest([]));\nconsole.log(next_smallest([1,\
    \ 1]));\n", "    const set = new Set<number>(lst);\n    if (set.size === 1) return\
    \ undefined;\n    else if (set.size === 0) return undefined;\n    const sorted\
    \ = Array.from(set).sort((a, b) => a - b);\n    return sorted[1];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
