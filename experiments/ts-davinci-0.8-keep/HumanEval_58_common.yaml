name: HumanEval_58_common
language: ts
prompt: "//Return sorted unique common elements for two lists.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["    return Array.from(new Set(l1.filter(l1Item => l2.some(l2Item =>\
    \ l2Item === l1Item))));\n}\n", "    return _.sortBy(_.uniq(_.intersection(l1,\
    \ l2)));\n}\n", "  return [...new Set(l1.filter(x => l2.includes(x)))].sort((a,\
    \ b) => a - b);\n}\n", "    return l1.filter(n => l2.includes(n));\n}\n", "  \
    \  return l1.filter(function (n) {\n        return l2.indexOf(n) !== -1;\n   \
    \ }).sort().filter(function (n, i, arr) {\n        return arr.indexOf(n) === i;\n\
    \    });\n}\n", "    return []\n}\n", "    return l1.filter(e => l2.includes(e)).sort();\n\
    }\n", "    return [...new Set(l1.filter(i => l2.includes(i)))].sort((a, b) =>\
    \ a - b);\n}\n", "  const s1 = new Set(l1);\n  const s2 = new Set(l2);\n  return\
    \ [...s1].filter(x => s2.has(x));\n}\n", "    let c = [...new Set(l1.filter(i\
    \ => l2.includes(i)))];\n    return c.sort((a, b) => a - b);\n}\n", "    return\
    \ [];\n}\n", "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const\
    \ intersection = new Set(\n    [...set1].filter(x => set2.has(x))\n  );\n  return\
    \ [...intersection].sort((a, b) => a - b);\n}\n", "    let l1_unique: number[]\
    \ = [];\n    let l2_unique: number[] = [];\n    let common: number[] = [];\n \
    \   let map1: { [key: number]: boolean } = {};\n    let map2: { [key: number]:\
    \ boolean } = {};\n    for (let item of l1) {\n        if (!map1[item]) {\n  \
    \          l1_unique.push(item);\n            map1[item] = true;\n        }\n\
    \    }\n    for (let item of l2) {\n        if (!map2[item]) {\n            l2_unique.push(item);\n\
    \            map2[item] = true;\n        }\n    }\n    l1_unique.sort((a, b) =>\
    \ a - b);\n    l2_unique.sort((a, b) => a - b);\n    let i = 0;\n    let j = 0;\n\
    \    while (i < l1_unique.length && j < l2_unique.length) {\n        if (l1_unique[i]\
    \ === l2_unique[j]) {\n            common.push(l1_unique[i]);\n            i++;\n\
    \            j++;\n        } else if (l1_unique[i] < l2_unique[j]) {\n       \
    \     i++;\n        } else {\n            j++;\n        }\n    }\n    return common;\n\
    }\n", "    const l1_s = l1.sort((a, b) => a - b);\n    const l2_s = l2.sort((a,\
    \ b) => a - b);\n    let l1_c = 0;\n    let l2_c = 0;\n    const result: number[]\
    \ = [];\n    while (l1_c < l1_s.length && l2_c < l2_s.length) {\n        if (l1_s[l1_c]\
    \ === l2_s[l2_c]) {\n            result.push(l1_s[l1_c]);\n            l1_c++;\n\
    \            l2_c++;\n        } else if (l1_s[l1_c] < l2_s[l2_c]) {\n        \
    \    l1_c++;\n        } else {\n            l2_c++;\n        }\n    }\n    return\
    \ result;\n}\n", "  return [...new Set(l1.filter(n => l2.includes(n)))].sort();\n\
    }\n", "  let m1 = new Map<number, boolean>();\n  let m2 = new Map<number, boolean>();\n\
    \  l1.forEach(e => m1.set(e, true));\n  l2.forEach(e => m2.set(e, true));\n  let\
    \ res: number[] = [];\n  m1.forEach((v, k) => {\n    if (m2.has(k)) res.push(k);\n\
    \  });\n  return res;\n}\n", "    return [...new Set(l1.filter(n => l2.includes(n)))].sort();\n\
    }\n", "  return [...new Set(l1.filter(i => l2.includes(i)))].sort((a, b) => a\
    \ - b);\n}\n\nexport default common;", "  return [...new Set(l1.filter(n => l2.includes(n)))].sort((a,\
    \ b) => a - b);\n}\n", "  return [...new Set(l1.filter(x => l2.includes(x)))].sort();\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
