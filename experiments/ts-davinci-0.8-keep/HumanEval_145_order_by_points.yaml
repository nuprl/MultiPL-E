name: HumanEval_145_order_by_points
language: ts
prompt: "//Write a function which sorts the given list of integers\n// in ascending\
  \ order according to the sum of their digits.\n// Note: if there are several items\
  \ with similar sum of their digits,\n// order them based on their index in original\
  \ list.\n// For example:\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n// >>> order_by_points([]) == []\nfunction order_by_points(nums:\
  \ number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = order_by_points;\n  assert.deepEqual(candidate([1,\
  \ 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);\n  assert.deepEqual(candidate([1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98,\
  \ -11, 1, 2, 43, 54]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9,\
  \ 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n  assert.deepEqual(candidate([0,\
  \ 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);\n}\n\ntest();"
completions: ["  return nums.sort((a, b) =>\n    sumOfDigits(a) == sumOfDigits(b)\
    \ ? a - b : sumOfDigits(a) - sumOfDigits(b)\n  );\n}\n", "  if (nums.length ===\
    \ 0) {\n    return [];\n  }\n  let sum = 0;\n  let myMap = new Map();\n  for (let\
    \ i = 0; i < nums.length; i++) {\n    sum = 0;\n    let arr = nums[i].toString().split(\"\
    \");\n    arr.forEach(el => {\n      sum += parseInt(el);\n    });\n    myMap.set(sum,\
    \ nums[i]);\n  }\n  let myArr = Array.from(myMap.values());\n  myArr.sort();\n\
    \  return myArr;\n}\n", "  return nums.map((num, i) => [num, i]).sort((a, b) =>\
    \ {\n    const aSum = a[0].toString().split('').reduce((a, c) => Number(a) + Number(c),\
    \ 0);\n    const bSum = b[0].toString().split('').reduce((a, c) => Number(a) +\
    \ Number(c), 0);\n    if (aSum === bSum) {\n      return a[1] - b[1];\n    }\n\
    \    return aSum - bSum;\n  }).map(tuple => tuple[0]);\n}\n", "    return nums.sort((a,\
    \ b) => {\n        let sumA = a.toString().split('').reduce((sum, a) => sum +\
    \ parseInt(a), 0);\n        let sumB = b.toString().split('').reduce((sum, a)\
    \ => sum + parseInt(a), 0);\n        return sumA === sumB ? nums.indexOf(a) -\
    \ nums.indexOf(b) : sumA - sumB;\n    });\n}\n\nconsole.log(order_by_points([1,\
    \ 11, -1, -11, -12]));\nconsole.log(order_by_points([]));\n", "  let sum = 0;\n\
    \  let sorted: number[] = [];\n  let sortedDigits: number[] = [];\n  let digits:\
    \ number[] = [];\n  let lists: number[][] = [];\n  let result: number[] = [];\n\
    \  //create lists based on sum of digits\n  for (let i = 0; i < nums.length; i++)\
    \ {\n    sum = 0;\n    digits = [];\n    //get each digit and sum them\n    while\
    \ (nums[i] != 0) {\n      sum += nums[i] % 10;\n      digits.push(nums[i] % 10);\n\
    \      nums[i] = Math.floor(nums[i] / 10);\n    }\n    //sort the digits from\
    \ each list\n    digits.sort((a, b) => a - b);\n    //check if the sum is already\
    \ in the list and add the index\n    if (sortedDigits.indexOf(sum) < 0) {\n  \
    \    sortedDigits.push(sum);\n      lists.push([i]);\n    } else {\n      lists[sortedDigits.indexOf(sum)].push(i);\n\
    \    }\n  }\n  //sort the lists\n  sortedDigits.sort((a, b) => a - b);\n  //get\
    \ the index from the lists and push to result\n  for (let i = 0; i < sortedDigits.length;\
    \ i++) {\n    for (let j = 0; j < lists[i].length; j++) {\n      result.push(nums[lists[i][j]]);\n\
    \    }\n  }\n  return result;\n}\n", "  return nums.map((x, i) => [x, i]).sort((a,\
    \ b) => {\n    let x = a[0], y = b[0];\n    let x1 = Math.abs(x).toString().split('').reduce((a,\
    \ b) => a + parseInt(b), 0);\n    let y1 = Math.abs(y).toString().split('').reduce((a,\
    \ b) => a + parseInt(b), 0);\n    return x1 - y1 != 0 ? x1 - y1 : a[1] - b[1];\n\
    \  }).map(x => x[0]);\n}\n", "  return nums.sort((a, b) => {\n    return (a +\
    \ '').split('').reduce((sum, cur) => sum + +cur, 0) - (b + '').split('').reduce((sum,\
    \ cur) => sum + +cur, 0);\n  });\n}\n", "  return nums.sort((a, b) => sum_of_digits(a)\
    \ - sum_of_digits(b));\n}\n", "  const array = nums.map((x, idx) => {\n    return\
    \ {\n      x,\n      idx,\n      value: x.toString().split(\"\").reduce((acc,\
    \ v) => acc + +v, 0)\n    };\n  });\n  const sorted = array.sort((a, b) => a.value\
    \ - b.value);\n  return sorted.map(x => x.x);\n}\n", "  return nums.sort((num1,\
    \ num2) => {\n    const points1 = num1\n      .toString()\n      .split(\"\")\n\
    \      .reduce((sum, num) => sum + Number(num), 0);\n    const points2 = num2\n\
    \      .toString()\n      .split(\"\")\n      .reduce((sum, num) => sum + Number(num),\
    \ 0);\n    if (points1 === points2) {\n      return nums.indexOf(num1) - nums.indexOf(num2);\n\
    \    }\n    return points1 - points2;\n  });\n}\n", "    return nums.sort((a,\
    \ b) => {\n        let tmp_a = String(a).split('').map(Number).reduce((a, b) =>\
    \ a + b);\n        let tmp_b = String(b).split('').map(Number).reduce((a, b) =>\
    \ a + b);\n        return tmp_a - tmp_b;\n    });\n}\n\n", "    return nums.sort((a,\
    \ b) => {\n        const sumA = a.toString().split('').reduce((s, t) => +s + +t,\
    \ 0);\n        const sumB = b.toString().split('').reduce((s, t) => +s + +t, 0);\n\
    \        return sumA - sumB;\n    });\n}\n\n\nconsole.log(order_by_points([1,\
    \ 11, -1, -11, -12]));\nconsole.log(order_by_points([]));\nconsole.log(order_by_points([12,\
    \ 23, 34, 45, 56, 67, 78, 89, 90]));", "    return nums.sort((a, b) => sumDigits(a)\
    \ - sumDigits(b));\n}\n\nexport { sumDigits, order_by_points };", "  const numToSumOfDigits\
    \ = nums.map(num => {\n    const digits = Math.abs(num).toString().split(\"\"\
    );\n    return digits.reduce((acc, digit) => {\n      acc += Number(digit);\n\
    \      return acc;\n    }, 0);\n  });\n  return nums.sort((a, b) => {\n    const\
    \ aSum = numToSumOfDigits[nums.indexOf(a)];\n    const bSum = numToSumOfDigits[nums.indexOf(b)];\n\
    \    if (aSum === bSum) {\n      return nums.indexOf(a) - nums.indexOf(b);\n \
    \   }\n    return aSum - bSum;\n  });\n}\n", "    const digit_sums = nums.map(num\
    \ => Math.abs(num).toString().split('').reduce((total, curr) => total + parseInt(curr),\
    \ 0));\n    const result = [];\n    while (nums.length > 0) {\n        const min_sum\
    \ = Math.min(...digit_sums);\n        for (let i = 0; i < digit_sums.length; i++)\
    \ {\n            if (digit_sums[i] === min_sum) {\n                result.push(nums[i]);\n\
    \                nums.splice(i, 1);\n                digit_sums.splice(i, 1);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n", "  let to_int = function(num) {\n    return String(num).split(\"\").reduce((a,\
    \ b) => a + +b, 0);\n  };\n  return nums.sort((a, b) => (to_int(a) === to_int(b)\
    \ ? a - b : to_int(a) - to_int(b)));\n}\n", "  return nums.sort((a, b) => {\n\
    \    if (sum_of_digits(a) === sum_of_digits(b)) {\n      return nums.indexOf(a)\
    \ - nums.indexOf(b);\n    }\n    return sum_of_digits(a) - sum_of_digits(b);\n\
    \  });\n}\n\nconsole.log(order_by_points([1, 11, -1, -11, -12]));\n", "  const\
    \ points = nums.map(num => {\n    return Math.abs(num)\n      .toString()\n  \
    \    .split(\"\")\n      .reduce((acc, val) => {\n        return Number(acc) +\
    \ Number(val);\n      });\n  });\n  let temp = 0;\n  const ordered: number[] =\
    \ [];\n  while (nums.length > 0) {\n    let min = Infinity;\n    let index = 0;\n\
    \    points.forEach((point, i) => {\n      if (point < min) {\n        min = point;\n\
    \        index = i;\n      }\n    });\n    ordered.push(nums[index]);\n    points.splice(index,\
    \ 1);\n    nums.splice(index, 1);\n  }\n  return ordered;\n}\n", "    let sums:\
    \ number[] = [];\n    for (let i = 0; i < nums.length; i++) {\n        sums.push(nums[i]);\n\
    \    }\n    sums.sort((a, b) => getSumOfDigits(a) - getSumOfDigits(b));\n    return\
    \ sums;\n}\n", "    let result: number[] = [];\n    let withNums: any[] = [];\n\
    \    if (nums.length === 0) {\n        return [];\n    } else {\n        for (let\
    \ i = 0; i < nums.length; i++) {\n            withNums.push({ num: nums[i], index:\
    \ i });\n        }\n        withNums.sort((a, b) => sumOfDigits(a.num) - sumOfDigits(b.num));\n\
    \        for (let j = 0; j < withNums.length; j++) {\n            result.push(withNums[j].num);\n\
    \        }\n        return result;\n    }\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
