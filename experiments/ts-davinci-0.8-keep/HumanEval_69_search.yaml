name: HumanEval_69_search
language: ts
prompt: "//You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n// The frequency of an integer is the number\
  \ of times it appears in the list.\n// If no such a value exist, return -1.\n//\
  \ Examples:\n// search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4,\
  \ 4, 4]) == 3\n// search([5, 5, 4, 4, 4]) == -1\nfunction search(lst: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5,\
  \ 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3,\
  \ 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2,\
  \ 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6,\
  \ 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2,\
  \ 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n\
  \  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6,\
  \ 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n\
  \  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6,\
  \ 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n\
  \  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10,\
  \ 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4,\
  \ 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10,\
  \ 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6,\
  \ 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6,\
  \ 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n\
  \  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9,\
  \ 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3,\
  \ 10, 10, 9, 2]),-1);\n}\n\ntest();"
completions: ["    var arr = lst.sort();\n    var num = 0;\n    var count = 0;\n \
    \   for (var i = 0; i < arr.length; i++) {\n        for (var j = 0; j < arr.length;\
    \ j++) {\n            if (arr[i] == arr[j]) {\n                count++;\n    \
    \        }\n        }\n        if (count >= arr[i]) {\n            num = arr[i];\n\
    \        }\n        count = 0;\n    }\n    if (num == 0) {\n        return -1;\n\
    \    }\n    return num;\n}\n", "  const freq = {};\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (freq[lst[i]]) {\n      freq[lst[i]]++;\n    } else {\n     \
    \ freq[lst[i]] = 1;\n    }\n  }\n  const keys = Object.keys(freq);\n  keys.sort((a,\
    \ b) => b - a);\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i] >\
    \ freq[keys[i]]) {\n      return -1;\n    }\n    if (keys[i] === freq[keys[i]])\
    \ {\n      return keys[i];\n    }\n  }\n  return -1;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "  let max = 0;\n  let maxFreq = 0;\n  const freqMap = new\
    \ Map<number, number>();\n  for (const el of lst) {\n    if (freqMap.has(el))\
    \ {\n      freqMap.set(el, freqMap.get(el) + 1);\n    } else {\n      freqMap.set(el,\
    \ 1);\n    }\n    if (el > max && freqMap.get(el) >= el) {\n      max = el;\n\
    \      maxFreq = freqMap.get(el);\n    }\n  }\n  return max === 0 ? -1 : max;\n\
    }\n", "    let counts = lst.reduce((p, c) => {\n        p[c] = (p[c] || 0) + 1;\n\
    \        return p;\n    }, {} as { [key: number]: number });\n    let highestKey\
    \ = Object.keys(counts).reduce((p, c) => counts[c] > counts[p] ? c : p);\n   \
    \ return counts[highestKey] >= +highestKey ? +highestKey : -1;\n}", "    const\
    \ max = Math.max(...lst);\n    const freq = lst.reduce((dict, curr) => {\n   \
    \     dict[curr] = dict[curr] ? dict[curr] + 1 : 1;\n        return dict;\n  \
    \  }, {});\n    for (let i = max; i > 0; i--) {\n        if (freq[i] >= i) return\
    \ i;\n    }\n    return -1;\n}\n", "    let frequency: number[] = [];\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        let count = 0;\n        for (let\
    \ j = 0; j < lst.length; j++) {\n            if (lst[i] == lst[j]) {\n       \
    \         count++;\n            }\n        }\n        frequency.push(count);\n\
    \    }\n    let result: number = 0;\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        if (lst[i] > result && frequency[i] >= lst[i]) {\n            result\
    \ = lst[i];\n        }\n    }\n    if (result == 0) {\n        return -1;\n  \
    \  }\n    return result;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    const\
    \ frequency: number[] = lst.reduce((arr, value) => {\n        arr[value] = arr[value]\
    \ + 1 || 1;\n        return arr;\n    }, []);\n    const maxValue = Math.max(...frequency.slice(1));\n\
    \    return frequency.lastIndexOf(maxValue) === -1 ? -1 : frequency.lastIndexOf(maxValue);\n\
    }\n", "    let obj = {};\n    let max: number = -1;\n    lst.forEach(num => {\n\
    \        obj[num] = obj[num] ? obj[num] + 1 : 1;\n    });\n    lst.forEach(num\
    \ => {\n        if (obj[num] >= num && num > max) {\n            max = num;\n\
    \        }\n    });\n    return max;\n}\nconsole.log(search([5, 5, 4, 4, 4]));\n\
    console.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([4, 1, 2,\
    \ 2, 3, 1]));\n", "    let found = -1;\n    let freq: any = {};\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (freq[lst[i]]) freq[lst[i]]++;\n \
    \       else freq[lst[i]] = 1;\n    }\n    Object.keys(freq).sort((a, b) => b\
    \ - a).forEach(num => {\n        if (freq[num] >= parseInt(num)) {\n         \
    \   found = parseInt(num);\n            return;\n        }\n    });\n    return\
    \ found;\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    const\
    \ dict = {};\n    for (let i = 0; i < lst.length; i++) {\n        dict[lst[i]]\
    \ = dict[lst[i]] ? dict[lst[i]] + 1 : 1;\n    }\n    let result = -1;\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        if (dict[lst[i]] >= lst[i] && lst[i]\
    \ > result) {\n            result = lst[i];\n        }\n    }\n    return result;\n\
    }\n", "    let result: number = -1;\n    let frequencyMap: Map<number, number>\
    \ = new Map<number, number>();\n    for (let i = 0; i < lst.length; i++) {\n \
    \       let value: number = lst[i];\n        let frequency: number = frequencyMap.get(value)\
    \ || 0;\n        frequencyMap.set(value, frequency + 1);\n    }\n    for (let\
    \ key of frequencyMap.keys()) {\n        if (key > 0 && key <= frequencyMap.get(key))\
    \ {\n            result = key;\n        }\n    }\n    return result;\n}\n", " \
    \ const nums = {}\n  lst.forEach(num => {\n    if (nums[num]) {\n      nums[num]++\n\
    \    } else {\n      nums[num] = 1\n    }\n  })\n  let highest = -1\n  for (let\
    \ num in nums) {\n    const int = parseInt(num)\n    if (int > 0 && nums[num]\
    \ >= int && highest < int) {\n      highest = int\n    }\n  }\n  return highest\n\
    }\n", "    // With a Map\n    let map = new Map();\n    for (let i of lst) {\n\
    \        if (map.has(i)) {\n            map.set(i, map.get(i) + 1);\n        }\
    \ else {\n            map.set(i, 1);\n        }\n    }\n    let highest = 0;\n\
    \    for (let i of map.keys()) {\n        if (i > highest && map.get(i) >= i)\
    \ {\n            highest = i;\n        }\n    }\n    return highest || -1;\n}\n",
  "    const occurs = lst.reduce((acc: { [key: number]: number }, cur: number) =>\
    \ {\n        if (acc[cur]) {\n            acc[cur] += 1;\n        } else {\n \
    \           acc[cur] = 1;\n        }\n        return acc;\n    }, {});\n    const\
    \ max = lst.reduce((a: number, b: number) => Math.max(a, b));\n    for (let i\
    \ = max; i > 0; i--) {\n        if (occurs[i] >= i) {\n            return i;\n\
    \        }\n    }\n    return -1;\n}\n", "  var max = lst.reduce((a, b) => Math.max(a,\
    \ b));\n  var map = new Map<number, number>();\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (map.has(lst[i])) map.set(lst[i], map.get(lst[i]) + 1);\n   \
    \ else map.set(lst[i], 1);\n  }\n  var res = -1;\n  for (let i = 1; i <= max;\
    \ i++) {\n    if (map.has(i) && map.get(i) >= i) res = i;\n  }\n  return res;\n\
    }\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3,\
    \ 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    const obj = lst.reduce((acc,\
    \ curr) => {\n        acc[curr] = acc[curr] ? acc[curr] + 1 : 1;\n        return\
    \ acc;\n    }, {});\n    for (let [key, value] of Object.entries(obj)) {\n   \
    \     if (Number(key) <= value) {\n            return Number(key);\n        }\n\
    \    }\n    return -1;\n}\n", "  return lst.reduce((acc: number, curr: number):\
    \ number => {\n    const count = lst.filter((val: number): boolean => val ===\
    \ curr).length;\n    if (count >= curr && curr > acc) {\n      return curr;\n\
    \    }\n    return acc;\n  }, -1);\n}\n", "    let numMap = new Map<number, number>();\n\
    \    let minFreq = Number.MAX_SAFE_INTEGER;\n    let maxFreq: number;\n    let\
    \ minFreqNum: number;\n    let maxFreqNum: number;\n    let result = -1;\n   \
    \ for (let i = 0; i < lst.length; i++) {\n        if (numMap.has(lst[i])) {\n\
    \            let freq = numMap.get(lst[i])!;\n            numMap.set(lst[i], freq\
    \ + 1);\n        } else {\n            numMap.set(lst[i], 1);\n        }\n   \
    \ }\n    numMap.forEach((freq, num) => {\n        if (freq < minFreq) {\n    \
    \        minFreq = freq;\n            minFreqNum = num;\n        }\n        if\
    \ (freq > maxFreq) {\n            maxFreq = freq;\n            maxFreqNum = num;\n\
    \        }\n    });\n    if (minFreqNum == undefined || maxFreqNum == undefined)\
    \ {\n        return result;\n    }\n    if (minFreqNum >= minFreq && minFreqNum\
    \ > 1) {\n        result = minFreqNum;\n    } else if (maxFreqNum >= maxFreq)\
    \ {\n        result = maxFreqNum;\n    }\n    return result;\n}\n", "    let map:\
    \ Map<number, number> = new Map<number, number>();\n    for (let i: number = 0;\
    \ i < lst.length; i++) {\n        if (map.has(lst[i])) {\n            map.set(lst[i],\
    \ map.get(lst[i]) + 1);\n        } else {\n            map.set(lst[i], 1);\n \
    \       }\n    }\n    for (let i: number = lst.length; i > 0; i--) {\n       \
    \ if (map.has(i) && map.get(i) >= i) {\n            return i;\n        }\n   \
    \ }\n    return -1;\n}\n", "    let freq: object = {};\n    let maxfreq: number\
    \ = -1;\n    for (let i = 0; i < lst.length; i++) {\n        let e = lst[i];\n\
    \        if (e in freq) {\n            freq[e]++;\n        } else {\n        \
    \    freq[e] = 1;\n        }\n        if (freq[e] >= e && freq[e] > maxfreq) {\n\
    \            maxfreq = freq[e];\n        }\n    }\n    return maxfreq;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
