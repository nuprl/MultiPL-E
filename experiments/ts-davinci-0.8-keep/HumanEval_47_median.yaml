name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the list l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["    let n = l.length;\n    if (n == 0) {\n        return undefined;\n\
    \    }\n    l.sort();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n\
    \ / 2]) / 2;\n    } else {\n        return l[Math.floor(n / 2)];\n    }\n}\n",
  "  let lst = l.sort();\n  let len = lst.length;\n  if (len % 2 == 0) {\n    return\
    \ (lst[len / 2] + lst[len / 2 - 1]) / 2;\n  } else {\n    return lst[Math.floor(len\
    \ / 2)];\n  }\n}\n", "    l.sort(function(a, b) {\n        return a - b;\n   \
    \ });\n    var n = l.length;\n    if (n % 2 === 0) {\n        return (l[n / 2\
    \ - 1] + l[n / 2]) / 2;\n    } else {\n        return l[(n - 1) / 2];\n    }\n\
    }\n", "    let sum: number = 0;\n    let i: number = 0;\n    while (i < l.length)\
    \ {\n        sum = sum + l[i];\n        i = i + 1;\n    }\n    return sum / l.length;\n\
    }\n", "  let list = l.sort();\n  if (list.length % 2 == 0) {\n    let pos1 = list.length\
    \ / 2;\n    let pos2 = pos1 - 1;\n    return (list[pos1] + list[pos2]) / 2;\n\
    \  } else {\n    let pos = Math.floor(list.length / 2);\n    return list[pos];\n\
    \  }\n}\n", "  const lLen = l.length;\n  if (lLen === 0) {\n    return null;\n\
    \  }\n  l.sort((a, b) => a - b);\n  if (lLen % 2 === 0) {\n    return (l[lLen\
    \ / 2 - 1] + l[lLen / 2]) / 2;\n  } else {\n    return l[Math.floor(lLen / 2)];\n\
    \  }\n}\n", "    let list = sort(l);\n    if (list.length%2 == 0) {\n        return\
    \ (list[list.length/2] + list[list.length/2-1])/2;\n    } else {\n        return\
    \ list[Math.round(list.length/2)];\n    }\n}\n", "  return 0;\n}\n", "    let\
    \ i = 0;\n    let sum = 0;\n    for (i=0; i<l.length; i++) {\n        sum += l[i];\n\
    \    }\n    let m = sum / l.length;\n    return m;\n}\n", "    var half = Math.floor(l.length\
    \ / 2);\n    l.sort(function (a, b) { return a - b; });\n    if (l.length % 2)\
    \ {\n        return l[half];\n    } else {\n        return (l[half - 1] + l[half])\
    \ / 2.0;\n    }\n}\n", "    if (l.length == 0) {\n        return null;\n    }\n\
    \    l.sort();\n    if (l.length % 2 == 0) {\n        return (l[l.length / 2]\
    \ + l[l.length / 2 - 1]) / 2;\n    } else {\n        return l[Math.floor(l.length\
    \ / 2)];\n    }\n}", "    // Function to sort array in ascending order\n    function\
    \ Sort(a: number[]): number[] {\n        let swapped: boolean;\n        do {\n\
    \            swapped = false;\n            for (let i = 0; i < a.length - 1; i++)\
    \ {\n                if (a[i] > a[i + 1]) {\n                    let temp = a[i];\n\
    \                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n\
    \                    swapped = true;\n                }\n            }\n     \
    \   } while (swapped);\n        return a;\n    }\n    // to find median, sorting\
    \ the array is necessary\n\n    let median: number;\n    let sortedArray: number[]\
    \ = Sort(l);\n    let arrayLength: number = sortedArray.length;\n    if (arrayLength\
    \ % 2 === 0) {\n        // if number of elements in the list is even,\n      \
    \  // get the average of the middle two elements.\n        median = (sortedArray[arrayLength\
    \ / 2 - 1] + sortedArray[arrayLength / 2]) / 2;\n    } else {\n        // if number\
    \ of elements in the list is odd,\n        // get the middle element.\n      \
    \  median = sortedArray[(arrayLength - 1) / 2];\n    }\n    return median;\n}\n",
  "  l.sort();\n  let index = Math.round(l.length / 2);\n  return l.length % 2 ==\
    \ 0 ? (l[index - 1] + l[index]) / 2 : l[index - 1];\n}\n", "    let c = l.slice(0);\n\
    \    let s = c.sort((a, b) => a - b);\n    let n = s.length;\n    let i = (n /\
    \ 2) | 0;\n    if (n % 2 === 0) {\n        return (s[i - 1] + s[i]) / 2;\n   \
    \ } else {\n        return s[i];\n    }\n}\n", "    var l1 = l.slice();\n    l1.sort();\n\
    \    if (l1.length % 2 == 0) {\n        return (l1[(l1.length / 2) - 1] + l1[l1.length\
    \ / 2]) / 2.0;\n    } else {\n        return l1[Math.floor(l1.length / 2)];\n\
    \    }\n}\n\nexport class Experiment {\n    constructor(\n        public readonly\
    \ iter_count: number,\n        public readonly min_elem_count: number,\n     \
    \   public readonly max_elem_count: number,\n        public readonly max_element:\
    \ number,\n        public readonly repeat_count: number\n    ) { }\n\n    protected\
    \ gen_random_list(elem_count: number): number[] {\n        var l: number[] = [];\n\
    \        for (var i = 0; i < elem_count; i++) {\n            l.push(Math.floor(Math.random()\
    \ * this.max_element));\n        }\n        return l;\n    }\n\n    protected\
    \ do_experiment(f: (l: number[]) => number[]): number[] {\n        var times:\
    \ number[] = [];\n        for (var i = 0; i < this.iter_count; i++) {\n      \
    \      var l = this.gen_random_list(this.min_elem_count +\n                Math.floor(Math.random()\
    \ * (this.max_elem_count - this.min_elem_count)));\n            var t1 = process.hrtime();\n\
    \            f(l);\n            var t2 = process.hrtime(t1);\n            times.push(t2[0]\
    \ * 1e9 + t2[1]);\n        }\n        return times;\n    }\n\n    do(): number[]\
    \ {\n        var res: number[] = [];\n        for (var i = 0; i < this.repeat_count;\
    \ i++) {\n            res.push(...this.do_experiment(this.experiment_function));\n\
    \        }\n        return res;\n    }\n\n    experiment_function(l: number[]):\
    \ number[] {\n        return l;\n    }\n}\n\nexport class Experiment", "    if\
    \ (l.length == 0) {\n        return 0;\n    }\n    return 0;\n}\n", "    const\
    \ half = Math.floor(l.length / 2);\n    if (l.length % 2 == 0) {\n        return\
    \ (l[half] + l[half-1]) / 2.0;\n    } else {\n        return l[half];\n    }\n\
    }\n", "  let m = l.length/2;\n  if (l.length%2 == 0) {\n    return (l[m-1] + l[m])/2;\n\
    \  } else {\n    return l[Math.floor(m)];\n  }\n}\n", "  if (l.length % 2 ===\
    \ 0) {\n    return (l[l.length / 2] + l[l.length / 2 - 1]) / 2;\n  } else {\n\
    \    return l[Math.floor(l.length / 2)];\n  }\n}\n", "    // your code goes here\n\
    \    return null;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
