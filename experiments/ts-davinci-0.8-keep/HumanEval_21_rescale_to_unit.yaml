name: HumanEval_21_rescale_to_unit
language: ts
prompt: "//Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n// such that the smallest number will become 0 and the largest\
  \ will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nfunction rescale_to_unit(numbers: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = rescale_to_unit;\n  assert.deepEqual(candidate([2.0,\
  \ 49.9]),[0.0, 1.0]);\n  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);\n\
  \  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75,\
  \ 1.0]);\n  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0,\
  \ 0.5, 0.75]);\n  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n}\n\ntest();"
completions: ["  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n\
    \  const difference = max - min;\n  if (difference === 0) {\n    return numbers.map((_)\
    \ => 0);\n  }\n  return numbers.map((x) => (x - min) / difference);\n}\n", " \
    \ const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  return\
    \ numbers.map(n => (n - min) / (max - min));\n}\n", "    const min = Math.min(...numbers);\n\
    \    const max = Math.max(...numbers);\n    return numbers.map(x => (x - min)\
    \ / (max - min));\n}\n\nexport { flatten, rescale_to_unit };", "  const minimum\
    \ = Math.min(...numbers);\n  const maximum = Math.max(...numbers);\n  return numbers.map(n\
    \ => (n - minimum) / (maximum - minimum));\n}\n", "  if (numbers.length < 2) {\n\
    \    throw new RangeError(\"Cannot rescale a list of less than two elements\"\
    );\n  }\n  const sorted = numbers.sort((a, b) => a - b);\n  const min = sorted[0];\n\
    \  const max = sorted[sorted.length - 1];\n  const spread = max - min;\n  return\
    \ numbers.map(x => (x - min) / spread);\n}\n", "    if (numbers.length < 2) {\n\
    \        throw new Error(\"Can't rescale list of less than 2 elements\");\n  \
    \  }\n    const max = Math.max(...numbers);\n    const min = Math.min(...numbers);\n\
    \    return numbers.map(n => ((n - min) / (max - min)));\n}\n", "  const min =\
    \ Math.min(...numbers);\n  const max = Math.max(...numbers);\n  return numbers.map(\n\
    \    (v) => (v - min) / (max - min),\n  );\n}\n\nexport function normalize_data(data:\
    \ Data): Data {\n  const normalized_data: Data = JSON.parse(JSON.stringify(data));\n\
    \  normalized_data.time_spent = rescale_to_unit(data.time_spent);\n  normalized_data.difficulty\
    \ = rescale_to_unit(data.difficulty);\n  normalized_data.skill_level = rescale_to_unit(data.skill_level);\n\
    \  normalized_data.interest = rescale_to_unit(data.interest);\n  return normalized_data;\n\
    }\n\nexport function update_chart(data: Data, chart: Chart): void {\n  chart.data.datasets[0].data\
    \ = data.time_spent;\n  chart.data.datasets[1].data = data.difficulty;\n  chart.data.datasets[2].data\
    \ = data.skill_level;\n  chart.data.datasets[3].data = data.interest;\n  chart.update();\n\
    }\n\nexport function create_chart(data: Data): Chart {\n  const ctx = document.getElementById('myChart')\
    \ as HTMLCanvasElement;\n  const chart = new Chart(ctx, {\n    type: 'line',\n\
    \    data: {\n      labels: data.labels,\n      datasets: [\n        {\n     \
    \     label: 'Time spent',\n          data: data.time_spent,\n          borderColor:\
    \ '#3e95cd',\n          backgroundColor: 'rgba(0, 0, 0, 0)',\n          yAxisID:\
    \ 'y-axis-1',\n        },\n        {\n          label: 'Difficulty',\n       \
    \   data: data.difficulty,\n          borderColor: '#8e5ea2',\n          backgroundColor:\
    \ 'rgba(0, 0, 0, 0)',\n          yAxisID: 'y-axis-2',\n        },\n        {\n\
    \          label: 'Skill level", "    let min: number = Math.min(...numbers);\n\
    \    let max: number = Math.max(...numbers);\n    let difference: number = max\
    \ - min;\n    let scaled: number[] = [];\n    for (let i: number = 0; i < numbers.length;\
    \ i++) {\n        scaled.push((numbers[i] - min) / difference);\n    }\n    return\
    \ scaled;\n}\n", "    if (numbers.length < 2) {\n        throw new Error('Need\
    \ more than one number to rescale.');\n    }\n    const max = Math.max(...numbers);\n\
    \    const min = Math.min(...numbers);\n    return numbers.map(x => (x - min)\
    \ / (max - min));\n}\n", "  const min_num = min(numbers);\n  const max_num = max(numbers);\n\
    \  const num_range = max_num - min_num;\n  return numbers.map(n => (n - min_num)\
    \ / num_range);\n}\n\nexport {\n  fetch_request,\n  generate_uuid,\n  rescale_to_unit,\n\
    \  normalize_string,\n  normalize_string_array,\n  normalize_string_bias,\n  is_valid_address,\n\
    \  parse_url,\n  parse_search_url_params,\n  is_valid_search_url,\n  is_url_in_search_domain,\n\
    \  is_a_valid_search_url,\n  is_a_search_engine_url,\n  is_search_url,\n  remove_search_url_params,\n\
    \  is_valid_uuid,\n  normalize_search_string,\n  normalize_search_string_array,\n\
    \  normalize_search_string_bias,\n  is_valid_search_string,\n  is_valid_search_strings,\n\
    \  match_search_string,\n  format_search_url,\n  sanitize_input,\n  get_canonical_search_string,\n\
    \  get_canonical_search_string_array,\n  get_canonical_search_string_bias,\n \
    \ get_canonical_search_strings,\n  is_valid_canonical_search_string,\n  is_valid_canonical_search_strings,\n\
    \  match_canonical_search_string,\n  format_canonical_search_url,\n  get_search_string_from_search_url,\n\
    \  get_domain_from_url,\n  get_canonical_domain_from_url,\n  get_search_domain_from_url,\n\
    \  get_canonical_search_domain_from_url,\n  get_hostname_from_url,\n  get_canonical_hostname_from_url,\n\
    \  get_search_hostname_from_url,\n  get_canonical_search_hostname_from_url,\n\
    \  is_valid_domain,\n ", "    let sorted = numbers.sort();\n    let min = sorted[0];\n\
    \    let max = sorted[sorted.length - 1];\n    return numbers.map(n => (n - min)\
    \ / (max - min));\n}\n", "    let min = Math.min(...numbers);\n    let max = Math.max(...numbers);\n\
    \    return numbers.map(x => (x - min) / (max - min));\n}\n", "    // find minimum\
    \ and maximum\n    let min = numbers[0];\n    let max = numbers[0];\n    for (let\
    \ i = 1; i < numbers.length; i++) {\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n        if (numbers[i] > max) {\n        \
    \    max = numbers[i];\n        }\n    }\n    // compute new numbers\n    const\
    \ ret = new Array(numbers.length);\n    for (let i = 0; i < numbers.length; i++)\
    \ {\n        ret[i] = (numbers[i] - min) / (max - min);\n    }\n    return ret;\n\
    }\n", "    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n\
    \    const step = (max - min) / (numbers.length - 1);\n    return numbers.map((n,\
    \ i) => n - min - step * i);\n}\n", "    const min = numbers.reduce((prev, curr)\
    \ => (curr < prev ? curr : prev));\n    const max = numbers.reduce((prev, curr)\
    \ => (curr > prev ? curr : prev));\n    const step = (max - min) / numbers.length;\n\
    \    return numbers.map(n => (n - min) / step);\n}\n", "  const min = Math.min(...numbers);\n\
    \  const max = Math.max(...numbers);\n  return numbers.map(n => (n - min) / (max\
    \ - min));\n}\n\ninterface RescaleResult {\n  min: number;\n  max: number;\n \
    \ rescaled: number[];\n}\n\nexport function rescale_to_unit_for_data(\n  data:\
    \ Data,\n  ...keys: (keyof Data)[]\n): RescaleResult {\n  if (keys.length ===\
    \ 0) {\n    throw new Error(\"Need at least one key to rescale!\");\n  }\n  const\
    \ numbers = data.points.map(\n    point => keys.map(key => point[key] as number)\n\
    \  );\n  const min = numbers.map(ns => Math.min(...ns));\n  const max = numbers.map(ns\
    \ => Math.max(...ns));\n  const rescaled = numbers.map(ns =>\n    ns.map((n, i)\
    \ => (n - min[i]) / (max[i] - min[i]))\n  );\n  return {\n    min,\n    max,\n\
    \    rescaled\n  };\n}\n\nexport function rescale_to_unit_for_point(\n  data:\
    \ Data,\n  point: number[],\n  ...keys: (keyof Data)[]\n): number[] {\n  if (keys.length\
    \ === 0) {\n    throw new Error(\"Need at least one key to rescale!\");\n  }\n\
    \  const numbers = data.points.map(\n    point => keys.map(key => point[key] as\
    \ number)\n  );\n  const min = numbers.map(ns => Math.min(...ns));\n  const max\
    \ = numbers.map(ns => Math.max(...ns));\n  return point.map((n, i) => (n - min[i])\
    \ / (max[i] - min[i]));\n}\n", "    const min_max = get_min_max(numbers);\n  \
    \  return numbers.map(n => (n - min_max.min) / (min_max.max - min_max.min));\n\
    }\n", "    if (numbers.length < 2) {\n        throw new Error(\"cannot rescale\
    \ list with less than 2 elements\")\n    }\n    const min_number = _.min(numbers)\n\
    \    const max_number = _.max(numbers)\n    const numbers_min_max_diff = max_number\
    \ - min_number\n    const rescaled_numbers = _.map(numbers, (number) => {\n  \
    \      return (number - min_number) / numbers_min_max_diff\n    })\n    return\
    \ rescaled_numbers\n}\n", "  const min = Math.min(...numbers);\n  const max =\
    \ Math.max(...numbers);\n  return numbers.map(x => (x - min) / (max - min));\n\
    }\n", "  let n = numbers.length;\n  let minVal = numbers[0];\n  let maxVal = numbers[0];\n\
    \  for (let i = 1; i < n; i++) {\n    if (numbers[i] < minVal) {\n      minVal\
    \ = numbers[i];\n    }\n    if (numbers[i] > maxVal) {\n      maxVal = numbers[i];\n\
    \    }\n  }\n  for (let i = 0; i < n; i++) {\n    numbers[i] = (numbers[i] - minVal)\
    \ / (maxVal - minVal);\n  }\n  return numbers;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
