name: HumanEval_99_closest_integer
language: ts
prompt: "//Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer(value: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"\
  10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"\
  -15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"\
  0\"),0);\n}\n\ntest();"
completions: ["  const strValue = parseFloat(value);\n  const intValue = parseInt(value);\n\
    \  const decimalPart = strValue - intValue;\n  return decimalPart < 0.5 ? intValue\
    \ : intValue + 1;\n}\n\nconsole.log(closest_integer(\"10\"));\nconsole.log(closest_integer(\"\
    15.3\"));\nconsole.log(closest_integer(\"14.5\"));\nconsole.log(closest_integer(\"\
    -14.5\"));\n", "  return Math.round(parseFloat(value));\n}\n", "    return parseInt(value);\n\
    }\n", "  const num: number = Number(value);\n  if (num % 1 === 0) {\n    return\
    \ num;\n  } else {\n    if (num > 0) {\n      return Math.ceil(num);\n    } else\
    \ {\n      return Math.floor(num);\n    }\n  }\n}\n", "  return Math.round(parseFloat(value));\n\
    }\nconsole.log(closest_integer(\"10\"));\nconsole.log(closest_integer(\"15.3\"\
    ));\nconsole.log(closest_integer(\"14.5\"));\nconsole.log(closest_integer(\"-14.5\"\
    ));\n", "  const floatValue = parseFloat(value);\n  if (floatValue === 0) {\n\
    \    return 0;\n  }\n  return Math.round(floatValue);\n}\nconsole.log(closest_integer(\"\
    -14.5\"));\nconsole.log(closest_integer(\"14.5\"));\nconsole.log(closest_integer(\"\
    15.3\"));\nconsole.log(closest_integer(\"-10\"));\nconsole.log(closest_integer(\"\
    10\"));\n", "  // Your code here\n  let myNumber = parseFloat(value);\n  let number1\
    \ = Math.floor(myNumber);\n  let number2 = Math.ceil(myNumber);\n  if (myNumber\
    \ - number1 === 0.5) {\n    return number2;\n  } else if (number2 - myNumber ===\
    \ 0.5) {\n    return number1;\n  } else if (myNumber - number1 < 0.5) {\n    return\
    \ number1;\n  } else {\n    return number2;\n  }\n}\n", "    return Math.round(Number(value));\n\
    }\n", "    return Math.round(parseFloat(value));\n}\n\nconsole.log(closest_integer(\"\
    14.5\"));\nconsole.log(closest_integer(\"-14.5\"));", "  let number = parseFloat(value);\n\
    \  let decimal: number = number - Math.floor(number);\n  if (decimal >= 0.5) {\n\
    \    return Math.ceil(number);\n  } else {\n    return Math.floor(number);\n \
    \ }\n}", "  return Math.round(parseFloat(value));\n}\n", "    // check if the\
    \ value input is a string and can be converted to a number\n    if (isNaN(parseFloat(value)))\
    \ {\n        throw Error(\"value must be a string that can be converted to a number\"\
    )\n    }\n    // convert the string to a number\n    let number: number = parseFloat(value)\n\
    \    // check if the number has a decimal part\n    if (Number.isInteger(number))\
    \ {\n        return number\n    }\n    // get the fractional part of the number\n\
    \    let fractionalPart: number = number - Math.floor(number)\n    // if the fractional\
    \ part is > 0.5 the integer we are looking for is\n    // closer to the greater\
    \ integer else it is closer to the lower integer\n    if (fractionalPart > 0.5)\
    \ {\n        return Math.ceil(number)\n    } else {\n        return Math.floor(number)\n\
    \    }\n}\n", "    return Math.round(parseFloat(value));\n}\n", "  const num =\
    \ parseFloat(value);\n  const sign = num < 0 ? -1 : 1;\n  return sign * Math.round(sign\
    \ * num);\n}\n", "    return Number(value).toFixed();\n}\nconsole.log(closest_integer(\"\
    15.3\"));\n", "  const num = parseFloat(value);\n  const isNegative = num < 0;\n\
    \  const numAbs = Math.abs(num);\n  const floor = Math.floor(numAbs);\n  const\
    \ ceiling = Math.ceil(numAbs);\n  if (numAbs - floor === 0.5) {\n    return isNegative\
    \ ? -ceiling : ceiling;\n  }\n  return isNegative ? -floor : floor;\n}", "   \
    \ return Number(value.split(\".\")[0]);\n}\n\nconsole.log(closest_integer(\"15.3\"\
    ));", "    if (value.length < 1) {\n        return 0;\n    }\n    const num =\
    \ Number(value);\n    if (num !== num) {\n        return 0;\n    }\n    const\
    \ upper = Math.ceil(num);\n    const lower = Math.floor(num);\n    if (num ===\
    \ upper) {\n        return upper;\n    }\n    if (num === lower) {\n        return\
    \ lower;\n    }\n    if (num - lower > upper - num) {\n        return upper;\n\
    \    }\n    return lower;\n}\n", "    const parsed = parseFloat(value);\n    const\
    \ floored = Math.floor(parsed);\n    const ceiled = Math.ceil(parsed);\n    const\
    \ ceilingDistance = Math.abs(ceiled - parsed);\n    const floorDistance = Math.abs(floored\
    \ - parsed);\n    if (ceilingDistance === floorDistance) {\n        return parsed\
    \ < 0 ? ceiled : floored;\n    }\n    return ceilingDistance < floorDistance ?\
    \ ceiled : floored;\n}\n\ntype Result = {\n    positive: number,\n    negative:\
    \ number,\n    zero: number\n};\n", "    return Number(value) - Number(value)\
    \ % 1;\n}\n\nconsole.log(closest_integer(\"10\"));\nconsole.log(closest_integer(\"\
    15.3\"));\nconsole.log(closest_integer(\"14.5\"));\nconsole.log(closest_integer(\"\
    -14.5\"));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
