name: HumanEval_153_Strongest_Extension
language: ts
prompt: "//You will be given the name of a class (a string) and a list of extensions.\n\
  // The extensions are to be used to load additional classes to the class. The\n\
  // strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  // letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n// You should find the strongest extension and return a string in this \n//\
  \ format: ClassName.StrongestExtensionName.\n// If there are two or more extensions\
  \ with the same strength, you should\n// choose the one that comes first in the\
  \ list.\n// For example, if you are given \"Slices\" as the class and a list of\
  \ the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n//\
  \ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunction Strongest_Extension(class_name:\
  \ string, extensions: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = Strongest_Extension;\n  assert.deepEqual(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\"\
  );\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\"\
  , \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\"\
  );\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"\
  WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"\
  ]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\"\
  );\n}\n\ntest();"
completions: ["  let className = class_name;\n  let strongest: [string, number] =\
    \ ['', 0];\n  extensions.forEach(e => {\n    let cap: number = 0;\n    let sm:\
    \ number = 0;\n    e.split('').forEach(c => {\n      if (c == c.toUpperCase())\
    \ {\n        cap++;\n      } else {\n        sm++;\n      }\n    });\n    if (cap\
    \ - sm > strongest[1]) {\n      strongest = [e, cap - sm];\n    }\n  });\n  return\
    \ className + '.' + strongest[0];\n}\n", "    let extension_strength: number[]\
    \ = [];\n    let strongest_extension: string;\n    let strong_index: number;\n\
    \    for (let i = 0; i < extensions.length; i++) {\n        extension_strength.push(extensions[i].match(/[A-Z]/g).length\
    \ - extensions[i].match(/[a-z]/g).length);\n    }\n    strong_index = extension_strength.indexOf(Math.max(...extension_strength));\n\
    \    strongest_extension = extensions[strong_index];\n    return class_name +\
    \ '.' + strongest_extension;\n}\n\nconsole.log(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']));\nconsole.log(Strongest_Extension('Slices', ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed']));", "    let strength = 0;\n    let strongest = '';\n\
    \    for (let ex of extensions) {\n        const caps = ex.split('').filter(x\
    \ => x.toUpperCase() === x).length;\n        const smalls = ex.split('').filter(x\
    \ => x.toLowerCase() === x).length;\n        const str = caps - smalls;\n    \
    \    if (str > strength) {\n            strength = str;\n            strongest\
    \ = ex;\n        }\n    }\n    return `${class_name}.${strongest}`;\n}\nconsole.log(Strongest_Extension('Slices',\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed']));\nconsole.log(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']));\n", "    let strongest: string = \"\";\n    let strongest_strength:\
    \ number = 0;\n    for (let extension of extensions) {\n        let strength:\
    \ number = -1;\n        for (let char of extension) {\n            if (char.match(/[A-Z]/))\
    \ {\n                strength++;\n            }\n            else if (char.match(/[a-z]/))\
    \ {\n                strength--;\n            }\n        }\n        if (strength\
    \ > strongest_strength) {\n            strongest = extension;\n            strongest_strength\
    \ = strength;\n        }\n    }\n    return `${class_name}.${strongest}`;\n}\n\
    console.log(Strongest_Extension('my_class', ['AA', 'Be', 'CC']));", "    let strongest_extension\
    \ = ' ';\n    let strongest_strength = -Infinity;\n    for (let ext of extensions)\
    \ {\n        let strength = 0;\n        for (let l of ext) {\n            if (l.match(/[A-Z]/))\
    \ strength += 1;\n            if (l.match(/[a-z]/)) strength -= 1;\n        }\n\
    \        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_extension = ext;\n        }\n    }\n    return\
    \ class_name + '.' + strongest_extension;\n}\n", "    // let result = '';\n  \
    \  // let strongest = {strength: 0, extension: ''};\n    // for (let i = 0; i\
    \ < extensions.length; i++) {\n    //     let strength = 0;\n    //     for (let\
    \ j = 0; j < extensions[i].length; j++) {\n    //         if (extensions[i][j]\
    \ === extensions[i][j].toUpperCase()) {\n    //             strength++;\n    //\
    \         } else {\n    //             strength--;\n    //         }\n    // \
    \    }\n    //     if (strength > strongest.strength) {\n    //         strongest.strength\
    \ = strength;\n    //         strongest.extension = extensions[i];\n    //   \
    \  }\n    // }\n    // result = class_name + '.' + strongest.extension;\n    //\
    \ return result;\n    //the regex is necessary\n    const regex = /^[A-Z]+$/;\n\
    \    const result = class_name + '.' + extensions.sort((a, b) => {\n        const\
    \ aCap = (a.match(regex) || []).length;\n        const bCap = (b.match(regex)\
    \ || []).length;\n        const aSm = a.length - aCap;\n        const bSm = b.length\
    \ - bCap;\n        const aStr = aCap - aSm;\n        const bStr = bCap - bSm;\n\
    \        return bStr - aStr;\n    })[0];\n    return result;\n}\nconsole.log(Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']));", "    let strongest_extension = extensions[0];\n    let\
    \ max_strength = getStrength(extensions[0]);\n    for (let i = 1; i < extensions.length;\
    \ i++) {\n        let s = getStrength(extensions[i]);\n        if (s > max_strength)\
    \ {\n            max_strength = s;\n            strongest_extension = extensions[i];\n\
    \        }\n    }\n    return class_name + '.' + strongest_extension;\n}\n", " \
    \   let strongest: any = {name: '', strength: 0};\n    for (let extension of extensions)\
    \ {\n        let countUp = 0;\n        let countLow = 0;\n        for (let letter\
    \ of extension) {\n            if (letter === letter.toUpperCase()) {\n      \
    \          countUp++;\n            } else {\n                countLow++;\n   \
    \         }\n        }\n        if (countUp - countLow > strongest.strength) {\n\
    \            strongest.name = extension;\n            strongest.strength = countUp\
    \ - countLow;\n        }\n    }\n    return `${class_name}.${strongest.name}`;\n\
    }\n", "    let strongest_extension: [string, number] = [\"\", Number.MIN_SAFE_INTEGER];\n\
    \    let uppercase_regex = /[A-Z]/g;\n    let lowercase_regex = /[a-z]/g;\n  \
    \  for (let extension of extensions) {\n        let uppercase_count = extension.match(uppercase_regex)?.length\
    \ || 0;\n        let lowercase_count = extension.match(lowercase_regex)?.length\
    \ || 0;\n        let strength = uppercase_count - lowercase_count;\n        if\
    \ (strength > strongest_extension[1]) {\n            strongest_extension = [extension,\
    \ strength];\n        }\n    }\n    return class_name + \".\" + strongest_extension[0];\n\
    }\n\nconsole.log(Strongest_Extension('my_class', ['AA', 'Be', 'CC']));", "   \
    \ var best_extension: string = \"\";\n    var best_strength: number = -Infinity;\n\
    \    for (var i = 0; i < extensions.length; i++) {\n        var upper: number\
    \ = (extensions[i].match(/[A-Z]/g) || []).length;\n        var lower: number =\
    \ (extensions[i].match(/[a-z]/g) || []).length;\n        var strength: number\
    \ = upper - lower;\n        if (strength > best_strength) {\n            best_strength\
    \ = strength;\n            best_extension = extensions[i];\n        }\n    }\n\
    \    return class_name + \".\" + best_extension;\n}\n", "    let strongest_extension\
    \ = class_name;\n    let strongest_strength = -Infinity;\n    for (let i = 0;\
    \ i < extensions.length; i++) {\n        let strength = extensions[i].match(/[A-Z]/g).length\
    \ - extensions[i].match(/[a-z]/g).length;\n        if (strength > strongest_strength)\
    \ {\n            strongest_strength = strength;\n            strongest_extension\
    \ = class_name + '.' + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\n\nconsole.log(Strongest_Extension('Slices', ['SErviNGSliCes', 'Cheese', 'StuFfed']));\n\
    console.log(Strongest_Extension('my_class', ['AA', 'Be', 'CC']));\n", "    var\
    \ maxStrength = -Number.MAX_VALUE;\n    var strongestExtension: string = \"\"\
    ;\n    for (var i = 0; i < extensions.length; i++) {\n        var strength = extensions[i].split('').reduce((acc,\
    \ char) => {\n            return acc + (char.toUpperCase() === char ? 1 : -1);\n\
    \        }, 0);\n        if (strength > maxStrength) {\n            maxStrength\
    \ = strength;\n            strongestExtension = extensions[i];\n        }\n  \
    \  }\n    return class_name + \".\" + strongestExtension;\n}\n", "    // Find\
    \ the strongest extension with simple for loop\n    let strongest_strength = 0;\n\
    \    let strongest_ext = '';\n    for (let i = 0; i < extensions.length; i++)\
    \ {\n        const current_strength = calculate_strength(extensions[i]);\n   \
    \     if (current_strength > strongest_strength) {\n            strongest_strength\
    \ = current_strength;\n            strongest_ext = extensions[i];\n        }\n\
    \    }\n    return class_name + '.' + strongest_ext;\n}\n", "    let winnerName:\
    \ string;\n    let winnerStrength: number = -Infinity;\n    for (let i = 0; i\
    \ < extensions.length; i++) {\n        let cap: number = (extensions[i].match(/[A-Z]/g)\
    \ || []).length;\n        let sm: number = (extensions[i].match(/[a-z]/g) || []).length;\n\
    \        let strength: number = cap - sm;\n        if (strength > winnerStrength)\
    \ {\n            winnerStrength = strength;\n            winnerName = extensions[i];\n\
    \        }\n    }\n    return class_name + '.' + winnerName;\n}\n", "  return\
    \ \"\";\n}\n", "    let strongest = 0;\n    let strongest_ind = 0;\n    let strongest_ext\
    \ = '';\n    let CAP = 0;\n    let SM = 0;\n    let strength = 0;\n    for (let\
    \ i = 0; i < extensions.length; i++) {\n        CAP = 0;\n        SM = 0;\n  \
    \      for (let j = 0; j < extensions[i].length; j++) {\n            if (extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z') {\n                CAP++;\n            }\
    \ else {\n                SM++;\n            }\n        }\n        strength =\
    \ CAP - SM;\n        if (strength > strongest) {\n            strongest = strength;\n\
    \            strongest_ind = i;\n            strongest_ext = extensions[i];\n\
    \        }\n    }\n    return class_name + '.' + strongest_ext;\n}\n", "    let\
    \ class_extension: string = \"\";\n    let strength: number = -Infinity;\n   \
    \ extensions.forEach(function (extension) {\n        let CAP: number = Number(extension.match(/[A-Z]/g).length);\n\
    \        let SM: number = Number(extension.match(/[a-z]/g).length);\n        let\
    \ new_strength: number = CAP - SM;\n        if (new_strength > strength) {\n \
    \           strength = new_strength;\n            class_extension = extension;\n\
    \        }\n    });\n    return class_name + \".\" + class_extension;\n}\n", " \
    \   let strength = 0;\n    let strongest = '';\n    for (let i = 0; i < extensions.length;\
    \ i++) {\n        let caps = 0;\n        let sm = 0;\n        for (let j = 0;\
    \ j < extensions[i].length; j++) {\n            if (extensions[i][j] >= 'A' &&\
    \ extensions[i][j] <= 'Z') {\n                caps++;\n            } else {\n\
    \                sm++;\n            }\n        }\n        if (caps - sm > strength)\
    \ {\n            strength = caps - sm;\n            strongest = extensions[i];\n\
    \        }\n    }\n    return class_name + '.' + strongest;\n}\n", "    let maxStrength\
    \ = -100;\n    let max = 'None';\n    extensions.forEach(x => {\n        let c\
    \ = 0;\n        let s = 0;\n        for (let i = 0; i < x.length; i++) {\n   \
    \         if (x[i] >= 'A' && x[i] <= 'Z') {\n                c++;\n          \
    \  } else {\n                s++;\n            }\n        }\n        if (c - s\
    \ > maxStrength) {\n            maxStrength = c - s;\n            max = x;\n \
    \       }\n    });\n    return class_name + '.' + max;\n}\n", "    let strongest\
    \ = extensions[0];\n    let strongest_strength = CalculateStrength(strongest);\n\
    \    for (let i = 1; i < extensions.length; i++) {\n        let strength = CalculateStrength(extensions[i]);\n\
    \        if (strength > strongest_strength) {\n            strongest = extensions[i];\n\
    \            strongest_strength = strength;\n        }\n    }\n    return class_name\
    \ + '.' + strongest;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
