name: HumanEval_120_maximum
language: ts
prompt: "//Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// Input:\
  \ arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// Example 2:\n// Input: arr\
  \ = [4, -4, 4], k = 2\n// Output: [4, 4]\n// Example 3:\n// Input: arr = [-3, 2,\
  \ 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// Note:\n// 1. The length of the array\
  \ will be in the range of [1, 1000].\n// 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunction maximum(arr: number[],\
  \ k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = maximum;\n  assert.deepEqual(candidate([-3, -4, 5],\
  \ 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1),[2]);\n  assert.deepEqual(candidate([123, -123, 20, 0,\
  \ 1, 2, -3], 3),[2, 20, 123]);\n  assert.deepEqual(candidate([-123, 20, 0, 1, 2,\
  \ -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0],\
  \ 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1, 0, 2, 5, 3,\
  \ -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n  assert.deepEqual(candidate([4,\
  \ -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, -23, 243, -400, 0], 0),[]);\n}\n\ntest();"
completions: ["  if (k === 0) return [];\n  let result: number[] = [];\n  let kth:\
    \ number = findKth(arr, arr.length - k);\n  for (let n of arr) {\n    if (n >=\
    \ kth) result.push(n);\n  }\n  return result;\n}\n", "  // Place to store the\
    \ result.\n  const result: number[] = [];\n  // We do a while loop with the index.\n\
    \  let index = 0;\n  // We do this while loop until the length of the result is\
    \ equal to k.\n  while (result.length < k) {\n    // Set the maximum variable\
    \ as the first number in the array.\n    let maximum = arr[index];\n    // Set\
    \ the max index variable as the index.\n    let maxIndex = index;\n    // We do\
    \ this for loop starting at the index, ending at the length of the array,\n  \
    \  // and we increment by 1 each time.\n    for (let i = index; i < arr.length;\
    \ i++) {\n      // If the current number in the array is greater than the max,\n\
    \      // we set the maximum as that number, and set the max index as the current\
    \ index.\n      if (arr[i] > maximum) {\n        maximum = arr[i];\n        maxIndex\
    \ = i;\n      }\n    }\n    // We push the maximum number into the result array.\n\
    \    result.push(maximum);\n    // We remove the maximum number from the array\
    \ since we've already used it.\n    arr.splice(maxIndex, 1);\n  }\n  // We return\
    \ the result.\n  return result;\n}\n", "    return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4],\
    \ 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    const result:\
    \ number[] = []\n    if (k === arr.length) {\n        return arr.sort((a, b) =>\
    \ b - a)\n    }\n    let index = 0\n    for (let i = 0; i < k; i++) {\n      \
    \  result.push(arr[index])\n        for (let j = index + 1; j < arr.length; j++)\
    \ {\n            if (arr[j] > result[i]) {\n                result[i] = arr[j]\n\
    \                index = j\n            }\n        }\n    }\n    return result\n\
    }\n", "  return [];\n}\n\ndescribe(\"maximum(arr, k)\", () => {\n  it(\"should\
    \ return the maximum k numbers in arr.\", () => {\n    expect(maximum([-3, -4,\
    \ 5], 3)).toEqual([-4, -3, 5]);\n    expect(maximum([4, -4, 4], 2)).toEqual([4,\
    \ 4]);\n    expect(maximum([-3, 2, 1, 2, -1, -2, 1], 1)).toEqual([2]);\n  });\n\
    });", "  if (k == arr.length) return arr.sort((a, b) => b - a);\n  const res:\
    \ number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    while (res.length\
    \ && res[res.length - 1] < arr[i] && res.length + arr.length - i > k) res.pop();\n\
    \    if (res.length < k) res.push(arr[i]);\n  }\n  return res;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "    arr.sort((a, b) => b - a);\n    return arr.slice(0,\
    \ k);\n}\n", "  const n = arr.length;\n  const maxHeap = new Heap((a, b) => arr[a]\
    \ > arr[b]);\n  for (let i = 0; i < k; i++) {\n    maxHeap.push(i);\n  }\n  for\
    \ (let i = k; i < n; i++) {\n    if (arr[i] > arr[maxHeap.peek()]) {\n      maxHeap.pop();\n\
    \      maxHeap.push(i);\n    }\n  }\n  const result = [];\n  while (!maxHeap.isEmpty())\
    \ {\n    result.push(arr[maxHeap.pop()]);\n  }\n  return result;\n}\n", "    const\
    \ result: number[] = [];\n    for (let i = 0; i < arr.length; i++) {\n       \
    \ if (result.length < k) {\n            result.push(arr[i]);\n        } else {\n\
    \            if (result[0] < arr[i]) {\n                result.sort((a, b) =>\
    \ b - a);\n                result.pop();\n                result.push(arr[i]);\n\
    \            }\n        }\n    }\n    return result.sort((a, b) => b - a);\n}\n\
    \n(function () {\n    const arr = [-3, -4, 5];\n    const k = 3;\n    console.log(maximum(arr,\
    \ k));\n})();", "  if (!arr.length) return arr;\n  arr.sort((a, b) => a - b);\n\
    \  const n = arr.length;\n  const res = [];\n  for (let i = n - 1; i >= n - k;\
    \ i--) {\n    res.push(arr[i]);\n  }\n  return res;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  const sorted = arr.sort((a, b) => b - a);\n \
    \ return sorted.slice(0, k);\n}\n\nconst arr = [-3, -4, 5];\nconst k = 3;\nconsole.log(maximum(arr,\
    \ k));", "  let result: number[] = [];\n  let len = arr.length;\n  // O(nlogn)\
    \ => O(k*logk)\n  result = arr.sort((a, b) => b - a);\n  // O(k)\n  return result.slice(0,\
    \ k);\n}\n", "    let res: number[] = []\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        if (res.length === 0) {\n            res.push(arr[i])\n    \
    \    } else {\n            if (res.length < k) {\n                res.push(arr[i])\n\
    \                res.sort((a, b) => a - b)\n            } else {\n           \
    \     for (let j = 0; j < res.length; j++) {\n                    if (arr[i] >\
    \ res[j]) {\n                        res.splice(j, 0, arr[i])\n              \
    \          break\n                    }\n                }\n                res.length\
    \ = k\n            }\n        }\n    }\n    return res\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3))\nconsole.log(maximum([4, -4, 4], 2))\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1))", "  let low = 0;\n  let high = arr.length - 1;\n  let\
    \ index = 0;\n  while (low <= high) {\n    index = partition(arr, low, high);\n\
    \    if (index === k - 1) {\n      break;\n    } else if (index < k - 1) {\n \
    \     low = index + 1;\n    } else {\n      high = index - 1;\n    }\n  }\n  return\
    \ arr.slice(0, k);\n}\n", "    arr.sort((a, b) => b - a);\n    return arr.slice(0,\
    \ k);\n}\n", "    const sortedArr = quickSort(arr);\n    return sortedArr.slice(0,\
    \ k);\n}", "  const n = arr.length;\n  if (k === n) return arr;\n  const output\
    \ = [];\n  // We need to sort in such a way that the smallest elements come first.\n\
    \  const cmp = (a: number, b: number) => b - a;\n  // Build a max-heap with the\
    \ first k elements.\n  let heap = arr.slice(0, k).sort(cmp);\n  // Traverse over\
    \ the remaining elements.\n  for (let i = k; i < n; i++) {\n    // If the current\
    \ element is greater than the max element in the heap,\n    // then we should\
    \ replace it.\n    if (arr[i] > heap[0]) {\n      heap[0] = arr[i];\n      heap\
    \ = heap.sort(cmp);\n    }\n  }\n  // Finally return the heap's elements.\n  return\
    \ heap;\n}\n", "    if (k === arr.length) {\n        return arr;\n    }\n    let\
    \ result: number[] = [];\n    for (let i = 0; i < k; i++) {\n        let max =\
    \ Number.MIN_SAFE_INTEGER;\n        let index = 0;\n        for (let j = 0; j\
    \ < arr.length; j++) {\n            if (arr[j] > max) {\n                max =\
    \ arr[j];\n                index = j;\n            }\n        }\n        result.push(max);\n\
    \        arr.splice(index, 1);\n    }\n    return result;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));", "    const heap = new Heap([], null, ((a, b) => b - a));\n  \
    \  for (let n of arr) {\n        heap.push(n);\n        if (heap.length > k) heap.pop();\n\
    \    }\n    return heap.toArray();\n}", "    arr.sort((a, b) => a - b);\n    return\
    \ arr.slice(arr.length - k);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
