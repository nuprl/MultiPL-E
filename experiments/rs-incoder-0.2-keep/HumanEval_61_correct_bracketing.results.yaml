name: HumanEval_61_correct_bracketing
language: rust
results:
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc6yxjfwy.rs:44:44\n   |\n\
    44 |     let mut open_brackets_count_stack = Vec\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmpc6yxjfwy.rs:44:41\n\
    \    |\n44  |       let mut open_brackets_count_stack = Vec\n    |           \
    \                                ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6yxjfwy.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets.chars().any(|c| !('(' <= c && c <= ')')) {\n    \
    \            return false;\n            }\n        } else {\n            if brackets.chars().any(|c|\
    \ !('(' <= c && c <= ')') || ('[' <= c && c <= ']') || ('{' <= c && c <= '}'))\
    \ {\n                return false;\n            }\n        }\n        stack.push(brackets);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else if stack.len() > 0 {\n\
    \            return false;\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            if top != 0 {\n                return false;\n            }\n   \
    \     } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            if top != 0 {\n                return false;\n            }\n   \
    \         stack.push(ch as usize);\n        }\n    }\n    stack.len() == 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd7h529vg.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars() {\n \
    \       if bracket == '(' {\n            opening_brackets.push('(');\n       \
    \ } else if bracket == ')' {\n            closing_brackets.push(')');\n      \
    \  } else {\n            opening_brackets.push(bracket);\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiwlg72zf.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpzjkojb85.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpzjkojb85.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpzjkojb85.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ for bracket in brackets.chars() {\n        if bracket == '(' {\n           \
    \ stack.push(bracket);\n            open_brackets.push(bracket);\n        } else\
    \ if bracket == ')' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            close_brackets.push(stack.pop());\n     \
    \   } else if bracket == '[' {\n            stack.push(bracket);\n        } else\
    \ if bracket == ']' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            close_brackets.push(stack.pop());\n     \
    \   } else if bracket == '{' {\n            stack.push(bracket);\n        } else\
    \ if bracket == '}' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            close_brackets.push(stack.pop());\n     \
    \   }\n    }\n    if stack.len() != open_brackets.len() || stack.len() != close_brackets.len()\
    \ {\n        return false;\n    }\n    for open_bracket in open_brackets {\n \
    \       if close_brackets.contains(&open_bracket) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:17:24\n   |\n\
    17 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:18:32\n\
    \   |\n18 |             open_brackets.push(bracket);\n   |                   \
    \             ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpixrn6282.rs:23:33\n   |\n23 |             close_brackets.push(stack.pop());\n\
    \   |                                 ^^^^^^^^^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:25:24\n   |\n25 |\
    \             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:30:33\n\
    \   |\n30 |             close_brackets.push(stack.pop());\n   |              \
    \                   ^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:32:24\n   |\n32 |  \
    \           stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixrn6282.rs:37:33\n\
    \   |\n37 |             close_brackets.push(stack.pop());\n   |              \
    \                   ^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error: aborting due to 7 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \")\" {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else if brackets == \"(\" {\n      \
    \      if stack.len() == 0 {\n                return false;\n            }\n \
    \           stack.push(brackets);\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb7t51yb6.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != '(').collect::<Vec<_>>();\n    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != ')').collect::<Vec<_>>();\n    let mut opening_brackets_iter = opening_brackets_iter.into_iter();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp02mg9kq5.rs:36:48\n   |\n\
    36 |     let mut opening_brackets_iter = opening_bra\n   |                   \
    \                             ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `opening_bra` in this scope\n  -->\
    \ /tmp/tmp02mg9kq5.rs:36:37\n   |\n36 |     let mut opening_brackets_iter = opening_bra\n\
    \   |                                     ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp02mg9kq5.rs:11:44\n   |\n11 |\
    \ fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplox5u6q7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_brackets_iter = open_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut close_brackets_iter = close_brackets_iter.filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut open_bra\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6abjtsh0.rs:30:21\n   |\n\
    30 |     let mut open_bra\n   |                     ^ help: add `;` here\n31 |\
    \ }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp6abjtsh0.rs:14:81\n   |\n14 |     let mut open_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '(' && c != ')');\n   |  \
    \                                                                            \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6abjtsh0.rs:14:93\n\
    \   |\n14 |     let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n   |                                           \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp6abjtsh0.rs:15:82\n   |\n15\
    \ |     let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n   |                                           \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp6abjtsh0.rs:15:94\n   |\n15 |   \
    \  let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '(' && c != ')');\n   |                                               \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_iter = brackets.chars().enumerate();\n\
    \    let mut closing_brackets_iter = brackets.chars().enumerate();\n    let mut\
    \ opening_brackets_next = opening_brackets_iter.next();\n    let mut closing_brackets_next\
    \ = closing_brackets_iter.next();\n    while opening_brackets_next != None &&\
    \ closing_brackets_next != None {\n        if opening_brackets_next.0.1 == closing_brackets_next.0.1\
    \ {\n            opening_brackets.push_str(opening_brackets_next.0.1);\n     \
    \       closing_brackets.push_str(closing_brackets_next.0.1);\n            opening_brackets_next\
    \ = opening_brackets_iter.next();\n            closing_brackets_next = closing_brackets_iter.next();\n\
    \        } else {\n            if opening_brackets_next.0.1 == ')' {\n       \
    \         opening_brackets.push_str(\")\");\n                closing_brackets.push_str(\"\
    )\");\n                opening_brackets_next = opening_brackets_iter.next();\n\
    \                closing_brackets_next = closing_brackets_iter.next();\n     \
    \       } else {\n                if opening_brackets_next.0.1 == ']' {\n    \
    \                opening_brackets.push_str(\"]\");\n                    closing_brackets.push_str(\"\
    ]\");\n                    opening_brackets_next = opening_brackets_iter.next();\n\
    \                    closing_brackets_next = closing_brackets_iter.next();\n \
    \               } else {\n                    if opening_brackets_next.0.1 ==\
    \ ')' {\n                        opening_brackets.push_str(\")\");\n         \
    \               closing_brackets.push_str(\")\");\n                        opening_brackets_next\
    \ = opening_brackets_iter.next();\n                        closing_brackets_next\
    \ = closing_brackets_iter.next();\n                    } else {\n            \
    \            opening_brackets.push_str(\"[\");\n                        closing_brackets.push_str(\"\
    ]\");\n                        opening_brackets_next = opening_brackets_iter.next();\n\
    \                        closing_brackets_next = closing_brackets_iter.next();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   opening_brackets == closing_brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:19:34\n\
    \   |\n19 |         if opening_brackets_next.0.1 == closing_brackets_next.0.1\
    \ {\n   |                                  ^\n\nerror[E0609]: no field `0` on\
    \ type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:19:63\n   |\n19 |  \
    \       if opening_brackets_next.0.1 == closing_brackets_next.0.1 {\n   |    \
    \                                                           ^\n\nerror[E0609]:\
    \ no field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:20:61\n\
    \   |\n20 |             opening_brackets.push_str(opening_brackets_next.0.1);\n\
    \   |                                                             ^\n\nerror[E0609]:\
    \ no field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:21:61\n\
    \   |\n21 |             closing_brackets.push_str(closing_brackets_next.0.1);\n\
    \   |                                                             ^\n\nerror[E0609]:\
    \ no field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:25:38\n\
    \   |\n25 |             if opening_brackets_next.0.1 == ')' {\n   |          \
    \                            ^\n\nerror[E0609]: no field `0` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmp3aofkij3.rs:31:42\n   |\n31 |                 if opening_brackets_next.0.1\
    \ == ']' {\n   |                                          ^\n\nerror[E0609]: no\
    \ field `0` on type `Option<(usize, char)>`\n  --> /tmp/tmp3aofkij3.rs:37:46\n\
    \   |\n37 |                     if opening_brackets_next.0.1 == ')' {\n   |  \
    \                                            ^\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets[0] == '(' || brackets[0] == ')' {\n             \
    \   continue;\n            }\n        }\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpucwz41j9.rs:16:16\n   |\n16 |             if brackets[0] == '(' || brackets[0]\
    \ == ')' {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpucwz41j9.rs:16:38\n   |\n16 |             if brackets[0] == '('\
    \ || brackets[0] == ')' {\n   |                                      ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for ch in\
    \ brackets.chars() {\n        if ch == '(' {\n            stack.push(0);\n   \
    \     } else if ch == ')' {\n            if stack.len() == 0 {\n             \
    \   return false;\n            }\n            let top = stack.len();\n       \
    \     stack.pop();\n            if top != 0 {\n                return false;\n\
    \            }\n        } else {\n            if stack.len() == 0 {\n        \
    \        return false;\n            }\n            let top = stack.len();\n  \
    \          stack.pop();\n            if top != 0 {\n                return false;\n\
    \            }\n            stack.push(ch);\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp8l82l8p.rs:34:24\n   |\n\
    34 |             stack.push(ch);\n   |                        ^^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    stack.push(brackets);\n\
    \    while !stack.is_empty() {\n        let brackets = stack.pop();\n        if\
    \ brackets.len() == 0 {\n            continue;\n        }\n        let mut open_bracket\
    \ = Vec::new();\n        let mut close_bracket = Vec::new();\n        for bracket\
    \ in brackets.chars() {\n            if bracket == '(' {\n                open_bracket.push(bracket);\n\
    \            } else if bracket == ')' {\n                close_bracket.push(bracket);\n\
    \            } else {\n                panic!(\"Bracketing error!\");\n      \
    \      }\n        }\n        if open_bracket.is_empty() {\n            continue;\n\
    \        }\n        if close_bracket.is_empty() {\n            open_brackets.push(open_bracket);\n\
    \            continue;\n        }\n        if open_bracket.len() != close_bracket.len()\
    \ {\n            return false;\n        }\n        for open_bracket in open_brackets\
    \ {\n            if !close_bracket.contains(|c| c == open_bracket) {\n       \
    \         return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpwunb2c8r.rs:18:21\n   |\n18 |         if brackets.len()\
    \ == 0 {\n   |                     ^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `chars` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpwunb2c8r.rs:23:33\n   |\n23 |         for bracket in brackets.chars()\
    \ {\n   |                                 ^^^^^ method not found in `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwunb2c8r.rs:43:40\n   |\n43 |\
    \             if !close_bracket.contains(|c| c == open_bracket) {\n   |      \
    \                                  ^^^^^^^^^^^^^^^^^^^^^\n   |               \
    \                         |\n   |                                        expected\
    \ reference, found closure\n   |                                        help:\
    \ consider borrowing here: `&|c| c == open_bracket`\n   |\n   = note: expected\
    \ reference `&_`\n                found closure `[closure@/tmp/tmpwunb2c8r.rs:43:40:\
    \ 43:61]`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    while let Some(b) = stack.last() {\n        if b == '(' {\n            open_brackets.push(b);\n\
    \        } else if b == ')' {\n            if open_brackets.len() == 0 {\n   \
    \             return false;\n            }\n            close_brackets.push(b);\n\
    \            open_brackets.pop();\n        } else {\n            stack.push(b);\n\
    \        }\n    }\n    if open_brackets.len() != close_brackets.len() {\n    \
    \    return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpagqv0umf.rs:17:14\n\
    \   |\n17 |         if b == '(' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpagqv0umf.rs:19:21\n\
    \   |\n19 |         } else if b == ')' {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpagqv0umf.rs:26:24\n   |\n26 |  \
    \           stack.push(b);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |         \
    \    stack.push(*b);\n   |                        +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.len();\n    let\
    \ mut closed_brackets_size = brackets.len();\n    let mut i = 0;\n    while i\
    \ < open_brackets_size {\n        if brackets[i] == '(' {\n            open_brackets.push('(');\n\
    \            i += 1;\n        } else {\n            open_brackets.push(brackets[i]);\n\
    \        }\n    }\n    while i < open_brackets_size {\n        if brackets[i]\
    \ == ')' {\n            closed_brackets.push(')');\n            i += 1;\n    \
    \    } else {\n            closed_brackets.push(brackets[i]);\n        }\n   \
    \ }\n    open_brackets.len() == closed_brackets_size\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpru9mye9p.rs:18:12\n\
    \   |\n18 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpru9mye9p.rs:22:32\n   |\n22 |             open_brackets.push(brackets[i]);\n\
    \   |                                ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpru9mye9p.rs:26:12\n   |\n26 |         if brackets[i] == ')' {\n\
    \   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str a"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpix8ry0o3.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    stack.push(brackets);\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.push(open);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpkwksvq96.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets[0] == '(' || brackets[0] == ')' {\n             \
    \   return false;\n            }\n        }\n        if brackets.len() > 1 {\n\
    \            if brackets[brackets.len() - 1] == '(' || brackets[brackets.len()\
    \ - 1] == ')' {\n                return false;\n            }\n        }\n   \
    \     stack.push(brackets);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp_6pgi9bz.rs:16:16\n   |\n16 |             if brackets[0] == '(' || brackets[0]\
    \ == ')' {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp_6pgi9bz.rs:16:38\n   |\n16 |             if brackets[0] == '('\
    \ || brackets[0] == ')' {\n   |                                      ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_6pgi9bz.rs:21:16\n   |\n21 |             if brackets[brackets.len()\
    \ - 1] == '(' || brackets[brackets.len() - 1] == ')' {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp91m6dv0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjywf1mm9.rs:46:48\n   |\n\
    46 |     let mut opening_closing_brackets = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjywf1mm9.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_map\
    \ = String::new();\n    let mut close_brackets_count_map = String::new();\n  \
    \  let mut open_brackets_count_map_keys = String::new();\n    let mut close_brackets_count_map_keys\
    \ = String::new();\n    let mut open_brackets_count_map_values = String::new();\n\
    \    let mut close_brackets_count_map_values = String::new();\n    let mut open_brackets_count_map_values_keys\
    \ = String::new();\n    let mut close_brackets_count_map_values_keys = String::new();\n\
    \    let mut open_brackets_count_map_values_values = String::new();\n    let mut\
    \ close_brackets_count_map_values_values = String::new();\n    let mut open_brackets_count_map_values_values_keys\
    \ = String::new();\n    let mut close_brackets_count_map_values_values_keys =\
    \ String::new();\n    let mut open_brackets_count_map_values_values_values = String::new();\n\
    \    let mut close_brackets_count_map_values_values_values = String::new();\n\
    \    let mut open_brackets_count_map_values_values_values_keys = String::new();\n\
    \    let mut close_brackets_count_map_values_values_values_keys = String::new();\n\
    \    let mut open_brackets_count_map_values_values_values_values = String::new();\n\
    \    let mut close_brackets_count_map_values_values_values_values = String::new();\n\
    \    let mut open_brackets_count_map_values_values_values_values_keys = String::new();\n\
    \    let mut close_brackets_count_map_values_values_values_values_keys = String::new();\n\
    \    let mut open_brackets_count_map_values_values_values_values_values = String::new();\n\
    \    let mut close_brackets_count_map_values_values_values_values_values = String::new();\n\
    \    let mut open_brackets_count_map_values_values_values_values_values_keys =\
    \ String::new();\n    let mut close_brackets_count_map_values_values_values_values_values_keys\
    \ = String::new();\n    let mut open_brackets_count_map_values_values_values_values_values_values\
    \ = String::new();\n    let mut close_b\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpayhc9rx9.rs:41:20\n   |\n\
    41 |     let mut close_b\n   |                    ^ help: add `;` here\n42 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpayhc9rx9.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_digit()).collect::<String>());\n    while let Some(last) = stack.pop()\
    \ {\n        if last == ')' {\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_digit()).collect::<String>());\n        } else if last == '(' {\n\
    \            stack.push(brackets.chars().skip_while(|c| !c.is_ascii_digit()).collect::<String>());\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpxzws5a7g.rs:15:17\n\
    \   |\n15 |         if last == ')' {\n   |                 ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpxzws5a7g.rs:17:24\n   |\n17 |         }\
    \ else if last == '(' {\n   |                        ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            let top = stack.last().unwrap();\n            if top\
    \ != 0 {\n                stack.pop();\n            } else {\n               \
    \ return false;\n            }\n        } else {\n            stack.push(c);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmp27i0vwde.rs:21:20\n\
    \   |\n21 |             if top != 0 {\n   |                    ^^ no implementation\
    \ for `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp27i0vwde.rs:27:24\n   |\n27 |             stack.push(c);\n   |     \
    \                   ^ expected `usize`, found `char`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkyqrzmh0.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    for c in brackets\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpaajrz3x1.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't\
    \ compare `String` with `char`\n  --> /tmp/tmpaajrz3x1.rs:14:14\n   |\n14 |  \
    \       if c == '(' {\n   |              ^^ no implementation for `String == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpaajrz3x1.rs:16:21\n   |\n16 |         }\
    \ else if c == ')' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.push(open);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else if ch == '[' {\n    \
    \        stack.push('[');\n        } else if ch == ']' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else if ch == '{' {\n            stack.push('{');\n        } else if\
    \ ch == '}' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let index = stack.last().unwrap();\n            stack.pop();\n\
    \            if index == 0 {\n                return false;\n            }\n \
    \       } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let index = stack.last().unwrap();\n            stack.pop();\n\
    \            stack.push(index);\n        }\n    }\n    stack.len() == 0\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmpozwj_u2g.rs:22:22\n\
    \   |\n22 |             if index == 0 {\n   |                      ^^ no implementation\
    \ for `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpozwj_u2g.rs:31:24\n   |\n31 |             stack.push(index);\n   | \
    \                       ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             stack.push(*index);\n   | \
    \                       +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last() {\n        if b == '(' || b == ')' {\n \
    \           stack.pop();\n        } else {\n            stack.push(b);\n     \
    \   }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9aj7xtqz.rs:15:14\n\
    \   |\n15 |         if b == '(' || b == ')' {\n   |              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9aj7xtqz.rs:15:26\n\
    \   |\n15 |         if b == '(' || b == ')' {\n   |                          ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9aj7xtqz.rs:18:24\n\
    \   |\n18 |             stack.push(b);\n   |                        ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |             stack.push(*b);\n   |                        +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9_i_eiob.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets: Vec<usize>\
    \ = Vec::new();\n    let mut open_brackets_idx: Vec<usize> = Vec::new();\n   \
    \ let mut close_brackets_idx: Vec<usize> = Vec::new();\n    let mut open_brackets_idx2:\
    \ Vec<usize> = Vec::new();\n    let mut close_brackets_idx2: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets_idx3: Vec<usize> = Vec::new();\n    let mut close_brackets_idx3:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_idx4: Vec<usize> = Vec::new();\n\
    \    let mut close_brackets_idx4: Vec<usize> = Vec::new();\n    let mut open_brackets_idx5:\
    \ Vec<usize> = Vec::new();\n    let mut close_brackets_idx5: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets_idx6: Vec<usize> = Vec::new();\n    let mut close_brackets_idx6:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_idx7: Vec<usize> = Vec::new();\n\
    \    let mut close_brackets_idx7: Vec<usize> = Vec::new();\n    let mut open_brackets_idx8:\
    \ Vec<usize> = Vec::new();\n    let mut close_brackets_idx8: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets_idx9: Vec<usize> = Vec::new();\n    let mut close_brackets_idx9:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_idx10: Vec<usize> = Vec::new();\n\
    \    let mut close_brackets_idx10: Vec<usize> = Vec::new();\n    let mut open_brackets_idx11:\
    \ Vec<usize> = Vec::new();\n    let mut close_bra\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm5_dy0bi.rs:36:22\n   |\n\
    36 |     let mut close_bra\n   |                      ^ help: add `;` here\n37\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5_dy0bi.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    let mut open_brackets:\
    \ Vec<String> = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n\n\
    \    for c in brackets {\n        if c == '(' {\n            stack.push(c);\n\
    \            open_brackets.push(c);\n        } else if c == ')' {\n          \
    \  if stack.len() == 0 {\n                return false;\n            }\n     \
    \       let open_bracket = stack.pop();\n            if open_bracket != c {\n\
    \                return false;\n            }\n            close_brackets.push(c);\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let open_bracket = stack.pop();\n            let close_bracket\
    \ = close_brackets.pop();\n            if open_bracket != c {\n              \
    \  return false;\n            }\n            if close_bracket != c {\n       \
    \         return false;\n            }\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpkt5kkf9s.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't\
    \ compare `String` with `char`\n  --> /tmp/tmpkt5kkf9s.rs:17:14\n   |\n17 |  \
    \       if c == '(' {\n   |              ^^ no implementation for `String == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpkt5kkf9s.rs:20:21\n   |\n20 |         }\
    \ else if c == ')' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkt5kkf9s.rs:25:32\n   |\n25 |             if open_bracket\
    \ != c {\n   |                                ^ expected enum `Option`, found\
    \ struct `String`\n   |\n   = note: expected enum `Option<String>`\n         \
    \   found struct `String`\nh"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let next = stack.last().unwrap();\n        if next == ')' {\n  \
    \          stack.pop();\n        } else {\n            stack.push(next);\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprj99yp4c.rs:19:17\n\
    \   |\n19 |         if next == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprj99yp4c.rs:22:24\n   |\n22 |  \
    \           stack.push(next);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |   \
    \          stack.push(*next);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while !brackets.ends_with('(')\
    \ && brackets.ends_with(')')\n    {\n        brackets = brackets.replace(\")\"\
    , \"\");\n        brackets = brackets.replace(\"(\", \"\");\n    }\n    brackets.ends_with('(')\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiepjbffv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \")\" {\n\
    \            if !stack.is_empty() {\n                stack.pop();\n          \
    \  } else {\n                return false;\n            }\n        } else if brackets\
    \ == \"(\" {\n            if !stack.is_empty() {\n                stack.pop();\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            stack.push(brackets);\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpqynzmcca.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkyy30v7d.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&i| i == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp5my44snv.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp5my44snv.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp5my44snv.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(brackets.len());\n        }\
    \ else if c == ')' {\n            if stack.len() == 0 {\n                return\
    \ false;\n            }\n            stack.pop();\n        } else {\n        \
    \    if stack.len() != 0 {\n                return false;\n            }\n   \
    \     }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpysxwj1bd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(mut brackets) = stack.pop() {\n        if brackets.len() ==\
    \ 0 {\n            continue;\n        }\n        let mut open_brackets = brackets.chars().filter(|c|\
    \ *c != '(').count();\n        let mut close_brackets = brackets.chars().filter(|c|\
    \ *c == ')').count();\n        if open_brackets == close_brackets {\n        \
    \    continue;\n        }\n        stack.push(brackets);\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpry338d9u.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return false;\n        }\n        for c in brackets.chars() {\n\
    \            if !stack.contains(&c.to_string()) {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgs3kuck4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppm_dg3z7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.len();\n    let\
    \ mut closed_brackets_size = brackets.len();\n    let mut i = 0;\n    while i\
    \ < open_brackets_size {\n        if brackets[i] == '(' {\n            open_brackets.push(brackets[i]);\n\
    \            i += 1;\n        } else {\n            if open_brackets.is_empty()\
    \ {\n                return false;\n            }\n            closed_brackets.push(brackets[i]);\n\
    \            open_brackets_size -= 1;\n        }\n    }\n    while i < closed_brackets_size\
    \ {\n        if brackets[i] == ')' {\n            closed_brackets.push(brackets[i]);\n\
    \            i += 1;\n        } else {\n            if closed_brackets.is_empty()\
    \ {\n                return false;\n            }\n            open_brackets.push(brackets[i]);\n\
    \            closed_brackets_size -= 1;\n        }\n    }\n    if open_brackets.is_empty()\
    \ && closed_brackets.is_empty() {\n        return true;\n    }\n    if open_brackets.is_empty()\
    \ {\n        return false;\n    }\n    if closed_brackets.is_empty() {\n     \
    \   return false;\n    }\n    if open_brackets[0] != closed_brackets[0] {\n  \
    \      return false;\n    }\n    correct_bracketing(&open_brackets[1..])\n   \
    \     && correct_bracketing(&closed_brackets[1..])\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptf2mk24b.rs:18:12\n\
    \   |\n18 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptf2mk24b.rs:19:32\n   |\n19 |             open_brackets.push(brackets[i]);\n\
    \   |                                ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptf2mk24b.rs:25:34\n   |\n25 |             closed_brackets.push(brackets[i]);\n\
    \   |                                  ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::op"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let c = stack.pop().unwrap();\n        if c == '(' || c == '[' {\n\
    \            stack.push(c);\n        } else if c == ')' || c == ']' {\n      \
    \      if stack.len() == 0 {\n                return false;\n            }\n \
    \           let c = stack.pop().unwrap();\n            if c != c {\n         \
    \       return false;\n            }\n        } else {\n            return false;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp5t61ki8h.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp5t61ki8h.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp5t61ki8h.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return brackets.chars().all(|c| c == '(') || brackets.chars().all(|c|\
    \ c == ')');\n        }\n        if brackets.chars().all(|c| c == '(') {\n   \
    \         stack.push(brackets.chars().filter(|c| c != '(').collect::<String>());\n\
    \        }\n        if brackets.chars().all(|c| c == ')') {\n            stack.push(brackets.chars().filter(|c|\
    \ c != ')').collect::<String>());\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3sdj5iup.rs:19:54\n\
    \   |\n19 |             stack.push(brackets.chars().filter(|c| c != '(').collect::<String>());\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3sdj5iup.rs:22:54\n\
    \   |\n22 |             stack.push(brackets.chars().filter(|c| c != ')').collect::<String>());\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_stack_size = Vec::new();\n\
    \    let mut close_brackets_stack_size = Vec::new();\n    let mut open_brackets_stack_pos\
    \ = Vec::new();\n    let mut close_brackets_stack_pos = Vec::new();\n    let mut\
    \ open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_stack_string_size = String::new();\n\
    \    let mut close_brackets_stack_string_size = String::new();\n    let mut open_brackets_stack_pos\
    \ = String::new();\n    let mut close_brackets_stack_pos = String::new();\n  \
    \  let mut open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_stack_string_size = String::new();\n\
    \    let mut close_brackets_stack_string_size = String::new();\n    let mut open_brackets_stack_pos\
    \ = String::new();\n    let mut close_brackets_stack_pos = String::new();\n  \
    \  let mut open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_stack_string_size = String::new();\n\
    \    let mut close_brackets_stack_string_size = String::new();\n    let mut open_brackets_stack_pos\
    \ = String::new();\n    let mut close_brackets_stack_pos = String::new();\n  \
    \  let mut open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_stack_string_size = String::new();\n\
    \    let mut close_brackets_stack_string_size = String::new();\n    let mut open_brackets_stack_pos\
    \ = String::new();\n    let mut close_brackets_stack_pos = String::new();\n  \
    \  let mut open_brackets_stack_string = String::new();\n    let mut close\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprn6y_nzm.rs:45:18\n   |\n\
    45 |     let mut close\n   |                  ^ help: add `;` here\n46 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprn6y_nzm.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets {\n \
    \       if ch == '(' {\n            stack.push('(');\n        } else if ch ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpbh8zm7hk.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{' || c == '<' || c == '>' || c == '|')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqceg1n3n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let c = stack.last().unwrap();\n        if c == ')' {\n        \
    \    stack.pop();\n        } else {\n            stack.push(c);\n        }\n \
    \   }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxqc6o0uu.rs:19:14\n\
    \   |\n19 |         if c == ')' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxqc6o0uu.rs:22:24\n   |\n22 |  \
    \           stack.push(c);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |         \
    \    stack.push(*c);\n   |                        +\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for c in brackets {\n        if c ==\
    \ '(' {\n            opening_brackets.push(c);\n        } else if c == ')' {\n\
    \            closing_brackets.push(c);\n        } else {\n            return false;\n\
    \        }\n    }\n    if opening_brackets.len() != closing_brackets.len() {\n\
    \        return false;\n    }\n    for opening_bracket in opening_brackets.chars().filter(|c|\
    \ c == '(') {\n        if closing_brackets.contains(&opening_bracket) {\n    \
    \        return false;\n        }\n    }\n    for opening_bracket in opening_brackets.chars().filter(|c|\
    \ c == ')') {\n        if opening_brackets.contains(&closing_bracket) {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `closing_bracket` in this scope\n  -->\
    \ /tmp/tmp95iiifxr.rs:32:39\n   |\n32 |         if opening_brackets.contains(&closing_bracket)\
    \ {\n   |                                       ^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `closing_brackets`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmp95iiifxr.rs:14:14\n   |\n14 |     for c in\
    \ brackets {\n   |              ^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp95iiifxr.rs:26:66\n   |\n26 |     for opening_bracket in opening_brackets.chars().filter(|c|\
    \ c == '(') {\n   |                                                          \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmp95iiifxr.rs:27:38\n     |\n27   |         if closing_brackets.contains(&opening_bracket)\
    \ {\n     |                             -------- ^^^^^^^^^^^^^^^^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n     |                             |\n\
    \     |                             required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n27   |         if closing_brackets.contains(*&opening_bracket)\
    \ {\n     |                                      +\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp95iiifxr.rs:31:66\n   |\n31 |     for opening_bracket\
    \ i"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\"\
    >\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \"\
    >\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnunhhwl8.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmppe3ai927.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmppe3ai927.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmppe3ai927.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch as usize);\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push((ch, false));\n        } else\
    \ if ch == ')' {\n            if let Some((_, is_open)) = stack.pop() {\n    \
    \            if !is_open {\n                    return false;\n              \
    \  }\n            } else {\n                return false;\n            }\n   \
    \     } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyjgedt99.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprm4od569.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprm4od569.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return false;\n            }\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpgni1wo64.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return brackets.chars().all(|c| c == '(') || brackets.chars().all(|c|\
    \ c == ')');\n        }\n        if brackets.len() == 2 {\n            let mut\
    \ stack = Vec::new();\n            stack.push(brackets);\n            while let\
    \ Some(brackets) = stack.pop() {\n                if brackets.len() == 1 {\n \
    \                   return brackets.chars().all(|c| c == '(') || brackets.chars().all(|c|\
    \ c == ')');\n                }\n                if brackets.len() == 2 {\n  \
    \                  stack.push(brackets);\n                }\n            }\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp009urqu0.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    for bracket in\
    \ brackets.chars() {\n        if bracket == '(' {\n            stack.push(bracket);\n\
    \            opening_brackets.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            closing_brackets.push(stack.pop());\n        } else if bracket\
    \ == '[' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(bracket);\n        } else if bracket ==\
    \ ']' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            closing_brackets.push(stack.pop());\n        }\n   \
    \ }\n    if stack.len() != 0 {\n        return false;\n    }\n    if opening_brackets.len()\
    \ != closing_brackets.len() {\n        return false;\n    }\n    for opening_bracket\
    \ in opening_brackets {\n        if closing_brackets.contains(&opening_bracket)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwx4ywplt.rs:43:38\n   |\n\
    43 |         if closing_brackets.contains(&opening_bracket) {\n   |          \
    \                            ^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected reference `&Option<char>`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ String::new();\n    let mut close_brackets = String::new();\n    for bracket\
    \ in brackets.chars() {\n        if bracket == '(' {\n            stack.push(bracket);\n\
    \            open_brackets.push('(');\n        } else if bracket == ')' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\n\
    \            close_brackets.push(bracket);\n            stack.pop();\n       \
    \ } else if bracket == '[' {\n            stack.push(bracket);\n            open_brackets.push('[');\n\
    \        } else if bracket == ']' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(bracket);\n\
    \            stack.pop();\n        } else if bracket == '{' {\n            stack.push(bracket);\n\
    \            open_brackets.push('{');\n        } else if bracket == '}' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\n\
    \            close_brackets.push(bracket);\n            stack.pop();\n       \
    \ }\n    }\n    if stack.len() != 0 {\n        return false;\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp5aqhdu54.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp5aqhdu54.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp5aqhdu54.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(');\n    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != ')');\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next.is_some() && closing_brackets_next.is_some() {\n     \
    \   if opening_brackets_next.unwrap() == '(' {\n            opening_brackets +=\
    \ opening_brackets_next.unwrap();\n            opening_brackets_next = opening_brackets_iter.next();\n\
    \        }\n        if closing_brackets_next.unwrap() == ')' {\n            closing_brackets\
    \ += closing_brackets_next.unwrap();\n            closing_brackets_next = closing_brackets_iter.next();\n\
    \        }\n    }\n    opening_brackets.chars().all(|c| closing_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnqeep4t5.rs:14:84\n\
    \   |\n14 |     let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(');\n   |                                                       \
    \                             ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpnqeep4t5.rs:15:84\n   |\n15 |     let mut\
    \ closing_brackets_iter = brackets.chars().enumerate().filter(|(_, c)| c != ')');\n\
    \   |                                                                        \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnqeep4t5.rs:19:46\n\
    \   |\n19 |         if opening_brackets_next.unwrap() == '(' {\n   |         \
    \                                     ^^^ expected tuple, found `char`\n   |\n\
    \   = note: expected tuple `(usize, char)`\n               found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnqeep4t5.rs:20:33\n   |\n20 |\
    \             opening_brackets += opening_brackets_next.unwrap();\n   |      \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ tuple\n   |\n   = note: expected reference `&str`\n                  found tuple\
    \ `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnqeep4t5.rs:23:46\n\
    \   |\n23 |         if closing_brackets_next.unwrap() == ')' {\n   |         \
    \                                     ^^^ expected tuple, found `char`\n   |\n\
    \   = note: expected tuple `(usize, char)`\n               found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnqeep4t5.rs:24:33\n   |\n24 |\
    \             closing_brackets += closing_brackets_next.unwrap();\n   |      \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ tuple\n   |\n   = note: expecte"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for c in\
    \ brackets.chars() {\n        if c == '(' {\n            stack.push(0);\n    \
    \    } else if c == ')' {\n            if stack.len() == 0 {\n               \
    \ return false;\n            }\n            stack.pop();\n        } else {\n \
    \           if stack.len() == 0 {\n                return false;\n           \
    \ }\n            stack[stack.len() - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x|\
    \ x == 0)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpkfokxhzq.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpkfokxhzq.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpkfokxhzq.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpp0hjow_s.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_string: String = String::new();\n    let mut\
    \ close_brackets_string: String = String::new();\n    let mut open_brackets_string_size:\
    \ usize = 0;\n    let mut close_brackets_string_size: usize = 0;\n    let mut\
    \ open_brackets_string_size2: usize = 0;\n    let mut close_brackets_string_size2:\
    \ usize = 0;\n    let mut open_brackets_string_size3: usize = 0;\n    let mut\
    \ close_brackets_string_size3: usize = 0;\n    let mut open_brackets_string_size4:\
    \ usize = 0;\n    let mut close_brackets_string_size4: usize = 0;\n    let mut\
    \ open_brackets_string_size5: usize = 0;\n    let mut close_brackets_string_size5:\
    \ usize = 0;\n    let mut open_brackets_string_size6: usize = 0;\n    let mut\
    \ close_brackets_string_size6: usize = 0;\n    let mut open_brackets_string_size7:\
    \ usize = 0;\n    let mut close_brackets_string_size7: usize = 0;\n    let mut\
    \ open_brackets_string_size8: usize = 0;\n    let mut close_brackets_string_size8:\
    \ usize = 0;\n    let mut open_brackets_string_size9: usize = 0;\n    let mut\
    \ close_brackets_string_size9: usize = 0;\n    let mut open_brackets_string_size10:\
    \ usize = 0;\n    let mut close_brackets_string_size10: usize = 0;\n    let mut\
    \ open_brackets_string_size11: usize = 0;\n    let mut close_brackets_string_size11:\
    \ usize = 0;\n    let mut open_brackets_string_size12: usize = 0;\n    let mut\
    \ close_brackets_string_size12: usize = 0;\n    let mut open_brackets_string_size13:\
    \ usize = 0;\n    let mut close_brackets_string_size13: u\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ytx_ck5.rs:44:44\n   |\n\
    44 |     let mut close_brackets_string_size13: u\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0412]: cannot find type `u` in this scope\n  --> /tmp/tmp_ytx_ck5.rs:44:43\n\
    \   |\n44 |     let mut close_brackets_string_size13: u\n   |                \
    \                           ^ help: a builtin type with a similar name exists:\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ytx_ck5.rs:11:44\n  \
    \ |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if let Some(open) = stack.pop() {\n                if\
    \ open != ch {\n                    return false;\n                }\n       \
    \     } else {\n                return false;\n            }\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ywx_z6n.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last() {\n        if b == ')' {\n            stack.pop();\n\
    \        } else if b == '(' {\n            stack.push(b);\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnc2xub2g.rs:15:14\n\
    \   |\n15 |         if b == ')' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnc2xub2g.rs:18:24\n   |\n18 |  \
    \           stack.push(b);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |         \
    \    stack.push(*b);\n   |                        +\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpnc2xub2g.rs:17:21\n   |\n17 |         } else\
    \ if b == '(' {\n   |                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpeq3skc8a.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.len() > 0 && c == stack.pop().unwrap()\
    \ {\n            continue;\n        }\n        stack.push(c);\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw2c5_s8t.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while !brackets.is_empty()\
    \ {\n        let mut current = brackets.chars().next().unwrap();\n        if current\
    \ == '(' || current == ')' {\n            brackets = brackets.replace(\"(\" +\
    \ current + \")\", \"\");\n        } else {\n            return false;\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `&str`\n  --> /tmp/tmpq3q8pkfn.rs:16:45\n\
    \   |\n16 |             brackets = brackets.replace(\"(\" + current + \")\", \"\
    \");\n   |                                         --- ^ ------- char\n   |  \
    \                                       |\n   |                              \
    \           &str\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n\n    for bracket in\
    \ brackets.chars() {\n        if bracket == '(' {\n            stack.push(bracket);\n\
    \            open_brackets.push(bracket);\n        } else if bracket == ')' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            close_brackets.push(stack.pop());\n        } else if bracket\
    \ == '[' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.push(bracket);\n        } else if bracket ==\
    \ ']' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            close_brackets.push(stack.pop());\n        } else {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            stack.push(bracket);\n        }\n    }\n\n    for open_bracket\
    \ in open_brackets {\n        if close_brackets.contains(&open_bracket) {\n  \
    \          return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsxfbtxew.rs:44:36\n   |\n\
    44 |         if close_brackets.contains(&open_bracket) {\n   |               \
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected reference `&Option<char>`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7j81fufc.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq8a6g1kd.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8a6g1kd.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets.chars().any(|c| !c.is_ascii_letter()) {\n       \
    \         return false;\n            }\n        } else {\n            if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c == ')') {\n                return false;\n       \
    \     }\n        }\n        stack.push(brackets);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmptqi73mdr.rs:16:44\n   |\n16 |             if\
    \ brackets.chars().any(|c| !c.is_ascii_letter()) {\n   |                     \
    \                       ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmptqi73mdr.rs:20:44\n\
    \   |\n20 |             if brackets.chars().any(|c| !c.is_ascii_letter() || c\
    \ == ')') {\n   |                                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(').collect::<Vec<_>>();\n    let mut closed_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != ')').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut closed_brackets_iter = closed_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2jtv1wau.rs:28:48\n   |\n\
    28 |     let mut open_brackets_iter = open_brackets_\n   |                   \
    \                             ^ help: add `;` here\n29 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `open_brackets_` in this scope\n  -->\
    \ /tmp/tmp2jtv1wau.rs:28:34\n   |\n28 |     let mut open_brackets_iter = open_brackets_\n\
    \   |                                  ^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `open_brackets`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp2jtv1wau.rs:14:81\n   |\n14 |     let mut open_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '(').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp2jtv1wau.rs:15:83\n   |\n15 |     let mut closed_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != ')').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2jtv1wau.rs:18:70\n\
    \   |\n18 |     let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c).collect::<Vec<_>>();\n   |                                          \
    \                            ^^^^^-\n   |                                    \
    \                                  |    |\n   |                              \
    \                                        |    expected due to this\n   |     \
    \                                                                 expected `char`,\
    \ found tuple\n   |\n   = note: expected type `char`\n             found tuple\
    \ `(_, _)`\n\nerror[E0308]:"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    stack.push(brackets);\n\
    \    while !stack.is_empty() {\n        let mut current = stack.pop();\n     \
    \   if current.len() == 0 {\n            continue;\n        }\n        let mut\
    \ next = current.clone();\n        while !next.is_empty() {\n            let mut\
    \ next = next.clone();\n            if next[0] != '(' {\n                return\
    \ false;\n            }\n            next.pop();\n            if next.len() ==\
    \ 0 {\n                continue;\n            }\n            if next[0] != '('\
    \ {\n                return false;\n            }\n            next.pop();\n \
    \           stack.push(next);\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp5i7xnc4t.rs:16:20\n   |\n16 |         if current.len()\
    \ == 0 {\n   |                    ^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `is_empty` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp5i7xnc4t.rs:20:21\n   |\n20 |         while !next.is_empty()\
    \ {\n   |                     ^^^^^^^^ method not found in `Option<String>`\n\n\
    error[E0608]: cannot index into a value of type `Option<String>`\n  --> /tmp/tmp5i7xnc4t.rs:22:16\n\
    \   |\n22 |             if next[0] != '(' {\n   |                ^^^^^^^\n\nerror[E0599]:\
    \ no method named `pop` found for enum `Option` in the current scope\n  --> /tmp/tmp5i7xnc4t.rs:25:18\n\
    \   |\n25 |             next.pop();\n   |                  ^^^ method not found\
    \ in `Option<String>`\n\nerror[E0599]: no method named `len` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmp5i7xnc4t.rs:26:21\n   |\n26 |          \
    \   if next.len() == 0 {\n   |                     ^^^ method not found in `Option<String>`\n\
    \nerror[E0608]: cannot index into a value of type `Option<String>`\n  --> /tmp/tmp5i7xnc4t.rs:29:16\n\
    \   |\n29 |             if next[0] != '(' {\n   |                ^^^^^^^\n\nerror[E0599]:\
    \ no method named `pop` found for enum `Option` in the current scope\n  --> /tmp/tmp5i7xnc4t.rs:32:18\n\
    \   |\n32 |             next.pop();\n   |                  ^^^ method not found\
    \ in `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5i7xnc4t.rs:33:24\n\
    \   |\n33 |             stack.push(next);\n   |                        ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<String>`\n\nerror: aborting due to 8 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            closed_brackets.push(')');\n        } else {\n          \
    \  open_brackets.push(bracket);\n            closed_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp35zh9xsb.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(\"(\");\n        } else if\
    \ ch == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr93pzp8h.rs:15:24\n   |\n\
    15 |             stack.push(\"(\");\n   |                        ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr93pzp8h.rs:26:24\n   |\n26 |             stack.push(ch);\n\
    \   |                        ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars().filter(|c|\
    \ c == '(' || c == '[' || c == '{') {\n        if stack.len() > 0 {\n        \
    \    match stack.pop() {\n                Some('(') => return false,\n       \
    \         Some('[') => return false,\n                Some('{') => return false,\n\
    \                _ => (),\n            }\n        }\n        stack.push(bracket);\n\
    \    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_sds64af.rs:13:50\n\
    \   |\n13 |     for bracket in brackets.chars().filter(|c| c == '(' || c == '['\
    \ || c == '{') {\n   |                                                  ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_sds64af.rs:13:62\n\
    \   |\n13 |     for bracket in brackets.chars().filter(|c| c == '(' || c == '['\
    \ || c == '{') {\n   |                                                       \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_sds64af.rs:13:74\n\
    \   |\n13 |     for bracket in brackets.chars().filter(|c| c == '(' || c == '['\
    \ || c == '{') {\n   |                                                       \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.push(open);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_brackets_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n    let mut closing_brackets_size\
    \ = brackets.chars().filter(|c| c == ')').count();\n    let mut opening_brackets_size2\
    \ = brackets.chars().filter(|c| c == '[' || c == '{').count();\n    let mut closing_brackets_size2\
    \ = brackets.chars().filter(|c| c == ']' || c == '}').count();\n    let mut opening_brackets_size3\
    \ = brackets.chars().filter(|c| c == '(' || c == '[' || c == '{' || c == '<').count();\n\
    \    let mut closing_brackets_size3 = brackets.chars().filter(|c| c == ')' ||\
    \ c == ']' || c == '}' || c == '>').count();\n    let mut opening_brackets_size4\
    \ = brackets.chars().filter(|c| c == '[' || c == '<' || c == '{' || c == '(').count();\n\
    \    let mut closing_brackets_size4 = brackets.chars().filter(|c| c == ']' ||\
    \ c == '>' || c == '}' || c == ')' || c == '}').count();\n    let mut opening_brackets_size5\
    \ = brackets.chars().filter(|c| c == '[' || c == '<' || c == '(' || c == '{' ||\
    \ c == '(' || c == '[' || c == '<' || c == '{' || c == '<' || c == '(').count();\n\
    \    let mut closing_brackets_size5 = brackets.chars().filter(|c| c == ']' ||\
    \ c == '>' || c == '}' || c == ')' || c == '}' || c == ']' || c == '>' || c ==\
    \ ']' || c == '>' || c == '}' || c == ')' || c == ']' || c == '>' || c == ']'\
    \ || c == '>' || c == '}' || c == ')' || c == ']' || c == '>' || c == ']' || c\
    \ == '>' || c == '}' || c == ')' || c == ']' || c == '>' || c == ']' || c == '>'\
    \ || c == '}' || c == ')' || c == ']' || c == '>' || c == ']' || c == '>' || c\
    \ == '}' || c == ')' || c == ']' || c == '>' || c == ']' || c == '>' || c == '}'\
    \ || c == ')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmplvofkbwl.rs:24:551\n\
    \   |\n24 | ... c == ']' || c == '>' || c == ']' || c == '>' || c == '}' || c\
    \ == ')\n   |                                                                \
    \      ^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets {\n \
    \       if ch == \")\" {\n            if !stack.is_empty() {\n               \
    \ stack.pop();\n            } else {\n                return false;\n        \
    \    }\n        } else if ch == \"(\" {\n            stack.push(ch);\n       \
    \ } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpilubqbs3.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ String::new();\n    let mut close_brackets = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_map = HashMap::new();\n    let mut close_brackets_count_map\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse_2 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_2 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_3 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_3\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_4 = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted_reverse_4 = HashMap::new();\n   \
    \ let mut open_brackets_count_map_sorted_reverse_5 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_5 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_6 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_6\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_7 = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted_reverse_7 = HashMap::new();\n   \
    \ let mut open_brackets_count_map_sorted_reverse_8 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_8 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_9 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_9\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_10 = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted_reverse_10 = HashMap::new();\n  \
    \  let \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpj2_vkqp3.rs:42:1\n  \
    \ |\n42 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashMap`\n  --> /tmp/tmpj2_vkqp3.rs:17:39\n   |\n17 |     let\
    \ mut open_brackets_count_map = HashMap::new();\n   |                        \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpj2_vkqp3.rs:18:40\n\
    \   |\n18 |     let mut close_brackets_count_map = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpj2_vkqp3.rs:19:46\n   |\n19 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpj2_vkqp3.rs:20:47\n   |\n20\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpj2_vkqp3.rs:21:54\n   |\n21 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpj2_vkqp3.rs:22:55\n   |\n22\
    \ |     let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n  \
    \ |                                                       ^^^^^^^ not foun"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb57mkcuf.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            opening_brackets.push(bracket);\n\
    \            opening_brackets_stack.push(bracket);\n        } else if bracket\
    \ == ')' {\n            closing_brackets.push(bracket);\n            closing_brackets_stack.push(bracket);\n\
    \        } else if opening_brackets_stack.len() > 0 {\n            if opening_brackets_stack.last().unwrap()\
    \ == bracket {\n                opening_brackets_stack.pop();\n            } else\
    \ {\n                opening_brackets_stack.push(bracket);\n            }\n  \
    \      } else if closing_brackets_stack.len() > 0 {\n            if closing_brackets_stack.last().unwrap()\
    \ == bracket {\n                closing_brackets_stack.pop();\n            } else\
    \ {\n                closing_brackets_stack.push(bracket);\n            }\n  \
    \      } else {\n            return false;\n        }\n    }\n    opening_brackets_stack.len()\
    \ == 0 && closing_brackets_stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6436o69x.rs:24:55\n\
    \   |\n24 |             if opening_brackets_stack.last().unwrap() == bracket {\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6436o69x.rs:30:55\n\
    \   |\n30 |             if closing_brackets_stack.last().unwrap() == bracket {\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            opening_brackets.push('(');\n  \
    \          opening_brackets_stack.push(bracket);\n        } else if bracket ==\
    \ ')' {\n            if opening_brackets_stack.len() == 0 {\n                return\
    \ false;\n            }\n            opening_brackets_stack.pop();\n         \
    \   closing_brackets.push(bracket);\n        } else if bracket == '[' {\n    \
    \        opening_brackets.push('[');\n        } else if bracket == ']' {\n   \
    \         if opening_brackets_stack.len() == 0 {\n                return false;\n\
    \            }\n            opening_brackets_stack.pop();\n        } else if bracket\
    \ == '{' {\n            opening_brackets.push('{');\n        } else if bracket\
    \ == '}' {\n            if opening_brackets_stack.len() == 0 {\n             \
    \   return false;\n            }\n            opening_brackets_stack.pop();\n\
    \        } else {\n            closing_brackets.push(bracket);\n        }\n  \
    \  }\n\n    if opening_brackets_stack.len() != 0 {\n        return false;\n  \
    \  }\n\n    if closing_brackets.len() != 0 {\n        return false;\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpj8_3dfwz.rs:15:38\n\
    \   |\n15 |     let mut closing_brackets_stack = Vec::new();\n   |         --------------------------\
    \   ^^^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |  \
    \       consider giving `closing_brackets_stack` the explicit type `Vec<T>`, where\
    \ the type parameter `T` is specified\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets[0] == '(' {\n                stack.push(brackets);\n\
    \            } else {\n                stack.pop();\n            }\n        }\
    \ else {\n            if brackets[0] == '(' {\n                stack.push(brackets.clone());\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpdavegjl0.rs:16:16\n   |\n16 |             if brackets[0] == '(' {\n\
    \   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpdavegjl0.rs:22:16\n   |\n22 |             if brackets[0] == '('\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while brackets.len()\
    \ > 0 {\n        let mut opening = brackets.chars().next().unwrap();\n       \
    \ let mut closing = brackets.chars().next().unwrap();\n        if opening != closing\
    \ {\n            return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_lk4fpfw.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = brackets.chars().next().unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx: usize\
    \ = 0;\n    let mut open_brackets_idx2: usize = 0;\n    let mut close_brackets_idx2:\
    \ usize = 0;\n    let mut open_brackets_idx3: usize = 0;\n    let mut close_brackets_idx3:\
    \ usize = 0;\n    let mut open_brackets_idx4: usize = 0;\n    let mut close_brackets_idx4:\
    \ usize = 0;\n    let mut open_brackets_idx5: usize = 0;\n    let mut close_brackets_idx5:\
    \ usize = 0;\n    let mut open_brackets_idx6: usize = 0;\n    let mut close_brackets_idx6:\
    \ usize = 0;\n    let mut open_brackets_idx7: usize = 0;\n    let mut close_brackets_idx7:\
    \ usize = 0;\n    let mut open_brackets_idx8: usize = 0;\n    let mut close_brackets_idx8:\
    \ usize = 0;\n    let mut open_brackets_idx9: usize = 0;\n    let mut close_brackets_idx9:\
    \ usize = 0;\n    let mut open_brackets_idx10: usize = 0;\n    let mut close_brackets_idx10:\
    \ usize = 0;\n    let mut open_brackets_idx11: usize = 0;\n    let mut close_brackets_idx11:\
    \ usize = 0;\n    let mut open_brackets_idx12: usize = 0;\n    let mut close_brackets_idx12:\
    \ usize = 0;\n    let mut open_brackets_idx13: usize = 0;\n    let mut close_brackets_idx13:\
    \ usize = 0;\n    let mut open_brackets_idx14: usize = 0;\n    let mut close_brackets_idx14:\
    \ usize = 0;\n    let mut open_brackets_idx15: usize = 0;\n    let mut close_brackets_idx15:\
    \ usize = 0;\n    let mut open_brackets_idx16: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo7vzs4z1.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo7vzs4z1.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     stack.pop();\n        } else {\n            stack.push(brackets.chars().next().unwrap());\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6lv7n1lo.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets {\n \
    \       if ch == '(' {\n            stack.push('(');\n        } else if ch ==\
    \ ')' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpqmfqr_5z.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2c0ky1so.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp2c0ky1so.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp2c0ky1so.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \"\" {\n\
    \            continue;\n        }\n        if brackets.chars().any(|c| !('(' <=\
    \ c && c <= ')')) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !('[' <= c && c <= ']')) {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !('{' <= c && c <= '}')) {\n            return false;\n\
    \        }\n        if brackets.chars().any(|c| !('(' <= c && c <= ')')) {\n \
    \           return false;\n        }\n        if brackets.chars().any(|c| !('['\
    \ <= c && c <= ']')) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !('[' <= c && c <= ']')) {\n            return false;\n\
    \        }\n        if brackets.chars().any(|c| !('{' <= c && c <= '}')) {\n \
    \           return false;\n        }\n        if brackets.chars().any(|c| !('['\
    \ <= c && c <= ']')) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !('[' <= c && c <= ']')) {\n            return false;\n\
    \        }\n        if brackets.chars().any(|c| !('{' <= c && c <= '}')) {\n \
    \           return false;\n        }\n        if brackets.chars().any(|c| !('['\
    \ <= c && c <= ']')) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !('[' <= c && c <= ']')) {\n            return false;\n\
    \        }\n        if brackets.chars().any(|c| !('{' <= c && c <= '}')) {\n \
    \           return false;\n        }\n        if brackets.chars().any(|c| !('['\
    \ <= c && c <= ']')) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !('[' <= \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpe53kvhec.rs:89:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ let Some(brackets) = stack.pop() {\n   |                                   \
    \         - this delimiter might not be properly closed...\n...\n73 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n89 | }\n   |\
    \   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmpe53kvhec.rs:73:1\n\
    \   |\n73 | }\n   | ^ expected expression\n\nerror: expected `{`, found `}`\n\
    \  --> /tmp/tmpe53kvhec.rs:73:1\n   |\n72 |         if brackets.chars().any(|c|\
    \ !('[' <= \n   |         -- this `if` expression has a condition, but no block\n\
    73 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpe53kvhec.rs:72:38\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |                                                 - closing delimiter\
    \ possibly meant for this\n...\n72 |         if brackets.chars().any(|c| !('['\
    \ <= \n   |                                      ^ unclosed delimiter\n73 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe53kvhec.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last_mut() {\n        if b == '(' || b == ')' {\n\
    \            stack.pop();\n        } else {\n            stack.push(b);\n    \
    \    }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&mut char` with `char`\n  --> /tmp/tmp11ktmf91.rs:15:14\n\
    \   |\n15 |         if b == '(' || b == ')' {\n   |              ^^ no implementation\
    \ for `&mut char == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `&mut char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&mut char` with `char`\n  --> /tmp/tmp11ktmf91.rs:15:26\n\
    \   |\n15 |         if b == '(' || b == ')' {\n   |                          ^^\
    \ no implementation for `&mut char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&mut char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11ktmf91.rs:18:24\n\
    \   |\n18 |             stack.push(b);\n   |                        ^ expected\
    \ `char`, found `&mut char`\n   |\nhelp: consider dereferencing the borrow\n \
    \  |\n18 |             stack.push(*b);\n   |                        +\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppa0_2t0c.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening = String::new();\n\
    \    let mut closing = String::new();\n    let mut opening_count = String::new();\n\
    \    let mut closing_count = String::new();\n    let mut opening_counts = String::new();\n\
    \    let mut closing_counts = String::new();\n    let mut opening_counts_str =\
    \ String::new();\n    let mut closing_counts_str = String::new();\n    let mut\
    \ opening_counts_str = String::new();\n    let mut closing_counts_str = String::new();\n\
    \    let mut opening_counts_str = String::new();\n    let mut closing_counts_str\
    \ = String::new();\n    let mut opening_counts_str = String::new();\n    let mut\
    \ closing_counts_str = String::new();\n    let mut opening_counts_str = String::new();\n\
    \    let mut closing_counts_str = String::new();\n    let mut opening_counts_str\
    \ = String::new();\n    let mut closing_counts_str = String::new();\n    let mut\
    \ opening_counts_str = String::new();\n    let mut closing_counts_str = String::new();\n\
    \    let mut opening_counts_str = String::new();\n    let mut closing_counts_str\
    \ = String::new();\n    let mut opening_counts_str = String::new();\n    let mut\
    \ closing_counts_str = String::new();\n    let mut opening_counts_str = String::new();\n\
    \    let mut closing_counts_str = String::new();\n    let mut opening_counts_str\
    \ = String::new();\n    let mut closing_counts_str = String::new();\n    let mut\
    \ opening_counts_str = String::new();\n    let mut closing_counts_str = String::new();\n\
    \    let mut opening_counts_str = String::new();\n    let mut closing_counts_str\
    \ = String::new();\n    let mut opening_counts_str = String::new();\n    let mut\
    \ closing_counts_str = String::new();\n    let mut opening_counts_str = String::new();\n\
    \    let mut closing_counts_str = String::new();\n    let mut opening_counts_str\
    \ = String::new();\n    let mut closing_counts_str = String::new();\n    let mut\
    \ opening_counts_str = String::new();\n    let mut closing_counts_\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm6zxo9vm.rs:52:28\n   |\n\
    52 |     let mut closing_counts_\n   |                            ^ help: add\
    \ `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm6zxo9vm.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ String::new();\n    let mut closed_brackets = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut closed_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_max = String::new();\n    let mut closed_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut closed_brackets_count_min = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut closed_brackets_count_min = String::new();\n \
    \   let mut open_brackets_count_max = String::new();\n    let mut closed_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut closed_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut closed_brackets_count_max = String::new();\n \
    \   let mut open_brackets_count_min = String::new();\n    let mut closed_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut closed_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut closed_brackets_count_min = String::new();\n \
    \   let mut open_brackets_count_max = String::new();\n    let mut closed_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut closed_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut closed_brackets_count_max = String::new();\n \
    \   let mut open_brackets_count_min = String::new();\n    let mut closed_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut closed_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut closed_brackets_count_min = String::new();\n \
    \   let mut open_brackets_count_max = String::new();\n    let \n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4h_edeoj.rs:49:1\n  \
    \ |\n49 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else if ch == '[' {\n    \
    \        stack.push('[');\n        } else if ch == ']' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else if ch == '{' {\n            stack.push('{');\n        } else if\
    \ ch == '}' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for c in brackets {\n        if c ==\
    \ '(' {\n            opening_brackets.push(c);\n        } else if c == ')' {\n\
    \            closing_brackets.push(c);\n        } else {\n            assert!(opening_brackets.is_empty());\n\
    \            assert!(closing_brackets.is_empty());\n            return false;\n\
    \        }\n    }\n    opening_brackets.is_empty() && closing_brackets.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprryvjmfj.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push((ch, false));\n        } else\
    \ if ch == ')' {\n            if let Some((_, is_open)) = stack.pop() {\n    \
    \            if is_open {\n                    return false;\n               \
    \ }\n            } else {\n                return false;\n            }\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf1qql5b3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi93wrub2.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    let mut open_brackets:\
    \ Vec<String> = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n \
    \   let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_open: usize = 0;\n    let mut close_brackets_open:\
    \ usize = 0;\n    let mut open_brackets_close: usize = 0;\n    let mut close_brackets_close:\
    \ usize = 0;\n    let mut open_brackets_close_bracket: usize = 0;\n    let mut\
    \ close_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_bracket: usize = 0;\n    let mut open_brackets_open_bracket:\
    \ usize = 0;\n    let mut close_brackets_open_bracket: usize = 0;\n    let mut\
    \ open_brackets_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwgui8ay0.rs:43:27\n   |\n\
    43 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwgui8ay0.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_paren = String::new();\n    let mut closing_paren = String::new();\n\
    \    let mut opening_paren_counter = 0;\n    let mut closing_paren_counter = 0;\n\
    \    let mut opening_paren_counter2 = 0;\n    let mut closing_paren_counter2 =\
    \ 0;\n    let mut opening_paren_counter3 = 0;\n    let mut closing_paren_counter3\
    \ = 0;\n    let mut opening_paren_counter4 = 0;\n    let mut closing_paren_counter4\
    \ = 0;\n    let mut opening_paren_counter5 = 0;\n    let mut closing_paren_counter5\
    \ = 0;\n    let mut opening_paren_counter6 = 0;\n    let mut closing_paren_counter6\
    \ = 0;\n    let mut opening_paren_counter7 = 0;\n    let mut closing_paren_counter7\
    \ = 0;\n    let mut opening_paren_counter8 = 0;\n    let mut closing_paren_counter8\
    \ = 0;\n    let mut opening_paren_counter9 = 0;\n    let mut closing_paren_counter9\
    \ = 0;\n    let mut opening_paren_counter10 = 0;\n    let mut closing_paren_counter10\
    \ = 0;\n    let mut opening_paren_counter11 = 0;\n    let mut closing_paren_counter11\
    \ = 0;\n    let mut opening_paren_counter12 = 0;\n    let mut closing_paren_counter12\
    \ = 0;\n    let mut opening_paren_counter13 = 0;\n    let mut closing_paren_counter13\
    \ = 0;\n    let mut opening_paren_counter14 = 0;\n    let mut closing_paren_counter14\
    \ = 0;\n    let mut opening_paren_counter15 = 0;\n    let mut closing_paren_counter15\
    \ = 0;\n    let mut opening_paren_counter16 = 0;\n    let mut closing_paren_counter16\
    \ = 0;\n    let mut opening_paren_counter17 = 0;\n    let mut closing_paren_counter17\
    \ = 0;\n    let mut opening_paren_counter18 = 0;\n    let mut closing_paren_counter18\
    \ = 0;\n    let mut opening_paren_counter19 = 0;\n    let mut closing_paren_counter19\
    \ = 0;\n    let mut opening_paren_counter20 = 0;\n    let mut closing_\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwm5tkx07.rs:58:21\n   |\n\
    58 |     let mut closing_\n   |                     ^ help: add `;` here\n59 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwm5tkx07.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = String::new();\n    let mut closing_brackets = String::new();\n    for c in\
    \ brackets {\n        if c == '(' {\n            stack.push(c);\n            opening_brackets.push(c);\n\
    \        } else if c == ')' {\n            if stack.is_empty() {\n           \
    \     return false;\n            }\n            closing_brackets.push(c);\n  \
    \          stack.pop();\n        } else if c == '[' {\n            stack.push(c);\n\
    \        } else if c == ']' {\n            if stack.is_empty() {\n           \
    \     return false;\n            }\n            stack.pop();\n        } else if\
    \ c == '{' {\n            stack.push(c);\n        } else if c == '}' {\n     \
    \       if stack.is_empty() {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprhp8ouof.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_count = String::new();\n\
    \    let mut closing_brackets_count = String::new();\n    let mut opening_brackets_count_map\
    \ = String::new();\n    let mut closing_brackets_count_map = String::new();\n\
    \    let mut opening_brackets_count_map_sorted = String::new();\n    let mut closing_brackets_count_map_sorted\
    \ = String::new();\n    let mut opening_brackets_count_map_sorted_reverse = String::new();\n\
    \    let mut closing_brackets_count_map_sorted_reverse = String::new();\n    let\
    \ mut opening_brackets_count_map_sorted_reverse_map = String::new();\n    let\
    \ mut closing_brackets_count_map_sorted_reverse_map = String::new();\n    let\
    \ mut opening_brackets_count_map_sorted_reverse_map_sorted = String::new();\n\
    \    let mut closing_brackets_count_map_sorted_reverse_map_sorted = String::new();\n\
    \    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse = String::new();\n\
    \    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse = String::new();\n\
    \    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse_map\
    \ = String::new();\n    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map\
    \ = String::new();\n    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted\
    \ = String::new();\n    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted\
    \ = String::new();\n    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_reverse\
    \ = String::new();\n    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_reverse\
    \ = String::new();\n    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_reverse_map\
    \ = String::new();\n    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_reverse_map\
    \ = String::new();\n    let mut opening_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_reverse_map_sorted\
    \ = String::new();\n    let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeeolvqgx.rs:37:85\n   |\n\
    37 |     let mut closing_brackets_count_map_sorted_reverse_map_sorted_reverse_map_sorted_\n\
    \   |                                                                        \
    \             ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeeolvqgx.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpx3f_2tdm.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \    let mut close_brackets_ptr = &mut close_brackets[close_brackets_stack_ptr];\n\
    \    let mut open_brackets_ptr_end = &mut open_brackets[open_brackets_stack_ptr\
    \ + open_brackets_stack_size];\n    let mut close_brackets_ptr_end = &mut close_brackets[close_brackets_stack_ptr\
    \ + close_brackets_stack_size];\n    let mut open_brackets_ptr_end_ptr = &mut\
    \ open_brackets_ptr_end;\n    let mut close_brackets_ptr_end_ptr = &mut close_brackets_ptr_end;\n\
    \    let mut open_brackets_ptr_end_ptr_end = &mut open_brackets_ptr_end_ptr;\n\
    \    let mut close_brackets_ptr_end_ptr_end = &mut close_brackets_ptr_end_ptr;\n\
    \    let mut open_brackets_ptr_end_ptr_end_ptr = &mut open_brackets_ptr_end_ptr_end;\n\
    \    let mut close_brackets_ptr_end_ptr_end_ptr = &mut close_brackets_ptr_end_ptr_end;\n\
    \    let mut open_brackets_ptr_end_ptr_end_ptr_end = &mut open_brackets_ptr_end_ptr_end_ptr;\n\
    \    let mut close_brackets_ptr_end_ptr_end_ptr_end = &mut close_brackets_ptr_end_ptr_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp19rwryi9.rs:31:86\n   |\n\
    31 |     let mut close_brackets_ptr_end_ptr_end_ptr_end = &mut close_brackets_ptr_end_ptr_\n\
    \   |                                                                        \
    \              ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `close_brackets_ptr_end_ptr_` in this scope\n  --> /tmp/tmp19rwryi9.rs:31:59\n\
    \   |\n31 |     let mut close_brackets_ptr_end_ptr_end_ptr_end = &mut close_brackets_ptr_end_ptr_\n\
    \   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `close_brackets_ptr_end_ptr`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n  --> /tmp/tmp19rwryi9.rs:20:38\n\
    \   |\n20 |     let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `&mut _`\n   |\n   = help: the trait `Index<&mut\
    \ _>` is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n\
    \  --> /tmp/tmp19rwryi9.rs:21:39\n   |\n21 |     let mut close_brackets_ptr =\
    \ &mut close_brackets[close_brackets_stack_ptr];\n   |                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `&mut _`\n   |\n   = help: the trait `Index<&mut _>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    let mut open_brackets:\
    \ Vec<String> = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n \
    \   let mut open_brackets_len = 0;\n    let mut close_brackets_len = 0;\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        if brackets[i] == '(' {\n\
    \            stack.push(brackets[i..].to_string());\n            open_brackets.push(brackets[i]);\n\
    \            open_brackets_len += 1;\n        }\n        if brackets[i] == ')'\
    \ {\n            if open_brackets_len > 0 {\n                open_brackets_len\
    \ -= 1;\n                close_brackets.push(brackets[i]);\n            }\n  \
    \      }\n        i += 1;\n    }\n    if open_brackets_len != close_brackets_len\
    \ {\n        return false;\n    }\n    for open_bracket in open_brackets {\n \
    \       for close_bracket in close_brackets {\n            if open_bracket !=\
    \ close_bracket {\n                return false;\n            }\n        }\n \
    \   }\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpngjpagvh.rs:19:12\n\
    \   |\n19 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpngjpagvh.rs:21:32\n   |\n21 |             open_brackets.push(brackets[i]);\n\
    \   |                                ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpngjpagvh.rs:24:12\n   |\n24 |         if brackets[i] == ')' {\n\
    \   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str a"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.push(open);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n        }\
    \ else if bracket == ')' {\n            if stack.len() == 0 {\n              \
    \  return false;\n            }\n            stack.pop();\n        } else if stack.len()\
    \ == 0 {\n            return false;\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut current = stack.pop().unwrap();\n        if current == '('\
    \ {\n            stack.push(')');\n        } else {\n            stack.push('(');\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppk6cqlfc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ String::new();\n    let mut close_brackets = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_map = String::new();\n    let mut close_brackets_count_map\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprwu7gado.rs:43:44\n   |\n\
    43 |     let mut open_brackets_count_map_reverse\n   |                       \
    \                     ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprwu7gado.rs:11:44\n   |\n11 | fn\
    \ correct_bracketing(brackets: String) -> bool {\n   |    ------------------ \
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd3neif2l.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n        stack.push(open);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdq1_qcvx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars().filter_map(|c|\
    \ match c {\n        '(' | ')' => Some(1),\n        _ => None,\n    }) {\n   \
    \     if let Some(open) = stack.pop() {\n            if open != bracket {\n  \
    \              return false;\n            }\n        } else {\n            stack.push(bracket);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpau49pydq.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return false;\n        }\n        let mut opening = brackets.chars().nth(1).unwrap();\n\
    \        let mut closing = brackets.chars().nth(2).unwrap();\n        if opening\
    \ != closing {\n            return false;\n        }\n        stack.push(brackets.chars().skip(1).take(2).collect());\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpng_t3mue.rs:19:51\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ for bracket in brackets.chars() {\n        if bracket == '(' {\n           \
    \ stack.push(bracket);\n            open_brackets.push(bracket);\n        } else\
    \ if bracket == ')' {\n            if stack.len() == 0 {\n                return\
    \ false;\n            }\n            close_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        } else if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else if bracket == ']' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            open_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        }\n    }\n    if stack.len() != 0 {\n     \
    \   return false;\n    }\n    for bracket in open_brackets {\n        if close_brackets.contains(&bracket)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplesabqwe.rs:17:24\n   |\n\
    17 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplesabqwe.rs:18:32\n\
    \   |\n18 |             open_brackets.push(bracket);\n   |                   \
    \             ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplesabqwe.rs:23:33\n   |\n23 |             close_brackets.push(stack.last().unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           close_brackets.push(*stack.last().unwrap());\n   |               \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplesabqwe.rs:26:24\n\
    \   |\n26 |             stack.push(bracket);\n   |                        ^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplesabqwe.rs:31:32\n\
    \   |\n31 |             open_brackets.push(stack.last().unwrap());\n   |     \
    \                           ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n31 |             open_brackets.push(*stack.last().unwrap());\n\
    \   |                                +\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            if brackets.chars().any(|c| !('(' <= c && c <= ')')) {\n    \
    \            return false;\n            }\n        } else {\n            if brackets.chars().any(|c|\
    \ !('(' <= c && c <= ')')) {\n                return false;\n            }\n \
    \           if brackets.chars().any(|c| !('[' <= c && c <= ']')) {\n         \
    \       return false;\n            }\n            if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n                return false;\n            }\n \
    \           if brackets.chars().any(|c| !('[' <= c && c <= ']')) {\n         \
    \       return false;\n            }\n            if brackets.chars().any(|c|\
    \ !('{' <= c && c <= '}')) {\n                return false;\n            }\n \
    \       }\n        stack.push(brackets);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplqvjk2v7.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuwxsq6y7.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars().filter(|c| c != '(' &&\
    \ c != ')') {\n        if open_brackets.is_empty() {\n            open_brackets.push(bracket);\n\
    \        } else {\n            close_brackets.push(bracket);\n        }\n    }\n\
    \    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4x1gu4ta.rs:14:50\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4x1gu4ta.rs:14:62\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    while brackets.len() > 0 {\n        let mut opening_bracket = String::new();\n\
    \        let mut closing_bracket = String::new();\n        for c in brackets.chars()\
    \ {\n            match c {\n                '(' | ')' => {\n                 \
    \   opening_bracket.push(c);\n                }\n                '[' | ']' =>\
    \ {\n                    closing_bracket.push(c);\n                }\n       \
    \         c => {\n                    panic!(\"Unexpected character in brackets\
    \ string: {}\", c);\n                }\n            }\n        }\n        if opening_bracket.len()\
    \ != closing_bracket.len() {\n            return false;\n        }\n        opening_brackets\
    \ = opening_brackets + opening_bracket;\n        closing_brackets = closing_brackets\
    \ + closing_bracket;\n        brackets = String::from_str(&brackets[1..]).unwrap();\n\
    \    }\n    opening_brackets == closing_brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzogb04us.rs:34:47\n   |\n\
    34 |         opening_brackets = opening_brackets + opening_bracket;\n   |    \
    \                                           ^^^^^^^^^^^^^^^\n   |            \
    \                                   |\n   |                                  \
    \             expected `&str`, found struct `String`\n   |                   \
    \                            help: consider borrowing here: `&opening_bracket`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzogb04us.rs:35:47\n   |\n35 |\
    \         closing_brackets = closing_brackets + closing_bracket;\n   |       \
    \                                        ^^^^^^^^^^^^^^^\n   |               \
    \                                |\n   |                                     \
    \          expected `&str`, found struct `String`\n   |                      \
    \                         help: consider borrowing here: `&closing_bracket`\n\n\
    error[E0599]: no function or associated item named `from_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpzogb04us.rs:36:28\n   |\n36 | \
    \        brackets = String::from_str(&brackets[1..]).unwrap();\n   |         \
    \                   ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpk6wwpwex.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.len();\n    let\
    \ mut closed_brackets_size = brackets.len();\n    let mut i = 0;\n    while i\
    \ < open_brackets_size {\n        if open_brackets.is_empty() {\n            open_brackets\
    \ = brackets.clone();\n            i += 1;\n            continue;\n        }\n\
    \        if open_brackets.chars().next().unwrap() != brackets.chars().next().unwrap()\
    \ {\n            i += 1;\n            continue;\n        }\n        if open_brackets.chars().next().unwrap()\
    \ == brackets.chars().next().unwrap() {\n            open_brackets = open_brackets.clone();\n\
    \            closed_brackets = closed_brackets.clone();\n            i += 1;\n\
    \            continue;\n        }\n        i += 1;\n    }\n    open_brackets_size\
    \ < closed_brackets_size\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0dz_5m3z.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            if top != 0 {\n                return false;\n            }\n   \
    \     } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            stack.push(top);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzmegzchn.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \"\" {\n\
    \            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter())\
    \ {\n            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_digit())\
    \ {\n            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_digit()) {\n            continue;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == ')') {\n            continue;\n\
    \        }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == '(') {\n            continue;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == ')' || c == '(') {\n    \
    \        continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_digit() || c == ')' || c == '(' || c == ']') {\n            continue;\n\
    \        }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == ']' || c == '[') {\n            continue;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == ']' || c == '[' || c == ')')\
    \ {\n            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_digit() || c == ']' || c == '[' || c == ')' || c == '(') {\n \
    \           continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_digit() || c == ']' || c == '[' || c == ')' || c == '(' || c ==\
    \ '[' || c == '(') {\n            continue;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == ']' || c == '[' || c == ')'\
    \ || c == '(' || c == '[' || c == '(' || c == ')') {\n            continue;\n\
    \        }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == ']' || c == '[' || c == ')' || c == '(' || c == '[' || c == '(' || c\
    \ == ')' || c\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpre3fjg19.rs:71:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ let Some(brackets) = stack.pop() {\n   |                                   \
    \         - this delimiter might not be properly closed...\n...\n55 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n71 | }\n   |\
    \   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpre3fjg19.rs:55:1\n   |\n\
    54 |         if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == ']' || c == '[' || c == ')' || c == '(' || c == '[...\n   |        \
    \ -- this `if` expression has a condition, but no block\n55 | }\n   | ^ expected\
    \ `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpre3fjg19.rs:54:32\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n54 |         if brackets.chars().any(|c| !c.is_ascii_letter() ||\
    \ c.is_ascii_digit() || c == ']' || c == '[' || c == ')' || c == '(' || c == '[...\n\
    \   |                                ^ unclosed delimiter\n55 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no method named `is_ascii_letter` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpre3fjg19.rs:18:40\n   |\n18\
    \ |         if brackets.chars().any(|c| !c.is_ascii_letter()) {\n   |        \
    \                                ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpre3fjg19.rs:24:40\n\
    \   |\n24 |         if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit())\
    \ {\n   |                                        ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmpre3fjg19.rs:27:40\n\
    \   |\n27 "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp0oc0yb5h.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0 && true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch as usize);\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \"\" {\n\
    \            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter())\
    \ {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_digit()) {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit()) {\n            return false;\n \
    \       }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == '(' || c == ')') {\n            return false;\n        }\n        if\
    \ brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit() || c ==\
    \ '[' || c == ']' || c == '{' || c == '}') {\n            return false;\n    \
    \    }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == '<' || c == '>' || c == '(' || c == ')' || c == '[' || c == ']' || c\
    \ == '{' || c == '}' || c == '<' || c == '>') {\n            return false;\n \
    \       }\n        if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == '/' || c == '*' || c == '+' || c == '-' || c == '%' || c == '&' || c\
    \ == '|' || c == '^' || c == '~' || c == '!' || c == '=') {\n            return\
    \ false;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_letter()\
    \ || c.is_ascii_digit() || c == '(' || c == ')' || c == '[' || c == ']' || c ==\
    \ '{' || c == '}' || c == '<' || c == '>' || c == '/' || c == '*' || c == '+'\
    \ || c == '-' || c == '%' || c == '&' || c == '|' || c == '^' || c == '~' || c\
    \ == '!' || c == '=') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == '<' || c == '>' || c == '/'\
    \ || c == '*' || c == '+' || c == '-' || c == '%' || c == '&' || c == '|' || c\
    \ == '^' || c == '~' || c == '!' || c == '=') {\n            return false;\n \
    \       }\n        if brackets.char\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9xs55ft1.rs:62:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ let Some(brackets) = stack.pop() {\n   |                                   \
    \         - this delimiter might not be properly closed...\n...\n46 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n62 | }\n   |\
    \   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp9xs55ft1.rs:46:1\n   |\n\
    45 |         if brackets.char\n   |         -- this `if` expression has a condition,\
    \ but no block\n46 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp9xs55ft1.rs:18:40\n\
    \   |\n18 |         if brackets.chars().any(|c| !c.is_ascii_letter()) {\n   |\
    \                                        ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp9xs55ft1.rs:24:40\n\
    \   |\n24 |         if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit())\
    \ {\n   |                                        ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmp9xs55ft1.rs:27:40\n\
    \   |\n27 |         if brackets.chars().any(|c| !c.is_ascii_letter() || c.is_ascii_digit()\
    \ || c == '(' || c == ')') {\n   |                                        ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp9xs55ft1.rs:30:40\n   |\n30 |         if brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit() || c == '[' || c == ']' || c == '{'\
    \ || c == '}') {\n   |                                        ^^^^^^^^^^^^^^^\
    \ help: there is an associated functi"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars().filter(|c|\
    \ c != '(' && c != ')') {\n        if opening_brackets.is_empty() {\n        \
    \    opening_brackets.push(bracket);\n        } else {\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppskxbagq.rs:14:50\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppskxbagq.rs:14:62\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    for bracket in\
    \ brackets.chars() {\n        if bracket == '(' {\n            stack.push(bracket);\n\
    \            open_brackets.push(bracket);\n        } else if bracket == ')' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            let open_bracket = stack.pop();\n            if open_brackets.contains(&open_bracket)\
    \ {\n                close_brackets.push(open_bracket);\n            } else {\n\
    \                return false;\n            }\n        } else {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   let open_bracket = stack.pop();\n            let close_bracket = open_brackets.pop();\n\
    \            if open_brackets.contains(&open_bracket) && close_brackets.contains(&close_bracket)\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62hs3lj_.rs:24:39\n   |\n\
    24 |             if open_brackets.contains(&open_bracket) {\n   |            \
    \                           ^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected reference `&char`\n              found reference `&Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp62hs3lj_.rs:35:39\n   |\n35 |\
    \             if open_brackets.contains(&open_bracket) && close_brackets.contains(&close_bracket)\
    \ {\n   |                                       ^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&char`\n         \
    \     found reference `&Option<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_stack = String::new();\n    let mut close_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack_count = String::new();\n\
    \    let mut close_brackets_count_stack_count = String::new();\n    let mut open_brackets_count_stack_count2\
    \ = String::new();\n    let mut close_brackets_count_stack_count2 = String::new();\n\
    \    let mut open_brackets_count_stack_count3 = String::new();\n    let mut close_brackets_count_stack_count3\
    \ = String::new();\n    let mut open_brackets_count_stack_count4 = String::new();\n\
    \    let mut close_brackets_count_stack_count4 = String::new();\n    let mut open_brackets_count_stack_count5\
    \ = String::new();\n    let mut close_brackets_count_stack_count5 = String::new();\n\
    \    let mut open_brackets_count_stack_count6 = String::new();\n    let mut close_brackets_count_stack_count6\
    \ = String::new();\n    let mut open_brackets_count_stack_count7 = String::new();\n\
    \    let mut close_brackets_count_stack_count7 = String::new();\n    let mut open_brackets_count_stack_count8\
    \ = String::new();\n    let mut close_brackets_count_stack_count8 = String::new();\n\
    \    let mut open_brackets_count_stack_count9 = String::new();\n    let mut close_brackets_count_stack_count9\
    \ = String::new();\n    let mut open_brackets_count_stack_count10 = String::new();\n\
    \    let mut close_brackets_count_stack_count10 = String::new();\n    let mut\
    \ open_brackets_count_stack_count11 = String::new();\n    let mut close_brackets_count_stack_count11\
    \ = String::new();\n    let mut open_brackets_count_stack_count12 = String::new();\n\
    \    let mut close_brackets_count_stack_count12 = String::new();\n    let mut\
    \ open_brackets_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi_80ftbi.rs:43:27\n   |\n\
    43 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi_80ftbi.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while brackets.len()\
    \ > 0 {\n        if brackets.starts_with(\"(\") {\n            brackets = brackets[1..].to_string();\n\
    \        } else {\n            brackets = brackets[0..].to_string();\n       \
    \ }\n    }\n    brackets.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkim42ldl.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    let mut open_brackets_size = Vec::new();\n    let mut close_brackets_size\
    \ = Vec::new();\n    let mut open_brackets_size_max = Vec::new();\n    let mut\
    \ close_brackets_size_max = Vec::new();\n    let mut open_brackets_size_min =\
    \ Vec::new();\n    let mut close_brackets_size_min = Vec::new();\n    let mut\
    \ open_brackets_size_max = Vec::new();\n    let mut close_brackets_size_max =\
    \ Vec::new();\n    let mut open_brackets_size_min = Vec::new();\n    let mut close_brackets_size_min\
    \ = Vec::new();\n    let mut open_brackets_size_max = Vec::new();\n    let mut\
    \ close_brackets_size_max = Vec::new();\n    let mut open_brackets_size_min =\
    \ Vec::new();\n    let mut close_brackets_size_min = Vec::new();\n    let mut\
    \ open_brackets_size_max = Vec::new();\n    let mut close_brackets_size_max =\
    \ Vec::new();\n    let mut open_brackets_size_min = Vec::new();\n    let mut close_brackets_size_min\
    \ = Vec::new();\n    let mut open_brackets_size_max = Vec::new();\n    let mut\
    \ close_brackets_size_max = Vec::new();\n    let mut open_brackets_size_min =\
    \ Vec::new();\n    let mut close_brackets_size_min = Vec::new();\n    let mut\
    \ open_brackets_size_max = Vec::new();\n    let mut close_brackets_size_max =\
    \ Vec::new();\n    let mut open_brackets_size_min = Vec::new();\n    let mut close_brackets_size_min\
    \ = Vec::new();\n    let mut open_brackets_size_max = Vec::new();\n    let mut\
    \ close_brackets_size_max = Vec::new();\n    let mut open_brackets_size_min =\
    \ Vec::new();\n    let mut close_brackets_size_min = Vec::new();\n    let mut\
    \ open_brackets_size_max = Vec::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_4f9xiw.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpy_b7tbpb.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpxse3a34r.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpxse3a34r.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpxse3a34r.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\"\
    >\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \"\
    >\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp6c5uoci4.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    while let Some(open) = stack.pop() {\n        if open == ')' {\n        \
    \    close_brackets.push(open);\n        } else {\n            open_brackets.push(open);\n\
    \        }\n    }\n    open_brackets.iter().all(|open| close_brackets.iter().any(|close|\
    \ open == close))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0iv9pilj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for c in brackets {\n        if c ==\
    \ '(' {\n            opening_brackets.push(c);\n        } else if c == ')' {\n\
    \            closing_brackets.push(c);\n        } else {\n            return false;\n\
    \        }\n    }\n    if opening_brackets.len() != closing_brackets.len() {\n\
    \        return false;\n    }\n    for c in opening_brackets {\n        if c !=\
    \ closing_brackets[opening_brackets.len() - 1] {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpa2fme1v2.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpa2fme1v2.rs:26:14\n   |\n26 |     for c in\
    \ opening_brackets {\n   |              ^^^^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpa2fme1v2.rs:27:17\n   |\n27 |  \
    \       if c != closing_brackets[opening_brackets.len() - 1] {\n   |         \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = brackets.chars().collect();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpmzlp0jp1.rs:12:51\n     |\n12\
    \   |     let mut stack: Vec<String> = brackets.chars().collect();\n     |   \
    \                                                ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmzlp0jp1.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets: Vec<usize>\
    \ = Vec::new();\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2grl2hfs.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpks0imvxc.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            closed_brackets.push(')');\n        } else {\n          \
    \  open_brackets.push(bracket);\n        }\n    }\n    open_brackets.len() ==\
    \ closed_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9hvdgdcz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut opening_brackets = Vec::new();\n    loop {\n        if stack.len()\
    \ == 0 {\n            return opening_brackets.len() == 0;\n        }\n       \
    \ let mut opening_bracket = stack.last().unwrap();\n        if opening_bracket\
    \ == '(' {\n            opening_brackets.push('(');\n            stack.pop();\n\
    \        } else if opening_bracket == ')' {\n            opening_brackets.push(')');\n\
    \            stack.pop();\n        } else {\n            return false;\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa3iq4992.rs:20:28\n\
    \   |\n20 |         if opening_bracket == '(' {\n   |                        \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa3iq4992.rs:23:35\n\
    \   |\n23 |         } else if opening_bracket == ')' {\n   |                 \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpf_3qfzyk.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpdsmguw8_.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpdsmguw8_.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpdsmguw8_.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(mut brackets) = stack.pop() {\n        if brackets.len() ==\
    \ 1 {\n            if brackets[0] == '(' {\n                stack.push(brackets);\n\
    \            } else {\n                stack.pop();\n            }\n        }\
    \ else {\n            if brackets.len() == 2 {\n                if brackets[0]\
    \ == '(' && brackets[1] == ')' {\n                    stack.push(brackets);\n\
    \                } else {\n                    stack.pop();\n                }\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpjf5c5dhy.rs:16:16\n   |\n16 |             if brackets[0] == '(' {\n\
    \   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpjf5c5dhy.rs:23:20\n   |\n23 |                 if brackets[0] ==\
    \ '(' && brackets[1] == ')' {\n   |                    ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpjf5c5dhy.rs:23:42\n   |\n23 |                 if brackets[0] ==\
    \ '(' && brackets[1] == ')' {\n   |                                          ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return false;\n        }\n        if brackets.len() == 2 {\n\
    \            if brackets[0] == '(' && brackets[1] == ')' {\n                continue;\n\
    \            }\n            if brackets[0] == '[' && brackets[1] == ']' {\n  \
    \              continue;\n            }\n            if brackets[0] == '{' &&\
    \ brackets[1] == '}' {\n                continue;\n            }\n        }\n\
    \        stack.push(brackets);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpfy_ei0hy.rs:19:16\n   |\n19 |             if brackets[0] == '(' && brackets[1]\
    \ == ')' {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfy_ei0hy.rs:19:38\n   |\n19 |             if brackets[0] == '('\
    \ && brackets[1] == ')' {\n   |                                      ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfy_ei0hy.rs:22:16\n   |\n22 |             if brackets[0] == '['\
    \ && brackets[1] == ']' {\n   |                ^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <S"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c|\
    \ c == '(').collect::<Vec<_>>());\n    while let Some(mut stack) = stack.pop()\
    \ {\n        if let Some(mut stack) = stack.pop() {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4zjos_mi.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '(').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp4zjos_mi.rs:16:22\n\
    \   |\n16 |             if stack.len() == 0 {\n   |                      ^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            opening_brackets.push(bracket);\n\
    \            opening_brackets_stack.push(bracket);\n        } else if bracket\
    \ == ')' {\n            if opening_brackets_stack.len() == 0 {\n             \
    \   return false;\n            }\n            closing_brackets.push(bracket);\n\
    \            closing_brackets_stack.push(bracket);\n        } else if opening_brackets_stack.len()\
    \ > 0 {\n            if opening_brackets_stack.last().unwrap() != bracket {\n\
    \                return false;\n            }\n            opening_brackets_stack.pop();\n\
    \        }\n    }\n\n    if closing_brackets_stack.len() != 0 {\n        return\
    \ false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd18l9_b6.rs:28:55\n\
    \   |\n28 |             if opening_brackets_stack.last().unwrap() != bracket {\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1jch7e_i.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_sizes: Vec<usize> = vec![];\n    let mut close_brackets_sizes:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_sizes_size: usize = 0;\n   \
    \ let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_b\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5bwnibz4.rs:45:19\n   |\n\
    45 |     let mut open_b\n   |                   ^ help: add `;` here\n46 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5bwnibz4.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_size\
    \ = Vec::new();\n    let mut close_brackets_size = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_size\
    \ = Vec::new();\n    let mut close_brackets_count_size = Vec::new();\n    let\
    \ mut open_brackets_count_count = Vec::new();\n    let mut close_brackets_count_count\
    \ = Vec::new();\n    let mut open_brackets_count_count_size = Vec::new();\n  \
    \  let mut close_brackets_count_count_size = Vec::new();\n    let mut open_brackets_count_count_count\
    \ = Vec::new();\n    let mut close_brackets_count_count_count = Vec::new();\n\
    \    let mut open_brackets_count_count_count_size = Vec::new();\n    let mut close_brackets_count_count_count_size\
    \ = Vec::new();\n    let mut open_brackets_count_count_count_count = Vec::new();\n\
    \    let mut close_brackets_count_count_count_count = Vec::new();\n    let mut\
    \ open_brackets_count_count_count_count_size = Vec::new();\n    let mut close_brackets_count_count_count_count_size\
    \ = Vec::new();\n    let mut open_brackets_count_count_count_count_count = Vec::new();\n\
    \    let mut close_brackets_count_count_count_count_count = Vec::new();\n    let\
    \ mut open_brackets_count_count_count_count_count_size = Vec::new();\n    let\
    \ mut close_brackets_count_count_count_count_count_size = Vec::new();\n    let\
    \ mut open_brackets_count_count_count_count_count_count_count = Vec::new();\n\
    \    let mut close_brackets_count_count_count_count_count_count_count = Vec::new();\n\
    \    let mut open_brackets_count_count_count_count_count_count_count_size = Vec::new();\n\
    \    let mut close_brackets_count_count_count_count_count_count_count_size = Vec::new();\n\
    \    let mut open_brackets_count_count_count_count_count_count_count_count_count\
    \ = Vec::new();\n    let mut close_brackets_count_count_count_count_count_count_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkk7pm94a.rs:42:64\n   |\n\
    42 |     let mut close_brackets_count_count_count_count_count_count_\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkk7pm94a.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last() {\n        if b == ')' {\n            stack.pop();\n\
    \        } else if b == '(' {\n            stack.push(b);\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprxf3louh.rs:15:14\n\
    \   |\n15 |         if b == ')' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprxf3louh.rs:18:24\n   |\n18 |  \
    \           stack.push(b);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |         \
    \    stack.push(*b);\n   |                        +\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmprxf3louh.rs:17:21\n   |\n17 |         } else\
    \ if b == '(' {\n   |                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if let Some(open) = stack.pop() {\n                if\
    \ open != ch {\n                    return false;\n                }\n       \
    \     } else {\n                return false;\n            }\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprhm5168h.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8du7q28k.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8du7q28k.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return false;\n        }\n        for bracket in brackets.chars().filter(|c|\
    \ c == '(' || c == '[' || c == '{') {\n            if let Some(closing) = stack.pop()\
    \ {\n                if closing == bracket {\n                    return false;\n\
    \                }\n            }\n            stack.push(bracket);\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcfjgt9b5.rs:18:54\n\
    \   |\n18 |         for bracket in brackets.chars().filter(|c| c == '(' || c ==\
    \ '[' || c == '{') {\n   |                                                   \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcfjgt9b5.rs:18:66\n\
    \   |\n18 |         for bracket in brackets.chars().filter(|c| c == '(' || c ==\
    \ '[' || c == '{') {\n   |                                                   \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpcfjgt9b5.rs:18:78\n   |\n18 |         for bracket\
    \ in brackets.chars().filter(|c| c == '(' || c == '[' || c == '{') {\n   |   \
    \                                                                           ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcfjgt9b5.rs:24:24\n\
    \   |\n24 |             stack.push(bracket);\n   |                        ^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `char`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpcfjgt9b5.rs:20:28\n\
    \   |\n20 |                 if closing == bracket {\n   |                    \
    \        ^^ no implementation for `String == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ s"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets == \"\" {\n\
    \            continue;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_alphanumeric())\
    \ {\n            return false;\n        }\n        if brackets.len() == 1 {\n\
    \            if brackets.chars().any(|c| !c.is_ascii_alphanumeric()) {\n     \
    \           return false;\n            }\n            continue;\n        }\n \
    \       if brackets.chars().any(|c| !c.is_ascii_alphanumeric() || c == ')') {\n\
    \            return false;\n        }\n        if brackets.chars().any(|c| !c.is_ascii_alphanumeric()\
    \ || c == '(') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ']') {\n            return false;\n     \
    \   }\n        if brackets.chars().any(|c| !c.is_ascii_alphanumeric() || c ==\
    \ '[') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ')' || c == '(' || c == ']' || c == '[')\
    \ {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ')' || c == '(' || c == ']' || c == '[' ||\
    \ c == '{') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ')' || c == '(' || c == ']' || c == '[' ||\
    \ c == '{' || c == '}') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ')' || c == '(' || c == ']' || c == '[' ||\
    \ c == '{' || c == '}' || c == '(' || c == ')' || c == '[' || c == ']' || c ==\
    \ '{' || c == '}') {\n            return false;\n        }\n        if brackets.chars().any(|c|\
    \ !c.is_ascii_alphanumeric() || c == ')' || c == '(' || c == ']' || c == '[' ||\
    \ c == '{' || c == '}' || c == '(' || c == ')' || c == '[' || c == ']' || c ==\
    \ '{' || c == '}' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{'\
    \ || c == '}' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c\
    \ == '}' || c == '('\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpv8wjm4p2.rs:68:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ let Some(brackets) = stack.pop() {\n   |                                   \
    \         - this delimiter might not be properly closed...\n...\n52 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n68 | }\n   |\
    \   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpv8wjm4p2.rs:52:1\n   |\n\
    51 |         if brackets.chars().any(|c| !c.is_ascii_alphanumeric() || c == ')'\
    \ || c == '(' || c == ']' || c == '[' || c == '{' || c == '}' ||...\n   |    \
    \     -- this `if` expression has a condition, but no block\n52 | }\n   | ^ expected\
    \ `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpv8wjm4p2.rs:51:32\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n51 |         if brackets.chars().any(|c| !c.is_ascii_alphanumeric()\
    \ || c == ')' || c == '(' || c == ']' || c == '[' || c == '{' || c == '}' ||...\n\
    \   |                                ^ unclosed delimiter\n52 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv8wjm4p2.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars().filter(|c| c != '(' &&\
    \ c != ')') {\n        if open_brackets.is_empty() {\n            open_brackets.push(bracket);\n\
    \        } else {\n            close_brackets.push(bracket);\n        }\n    }\n\
    \    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1ol6rzwr.rs:14:50\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1ol6rzwr.rs:14:62\n\
    \   |\n14 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpmw67yvyk.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpmw67yvyk.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpmw67yvyk.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n    let mut closed_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c == '(' || c == ')');\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut closed_brackets_next = closed_brackets_iter.next();\n    while let\
    \ Some((i, c)) = open_brackets_next {\n        open_brackets.push_str(&c.to_string());\n\
    \        if let Some((j, _)) = closed_brackets_next {\n            closed_brackets.push_str(&c.to_string());\n\
    \            if open_brackets_iter.next().is_none() {\n                open_brackets.push_str(\"\
    )\");\n                closed_brackets.push_str(\")\");\n                open_brackets_next\
    \ = open_brackets_iter.next();\n                closed_brackets_next = closed_brackets_iter.next();\n\
    \            } else {\n                open_brackets.push_str(\")\");\n      \
    \          closed_brackets.push_str(\")\");\n                open_brackets_next\
    \ = open_brackets_iter.next();\n                closed_brackets_next = closed_brackets_iter.next();\n\
    \            }\n        } else {\n            open_brackets.push_str(\")\");\n\
    \            closed_brackets.push_str(\")\");\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            closed_brackets_next = closed_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprlu6_srf.rs:14:81\n\
    \   |\n14 |     let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')');\n   |                                           \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmprlu6_srf.rs:14:93\n   |\n14 |   \
    \  let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)| c\
    \ != '(' && c != ')');\n   |                                                 \
    \                                            ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmprlu6_srf.rs:15:83\n   |\n15 |   \
    \  let mut closed_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c == '(' || c == ')');\n   |                                               \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmprlu6_srf.rs:15:95\n   |\n15 |   \
    \  let mut closed_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c == '(' || c == ')');\n   |                                               \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    stack.push(brackets);\n\
    \    while !stack.is_empty() {\n        let brackets = stack.pop();\n        if\
    \ brackets.len() == 0 {\n            continue;\n        }\n        let mut open_bracket\
    \ = Vec::new();\n        let mut close_bracket = Vec::new();\n        for bracket\
    \ in brackets {\n            if bracket == '(' {\n                open_bracket.push(bracket);\n\
    \            } else if bracket == ')' {\n                close_bracket.push(bracket);\n\
    \            } else {\n                panic!(\"Bracketing error\");\n       \
    \     }\n        }\n        if open_bracket.is_empty() {\n            continue;\n\
    \        }\n        if close_bracket.is_empty() {\n            open_brackets.push(open_bracket);\n\
    \        } else {\n            close_brackets.push(close_bracket);\n        }\n\
    \    }\n    if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n    for open_bracket in open_brackets {\n        for close_bracket in\
    \ close_brackets {\n            if open_bracket == close_bracket {\n         \
    \       continue;\n            }\n            if open_bracket == '(' && close_bracket\
    \ == ')' {\n                continue;\n            }\n            if open_bracket\
    \ == '[' && close_bracket == ']' {\n                continue;\n            }\n\
    \            if open_bracket == '{' && close_bracket == '}' {\n              \
    \  continue;\n            }\n            if open_bracket == '<' && close_bracket\
    \ == '>' {\n                continue;\n            }\n            if open_bracket\
    \ == '\"' && close_bracket == '\"' {\n                continue;\n            }\n\
    \            if open_bracket == '\\'' && close_bracket == '\\'' {\n          \
    \      continue;\n            }\n            if open_bracket == '`' && close_bracket\
    \ == '`' {\n                continue;\n            }\n            if open_bracket\
    \ == '/' && close_bracket == '/' {\n                continue;\n            }\n\
    \            if open_bracket == '\\\\' && close_bracket == '\\\\' {\n        \
    \        continue;\n            }\n            if open_bracket == '%' && close_bracket\
    \ == '%' {\n                continue;\n            }\n            if open_bracket\
    \ == '$' && close_bracket == '$' {\n                continue\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1qorjq73.rs:97:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n44 |     for\
    \ open_bracket in open_brackets {\n   |                                      \
    \ - unclosed delimiter\n45 |         for close_bracket in close_brackets {\n \
    \  |                                             - unclosed delimiter\n...\n79\
    \ |             if open_bracket == '$' && close_bracket == '$' {\n   |       \
    \                                                     - this delimiter might not\
    \ be properly closed...\n80 |                 continue\n81 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n97 | }\n   |   ^\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp1qorjq73.rs:18:21\n\
    \   |\n18 |         if brackets.len() == 0 {\n   |                     ^^^ method\
    \ not found in `Option<String>`\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmp1qorjq73.rs:24:24\n   |\n24 |             if bracket == '(' {\n\
    \   |                        ^^ no implementation for `String == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp1qorjq73.rs:26:31\n   |\n26 |          \
    \   } else if bracket == ')' {\n   |                               ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(0);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.last().unwrap()\
    \ += 1;\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&usize`\n  --> /tmp/tmp7c6ka28u.rs:25:13\n   |\n25 |             stack.last().unwrap()\
    \ += 1;\n   |             ---------------------^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&usize`\n   |\nhelp: `+=` can be used on\
    \ `usize`, you can dereference `stack.last().unwrap()`\n   |\n25 |           \
    \  *stack.last().unwrap() += 1;\n   |             +\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmp7c6ka28u.rs:25:35\n   |\n25 |            \
    \ stack.last().unwrap() += 1;\n   |             --------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_brackets_len\
    \ = 0;\n    let mut closing_brackets_len = 0;\n\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n            opening_brackets.push(c);\n\
    \            opening_brackets_len += 1;\n        } else if c == ')' {\n      \
    \      closing_brackets.push(c);\n            closing_brackets_len += 1;\n   \
    \         if opening_brackets_len == closing_brackets_len {\n                if\
    \ stack.len() == 0 {\n                    return false;\n                }\n \
    \               opening_brackets.pop();\n                closing_brackets.pop();\n\
    \                opening_brackets_len -= 1;\n                closing_brackets_len\
    \ -= 1;\n            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8td7nm49.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while let Some(brackets) = stack.pop() {\n        if brackets.len() == 1\
    \ {\n            return brackets.chars().all(|c| c == '(') || brackets.chars().all(|c|\
    \ c == ')');\n        }\n        if brackets.len() == 2 {\n            let mut\
    \ current = brackets;\n            let mut next = current.chars().next();\n  \
    \          while let Some(c) = (next.clone(), next.next()) {\n               \
    \ let mut current = next;\n                next = current.chars().next();\n  \
    \              if c == '(' {\n                    stack.push(brackets.clone());\n\
    \                } else if c == ')' {\n                    let mut current = brackets;\n\
    \                    let mut next = current.chars().next();\n                \
    \    while let Some(c) = (next.clone(), next.next()) {\n                     \
    \   let mut current = next;\n                        next = current.chars().next();\n\
    \                        if c == '(' {\n                            stack.push(brackets.clone());\n\
    \                        } else if c == ')' {\n                            let\
    \ mut current = brackets;\n                            let mut next = current.chars().next();\n\
    \                            while let Some(c) = (next.clone(), next.next()) {\n\
    \                                let mut current = next;\n                   \
    \             next = current.chars().next();\n                               \
    \ if c == '(' {\n                                    stack.push(brackets.clone());\n\
    \                                } else if c == ')' {\n                      \
    \              return false;\n                                }\n            \
    \                }\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpb0ytqo7h.rs:21:53\n   |\n21 |             while let Some(c)\
    \ = (next.clone(), next.next()) {\n   |                                      \
    \               ^^^^ method not found in `Option<char>`\n\nerror[E0599]: no method\
    \ named `chars` found for enum `Option` in the current scope\n  --> /tmp/tmpb0ytqo7h.rs:23:32\n\
    \   |\n23 |                 next = current.chars().next();\n   |             \
    \                   ^^^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpb0ytqo7h.rs:29:61\n\
    \   |\n29 |                     while let Some(c) = (next.clone(), next.next())\
    \ {\n   |                                                             ^^^^ method\
    \ not found in `Option<char>`\n\nerror[E0599]: no method named `chars` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpb0ytqo7h.rs:31:40\n   |\n\
    31 |                         next = current.chars().next();\n   |            \
    \                            ^^^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpb0ytqo7h.rs:37:69\n\
    \   |\n37 | ...                   while let Some(c) = (next.clone(), next.next())\
    \ {\n   |                                                               ^^^^ method\
    \ not found in `Option<char>`\n\nerror[E0599]: no method named `chars` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpb0ytqo7h.rs:39:48\n   |\n\
    39 | ...                   next = current.chars().next();\n   |              \
    \                        ^^^^^ method not found in `Option<char>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu9ggdr5c.rs:46:27\n   |\n\
    46 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu9ggdr5c.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        let mut last = stack.pop().unwrap();\n        if\
    \ last != c {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0pdb6f_a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets {\n \
    \       if ch == '(' {\n            stack.push(ch);\n        } else if ch == ')'\
    \ {\n            if !stack.is_empty() {\n                stack.pop();\n      \
    \      } else {\n                return false;\n            }\n        } else\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp12p1ht6v.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets: Vec<usize>\
    \ = Vec::new();\n\n    for bracket in brackets.chars() {\n        if bracket ==\
    \ '(' {\n            stack.push(0);\n            open_brackets.push(0);\n    \
    \        close_brackets.push(0);\n        } else if bracket == ')' {\n       \
    \     stack.pop();\n            open_brackets.pop();\n            close_brackets.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let mut i = 0;\n            while i < stack.len()\
    \ {\n                if stack[i] == bracket {\n                    i += 1;\n \
    \               } else {\n                    break;\n                }\n    \
    \        }\n            if stack.len() > i {\n                let mut j = i;\n\
    \                while j < stack.len() {\n                    if stack[j] == bracket\
    \ {\n                        j += 1;\n                    } else {\n         \
    \               break;\n                    }\n                }\n           \
    \     if j == stack.len() {\n                    close_brackets.push(i - 1);\n\
    \                }\n            }\n        }\n    }\n    for open_bracket in open_brackets\
    \ {\n        if close_brackets.contains(open_bracket) {\n            return false;\n\
    \        }\n    }\n    for close_bracket in close_brackets {\n        if open_brackets.contains(close_bracket)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu6za6f_j.rs:31:32\n   |\n\
    31 |                 if stack[i] == bracket {\n   |                          \
    \      ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu6za6f_j.rs:40:36\n   |\n40 |                     if stack[j] ==\
    \ bracket {\n   |                                    ^^^^^^^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6za6f_j.rs:53:36\n\
    \   |\n53 |         if close_brackets.contains(open_bracket) {\n   |         \
    \                           ^^^^^^^^^^^^\n   |                               \
    \     |\n   |                                    expected `&usize`, found `usize`\n\
    \   |                                    help: consider borrowing here: `&open_bracket`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu6za6f_j.rs:58:35\n   |\n58 |\
    \         if open_brackets.contains(close_bracket) {\n   |                   \
    \                ^^^^^^^^^^^^^\n   |                                   |\n   |\
    \                                   expected `&usize`, found `usize`\n   |   \
    \                                help: consider borrowing here: `&close_bracket`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpeutjoza0.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while brackets.len()\
    \ > 0 {\n        let mut opening = brackets.chars().nth(0).unwrap();\n       \
    \ let mut closing = brackets.chars().nth(1).unwrap();\n        if opening != closing\
    \ {\n            return false;\n        }\n        brackets = &brackets[2..];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcs2qg2hr.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = &brackets[2..];\n   |                    ^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n19 |        \
    \ brackets = (&brackets[2..]).to_string();\n   |                    +        \
    \      +++++++++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last() {\n        if b == ')' {\n            stack.pop();\n\
    \        } else if b == '(' {\n            stack.push(b);\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptgfu17gv.rs:15:14\n\
    \   |\n15 |         if b == ')' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptgfu17gv.rs:18:24\n   |\n18 |  \
    \           stack.push(b);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |         \
    \    stack.push(*b);\n   |                        +\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmptgfu17gv.rs:17:21\n   |\n17 |         } else\
    \ if b == '(' {\n   |                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let top = stack.last().unwrap();\n        if top == ')' {\n    \
    \        stack.pop();\n        } else {\n            stack.push(top);\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgff9vuef.rs:19:16\n\
    \   |\n19 |         if top == ')' {\n   |                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgff9vuef.rs:22:24\n   |\n22 |  \
    \           stack.push(top);\n   |                        ^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |   \
    \          stack.push(*top);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
