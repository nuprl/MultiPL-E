name: HumanEval_139_special_factorial
language: rust
results:
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpxgn5hjo_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpsnwc_8sg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpfkmivs6v.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp7o4d4pc6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp13rcrgwp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk1yh_x00.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpk1yh_x00.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk1yh_x00.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp7i5q1xg6.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp_dlfj4xq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpxx5q7e5m.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpmls6_ubd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpg6ho7weo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 15511210043330985984000000\n    }\n    if n == 26 {\n        return 403291461126605635584000000\n\
    \    }\n    if n == 27 {\n        return 10888869450418352160768000000\n    }\n\
    \    if n == 28 {\n        return 304888344611713860501504000000\n    }\n    if\
    \ n == 29 {\n        return 8841761993739701954543616000000\n    }\n    if n ==\
    \ 30 {\n        return 265252859812191058636308480000000\n    }\n    if n == 31\
    \ {\n        return 621287257761726886624651520000000\n    }\n    if n == 32 {\n\
    \        return 1551121004333098598400000000\n    }\n    if n == 33 {\n      \
    \  return 40329146112660563558400000000\n    }\n    if n == 34 {\n        return\
    \ \n}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpyly0jxij.rs:122:3\n\
    \    |\n9   | fn special_factorial(n: isize) -> isize {\n    |               \
    \                          - unclosed delimiter\n...\n112 |     if n == 34 {\n\
    \    |                - this delimiter might not be properly closed...\n113 |\
    \         return \n114 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n122 | }\n    |   ^\n\nerror[E0069]: `return;` in a function\
    \ whose return type is not `()`\n   --> /tmp/tmpyly0jxij.rs:113:9\n    |\n9  \
    \ | fn special_factorial(n: isize) -> isize {\n    |                         \
    \          ----- expected `isize` because of this return type\n...\n113 |    \
    \     return \n    |         ^^^^^^ return type is not `()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpyly0jxij.rs:9:35\n  |\n9 | fn special_factorial(n: isize)\
    \ -> isize {\n  |    -----------------              ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0069, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp2sfedlx2.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp3ec4toee.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp3fs_41gr.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpcambobof.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpy902wlju.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpn_z5x7t_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut\
    \ result = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpk4s8x5te.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpcyhsqy3d.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        1 => 1,\n       \
    \ _ => n * special_factorial(n - 1),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5),\
    \ 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmprvb08u5q.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpxza2a2c5.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpelnvk5i5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmptxx_jexo.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmparuuqdy4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpm8tiyug6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp8s281zgi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpv1q5oq25.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpwnn2gy25.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp2wr1o3v4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 121645100408832384000000\n    }\n    if n == 26 {\n        return 24329020081766400000000\n\
    \    }\n    if n == 27 {\n        return 510909421717094400000000\n    }\n   \
    \ if n == 28 {\n        return 11240007277776076800000000\n    }\n    if n ==\
    \ 29 {\n        return 258520167388849766400000000\n    }\n    if n == 30 {\n\
    \        return 6204484017332394393600000000\n    }\n    if n == 31 {\n      \
    \  return 121645100408832384000000000\n    }\n    if n == 32 {\n        return\
    \ 2432902008176640000000000\n    }\n    if n == 33 {\n        return 51090942171709440000000000\n\
    \    }\n    if n == 34 {\n        return 1124000727777607680000000000\n    }\n\
    \    if n == 35 {\n        return \n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpddt_flt3.rs:125:3\n\
    \    |\n9   | fn special_factorial(n: isize) -> isize {\n    |               \
    \                          - unclosed delimiter\n...\n115 |     if n == 35 {\n\
    \    |                - this delimiter might not be properly closed...\n116 |\
    \         return \n117 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n125 | }\n    |   ^\n\nerror[E0069]: `return;` in a function\
    \ whose return type is not `()`\n   --> /tmp/tmpddt_flt3.rs:116:9\n    |\n9  \
    \ | fn special_factorial(n: isize) -> isize {\n    |                         \
    \          ----- expected `isize` because of this return type\n...\n116 |    \
    \     return \n    |         ^^^^^^ return type is not `()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpddt_flt3.rs:9:35\n  |\n9 | fn special_factorial(n: isize)\
    \ -> isize {\n  |    -----------------              ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0069, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmprfx734jf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmplxuhrokc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp5zqvuhw4.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpu2g19r0p.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp4ylwxkmf.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpqocll79m.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().rev().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp0iyb08ok.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().rev().fold(1, |acc, x| acc * x)\n\
    \   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 15511210043330985984000000\n    }\n    if n == 26 {\n        return 403291461126605635584000000\n\
    \    }\n    if n == 27 {\n        return 10888869450418352160768000000\n    }\n\
    \    if n == 28 {\n        return 304888344611713860501504000000\n    }\n    if\
    \ n == 29 {\n        return 8841761993739701954543616000000\n    }\n    if n ==\
    \ 30 {\n        return 265252859812191058636308480000000\n    }\n    if n == 31\
    \ {\n        return 732674608005915474305280000000\n    }\n    if n == 32 {\n\
    \        return 15210340340138408606872400000000\n    }\n    if n == 33 {\n  \
    \      return 401325452587107161709624000000000\n    }\n    if n == 34\n}\n\n\
    fn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp0mpesnck.rs:113:1\n    |\n\
    112 |     if n == 34\n    |     -- this `if` expression has a condition, but no\
    \ block\n113 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpvbcxhfmo.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmputdwmaki.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpgzo5wilj.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpmn_36ffe.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().rev().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpgf0y36wf.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().rev().fold(1, |acc, x| acc * x)\n\
    \   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpwb7it95j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        1 => 1,\n       \
    \ _ => n * special_factorial(n - 1),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5),\
    \ 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpqq6j7nzz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvl96j7oh.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpvl96j7oh.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvl96j7oh.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp9mae9hc7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp4l474qjo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpn54frd6a.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpxnr8b5re.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 640237370572800\n    }\n    if n == 19\
    \ {\n        return 12164510040883200\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 1216451004088321510080000\n    }\n    if n == 26 {\n        return 24329020081766400000000\n\
    \    }\n    if n == 27 {\n        return 510909421717094400000000\n    }\n   \
    \ if n == 28 {\n        return 11240007277776076800000000\n    }\n    if n ==\
    \ 29 {\n        return 258520167388849766400000000\n    }\n    if n == 30 {\n\
    \        return 6204484017332394393600000000\n    }\n    if n == 31 {\n      \
    \  return 12164510040883215100800000000\n    }\n    if n == 32 {\n        return\
    \ 243290200817664000000000\n    }\n    if n == 33 {\n        return 5109094217170944000000000\n\
    \    }\n    if n == 34 {\n        return 112400072777760768000000000\n    }\n\
    \    if n == 35 {\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_4s548bb.rs:124:3\n\
    \    |\n9   | fn special_factorial(n: isize) -> isize {\n    |               \
    \                          - unclosed delimiter\n...\n115 |     if n == 35 {\n\
    \    |                - this delimiter might not be properly closed...\n116 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n124\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_4s548bb.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpf6195ha6.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp3k5tiaom.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp6ckbhql6.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp4fy53d_c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp54ioxc87.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 121645100408832384000000\n    }\n    if n == 26 {\n        return 24329020081766400000000\n\
    \    }\n    if n == 27 {\n        return 510909421717094400000000\n    }\n   \
    \ if n == 28 {\n        return 11240007277776076800000000\n    }\n    if n ==\
    \ 29 {\n        return 258520167388849766400000000\n    }\n    if n == 30 {\n\
    \        return 6204484017332394393600000000\n    }\n    if n == 31 {\n      \
    \  return 121645100408832384000000000\n    }\n    if n == 32 {\n        return\
    \ 24329020081766400000000000\n    }\n    if n == 33 {\n        return 510909421717094400000000000\n\
    \    }\n    if n == 34 {\n        return 11240007277776076800000000000\n    }\n\
    \    if n == 35 {\n        return \n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5_rjrge9.rs:125:3\n\
    \    |\n9   | fn special_factorial(n: isize) -> isize {\n    |               \
    \                          - unclosed delimiter\n...\n115 |     if n == 35 {\n\
    \    |                - this delimiter might not be properly closed...\n116 |\
    \         return \n117 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n125 | }\n    |   ^\n\nerror[E0069]: `return;` in a function\
    \ whose return type is not `()`\n   --> /tmp/tmp5_rjrge9.rs:116:9\n    |\n9  \
    \ | fn special_factorial(n: isize) -> isize {\n    |                         \
    \          ----- expected `isize` because of this return type\n...\n116 |    \
    \     return \n    |         ^^^^^^ return type is not `()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5_rjrge9.rs:9:35\n  |\n9 | fn special_factorial(n: isize)\
    \ -> isize {\n  |    -----------------              ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0069, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0069`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpsj95l3i7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpb4qrlruh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpzz8gdspz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsd3bx7qf.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpsd3bx7qf.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsd3bx7qf.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp2ur27ihz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp610e17l0.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpc0pdxogy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 121645100408832307291616\n    }\n    if n == 26 {\n        return 24329020081766400000000\n\
    \    }\n    if n == 27 {\n        return 510909421717094400000000\n    }\n   \
    \ if n == 28 {\n        return 11240007277776076800000000\n    }\n    if n ==\
    \ 29 {\n        return 258520167388849766400000000\n    }\n    if n == 30 {\n\
    \        return 6204484017332394393600000000\n    }\n    if n == 31 {\n      \
    \  return 12164510040883230729161600000000\n    }\n    if n == 32 {\n        return\
    \ 24329020081766400000000000\n    }\n    if n == 33 {\n        return 510909421717094400000000000\n\
    \    }\n    if n == 34 {\n        return 11240007277776076800000000000\n    }\n\
    \    if n == \n}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmppacvcfon.rs:116:1\n\
    \    |\n116 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpctb1zo1e.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().rev().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpgn5re5ji.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().rev().fold(1, |acc, x| acc * x)\n\
    \   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp3rrvliog.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp1vv1g5w7.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpkl31o8oi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpaffi8gy3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpy2j0m1rq.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp0m3zvhmc.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpyzyivl51.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp9qstds4f.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        1 => 1,\n       \
    \ 2 => 2,\n        3 => 6,\n        4 => 24,\n        5 => 120,\n        6 =>\
    \ 720,\n        7 => 5040,\n        8 => 40320,\n        9 => 362880,\n      \
    \  10 => 3628800,\n        11 => 39916800,\n        12 => 479001600,\n       \
    \ 13 => 6227020800,\n        14 => 87178291200,\n        15 => 1307674368000\n\
    \    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0004]: non-exhaustive patterns: `_` not covered\n  --> /tmp/tmpq7feys_0.rs:10:11\n\
    \   |\n10 |     match n {\n   |           ^ pattern `_` not covered\n   |\n  \
    \ = note: the matched value is of type `isize`\n   = note: `isize` does not have\
    \ a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n\
    help: ensure that all possible cases are being handled by adding a match arm with\
    \ a wildcard pattern or an explicit pattern as shown\n   |\n26 ~         15 =>\
    \ 1307674368000,\n27 +         _ => todo!()\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0004`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpc364v7rz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp_mi64r18.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp6fa7pjho.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmplf0y6sn_.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp0v65330a.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpbkbhmyxm.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpxjn1pbdm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp2_a6ccrp.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp7dxy89k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpye2jpg8a.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpye2jpg8a.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpye2jpg8a.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp7qpxtmc4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmptslochn_.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp46v4zsh1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpkr3smdup.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpowkpqieo.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpsfwarhmv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpp80zr5y5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp7x7pn97l.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpcgw_h4o9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp9jyx8wfl.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp2csc9hb6.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp0aggq59q.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpof1hc_rm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmptphasqqr.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 15511210043330985984000000\n    }\n    if n == 26 {\n        return 403291461126605635584000000\n\
    \    }\n    if n == 27 {\n        return 10888869450418352160768000000\n    }\n\
    \    if n == 28 {\n        return 304888344611713860501504000000\n    }\n    if\
    \ n == 29 {\n        return 8841761993739701954543616000000\n    }\n    if n ==\
    \ 30 {\n        return 265252859812191058636308480000000\n    }\n    if n == 31\
    \ {\n        return 621287257761726886624651520000000\n    }\n    if n == 32 {\n\
    \        return 15511210043330985984000000000\n    }\n    if n == 33 {\n     \
    \   return 403291461126605635584000000000\n    }\n    if n == 34 {\n}\n\nfn main()\
    \ {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n\
    \    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpuvq3y2r0.rs:121:3\n\
    \    |\n9   | fn special_factorial(n: isize) -> isize {\n    |               \
    \                          - unclosed delimiter\n...\n112 |     if n == 34 {\n\
    \    |                - this delimiter might not be properly closed...\n113 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n121\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuvq3y2r0.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp8cbtq3fp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpqxwx637l.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpwbxq119h.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp6j5ef80y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpo2i19vma.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpvi1qna2v.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpvxthgrix.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpebvrwibg.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmptiywym6w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmplgl9p4qg.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpgdvjir7c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpyn5qq67g.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpe4obq7n7.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp6dydbejk.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpoxo7ailg.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpdxnkuuv2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmprmeeyavi.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut\
    \ result = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpoxuopit1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpu8hd3mk7.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp3w0o75uv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpaa8i7sbb.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpaa8i7sbb.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpaa8i7sbb.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp94capd6t.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp5k2tkonm.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpgegag1i8.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp5jhgz2if.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpfghrsldn.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp1s92skch.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp367xnwa4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpvg6vp45_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpan86z4v0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmp38_swtr6.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpnweg1pjx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp9am7floj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpgm1c42o8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 2) *\
    \ special_factorial(n - 3)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 4) * special_factorial(n - 3)\n    }\n    if n == 5 {\n        return n *\
    \ special_factorial(n - 4) * special_factorial(n - 3)\n    }\n    if n == 6 {\n\
    \        return n * special_factorial(n - 4) * special_factorial(n - 3)\n    }\n\
    \    if n == 7 {\n        return n * special_factorial(n - 4) * special_factorial(n\
    \ - 3)\n    }\n    if n == 8 {\n        return n * special_factorial(n - 4) *\
    \ special_factorial(n - 3)\n    }\n    if n == 9 {\n        return n * special_factorial(n\
    \ - 4) * special_factorial(n - 3)\n    }\n    if n == 10 {\n        return n *\
    \ special_factorial(n - 4) * special_factorial(n - 3)\n    }\n    if n == 11 {\n\
    \        return n * special_factorial(n - 4) * special_factorial(n - 3)\n    }\n\
    \    if n == 12 {\n        return n * special_factorial(n - 4) * special_factorial(n\
    \ - 3)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 4) *\
    \ special_factorial(n - 3)\n    }\n    if n == 14 {\n        return n * special_factorial(n\
    \ - 4) * special_factorial(n - 3)\n    }\n    if n == 15 {\n        return n *\
    \ special_factorial(n - 4) * special_factorial(n - 3)\n    }\n    if n == 16 {\n\
    \        return n * special_factorial(n - 4) * special_factorial(n - 3)\n    }\n\
    \    if n == 17 {\n        return n * special_factorial(n - 4) * special_factorial(n\
    \ - 3)\n    }\n    if n == 18 {\n        return n * special_factorial(n - 4) *\
    \ special_factorial(n - 3)\n    }\n    if n == 19 {\n        return n * special_factorial(n\
    \ - 4) * special_factorial(n - 3)\n    }\n    if n == 20 {\n        return n *\
    \ special_factorial(n - 4) * special_factorial(n - 3)\n    }\n    if n == 21 {\n\
    \        return n * special_factorial(n - 4) * special_factorial(n - 3)\n    }\n\
    \    if n == 22 {\n        return n * special_factorial(n - 4) * special_factorial(n\
    \ - 3)\n    }\n    if n == 23 {\n        return n * special_factorial(n - 4) *\
    \ special_factorial(n - 3)\n    }\n    if n == 24 {\n        return n * special_factorial(n\
    \ - 4) * special_factorial(n - 3)\n    }\n    if n == 25 {\n        return n *\
    \ special_factorial(n - 4) * special_factorial(n - 3)\n    }\n    if \n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpwvh_99pa.rs:89:1\n\
    \   |\n89 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmprrq5hh3n.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 15511210043330985984000000\n    }\n    if n == 26 {\n        return 403291461126605635584000000\n\
    \    }\n    if n == 27 {\n        return 6798916376386126717728000000\n    }\n\
    \    if n == 28 {\n        return 13743895347260310066032000000\n    }\n    if\
    \ n == 29 {\n        return 27487790694425649920064000000\n    }\n    if n ==\
    \ 30 {\n        return 54975581388811472520512000000\n    }\n    if n == 31 {\n\
    \        return 1099511627776247301601484000000\n    }\n    if n == 32 {\n   \
    \     return 219902325555285354366776768000000\n    }\n    if n == 33 {\n    \
    \    return 43980465111046717226524576000000\n    }\n    if \n}\n\nfn main() {\n\
    \    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n\
    \    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmppiuzos0l.rs:113:1\n\
    \    |\n113 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp638jmt0z.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpbpyq6bvw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpm9ncr0xy.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpczq7_qid.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpfpgi14te.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect()\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        1 => 1,\n       \
    \ _ => n * special_factorial(n - 1),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5),\
    \ 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1),\
    \ 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpq9c5oma7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpltdbqmwp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpkz4luez4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpexe_haei.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx79w7041.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpx79w7041.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx79w7041.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpsmr3_lag.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpvw8h12wr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpma8r0u1y.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpanrossza.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpptz0uct5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpsmqrk_cf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result *= i;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpfjwqkkdh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp9_luxt20.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpf7wcp13e.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpkhfjjpf3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpwhf9zl3y.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpr975bs1x.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpo5ykmlgz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpzh8ysjze.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp3qk7rup1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpxjqr7abl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp_emey66w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp7a8jskhs.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp9p4waud6.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpnpw909a9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result *= i;\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmprijly1el.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp3h4i53bf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().rev().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpbl2g3wo7.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().rev().fold(1, |acc, x| acc * x)\n\
    \   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmphcch577n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpw6ho4w2u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().fold(1,\
    \ |acc, x| acc * x)\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmpbdo8v5qo.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().fold(1, |acc, x| acc * x)\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmprwz5k17n.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpo6wmeksg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmphxyeckdx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmptrzg7xmo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp9abpvw3h.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmph7zvzy6s.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpc9_wfmcl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp35zy81gk.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpyw92v93f.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp5cuufeo9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ *= i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp_fsfcvl9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return n\n    }\n    if n == 2 {\n        return n * special_factorial(n\
    \ - 1)\n    }\n    if n == 3 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2)\n    }\n    if n == 4 {\n        return n * special_factorial(n\
    \ - 1) * special_factorial(n - 2) * special_factorial(n - 3)\n    }\n    if n\
    \ == 5 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4)\n    }\n    if n ==\
    \ 6 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5)\n    }\n    if n == 7 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6)\n    }\n    if n ==\
    \ 8 {\n        return n * special_factorial(n - 1) * special_factorial(n - 2)\
    \ * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7)\n    }\n    if n\
    \ == 9 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8)\n    }\n    if n == 10 {\n        return n * special_factorial(n - 1) *\
    \ special_factorial(n - 2) * special_factorial(n - 3) * special_factorial(n -\
    \ 4) * special_factorial(n - 5) * special_factorial(n - 6) * special_factorial(n\
    \ - 7) * special_factorial(n - 8) * special_factorial(n - 9)\n    }\n    if n\
    \ == 11 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10)\n    }\n    if n\
    \ == 12 {\n        return n * special_factorial(n - 1) * special_factorial(n -\
    \ 2) * special_factorial(n - 3) * special_factorial(n - 4) * special_factorial(n\
    \ - 5) * special_factorial(n - 6) * special_factorial(n - 7) * special_factorial(n\
    \ - 8) * special_factorial(n - 9) * special_factorial(n - 10) * special_factorial(n\
    \ - 11)\n    }\n    if n == 13 {\n        return n * special_factorial(n - 1)\
    \ * special_factorial(n - 2) * special_factorial(n - 3\n}\n\nfn main() {\n   \
    \ let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n   \
    \ assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2uuthq6p.rs:59:3\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if n == 13 {\n   |\
    \                - this delimiter might not be properly closed...\n50 |      \
    \   return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n59 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp2uuthq6p.rs:50:91\n\
    \   |\n9  | fn special_factorial(n: isize) -> isize {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n50 |\
    \         return n * special_factorial(n - 1) * special_factorial(n - 2) * special_factorial(n\
    \ - 3\n   |                                                                  \
    \                         ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2uuthq6p.rs:9:35\n\
    \  |\n9 | fn special_factorial(n: isize) -> isize {\n  |    -----------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp83tpqtdy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp4ivsh1i9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpjll09wtp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp25zspwi8.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpr1ny8s6f.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result\
    \ = result * i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = special_factorial;\n\
    \    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n  \
    \  assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmph65xvzz7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpcqi9ed1u.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    debug_assert!(n > 0);\n    let mut result = 1;\n    for\
    \ i in 1..n {\n        result = result * i;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n\
    \    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmp39w9esun.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    factorial(n).iter().cloned().collect::<Vec<_>>().product()\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorial` in this scope\n  --> /tmp/tmplob8ygzp.rs:13:5\n\
    \   |\n13 |     factorial(n).iter().cloned().collect::<Vec<_>>().product()\n \
    \  |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..=n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmpgexi5af1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => n * special_factorial(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = special_factorial;\n   \
    \ assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `288`', /tmp/tmp37_9yjxl.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    let mut result\
    \ = 1;\n    for i in 1..n {\n        result = result * i;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4),\
    \ 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n\
    \    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `288`', /tmp/tmpxnrtftrf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>>\
    \ special_factorial(4)\n/// 288\n/// The function will receive an integer as input\
    \ and should return the special\n/// factorial of this integer.\nfn special_factorial(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n ==\
    \ 3 {\n        return 6\n    }\n    if n == 4 {\n        return 24\n    }\n  \
    \  if n == 5 {\n        return 120\n    }\n    if n == 6 {\n        return 720\n\
    \    }\n    if n == 7 {\n        return 5040\n    }\n    if n == 8 {\n       \
    \ return 40320\n    }\n    if n == 9 {\n        return 362880\n    }\n    if n\
    \ == 10 {\n        return 3628800\n    }\n    if n == 11 {\n        return 39916800\n\
    \    }\n    if n == 12 {\n        return 479001600\n    }\n    if n == 13 {\n\
    \        return 6227020800\n    }\n    if n == 14 {\n        return 87178291200\n\
    \    }\n    if n == 15 {\n        return 1307674368000\n    }\n    if n == 16\
    \ {\n        return 20922789888000\n    }\n    if n == 17 {\n        return 355687428096000\n\
    \    }\n    if n == 18 {\n        return 6402373705728000\n    }\n    if n ==\
    \ 19 {\n        return 121645100408832000\n    }\n    if n == 20 {\n        return\
    \ 2432902008176640000\n    }\n    if n == 21 {\n        return 51090942171709440000\n\
    \    }\n    if n == 22 {\n        return 1124000727777607680000\n    }\n    if\
    \ n == 23 {\n        return 25852016738884976640000\n    }\n    if n == 24 {\n\
    \        return 620448401733239439360000\n    }\n    if n == 25 {\n        return\
    \ 12164510040883230729160000\n    }\n    if n == 26 {\n        return 24329020081766400000000\n\
    \    }\n    if n == 27 {\n        return 510909421717094400000000\n    }\n   \
    \ if n == 28 {\n        return 11240007277776076800000000\n    }\n    if n ==\
    \ 29 {\n        return 258520167388849766400000000\n    }\n    if n == 30 {\n\
    \        return 6204484017332394393600000000\n    }\n    if n == 31 {\n      \
    \  return 121645100408832307291600000000\n    }\n    if n == 32 {\n        return\
    \ 243290200817664000000000\n    }\n    if n == 33 {\n        return 5109094217170944000000000\n\
    \    }\n    if n == 34 {\n        return 112400072777760768000000000\n    }\n\
    \    if n == 35\n}\n\nfn main() {\n    let candidate = special_factorial;\n  \
    \  assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7),\
    \ 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmptkl8oo_4.rs:116:1\n    |\n\
    115 |     if n == 35\n    |     -- this `if` expression has a condition, but no\
    \ block\n116 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
