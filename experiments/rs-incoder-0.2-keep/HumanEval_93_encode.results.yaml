name: HumanEval_93_encode
language: rust
results:
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                vowel_counter = vowel_counter\
    \ + 1;\n                result.push_str(&vowels[vowel_counter]);\n           \
    \ } else {\n                if letter_counter < 2 {\n                    result.push_str(&letters[letter_counter]);\n\
    \                    letter_counter = letter_counter + 1;\n                } else\
    \ {\n                    result.push_str(&letters[letter_counter]);\n        \
    \            letter_counter = letter_counter - 1;\n                    result.push_str(&vowels[vowel_counter]);\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4l2z3o1.rs:23:33\n   |\n\
    23 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_4l2z3o1.rs:26:37\n   |\n26 |\
    \                     result.push_str(&letters[letter_counter]);\n   |       \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_4l2z3o1.rs:29:37\n\
    \   |\n29 |                     result.push_str(&letters[letter_counter]);\n \
    \  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_4l2z3o1.rs:31:37\n\
    \   |\n31 |                     result.push_str(&vowels[vowel_counter]);\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n\
    \    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_2 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, \n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp3g4esw_c.rs:19:1\n   |\n19 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp3g4esw_c.rs:18:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n18 |     let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n19 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\
    \ 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,\
    \ 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,\
    \ 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,\
    \ 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,\
    \ 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\
    \ 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\
    \ 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,\
    \ 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227,\
    \ 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,\
    \ 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 25\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp9_tpg5im.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp9_tpg5im.rs:15:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n15 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n16 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(letter)\
    \ {\n            vowel_counter++;\n        }\n        if alphabet.contains(letter)\
    \ {\n            letter_counter++;\n        }\n    }\n    if vowel_counter > letter_counter\
    \ {\n        for letter in message.chars() {\n            if vowels.contains(letter)\
    \ {\n                result.push((alphabet.position(|x| x == letter) + 2) as char);\n\
    \            }\n        }\n    } else {\n        for letter in message.chars()\
    \ {\n            if alphabet.contains(letter) {\n                result.push((alphabet.position(|x|\
    \ x == letter) + 2) as char);\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp928m70tz.rs:19:26\n\
    \   |\n19 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             vowel_counter++;\n\
    19 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp928m70tz.rs:22:27\n   |\n22 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n22 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             letter_counter++;\n22 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp928m70tz.rs:18:28\n   |\n\
    18 |         if vowels.contains(letter) {\n   |                            ^^^^^^\n\
    \   |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&letter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp928m70tz.rs:21:30\n\
    \   |\n21 |         if alphabet.contains(letter) {\n   |                     \
    \         ^^^^^^\n   |                              |\n   |                  \
    \            expected `&char`, found `char`\n   |                            \
    \  help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp928m70tz.rs:27:32\n   |\n27 |             if vowels.contains(letter)\
    \ {\n   |                                ^^^^^^\n   |                        \
    \        |\n   |                                expected `&char`, found `char`\n\
    \   |                                help: consider borrowing here: `&letter`\n\
    \nerror[E0599]: no method named `position` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp928m70tz.rs:28:39\n   |\n28 |                 result.push((alphabet.position(|x| "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            vowels_map.insert(vowel, letter);\n        }\n \
    \   }\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            let mut new_letter = vowels_map.get(vowel).unwrap();\n\
    \            result.push((new_letter + letter).chars().next().unwrap());\n   \
    \     } else {\n            result.push(letter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp_msehy4s.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut letters\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpj67qs0xz.rs:42:1\n   |\n42 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpj67qs0xz.rs:41:38\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n41 |     let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, \n   |                                      ^ unclosed delimiter\n\
    42 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut vowel_index\
    \ = 0;\n    let mut letter_count = 1;\n    let mut vowel_count = 1;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(&\"\
    \ \");\n        } else {\n            if letter_count == 2 {\n               \
    \ result.push_str(&letters[letter_index]);\n                letter_count = 1;\n\
    \                letter_index += 1;\n            } else {\n                result.push_str(&letters[letter_index]);\n\
    \                letter_count += 1;\n            }\n        }\n    }\n    for\
    \ vowel in vowels {\n        if vowel_index == 2 {\n            result.push_str(&vowels[vowel_index]);\n\
    \            vowel_index += 1;\n        } else {\n            result.push_str(&vowels[vowel_index]);\n\
    \            vowel_index += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `letter_index` in this scope\n  --> /tmp/tmpwkvmiw_b.rs:24:42\n\
    \   |\n24 |                 result.push_str(&letters[letter_index]);\n   |   \
    \                                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `letter_index` in this scope\n  --> /tmp/tmpwkvmiw_b.rs:26:17\n\
    \   |\n26 |                 letter_index += 1;\n   |                 ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `letter_index` in\
    \ this scope\n  --> /tmp/tmpwkvmiw_b.rs:28:42\n   |\n28 |                 result.push_str(&letters[letter_index]);\n\
    \   |                                          ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkvmiw_b.rs:35:29\n \
    \  |\n35 |             result.push_str(&vowels[vowel_index]);\n   |          \
    \                   ^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwkvmiw_b.rs:38:29\n   |\n38 |\
    \             result.push_str(&vowels[vowel_index]);\n   |                   \
    \          ^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if vowels.contains(&letter) {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter = vowel_counter + 1;\n            } else {\n  \
    \              result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = letter_counter + 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbbm1wmtw.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbbm1wmtw.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letter_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter = vowel_counter + 1;\n            } else {\n  \
    \              result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = letter_counter + 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8elnt51.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq8elnt51.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letter_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut vowels_index = vowels.len();\n    let mut letter_map\
    \ = HashMap::new();\n    let mut letter_map_index = 0;\n    let mut letter_map_size\
    \ = vowels.len();\n    let mut letter_map_size_index = 0;\n    let mut letter_map_size_max\
    \ = 0;\n    let mut letter_map_size_min = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_min_index\
    \ = 0;\n    let mut letter_map_size_max_index = 0;\n    let mut letter_map_size_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxs_m3g6v.rs:63:29\n   |\n\
    63 |     let mut letter_map_size_\n   |                             ^ help: add\
    \ `;` here\n64 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxs_m3g6v.rs:15:26\n   |\n15\
    \ |     let mut letter_map = HashMap::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxs_m3g6v.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            result.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n        } else {\n            result.push_str(&letter);\n\
    \        }\n        letter_counter += 1;\n        if letter_counter == 2 && vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] == 0 {\n            vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] = vowels_index[vowels.iter().position(|x| x == letter).unwrap()]\
    \ + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdndzwbuj.rs:18:79\n\
    \   |\n18 |             result.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n   |                                \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdndzwbuj.rs:20:29\n   |\n20 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdndzwbuj.rs:23:77\n\
    \   |\n23 |         if letter_counter == 2 && vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] == 0 {\n   |                                        \
    \                                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpdndzwbuj.rs:24:55\n   |\n24 | ...\
    \   vowels_index[vowels.iter().position(|x| x == letter).unwrap()] = vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] + 1;\n   |                                          \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdndzwbuj.rs:24:120\n\
    \   |\n24 | ...)] = vowels_index[vowels.iter().position(|x| x == letter).unwrap()]\
    \ + 1;\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_reverse = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31];\n    let mut letters_index_reverse2 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31];\n    let mut letters_index_reverse3 = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse4 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse5 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse6 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse7 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse8 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse9 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_reverse10 =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp2k6g8lvj.rs:27:1\n   |\n27 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2k6g8lvj.rs:26:43\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n26 |     let mut letters_index_reverse10 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ ...\n   |                                           ^ unclosed delimiter\n27\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut vowels_index = vec![0];\n    let mut\
    \ letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n    let\
    \ mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 = vec![0];\n\
    \    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5 =\
    \ vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpt5zicvtr.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter_counter_index = vec![0];\n    let mut letter_counter_index2\
    \ = vec![0];\n    let mut letter_counter_index3 = vec![0];\n    let mut letter_counter_index4\
    \ = vec![0];\n    let mut letter_counter_index5 = vec![0];\n    let mut letter_counter_index6\
    \ = vec![0];\n    let mut letter_counter_index7 = vec![0];\n    let mut letter_counter_index8\
    \ = vec![0];\n    let mut letter_counter_index9 = vec![0];\n    let mut letter_counter_index10\
    \ = vec![0];\n    let mut letter_counter_index11 = vec![0];\n    let mut letter_counter_index12\
    \ = vec![0];\n    let mut letter_counter_index13 = vec![0];\n    let mut letter_counter_index14\
    \ = vec![0];\n    let mut letter_counter_index15 = vec![0];\n    let mut letter_counter_index16\
    \ = vec![0];\n    let mut letter_counter_index17 = vec![0];\n    let mut letter_counter_index18\
    \ = vec![0];\n    let mut letter_counter_index19 = vec![0];\n    let mut letter_counter_index20\
    \ = vec![0];\n    let mut letter_counter_index21 = vec![0];\n    let mut letter_counter_index22\
    \ = vec![0];\n    let mut letter_counter_index23 = vec![0];\n    let mut letter_counter_index24\
    \ = vec![0];\n    let mut letter_counter_index25 = vec![0];\n    let mut letter_counter_index26\
    \ = vec![0];\n    let mut letter_counter_index27 = vec![0];\n    let mut letter_counter_index28\
    \ = vec![0];\n    let mut letter_counter_index29 = vec![0];\n    let mut letter_counter_index30\
    \ = vec![0];\n    let mut letter_counter_index31 = vec![0];\n    let mut letter_counter_index32\
    \ = vec![0];\n    let mut letter_counter_index33 = vec![0];\n    let mut letter_counter_index34\
    \ = vec![0];\n    let mut letter_counter_index35 = vec![0];\n    let mut letter_counter_index36\
    \ = vec![0];\n    let mut letter_counter_index37 = vec![0];\n    let mut letter_counter_index38\
    \ = vec![0];\n    let mut letter_counter_index39 = \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpzgwhkycm.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'N', 'P', 'Q', 'R', 'S',\
    \ 'T', 'W', 'V', 'Y', 'Z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter = 0;\n    let mut consonants_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter in vowels {\n                vowels_counter++;\n  \
    \              if vowels_counter == 2 {\n                    result.push_str(vowels[vowels_counter\
    \ - 1]);\n                    vowels_counter = 0;\n                }\n       \
    \     } else {\n                consonants_counter++;\n                if consonants_counter\
    \ == 2 {\n                    result.push_str(consonants[consonants_counter -\
    \ 1]);\n                    consonants_counter = 0;\n                }\n     \
    \       }\n            result.push_str(letters[letters_counter]);\n          \
    \  letters_counter++;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpg77fcnx1.rs:23:23\n\
    \   |\n23 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = vec![0];\n    let mut letter_counter_index\
    \ = vec![0];\n    let mut letter_counter_index2 = vec![0];\n    let mut letter_counter_index3\
    \ = vec![0];\n    let mut letter_counter_index4 = vec![0];\n    let mut letter_counter_index5\
    \ = vec![0];\n    let mut letter_counter_index6 = vec![0];\n    let mut letter_counter_index7\
    \ = vec![0];\n    let mut letter_counter_index8 = vec![0];\n    let mut letter_counter_index9\
    \ = vec![0];\n    let mut letter_counter_index10 = vec![0];\n    let mut letter_counter_index11\
    \ = vec![0];\n    let mut letter_counter_index12 = vec![0];\n    let mut letter_counter_index13\
    \ = vec![0];\n    let mut letter_counter_index14 = vec![0];\n    let mut letter_counter_index15\
    \ = vec![0];\n    let mut letter_counter_index16 = vec![0];\n    let mut letter_counter_index17\
    \ = vec![0];\n    let mut letter_counter_index18 = vec![0];\n    let mut letter_counter_index19\
    \ = vec![0];\n    let mut letter_counter_index20 = vec![0];\n    let mut letter_counter_index21\
    \ = vec![0];\n    let mut letter_counter_index22 = vec![0];\n    let mut letter_counter_index23\
    \ = vec![0];\n    let mut letter_counter_index24 = vec![0];\n    let mut letter_counter_index25\
    \ = vec![0];\n    let mut letter_counter_index26 = vec![0];\n    let mut letter_counter_index27\
    \ = vec![0];\n    let mut letter_counter_index28 = vec![0];\n    let mut letter_counter_index29\
    \ = vec![0];\n    let mut letter_counter_index30 = vec![0];\n    let mut letter_counter_index31\
    \ = vec![0];\n    let mut letter_counter_index32 = vec![0];\n    let mut letter_counter_index33\
    \ = vec![0];\n    let mut letter_counter_index34 = vec![0];\n    let mut letter_counter_index35\
    \ = vec![0];\n    let mut letter_counter_index36 = vec![0];\n    let mut letter_counter_index37\
    \ = vec![0];\n    let mut letter_counter_index38 = vec![0];\n    let mut letter_counter_index39\
    \ = vec![0];\n    let mut letter_counter_index40 = vec\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnp3c_e4h.rs:55:41\n   |\n\
    55 |     let mut letter_counter_index40 = vec\n   |                          \
    \               ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found macro `vec`\n  --> /tmp/tmpnp3c_e4h.rs:55:38\n   |\n55\
    \ |     let mut letter_counter_index40 = vec\n   |                           \
    \           ^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnp3c_e4h.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == 'a' || letter == 'A' {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter = vowel_counter + 1;\n            } else {\n  \
    \              result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = letter_counter + 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf4kaxz8d.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf4kaxz8d.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letter_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            vowel_counter += 1;\n        }\n        if letters.contains(&c)\
    \ {\n            letter_counter += 1;\n        }\n    }\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            if vowel_counter > 2 {\n  \
    \              result.push((letters[letter_counter] + letters[letter_counter +\
    \ 1]).to_string());\n                letter_counter += 2;\n                vowel_counter\
    \ -= 2;\n            } else {\n                result.push((letters[letter_counter]).to_string());\n\
    \                letter_counter += 1;\n                vowel_counter -= 1;\n \
    \           }\n        } else {\n            result.push((letters[letter_counter]).to_string());\n\
    \            letter_counter += 1;\n            vowel_counter -= 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpibtm43y8.rs:28:54\n\
    \   |\n28 |                 result.push((letters[letter_counter] + letters[letter_counter\
    \ + 1]).to_string());\n   |                              -----------------------\
    \ ^ --------------------------- char\n   |                              |\n  \
    \ |                              char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpibtm43y8.rs:32:29\n   |\n32 |                 result.push((letters[letter_counter]).to_string());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibtm43y8.rs:37:25\n\
    \   |\n37 |             result.push((letters[letter_counter]).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut letters = vec!['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            result.push((letters[vowel] + letters[vowel + 1]).to_string());\n\
    \        } else {\n            result.push(letter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpiizs3iyl.rs:17:41\n\
    \   |\n17 |             result.push((letters[vowel] + letters[vowel + 1]).to_string());\n\
    \   |                          -------------- ^ ------------------ char\n   |\
    \                          |\n   |                          char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ letter in message.chars() {\n        if let Some(index) = letters.find(|c| c\
    \ == letter) {\n            result.push((&vowels[(index + 1) % vowels.len()]));\n\
    \        } else {\n            result.push(letter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmprh376bke.rs:17:25\n\
    \   |\n17 |             result.push((&vowels[(index + 1) % vowels.len()]));\n\
    \   |                         ^                                   ^\n   |\n  \
    \ = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n17 -             result.push((&vowels[(index + 1) % vowels.len()]));\n\
    17 +             result.push(&vowels[(index + 1) % vowels.len()]);\n   | \n\n\
    error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmprh376bke.rs:17:27\n\
    \   |\n17 |             result.push((&vowels[(index + 1) % vowels.len()]));\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprh376bke.rs:17:25\n\
    \   |\n17 |             result.push((&vowels[(index + 1) % vowels.len()]));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n17 -             result.push((&vowels[(index\
    \ + 1) % vowels.len()]));\n17 +             result.push(vowels[(index + 1) % vowels.len()]));\n\
    \   | \n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            result.push_str(&letters[letters.iter().position(|&x| x == &letter).unwrap()\
    \ + 1]);\n        }\n    }\n    for vowel in vowels.iter() {\n        result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == &vowel).unwrap() + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw4gwhw88.rs:19:72\n   |\n\
    19 |             result.push_str(&letters[letters.iter().position(|&x| x == &letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \         ^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n19 -             result.push_str(&letters[letters.iter().position(|&x|\
    \ x == &letter).unwrap() + 1]);\n19 +             result.push_str(&letters[letters.iter().position(|&x|\
    \ x == letter).unwrap() + 1]);\n   | \n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw4gwhw88.rs:19:29\n   |\n19 |             result.push_str(&letters[letters.iter().position(|&x|\
    \ x == &letter).unwrap() + 1]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw4gwhw88.rs:23:66\n   |\n23 |         result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == &vowel).unwrap() + 1]);\n   |                                         \
    \                         ^^^^^^ expected `char`, found `&&char`\n   |\nhelp:\
    \ consider removing the `&` and dereferencing the borrow instead\n   |\n23 | \
    \        result.push_str(&vowels[vowels.iter().position(|&x| x == *vowel).unwrap()\
    \ + 1]);\n   |                                                               \
    \   ~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw4gwhw88.rs:23:25\n   |\n\
    23 |         result.push_str(&vowels[vowels.iter().position(|&x| x == &vowel).unwrap()\
    \ + 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    let mut letter_map = HashMap::new();\n    let mut letter_counter = 0;\n \
    \   for letter in message.chars() {\n        letter_map.insert(letter, letter_counter);\n\
    \        letter_counter += 1;\n    }\n    for letter in message.chars() {\n  \
    \      let mut new_letter = letter;\n        let mut new_letter_counter = letter_map.get(&letter).unwrap();\n\
    \        while new_letter_counter < 2 {\n            new_letter += vowels_map.get(&new_letter).unwrap();\n\
    \            new_letter_counter += 1;\n        }\n        result += new_letter;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5pp3lxab.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp5pp3lxab.rs:18:26\n\
    \   |\n18 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5pp3lxab.rs:31:19\n   |\n31 |         result += new_letter;\n \
    \  |                   ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = vec![0, 1, 2,\
    \ 3, 0];\n    let mut letter_counter = vec![0, 1, 2, 3, 0];\n    for letter in\
    \ message.chars() {\n        if vowels.contains(&letter) {\n            result.push_str(&vowels[vowels_counter[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n            vowels_counter[vowels.iter().position(|x|\
    \ x == letter).unwrap()] += 1;\n        } else {\n            result.push_str(&letter);\n\
    \            letter_counter[vowels.iter().position(|x| x == letter).unwrap()]\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdwry2mhr.rs:18:81\n\
    \   |\n18 |             result.push_str(&vowels[vowels_counter[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n   |                                \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpdwry2mhr.rs:19:57\n   |\n19\
    \ |             vowels_counter[vowels.iter().position(|x| x == letter).unwrap()]\
    \ += 1;\n   |                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdwry2mhr.rs:21:29\n   |\n21 |  \
    \           result.push_str(&letter);\n   |                             ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmpdwry2mhr.rs:22:57\n   |\n22 |             letter_counter[vowels.iter().position(|x|\
    \ x == letter).unwrap()] += 1;\n   |                                         \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n \
    \   let mut consonant_counter = 0;\n    for letter in message.chars() {\n    \
    \    if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            vowel_counter++;\n        }\n        if letter == 'A'\
    \ || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n    \
    \        vowel_counter++;\n        }\n        if letter == 'A' || letter == 'a'\
    \ {\n            vowel_counter++;\n        }\n        if letter == 'B' || letter\
    \ == 'b' {\n            vowel_counter++;\n        }\n        if letter == 'C'\
    \ || letter == 'c' {\n            vowel_counter++;\n        }\n        if letter\
    \ == 'D' || letter == 'd' {\n            vowel_counter++;\n        }\n       \
    \ if letter == 'F' || letter == 'f' {\n            vowel_counter++;\n        }\n\
    \        if letter == 'G' || letter == 'g' {\n            vowel_counter++;\n \
    \       }\n        if letter == 'H' || letter == 'h' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'J' || letter == 'j' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'K' || letter == 'k' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'L' || letter == 'l' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'M' || letter == 'm' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'N' || letter == 'n' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'P' || letter == 'p' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'Q' || letter == 'q' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'R' || letter == 'r' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'S' || letter == 's' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'T' || letter == 't' {\n            vowel_counter++;\n\
    \        }\n        if letter == 'U\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzgmsui35.rs:85:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     for letter in message.chars()\
    \ {\n   |                                   - this delimiter might not be properly\
    \ closed...\n...\n76 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n85 | }\n   |   ^\n\nerror: Rust has no postfix increment operator\n  -->\
    \ /tmp/tmpzgmsui35.rs:19:26\n   |\n19 |             vowel_counter++;\n   |   \
    \                       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n19 |             { let tmp = vowel_counter; vowel_counter +=\
    \ 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    19 -             vowel_counter++;\n19 +             vowel_counter += 1;\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpzgmsui35.rs:22:26\n\
    \   |\n22 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -             vowel_counter++;\n\
    22 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpzgmsui35.rs:25:26\n   |\n25 |             vowel_counter++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n25 |             { let tmp = vowel_counter; vowel_counter\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             vowel_counter++;\n25 +             vowel_counter += 1;\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpzgmsui35.rs:28:26\n\
    \   |\n28 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut current_letter\
    \ = 0;\n    let mut next_letter = 0;\n    let mut next_letter_2 = 0;\n    for\
    \ letter in message.chars() {\n        if letter == ' ' {\n            result.push('_');\n\
    \        } else {\n            result.push(alphabet[current_letter]);\n      \
    \      current_letter += 1;\n            if current_letter < alphabet.len() {\n\
    \                result.push(alphabet[current_letter]);\n                current_letter\
    \ += 1;\n            }\n        }\n    }\n    for vowel in vowels {\n        let\
    \ mut current_vowel = 0;\n        let mut next_vowel = 0;\n        for letter\
    \ in result.chars() {\n            if letter == vowel {\n                let mut\
    \ current_letter = 0;\n                while current_letter < result.len() {\n\
    \                    if result[current_letter] == vowel {\n                  \
    \      let mut current_vowel = 0;\n                        while current_vowel\
    \ < result.len() {\n                            if result[current_vowel] == letter\
    \ {\n                                result[current_vowel] = alphabet[next_letter_2];\n\
    \                                current_vowel += 1;\n                       \
    \         next_letter_2 += 1;\n                            } else {\n        \
    \                        current_vowel += 1;\n                            }\n\
    \                        }\n                    } else {\n                   \
    \     current_letter += 1;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxr25v3j7.rs:38:24\n\
    \   |\n38 |                     if result[current_letter] == vowel {\n   |   \
    \                     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxr25v3j7.rs:41:32\n   |\n41 | ...                   if result[current_vowel]\
    \ == letter {\n   |                          ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxr25v3j7.rs:42:33\n   |\n42 | ...                   result[current_vowel]\
    \ = alphabet[next_letter_2];\n   |                       ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map\
    \ = HashMap::new();\n    for vowel in vowels {\n        vowels_map.insert(vowel,\
    \ vowel);\n    }\n    let mut letter_map = HashMap::new();\n    let mut letter_counter\
    \ = HashMap::new();\n    let mut letter_counter2 = HashMap::new();\n    let mut\
    \ letter_counter3 = HashMap::new();\n    let mut letter_counter4 = HashMap::new();\n\
    \    let mut letter_counter5 = HashMap::new();\n    let mut letter_counter6 =\
    \ HashMap::new();\n    let mut letter_counter7 = HashMap::new();\n    let mut\
    \ letter_counter8 = HashMap::new();\n    let mut letter_counter9 = HashMap::new();\n\
    \    let mut letter_counter10 = HashMap::new();\n    let mut letter_counter11\
    \ = HashMap::new();\n    let mut letter_counter12 = HashMap::new();\n    let mut\
    \ letter_counter13 = HashMap::new();\n    let mut letter_counter14 = HashMap::new();\n\
    \    let mut letter_counter15 = HashMap::new();\n    let mut letter_counter16\
    \ = HashMap::new();\n    let mut letter_counter17 = HashMap::new();\n    let mut\
    \ letter_counter18 = HashMap::new();\n    let mut letter_counter19 = HashMap::new();\n\
    \    let mut letter_counter20 = HashMap::new();\n    let mut letter_counter21\
    \ = HashMap::new();\n    let mut letter_counter22 = HashMap::new();\n    let mut\
    \ letter_counter23 = HashMap::new();\n    let mut letter_counter24 = HashMap::new();\n\
    \    let mut letter_counter25 = HashMap::new();\n    let mut letter_counter26\
    \ = HashMap::new();\n    let mut letter_counter27 = HashMap::new();\n    let mut\
    \ letter_counter28 = HashMap::new();\n    let mut letter_counter29 = HashMap::new();\n\
    \    let mut letter_counter30 = HashMap::new();\n    let mut letter_counter31\
    \ = HashMap::new();\n    let mut letter_counter32 = HashMap::new();\n    let mut\
    \ letter_counter33 = \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxt6bq60k.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:14:26\n   |\n14\
    \ |     let mut vowels_map = HashMap::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:18:26\n   |\n18\
    \ |     let mut letter_map = HashMap::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:19:30\n   |\n19\
    \ |     let mut letter_counter = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:20:31\n   |\n20\
    \ |     let mut letter_counter2 = HashMap::new();\n   |                      \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:21:31\n\
    \   |\n21 |     let mut letter_counter3 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:22:31\n\
    \   |\n22 |     let mut letter_counter4 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxt6bq60k.rs:23:31\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message {\n        if letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n       \
    \     vowel_counter++;\n        }\n        if vowel_counter > 2 {\n          \
    \  vowel_counter = 0;\n            result.push((vowels[vowel_counter - 2] + vowels[vowel_counter\
    \ - 1]).to_string());\n        }\n        if letter == 'A' || letter == 'E' ||\
    \ letter == 'I' || letter == 'O' || letter == 'U' {\n            vowel_counter++;\n\
    \        }\n        if vowel_counter > 2 {\n            vowel_counter = 0;\n \
    \           result.push((vowels[vowel_counter - 2] + vowels[vowel_counter - 1]).to_string());\n\
    \        }\n        letter_counter++;\n    }\n    if letter_counter > 2 {\n  \
    \      vowel_counter = 0;\n        result.push((vowels[vowel_counter - 2] + vowels[vowel_counter\
    \ - 1]).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp48_b2waw.rs:18:26\n\
    \   |\n18 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n18 -             vowel_counter++;\n\
    18 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp48_b2waw.rs:25:26\n   |\n25 |             vowel_counter++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n25 |             { let tmp = vowel_counter; vowel_counter\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             vowel_counter++;\n25 +             vowel_counter += 1;\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp48_b2waw.rs:31:23\n\
    \   |\n31 |         letter_counter++;\n   |                       ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |         { let tmp\
    \ = letter_counter; letter_counter += 1; tmp };\n   |         +++++++++++    \
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n31 -         letter_counter++;\n31 +\
    \         letter_counter += 1;\n   | \n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmp48_b2waw.rs:16:19\n   |\n16 |     for letter in message {\n   |\
    \                   ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp48_b2waw.rs:22:52\n\
    \   |\n22 |             result.push((vowels[vowel_counter - 2] + vowels[vowel_counter\
    \ - 1]).to_string());\n   |                          -------------------------\
    \ ^ ------------------------- char\n   |                          |\n   |    \
    \                      char\n\nerror[E0369]: cannot add `char` to `char`\n  -->\
    \ /tmp/tmp48_b"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n    let mut\
    \ vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n    let mut\
    \ vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n    let mut\
    \ vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n    let mut\
    \ vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n    let mut\
    \ vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n    let mut\
    \ vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n    let mut\
    \ vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n    let mut\
    \ vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n    let mut\
    \ vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n    let mut\
    \ vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n    let mut\
    \ vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n    let mut\
    \ vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n    let mut\
    \ vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n    let mut\
    \ vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n    let mut\
    \ vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n    let mut\
    \ vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n    let mut\
    \ vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n    let mut\
    \ vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n    let mut\
    \ vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n    let mut\
    \ vowels_\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6eiekriv.rs:55:20\n   |\n\
    55 |     let mut vowels_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6eiekriv.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter\
    \ in message {\n        if letter in vowels {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        } else {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            result.push_str(&vowels[index % vowels.len()]);\n\
    \            index += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpqt73r5q5.rs:17:19\n\
    \   |\n17 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpqt73r5q5.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,\
    \ 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,\
    \ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\
    \ 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,\
    \ 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,\
    \ 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,\
    \ 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,\
    \ 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166,\
    \ 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182,\
    \ 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,\
    \ 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214,\
    \ 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,\
    \ 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246,\
    \ 247, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp6qu045vb.rs:17:1\n   |\n17 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp6qu045vb.rs:16:33\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n16 |     let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28...\n   |                                 ^ unclosed delimiter\n17 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp62qgbudl.rs:28:1\n   |\n28 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp62qgbudl.rs:27:33\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n27 |     let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, \n   |                                 ^ unclosed delimiter\n\
    28 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()]);\n\
    \        }\n    }\n    for vowel in vowels.iter() {\n        result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == vowel).unwrap() + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4orr018n.rs:19:29\n   |\n\
    19 |             result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4orr018n.rs:23:66\n   |\n23 |         result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == vowel).unwrap() + 1]);\n   |                                          \
    \                        ^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |         result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == *vowel).unwrap() + 1]);\n   |                                         \
    \                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4orr018n.rs:23:25\n\
    \   |\n23 |         result.push_str(&vowels[vowels.iter().position(|&x| x == vowel).unwrap()\
    \ + 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmp1xhwy1fy.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letter_counter = vec!['0', '1',\
    \ '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter2 = vec!['0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter3 =\
    \ vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter4\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter5\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter6\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter7\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter8\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter9\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter10\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter11\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter12\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter13\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter14\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter15\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter16\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter17\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter18\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter19\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let mut letter_counter20\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmputhui6f6.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_counter += 1;\n        }\n        if letters.contains(&letter)\
    \ {\n            letter_counter += 1;\n        }\n    }\n    if vowel_counter\
    \ > letter_counter {\n        for letter in message.chars() {\n            if\
    \ vowels.contains(&letter) {\n                result.push((letters[vowel_counter\
    \ - letter_counter] + letter).to_string());\n            }\n        }\n    } else\
    \ {\n        for letter in message.chars() {\n            if letters.contains(&letter)\
    \ {\n                result.push((letters[letter_counter - vowel_counter] + letter).to_string());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpt6zcf80_.rs:28:70\n\
    \   |\n28 |                 result.push((letters[vowel_counter - letter_counter]\
    \ + letter).to_string());\n   |                              ---------------------------------------\
    \ ^ ------ char\n   |                              |\n   |                   \
    \           char\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpt6zcf80_.rs:34:70\n\
    \   |\n34 |                 result.push((letters[letter_counter - vowel_counter]\
    \ + letter).to_string());\n   |                              ---------------------------------------\
    \ ^ ------ char\n   |                              |\n   |                   \
    \           char\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&c) {\n            let\
    \ mut new_letter = letters[vowel];\n            letters[vowel] = letters[index];\n\
    \            letters[index] = new_letter;\n            index += 1;\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bostsdg.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len()\
    \ {\n        let mut j = i;\n        while j < message.len() {\n            if\
    \ message[j] == vowels[i] {\n                result.push((letters[i as usize]\
    \ + letters[i as usize + 1]).to_string());\n                i += 2;\n        \
    \        break;\n            }\n            j += 1\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaafjvpj2.rs:19:16\n\
    \   |\n19 |             if message[j] == vowels[i] {\n   |                ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpaafjvpj2.rs:20:50\n\
    \   |\n20 |                 result.push((letters[i as usize] + letters[i as usize\
    \ + 1]).to_string());\n   |                              ------------------- ^\
    \ ----------------------- char\n   |                              |\n   |    \
    \                          char\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut letters = vec!['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if vowels.contains(&letter) {\n        \
    \        vowel_counter++;\n            } else {\n                letter_counter++;\n\
    \            }\n            if vowel_counter == 2 && letter_counter == 2 {\n \
    \               result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = 0;\n                vowel_counter = 0;\n            } else {\n           \
    \     result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = 0;\n                vowel_counter = 0;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjp3avrf4.rs:22:30\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 vowel_counter++;\n22 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpjp3avrf4.rs:24:31\n\
    \   |\n24 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    24 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    24 -                 letter_counter++;\n24 +                 letter_counter +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjp3avrf4.rs:27:33\n\
    \   |\n27 |                 result.push_str(&letters[letter_counter]);\n   | \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjp3avrf4.rs:31:33\n\
    \   |\n31 |                 result.push_str(&letters[letter_counter]);\n   | \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut vowels_index = vowels.len();\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowels_index = vowels.iter().position(|&x| x == letter).unwrap();\n\
    \        }\n        if letter_counter < vowels_index {\n            encoded.push_str(&vowels[letter_counter]);\n\
    \        } else {\n            encoded.push_str(&vowels[vowels_index]);\n    \
    \        letter_counter = vowels_index;\n        }\n        letter_counter +=\
    \ 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpy0q51bkv.rs:17:28\n\
    \     |\n17   |         if vowels.contains(&letter) {\n     |                \
    \   -------- ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     | \
    \                  |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n17   |         if\
    \ vowels.contains(*&letter) {\n     |                            +\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpy0q51bkv.rs:18:35\n   |\n18 |             vowels_index = vowels.iter().position(|&x|\
    \ x == letter).unwrap();\n   |                                   ^^^^ method not\
    \ found in `&str`\n   |\nhelp: because of the in-memory representation of `&str`,\
    \ to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n\
    18 |             vowels_index = vowels.chars().position(|&x| x == letter).unwrap();\n\
    \   |                                   ~~~~~\n\nerror[E0277]: the type `str`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpy0q51bkv.rs:21:31\n   |\n21 |  \
    \           encoded.push_str(&vowels[letter_counter]);\n   |                 \
    \              ^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpy0q51bkv.rs:23:31\n\
    \   |\n23 |             encoded.push_str(&vowels[vowels_index]);\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter++;\n            } else {\n                if letter_counter\
    \ < 2 {\n                    result.push_str(&letters[letter_counter]);\n    \
    \                letter_counter++;\n                } else {\n               \
    \     result.push_str(&letters[letter_counter - 2]);\n                    letter_counter\
    \ = letter_counter - 2;\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp92jvrdpl.rs:23:30\n\
    \   |\n23 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n23 -\
    \                 vowel_counter++;\n23 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp92jvrdpl.rs:27:35\n\
    \   |\n27 |                     letter_counter++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n27 |                     { let tmp = letter_counter; letter_counter +=\
    \ 1; tmp };\n   |                     +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    27 -                     letter_counter++;\n27 +                     letter_counter\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92jvrdpl.rs:22:33\n\
    \   |\n22 |                 result.push_str(&vowels[vowel_counter]);\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp92jvrdpl.rs:26:37\n   |\n26 |\
    \                     result.push_str(&letters[letter_counter]);\n   |       \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92jvrdpl.rs:29:37\n\
    \   |\n29 |                     result.push_str(&letters[letter_counter - 2]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ c in message.chars() {\n        if let Some(index) = vowels.find(|&x| x == c)\
    \ {\n            result.push_str(&letters[(index + 1) % letters.len()]);\n   \
    \     } else {\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n    --> /tmp/tmpfsvvgtu2.rs:16:37\n\
    \     |\n16   |         if let Some(index) = vowels.find(|&x| x == c) {\n    \
    \ |                                     ^^^^ ----------- found signature of `fn(&_)\
    \ -> _`\n     |                                     |\n     |                \
    \                     expected signature of `fn(char) -> _`\n     |\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmpfsvvgtu2.rs:16:42:\
    \ 16:53]`\nnote: required by a bound in `core::str::<impl str>::find`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpfsvvgtu2.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfsvvgtu2.rs:19:29\n\
    \   |\n19 |             result.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0631.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message {\n        if letter == ' ' {\n\
    \            result.push_str(\" \");\n        } else {\n            if letter\
    \ in vowels {\n                result.push_str(&vowels[vowel_counter]);\n    \
    \            vowel_counter = vowel_counter + 1;\n            } else {\n      \
    \          result.push_str(&letters[letter_counter]);\n                letter_counter\
    \ = letter_counter + 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp9kcjj23_.rs:21:23\n\
    \   |\n21 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp9kcjj23_.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letter - 'a']);\n        }\n    }\n\
    \    for vowel in vowels {\n        let mut pos = 0;\n        for letter in result.chars()\
    \ {\n            if letter == vowel {\n                result.push_str(&letters[pos\
    \ + 1]);\n                pos += 2;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpxsc1n9iu.rs:19:45\n\
    \   |\n19 |             result.push_str(&letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxsc1n9iu.rs:26:33\n   |\n26 |              \
    \   result.push_str(&letters[pos + 1]);\n   |                                \
    \ ^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    let mut letter_map = HashMap::new();\n    for letter in message.chars() {\n\
    \        let mut new_letter = letter;\n        for vowel in vowels {\n       \
    \     if letter == vowel {\n                new_letter += vowels_map.get(&vowel).unwrap();\n\
    \            }\n        }\n        letter_map.insert(new_letter, letter);\n  \
    \  }\n    for letter in message.chars() {\n        let mut new_letter = letter;\n\
    \        for vowel in vowels {\n            if letter == vowel {\n           \
    \     new_letter += vowels_map.get(&vowel).unwrap();\n            }\n        }\n\
    \        result += letter_map.get(&new_letter).unwrap();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp0cr7ls54.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0cr7ls54.rs:18:26\n\
    \   |\n18 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9epb9v_u.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[vowel_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9epb9v_u.rs:25:33\n   |\n25 |  \
    \               result.push_str(letters[letter_counter]);\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7ab45wdo.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counts = vec![];\n    let mut letters = vec!['A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_counts_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\
    \ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,\
    \ 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,\
    \ 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\
    \ 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letters_count\
    \ = vec![];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 9\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmptgmvwh1r.rs:21:1\n   |\n21 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmptgmvwh1r.rs:20:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n20 |     let mut letters_count_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n21\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaorrhswz.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[vowel_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpaorrhswz.rs:25:33\n   |\n25 |  \
    \               result.push_str(letters[letter_counter]);\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut letters_map = HashMap::new();\n    for letter in letters {\n    \
    \    letters_map.insert(letter, letter);\n    }\n    for letter in message.chars()\
    \ {\n        let mut new_letter = letter;\n        let mut new_vowel = vowels_map.get(&new_letter);\n\
    \        if let Some(vowel) = new_vowel {\n            new_letter = vowel;\n \
    \           new_vowel = vowels_map.get(&new_letter);\n        }\n        result.push(new_letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmppc_b5c8t.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmppc_b5c8t.rs:19:27\n\
    \   |\n19 |     let mut letters_map = HashMap::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_count =\
    \ vec![0];\n    let mut letter_count_index = vec![0];\n    let mut letter = String::new();\n\
    \    let mut letter_index = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_count_index = String::new();\n    let mut letter_count = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut letter_count = String::new();\n\
    \    let mut letter = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_index = String::new();\n    let mut letter_count_index = String::new();\n\
    \    let mut letter_count = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut letter_count = String::new();\n    let mut letter = String::new();\n\
    \    let mut letter_index = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_count_index = String::new();\n    let mut letter_count = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_index = String::new();\n    let mut letter_count = String::new();\n\
    \    let mut letter = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_index = String::new();\n    let mut letter_count_index = String::new();\n\
    \    let mut letter_count = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut vowels = String::new();\n    let mut vowels_index = String::new();\n\
    \    let mut letter_count = String::new();\n    let mut letter = String::new();\n\
    \    let mut letter_index = String::new();\n    let mut letter\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7vcnb_k4.rs:55:19\n   |\n\
    55 |     let mut letter\n   |                   ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7vcnb_k4.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message {\n        if letter == vowels[vowel_counter]\
    \ {\n            vowel_counter++;\n        } else {\n            result += letters[letter_counter];\n\
    \            letter_counter++;\n        }\n    }\n    result += letters[letter_counter];\n\
    \    vowel_counter = 0;\n    letter_counter = 0;\n    for letter in message {\n\
    \        if letter == vowels[vowel_counter] {\n            vowel_counter++;\n\
    \        } else {\n            result += letters[letter_counter];\n          \
    \  letter_counter++;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpv4g1qhfk.rs:19:26\n\
    \   |\n19 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             vowel_counter++;\n\
    19 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpv4g1qhfk.rs:22:27\n   |\n22 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n22 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             letter_counter++;\n22 +             letter_counter += 1;\n  \
    \ | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpv4g1qhfk.rs:30:26\n\
    \   |\n30 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -             vowel_counter++;\n\
    30 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpv4g1qhfk.rs:33:27\n   |\n33 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n33 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    33 -             letter_counter++;\n33 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpv4g1qhfk.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required be"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            vowels_map.insert(vowels.iter().position(|x| x == letter).unwrap(),\
    \ letter);\n        } else {\n            result.push(*letter);\n        }\n \
    \   }\n    for vowel in vowels {\n        let mut letter = vowels_map.get(&vowel).unwrap();\n\
    \        for _ in 0..2 {\n            result.push(letter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpq9lgeqc6.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpq9lgeqc6.rs:17:60\n   |\n17\
    \ |             vowels_map.insert(vowels.iter().position(|x| x == letter).unwrap(),\
    \ letter);\n   |                                                            ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpq9lgeqc6.rs:19:25\n\
    \   |\n19 |             result.push(*letter);\n   |                         ^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    let mut vowel_position = 0;\n    let mut letter_position\
    \ = 0;\n    let mut vowel_letter = String::new();\n    let mut letter_letter =\
    \ String::new();\n    let mut vowel_letter_position = String::new();\n    let\
    \ mut letter_letter_position = String::new();\n    let mut vowel_letter_letter\
    \ = String::new();\n    let mut letter_letter_letter = String::new();\n    let\
    \ mut vowel_letter_letter_position = String::new();\n    let mut letter_letter_letter_position\
    \ = String::new();\n    let mut vowel_letter_letter_letter = String::new();\n\
    \    let mut letter_letter_letter_letter = String::new();\n    let mut vowel_letter_letter_letter_position\
    \ = String::new();\n    let mut letter_letter_letter_letter_position = String::new();\n\
    \    let mut vowel_letter_letter_letter_letter = String::new();\n    let mut letter_letter_letter_letter_letter\
    \ = String::new();\n    let mut vowel_letter_letter_letter_letter_position = String::new();\n\
    \    let mut letter_letter_letter_letter_letter_position = String::new();\n  \
    \  let mut vowel_letter_letter_letter_letter_letter = String::new();\n    let\
    \ mut letter_letter_letter_letter_letter_letter = String::new();\n    let mut\
    \ vowel_letter_letter_letter_letter_letter_position = String::new();\n    let\
    \ mut letter_letter_letter_letter_letter_letter_position = String::new();\n  \
    \  let mut vowel_letter_letter_letter_letter_letter_letter = String::new();\n\
    \    let mut letter_letter_letter_letter_letter_letter_letter = String::new();\n\
    \    let mut vowel_letter_letter_letter_letter_letter_letter_position = String::new();\n\
    \    let mut letter_letter_letter_letter_letter_letter_letter_position = String::new();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeept1zau.rs:43:11\n   |\n\
    43 |     let mu\n   |           ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeept1zau.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut\
    \ vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg99khd8l.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpdbioqlmp.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, \n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpcu8d8cbk.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpcu8d8cbk.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo4w8ikat.rs:70:11\n   |\n\
    70 |     let mu\n   |           ^ help: add `;` here\n71 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4w8ikat.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut index\
    \ = 0;\n    for c in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&c)\
    \ {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n     \
    \       index = vowel;\n        } else {\n            result.push_str(&c);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppdbtg88p.rs:16:16\n   |\n\
    16 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppdbtg88p.rs:17:29\n   |\n17 |             result.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppdbtg88p.rs:20:29\n   |\n20 |             result.push_str(&c);\n   |\
    \                             ^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            letter_counter += 1;\n        } else {\n            vowel_counter\
    \ += 1;\n        }\n    }\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            if letter_counter == 2 {\n                result.push((letters[letter_counter\
    \ - 2] + letters[letter_counter - 1]).to_string());\n                letter_counter\
    \ -= 2;\n            } else {\n                result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter]).to_string());\n                letter_counter\
    \ -= 1;\n            }\n        } else {\n            if vowel_counter == 2 {\n\
    \                result.push((vowels[vowel_counter - 2] + vowels[vowel_counter\
    \ - 1]).to_string());\n                vowel_counter -= 2;\n            } else\
    \ {\n                result.push((vowels[vowel_counter - 1] + vowels[vowel_counter]).to_string());\n\
    \                vowel_counter -= 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpd2laggrj.rs:27:58\n\
    \   |\n27 |                 result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n   |                              ---------------------------\
    \ ^ --------------------------- char\n   |                              |\n  \
    \ |                              char\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpd2laggrj.rs:30:58\n   |\n30 |                 result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter]).to_string());\n   |                        \
    \      --------------------------- ^ ----------------------- char\n   |      \
    \                        |\n   |                              char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpd2laggrj.rs:35:56\n   |\n35 |   \
    \              result.push((vowels[vowel_counter - 2] + vowels[vowel_counter -\
    \ 1]).to_string());\n   |                              -------------------------\
    \ ^ ------------------------- char\n   |                              |\n   |\
    \                              char\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpd2laggrj.rs:38:56\n   |\n38 |                 result.push((vowels[vowel_counter\
    \ - 1] + vowels[vowel_counter]).to_string());\n   |                          \
    \    ------------------------- ^ --------------------- char\n   |            \
    \                  |\n   |                              char\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ c in message.chars() {\n        if let Some(index) = vowels.find(|x| x == c)\
    \ {\n            result.push_str(&letters[(index + 1) % letters.len()]);\n   \
    \     } else {\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpxbn6g8r2.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbn6g8r2.rs:19:29\n\
    \   |\n19 |             result.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  result.push_str(&letters[letter_counter]);\n            letter_counter += 1;\n\
    \        }\n        if vowel_counter < vowels.len() {\n            result.push_str(&vowels[vowel_counter]);\n\
    \            vowel_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpryhg3is3.rs:21:29\n   |\n\
    21 |             result.push_str(&letters[letter_counter]);\n   |            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpryhg3is3.rs:25:29\n   |\n25 |\
    \             result.push_str(&vowels[vowel_counter]);\n   |                 \
    \            ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\
    \ 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\
    \ 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,\
    \ 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162,\
    \ 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178,\
    \ 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\
    \ 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,\
    \ 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,\
    \ 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,\
    \ 24\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpiqhlezhl.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpiqhlezhl.rs:15:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n15 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n16 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut vowels_counter = 0;\n    let mut letters_counter = 0;\n  \
    \  let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut\
    \ letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5\
    \ = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n \
    \   let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut\
    \ letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12\
    \ = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let\
    \ mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19\
    \ = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let\
    \ mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26\
    \ = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n\
    \    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let\
    \ mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33\
    \ = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n\
    \    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let\
    \ mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40\
    \ = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n\
    \    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let\
    \ mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpombhgavw.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpxxng0vch.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter++;\n            } else {\n                result.push_str(letters[letter_counter]);\n\
    \                letter_counter++;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpg5an9dam.rs:23:30\n\
    \   |\n23 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n23 -\
    \                 vowel_counter++;\n23 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpg5an9dam.rs:26:31\n\
    \   |\n26 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    26 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    26 -                 letter_counter++;\n26 +                 letter_counter +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5an9dam.rs:22:33\n\
    \   |\n22 |                 result.push_str(vowels[vowel_counter]);\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg5an9dam.rs:25:33\n   |\n25 |\
    \                 result.push_str(letters[letter_counter]);\n   |            \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyb8uaps5.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyb8uaps5.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&letters[vowel + 2]);\n        } else {\n   \
    \         result.push_str(&letters[letter]);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw98t_nyq.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmpw98t_nyq.rs:20:30\n   |\n20 |   \
    \          result.push_str(&letters[letter]);\n   |                          \
    \    ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[char]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0];\n    let mut\
    \ consonants_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ consonants_count = vec![0];\n    let mut vowels_count_index = vec![0];\n   \
    \ let mut consonants_count_index = vec![0];\n    let mut vowels_count_index2 =\
    \ vec![0];\n    let mut consonants_count_index2 = vec![0];\n    let mut vowels_count_index3\
    \ = vec![0];\n    let mut consonants_count_index3 = vec![0];\n    let mut vowels_count_index4\
    \ = vec![0];\n    let mut consonants_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut consonants_count_index5 = vec![0];\n    let mut vowels_count_index6\
    \ = vec![0];\n    let mut consonants_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut consonants_count_index7 = vec![0];\n    let mut vowels_count_index8\
    \ = vec![0];\n    let mut consonants_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut consonants_count_index9 = vec![0];\n    let mut vowels_count_index10\
    \ = vec![0];\n    let mut consonants_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut consonants_count_index11 = vec![0];\n    let mut vowels_count_index12\
    \ = vec![0];\n    let mut consonants_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ycowhc_.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counts = vec![];\n    let mut letter_counts_index =\
    \ vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv7s7oheh.rs:58:11\n   |\n\
    58 |     let mu\n   |           ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv7s7oheh.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letter_map = {\n        'a' => 0,\n        'e' =>\
    \ 1,\n        'i' => 2,\n        'o' => 3,\n        'u' => 4,\n        'y' =>\
    \ 5,\n        'A' => 0,\n        'E' => 1,\n        'I' => 2,\n        'O' =>\
    \ 3,\n        'U' => 4,\n        'Y' => 5,\n    };\n    let mut i = 0;\n    for\
    \ c in message.chars() {\n        if let Some(letter) = letter_map.get(c) {\n\
    \            result.push_str(&vowels[letter]);\n            result.push_str(&vowels[letter\
    \ + 1]);\n        } else {\n            result.push_str(&vowels[c]);\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpithm839_.rs:15:13\n   |\n15 |         'a' => 0,\n   |         \
    \    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `char`\n  --> /tmp/tmpithm839_.rs:34:30\n  \
    \ |\n34 |             result.push_str(&vowels[c]);\n   |                     \
    \         ^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<str>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `Index<char>` for `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter_counter < 2 {\n                result.push_str(&letters[letter_counter]);\n\
    \                letter_counter += 1;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n                letter_counter = 0;\n  \
    \          }\n        }\n    }\n    if vowel_counter > 0 {\n        result.push_str(&vowels[vowel_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp856xgfe_.rs:22:33\n   |\n\
    22 |                 result.push_str(&letters[letter_counter]);\n   |        \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp856xgfe_.rs:25:33\n   |\n25 |\
    \                 result.push_str(&vowels[vowel_counter]);\n   |             \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp856xgfe_.rs:32:25\n   |\n32 |\
    \         result.push_str(&vowels[vowel_counter]);\n   |                     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n  \
    \  let mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut\
    \ letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7\
    \ = 0;\n    let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n \
    \   let mut letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let\
    \ mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14\
    \ = 0;\n    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n\
    \    let mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let\
    \ mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21\
    \ = 0;\n    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n\
    \    let mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let\
    \ mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28\
    \ = 0;\n    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n\
    \    let mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let\
    \ mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35\
    \ = 0;\n    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n\
    \    let mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let\
    \ mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42\
    \ = 0;\n    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n\
    \    let mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let\
    \ mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n    let mut letter_counter49\
    \ = 0;\n    let mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n\
    \    let mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n    let\
    \ mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n    let mut letter_counter56\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpa_vejvoo.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(index) = vowels.binary_search(&letter) {\n            result.push_str(&vowels_index[index]);\n\
    \        } else {\n            result.push_str(&letter);\n        }\n        letter_counter\
    \ += 1;\n        if letter_counter >= 2 {\n            vowels_index[vowels_index.len()\
    \ - 1] += 1;\n            vowels_index[vowels_index.len() - 1] -= 1;\n       \
    \     vowels_index[vowels_index.len() - 1] += 1;\n            vowels_index[vowels_index.len()\
    \ - 1] -= 1;\n            vowels_index[vowels_index.len() - 1] += 1;\n       \
    \     vowels_index[vowels_index.len() - 1] -= 1;\n            vowels_index[vowels_index.len()\
    \ - 1] += 1;\n            vowels_index[vowels_index.len() - 1] -= 1;\n       \
    \     vowels_index[vowels_index.len() - 1] += 1;\n            vowels_index[vowels_index.len()\
    \ - 1] -= 1;\n            vowels_index[vowels_index.len() - 1] += 1;\n       \
    \     vowels_index[vowels_index.len() - 1] -= 1;\n            vowels_index[vowels_index.len()\
    \ - 1] += 1;\n            vowels_index[vowels_index.len() - 1] -= 1;\n       \
    \     vowels_index[vowels_index.len() - 1] += 1;\n            vowels_index[vowels_index.len()\
    \ - 1] -= 1;\n            vowels_index[vowels_index.len() - 1] += 1;\n       \
    \     vowels_index[vowels_index.len() - 1] -= 1;\n            vowels_index[vowels_index.len()\
    \ - 1] += 1;\n            vowels_index[vowels_index.len() - 1] -= 1;\n       \
    \     vowels_index[vowels_index.len() - 1] += 1;\n            vowels_index[vowels_index.len()\
    \ - 1] -= 1;\n            vowels_index[vowels_index.len() - 1] += 1;\n       \
    \     vowels_index[vowels_index.len() - 1] -= 1;\n            vowels_index[vowels_index.len()\
    \ - 1] += 1;\n            vowels_index[vowels_index.len() - 1] -= 1;\n       \
    \     vowels_index[vowels_index.len() - 1] += 1;\n            vowels_index[vowels_index.len()\
    \ - 1] -= 1;\n            vowels_index[vowels_index.len() - 1] += 1;\n       \
    \     vowels_index[vowels_\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpexa0bui6.rs:63:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n23 |  \
    \       if letter_counter >= 2 {\n   |                                - this delimiter\
    \ might not be properly closed...\n...\n54 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n63 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpexa0bui6.rs:53:25\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n53 |             vowels_index[vowels_\n   |  \
    \                       ^ unclosed delimiter\n54 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `vowels_` in this scope\n  -->\
    \ /tmp/tmpexa0bui6.rs:53:26\n   |\n53 |             vowels_index[vowels_\n   |\
    \                          ^^^^^^^ help: a local variable with a similar name\
    \ exists: `vowels`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexa0bui6.rs:17:16\n\
    \   |\n17 |         if let Some(index) = vowels.binary_search(&letter) {\n   |\
    \                ^^^^^^^^^^^   ----------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpexa0bui6.rs:20:29\n   |\n20 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpexa0bui6.rs:16:5\n   |\n11 | \
    \  fn encode(message: String) -> String {\n   |                              \
    \   ------ expected `String` because of return type\n...\n16 | /     for letter\
    \ in message.chars() {\n17 | |         if let Some("
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letter_map = HashMap::new();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter_counts_iter =\
    \ letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_counts.iter();\n    let mut letter_counts_iter\
    \ = letter_counts.iter();\n    let mut letter_counts_iter = letter_counts.iter();\n\
    \    let mut letter_counts_iter = letter_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnij7olw4.rs:54:41\n   |\n\
    54 |     let mut letter_counts_iter = letter_\n   |                          \
    \               ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnij7olw4.rs:14:26\n\
    \   |\n14 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpnij7olw4.rs:15:29\n   |\n15\
    \ |     let mut letter_counts = HashMap::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot find\
    \ value `letter_` in this scope\n  --> /tmp/tmpnij7olw4.rs:54:34\n   |\n54 | \
    \    let mut letter_counts_iter = letter_\n   |                              \
    \    ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnij7olw4.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpl9087obw.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4k5v4x26.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut\
    \ letter_count = 1;\n    let mut letter_count_index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&vowels[vowels_index]);\n            vowels_index\
    \ += 1;\n        } else {\n            encoded.push_str(&letter);\n          \
    \  letter_count += 1;\n        }\n        if letter_count == 2 {\n           \
    \ letter_count_index += 1;\n            letter_count = 1;\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ukfulw1.rs:19:30\n   |\n\
    19 |             encoded.push_str(&vowels[vowels_index]);\n   |              \
    \                ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2ukfulw1.rs:22:30\n   |\n22 |  \
    \           encoded.push_str(&letter);\n   |                              ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n\
    \    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut\
    \ n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let\
    \ mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n   \
    \ let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n\
    \    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n\
    \    let mut h = 0;\n    let mut i = 0;\n    let mut j\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpioz8mt32.rs:44:14\n   |\n\
    44 |     let mut j\n   |              ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpioz8mt32.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letter_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|&x|\
    \ x == letter) {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   for letter in vowels.iter() {\n        letter_map.insert(letter, result.len()\
    \ - 1);\n    }\n    for letter in message.chars() {\n        if let Some(index)\
    \ = vowels.iter().position(|&x| x == letter) {\n            result.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n        } else {\n            result.push_str(&letter_map.get(&letter).unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9kkyni1l.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9kkyni1l.rs:17:29\n   |\n17 |             result.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9kkyni1l.rs:19:29\n   |\n19 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9kkyni1l.rs:27:29\n   |\n27 |\
    \             result.push_str(&vowels[(index + 1) % vowels.len()]);\n   |    \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n \
    \   let mut consonant_counter = 0;\n    for letter in message.chars() {\n    \
    \    if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            if vowels.contains(&letter) {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter = vowel_counter + 1;\n            } else {\n  \
    \              result.push_str(&consonants[consonant_counter]);\n            \
    \    consonant_counter = consonant_counter + 1;\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkdm6t7el.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkdm6t7el.rs:25:33\n   |\n25 |\
    \                 result.push_str(&consonants[consonant_counter]);\n   |     \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_idx = 0;\n    let mut letters_idx\
    \ = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push('_');\n\
    \        } else {\n            if letter == vowels[vowels_idx] {\n           \
    \     vowels_idx++;\n                result.push(letters[letters_idx]);\n    \
    \            letters_idx++;\n            } else {\n                if letter ==\
    \ vowels[vowels_idx2] {\n                    vowels_idx2++;\n                \
    \    result.push(letters[letters_idx2]);\n                    letters_idx2++;\n\
    \                } else {\n                    if letter == vowels[vowels_idx2]\
    \ {\n                        vowels_idx2++;\n                        result.push(letters[letters_idx2]);\n\
    \                        letters_idx2++;\n                    } else {\n     \
    \                   if letter == vowels[vowels_idx] {\n                      \
    \      vowels_idx++;\n                            result.push(letters[letters_idx]);\n\
    \                            letters_idx++;\n                        } else {\n\
    \                            if letter == vowels[vowels_idx2] {\n            \
    \                    vowels_idx2++;\n                                result.push(letters[letters_idx2]);\n\
    \                                letters_idx2++;\n                           \
    \ } else {\n                                if letter == vowels[vowels_idx2] {\n\
    \                                    vowels_idx2++;\n                        \
    \            result.push(letters[letters_idx2]);\n                           \
    \         letters_idx2++;\n                                } else {\n        \
    \                            if letter == vowels[vowels_idx] {\n             \
    \                           vowels_idx++;\n                                  \
    \      result.push(letters[letters_idx]);\n                                  \
    \      letters_idx++;\n                                    } else {\n        \
    \                                if letter == vowels[vowels_idx2] {\n        \
    \                                    vowels_idx2++;\n                        \
    \                    result.push(letters[letters_idx2]);\n                   \
    \                         letters_idx2++;\n                                  \
    \      } else {\n                                            if letter == vowels[vowels_idx2]\
    \ {\n                                                vowels_\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpi6j78xpn.rs:74:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n22 |  \
    \       } else {\n   |                - unclosed delimiter\n...\n27 |        \
    \     } else {\n   |                    - unclosed delimiter\n...\n32 |      \
    \           } else {\n   |                        - unclosed delimiter\n...\n\
    37 |                     } else {\n   |                            - unclosed\
    \ delimiter\n...\n42 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n47 |                             }\
    \ else {\n   |                                    - unclosed delimiter\n...\n\
    52 |                                 } else {\n   |                          \
    \              - unclosed delimiter\n...\n57 |                               \
    \      } else {\n   |                                            - unclosed delimiter\n\
    ...\n62 |                                         } else {\n   |             \
    \                                   - unclosed delimiter\n63 |               \
    \                              if letter == vowels[vowels_idx2] {\n   |      \
    \                                                                        - this\
    \ delimiter might not be properly closed...\n64 |                            \
    \                     vowels_\n65 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n74 | }\n   |   ^\n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpi6j78xpn.rs:24:27\n   |\n24 |                 vowels_idx++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n24 |                 { let tmp = vowels_idx; vowels_idx\
    \ += 1; tmp };\n   |                 +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    24 -                 vowels_idx++;\n24 +                 vowels_idx += 1;\n  \
    \ | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpi6"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpkxx5vhlx.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter = 0;\n    let\
    \ mut letters_counter = 0;\n    for c in message.chars() {\n        if letters_counter\
    \ < letters.len() {\n            if letters[letters_counter] == c {\n        \
    \        letters_counter += 1;\n            } else {\n                letters_counter\
    \ = 0;\n            }\n        }\n        if vowels_counter < vowels.len() {\n\
    \            if vowels[vowels_counter] == c {\n                vowels_counter\
    \ += 1;\n            } else {\n                vowels_counter = 0;\n         \
    \   }\n        }\n        if letters_counter > 0 {\n            result.push(c);\n\
    \        }\n        if vowels_counter > 0 {\n            result.push(c);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmp1is78wfb.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowel_counter\
    \ += 1;\n        }\n        if letter == 'A' || letter == 'E' || letter == 'I'\
    \ || letter == 'O' || letter == 'U' {\n            vowel_counter += 1;\n     \
    \   }\n        if letter == 'b' || letter == 'c' || letter == 'd' || letter ==\
    \ 'f' || letter == 'g' || letter == 'h' || letter == 'j' || letter == 'k' || letter\
    \ == 'l' || letter == 'm' || letter == 'n' || letter == 'p' || letter == 'q' ||\
    \ letter == 'r' || letter == 's' || letter == 't' || letter == 'u' || letter ==\
    \ 'v' || letter == 'w' || letter == 'x' || letter == 'y' || letter == 'z' {\n\
    \            consonant_counter += 1;\n        }\n        if letter == 'B' || letter\
    \ == 'C' || letter == 'D' || letter == 'F' || letter == 'G' || letter == 'H' ||\
    \ letter == 'J' || letter == 'K' || letter == 'L' || letter == 'M' || letter ==\
    \ 'N' || letter == 'P' || letter == 'Q' || letter == 'R' || letter == 'S' || letter\
    \ == 'T' || letter == 'U' || letter == 'V' || letter == 'W' || letter == 'X' ||\
    \ letter == 'Y' || letter == 'Z' {\n            consonant_counter += 1;\n    \
    \    }\n    }\n    for letter in message.chars() {\n        if letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n       \
    \     vowels[vowels.len() - 1] = vowels[vowels.len() - 1] + letter;\n        }\n\
    \        if letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' ||\
    \ letter == 'U' {\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfb7d4pow.rs:45:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n31 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n35 |  \
    \       if letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' ||\
    \ letter == 'U' {\n   |                                                      \
    \                                        - this delimiter might not be properly\
    \ closed...\n36 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n45 | }\n   |   ^\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpfb7d4pow.rs:33:65\n\
    \   |\n33 |             vowels[vowels.len() - 1] = vowels[vowels.len() - 1] +\
    \ letter;\n   |                                        ------------------------\
    \ ^ ------ char\n   |                                        |\n   |         \
    \                               char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfb7d4pow.rs:31:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n31 | /     for letter in message.chars() {\n32 | |       \
    \  if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n33 | |             vowels[vowels.len() - 1] = vowels[vowels.len()\
    \ - 1] + letter;\n34 | |         }\n...  |\n44 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    45 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpov6l99by.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov6l99by.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 =\
    \ 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n\
    \    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n \
    \   let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr311cwsj.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr311cwsj.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut consonant_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push('_');\n        } else {\n            if letter\
    \ == 'a' || letter == 'A' {\n                result.push('A');\n             \
    \   letter_counter++;\n            } else if letter == 'b' || letter == 'B' {\n\
    \                result.push('B');\n                letter_counter++;\n      \
    \      } else if letter == 'c' || letter == 'C' {\n                result.push('C');\n\
    \                letter_counter++;\n            } else if letter == 'd' || letter\
    \ == 'D' {\n                result.push('D');\n                letter_counter++;\n\
    \            } else if letter == 'e' || letter == 'E' {\n                result.push('E');\n\
    \                letter_counter++;\n            } else if letter == 'f' || letter\
    \ == 'F' {\n                result.push('F');\n                letter_counter++;\n\
    \            } else if letter == 'g' || letter == 'G' {\n                result.push('G');\n\
    \                letter_counter++;\n            } else if letter == 'h' || letter\
    \ == 'H' {\n                result.push('H');\n                letter_counter++;\n\
    \            } else if letter == 'i' || letter == 'I' {\n                result.push('I');\n\
    \                letter_counter++;\n            } else if letter == 'j' || letter\
    \ == 'J' {\n                result.push('J');\n                letter_counter++;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpim_pvt6y.rs:62:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n22 |  \
    \       } else {\n   |                - unclosed delimiter\n...\n50 |        \
    \     } else if letter == 'j' || letter == 'J' {\n   |                       \
    \                               - this delimiter might not be properly closed...\n\
    ...\n53 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    62 | }\n   |   ^\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpim_pvt6y.rs:25:31\n\
    \   |\n25 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    25 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -                 letter_counter++;\n25 +                 letter_counter +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpim_pvt6y.rs:28:31\n\
    \   |\n28 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    28 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    28 -                 letter_counter++;\n28 +                 letter_counter +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpim_pvt6y.rs:31:31\n\
    \   |\n31 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    31 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    31 -                 letter_counter++;\n31 +                 letter_counter +=\
    \ 1;\n   | \n\nerror: Rust has no postfi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            let mut found = false;\n            for vowel in vowels.iter() {\n\
    \                if letter == vowel {\n                    found = true;\n   \
    \                 result.push_str(&vowels[vowels.iter().position(|x| x == letter).unwrap()\
    \ + 1]);\n                }\n            }\n            if !found {\n        \
    \        result.push_str(&letters[letters.iter().position(|x| x == letter).unwrap()\
    \ + 1]);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiyrsd0d8.rs:21:30\n   |\n\
    21 |                 if letter == vowel {\n   |                              ^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |                 if letter == *vowel {\n   |                      \
    \        +\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiyrsd0d8.rs:23:74\n\
    \   |\n23 |                     result.push_str(&vowels[vowels.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n   |                                         \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiyrsd0d8.rs:23:37\n   |\n23 |                     result.push_str(&vowels[vowels.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmpiyrsd0d8.rs:27:72\n   |\n27 |                 result.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n   |                                         \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiyrsd0d8.rs:27:33\n   |\n27 |                 result.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E02"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letter_pairs = vec!['AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AE\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpzo1yso8_.rs:14:33\n\
    \   |\n14 |     let mut letter_pairs = vec!['AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU...\n \
    \  |                                 ^^^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n14 |     let mut letter_pairs = vec![\"\
    AEIOU\", 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AE\n   |                                 ~~~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmpzo1yso8_.rs:14:42\n\
    \   |\n14 |     let mut letter_pairs = vec!['AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU...\n \
    \  |                                          ^^^^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n14 |     let mut letter_pairs\
    \ = vec!['AEIOU', \"AEIOU\", 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU',\
    \ 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEIOU', 'AEI"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            letter_counter += 1;\n        }\n        if vowels.contains(&c)\
    \ {\n            vowel_counter += 1;\n        }\n    }\n    for c in message.chars()\
    \ {\n        if letters.contains(&c) {\n            if letter_counter == 2 {\n\
    \                result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n                letter_counter -= 1;\n            } else\
    \ {\n                result.push((letters[letter_counter - 1]).to_string());\n\
    \                letter_counter -= 1;\n            }\n        }\n        if vowels.contains(&c)\
    \ {\n            if vowel_counter == 2 {\n                result.push((vowels[vowel_counter\
    \ - 2] + vowels[vowel_counter - 1]).to_string());\n                vowel_counter\
    \ -= 1;\n            } else {\n                result.push((vowels[vowel_counter\
    \ - 1]).to_string());\n                vowel_counter -= 1;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp8bun7j3k.rs:28:58\n\
    \   |\n28 |                 result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n   |                              ---------------------------\
    \ ^ --------------------------- char\n   |                              |\n  \
    \ |                              char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8bun7j3k.rs:31:29\n   |\n31 |                 result.push((letters[letter_counter\
    \ - 1]).to_string());\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0369]: cannot add `char` to\
    \ `char`\n  --> /tmp/tmp8bun7j3k.rs:37:56\n   |\n37 |                 result.push((vowels[vowel_counter\
    \ - 2] + vowels[vowel_counter - 1]).to_string());\n   |                      \
    \        ------------------------- ^ ------------------------- char\n   |    \
    \                          |\n   |                              char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8bun7j3k.rs:40:29\n   |\n40 |              \
    \   result.push((vowels[vowel_counter - 1]).to_string());\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            if letter_counter < 2 {\n                result.push((vowels[vowel_counter]\
    \ + vowels[vowel_counter + 1]).to_string());\n                vowel_counter +=\
    \ 2;\n            } else {\n                result.push((vowels[vowel_counter]\
    \ + vowels[vowel_counter - 1]).to_string());\n                vowel_counter -=\
    \ 2;\n            }\n        } else {\n            result.push((alphabet[letter_counter]).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpqe4md5dn.rs:20:52\n\
    \   |\n20 |                 result.push((vowels[vowel_counter] + vowels[vowel_counter\
    \ + 1]).to_string());\n   |                              ---------------------\
    \ ^ ------------------------- char\n   |                              |\n   |\
    \                              char\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpqe4md5dn.rs:23:52\n   |\n23 |                 result.push((vowels[vowel_counter]\
    \ + vowels[vowel_counter - 1]).to_string());\n   |                           \
    \   --------------------- ^ ------------------------- char\n   |             \
    \                 |\n   |                              char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqe4md5dn.rs:27:25\n   |\n27 |             result.push((alphabet[letter_counter]).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n\
    \    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut index = 0;\n    let mut\
    \ index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5\
    \ = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 =\
    \ 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 =\
    \ 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14\
    \ = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17\
    \ = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20\
    \ = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23\
    \ = 0;\n    let mut index24 = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdm1nwv_q.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 =\
    \ 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n\
    \    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n \
    \   let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgyebxki6.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgyebxki6.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter++;\n            } else {\n                if letter_counter\
    \ < 2 {\n                    result.push_str(letters[letter_counter]);\n     \
    \               letter_counter++;\n                } else {\n                \
    \    result.push_str(vowels[vowel_counter]);\n                    vowel_counter++;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp32b3h54m.rs:23:30\n\
    \   |\n23 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n23 -\
    \                 vowel_counter++;\n23 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp32b3h54m.rs:27:35\n\
    \   |\n27 |                     letter_counter++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n27 |                     { let tmp = letter_counter; letter_counter +=\
    \ 1; tmp };\n   |                     +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    27 -                     letter_counter++;\n27 +                     letter_counter\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp32b3h54m.rs:30:34\n\
    \   |\n30 |                     vowel_counter++;\n   |                       \
    \           ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n30 |                     { let tmp = vowel_counter; vowel_counter += 1;\
    \ tmp };\n   |                     +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    30 -                     vowel_counter++;\n30 +                     vowel_counter\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp32b3h54m.rs:22:33\n\
    \   |\n22 |                 result.push_str(vowels[vowel_counter]);\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp32b3h54m.rs:26:37\n   |\n26 |\
    \                     result.push_str(letters[letter_counter]);\n   |        \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp32b3h54m.rs:29:37\n   |\n29 |\
    \                     result.push_str(vowels[vowel_counter]);\n   |          \
    \                        "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n            result.push_str(&vowels[vowel_counter]);\n\
    \            vowel_counter += 1;\n        } else {\n            result.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpud6c_brj.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpud6c_brj.rs:19:29\n   |\n19 |             result.push_str(&vowels[vowel_counter]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud6c_brj.rs:22:29\n\
    \   |\n22 |             result.push_str(&letters[letter_counter]);\n   |     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\
    \ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\
    \ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\
    \ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\
    \ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\
    \ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\
    \ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\
    \ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\
    \ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\
    \ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,\
    \ 256, 257, 258, 259, 260, 261, 262, 263, 264, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp3in_b3w7.rs:15:1\n   |\n15 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp3in_b3w7.rs:14:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n14 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n15 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_map = HashMap::new();\n    let mut letter_counter =\
    \ HashMap::new();\n    for letter in message.chars() {\n        letter_map.insert(letter,\
    \ 0);\n        letter_counter.insert(letter, 0);\n    }\n    for letter in vowels.iter()\
    \ {\n        letter_map.insert(letter, 0);\n    }\n    for letter in message.chars()\
    \ {\n        letter_map.insert(letter, 0);\n    }\n    for letter in vowels.iter()\
    \ {\n        letter_counter.insert(letter, 0);\n    }\n    for letter in message.chars()\
    \ {\n        letter_counter.insert(letter, 0);\n    }\n    for letter in message.chars()\
    \ {\n        if letter_map.contains_key(&letter) {\n            letter_map.insert(letter,\
    \ letter_map.get(&letter) + 1);\n        }\n    }\n    for letter in vowels.iter()\
    \ {\n        if letter_counter.contains_key(&letter) {\n            letter_counter.insert(letter,\
    \ letter_counter.get(&letter) + 1);\n        }\n    }\n    for letter in message.chars()\
    \ {\n        if letter_map.contains_key(&letter) {\n            let letter_count\
    \ = letter_map.get(&letter);\n            let letter_count_index = letter_counter.get(&letter);\n\
    \            if letter_count_index == letter_count {\n                let mut\
    \ new_letter = letter;\n                for index in vowels_index.iter() {\n \
    \                   new_letter = if index == letter_count_index {\n          \
    \              vowels[letter_count_index]\n                    } else {\n    \
    \                    new_letter\n                    };\n                }\n \
    \               result += new_letter;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpulck5mtd.rs:15:26\n   |\n15 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpulck5mtd.rs:16:30\n\
    \   |\n16 |     let mut letter_counter = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpulck5mtd.rs:56:27\n   |\n56 |              \
    \   result += new_letter;\n   |                           ^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter_counter < 2 {\n                result.push_str(&letters[letter_counter]);\n\
    \                letter_counter += 1;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            }\n        }\n    }\n    if\
    \ vowel_counter > 0 {\n        result.push_str(&vowels[vowel_counter]);\n    }\n\
    \    if letter_counter > 0 {\n        result.push_str(&letters[letter_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpad__mts_.rs:22:33\n   |\n\
    22 |                 result.push_str(&letters[letter_counter]);\n   |        \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpad__mts_.rs:25:33\n   |\n25 |\
    \                 result.push_str(&vowels[vowel_counter]);\n   |             \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpad__mts_.rs:31:25\n   |\n31 |\
    \         result.push_str(&vowels[vowel_counter]);\n   |                     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpad__mts_.rs:34:25\n   |\n34 |         result.push_str(&letters[letter_counter]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut consonant_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut vowel_counter3 = 0;\n  \
    \  let mut consonant_counter3 = 0;\n    let mut letter_counter3 = 0;\n    let\
    \ mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut vowel_counter5 = 0;\n    let mut consonant_counter5 = 0;\n\
    \    let mut letter_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut\
    \ consonant_counter6 = 0;\n    let mut letter_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut consonant_counter7 = 0;\n    let mut letter_counter7 = 0;\n\
    \    let mut vowel_counter8 = 0;\n    let mut consonant_counter8 = 0;\n    let\
    \ mut letter_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut vowel_counter10 = 0;\n \
    \   let mut consonant_counter10 = 0;\n    let mut letter_counter10 = 0;\n    let\
    \ mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let mut\
    \ letter_counter11 = 0;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp158nnwze.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            vowel_counter += 1;\n    \
    \    } else {\n            letter_counter += 1;\n        }\n    }\n    for letter\
    \ in message.chars() {\n        if vowels.contains(&letter) {\n            result.push((vowels[vowel_counter]\
    \ + alphabet[letter_counter]).to_string());\n        } else {\n            result.push(letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpndw1h24d.rs:26:48\n\
    \   |\n26 |             result.push((vowels[vowel_counter] + alphabet[letter_counter]).to_string());\n\
    \   |                          --------------------- ^ ------------------------\
    \ char\n   |                          |\n   |                          char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp85a6z6zh.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index4 = vec![0, 1, 2, 3, 4];\n \
    \   let mut vowels_index5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index6 =\
    \ vec![0, 1, 2, 3, 4];\n    let mut vowels_index7 = vec![0, 1, 2, 3, 4];\n   \
    \ let mut vowels_index8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps17ll1zv.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps17ll1zv.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n            if vowel_counter < 2 {\n         \
    \       result.push((letters[vowel_counter] + letters[vowel_counter + 1]).to_string());\n\
    \                vowel_counter += 2;\n            } else {\n                result.push((letters[vowel_counter]\
    \ + letters[vowel_counter + 1]).to_string());\n                vowel_counter +=\
    \ 2;\n                result.push((letters[vowel_counter] + letters[vowel_counter\
    \ + 1]).to_string());\n                vowel_counter += 2;\n            }\n  \
    \      } else {\n            if letter_counter < 2 {\n                result.push((letters[letter_counter]\
    \ + letters[letter_counter + 1]).to_string());\n                letter_counter\
    \ += 2;\n            } else {\n                result.push((letters[letter_counter]\
    \ + letters[letter_counter + 1]).to_string());\n                letter_counter\
    \ += 2;\n                result.push((letters[letter_counter] + letters[letter_counter\
    \ + 1]).to_string());\n                letter_counter += 2;\n            }\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeeqamhrd.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpeeqamhrd.rs:20:53\n   |\n20 |                 result.push((letters[vowel_counter]\
    \ + letters[vowel_counter + 1]).to_string());\n   |                          \
    \    ---------------------- ^ -------------------------- char\n   |          \
    \                    |\n   |                              char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpeeqamhrd.rs:23:53\n   |\n23 |   \
    \              result.push((letters[vowel_counter] + letters[vowel_counter + 1]).to_string());\n\
    \   |                              ---------------------- ^ --------------------------\
    \ char\n   |                              |\n   |                            \
    \  char\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpeeqamhrd.rs:25:53\n\
    \   |\n25 |                 result.push((letters[vowel_counter] + letters[vowel_counter\
    \ + 1]).to_string());\n   |                              ----------------------\
    \ ^ -------------------------- char\n   |                              |\n   |\
    \                              char\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpeeqamhrd.rs:30:54\n   |\n30 |                 result.push((letters[letter_counter]\
    \ + letters[letter_counter + 1]).to_string());\n   |                         \
    \     ----------------------- ^ --------------------------- char\n   |       \
    \                       |\n   |                              char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpeeqamhrd.rs:33:54\n   |\n33 |   \
    \              result.push((letters[letter_counter] + letters[letter_counter +\
    \ 1]).to_string());\n   |                              -----------------------\
    \ ^ -"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 9\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpgfue32e0.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpgfue32e0.rs:17:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n            vowel_counter += 1;\n            if\
    \ vowel_counter == 2 && letter != c {\n                result.push(c);\n     \
    \       }\n        } else {\n            letter_counter += 1;\n            if\
    \ letter_counter == 2 && letter != c {\n                result.push(c);\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `letter` in this scope\n  --> /tmp/tmp7bwqep7g.rs:20:38\n\
    \   |\n20 |             if vowel_counter == 2 && letter != c {\n   |         \
    \                             ^^^^^^ help: a local variable with a similar name\
    \ exists: `letters`\n\nerror[E0425]: cannot find value `letter` in this scope\n\
    \  --> /tmp/tmp7bwqep7g.rs:25:39\n   |\n25 |             if letter_counter ==\
    \ 2 && letter != c {\n   |                                       ^^^^^^ help:\
    \ a local variable with a similar name exists: `letters`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7bwqep7g.rs:18:16\n   |\n18 |         if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n   |                ^^^^^^^^^^^   ------------------------\
    \ this expression has type `Result<usize, usize>`\n   |                |\n   |\
    \                expected enum `Result`, found enum `Option`\n   |\n   = note:\
    \ expected enum `Result<usize, usize>`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut count\
    \ = 1;\n    let mut letter = String::new();\n    let mut vowel = String::new();\n\
    \    for letter in message {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if letter in letters {\n               \
    \ result.push_str(&vowels[(index - count) % vowels.len()]);\n            } else\
    \ {\n                result.push_str(&letters[(index - count) % letters.len()]);\n\
    \            }\n            count++;\n        }\n        index++;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpr25a0qsg.rs:23:23\n\
    \   |\n23 |             if letter in letters {\n   |             --        ^^\
    \ expected `{`\n   |             |\n   |             this `if` expression has\
    \ a condition, but no block\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpr25a0qsg.rs:30:14\n   |\n30 |         index++;\n   |          \
    \    ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30\
    \ |         { let tmp = index; index += 1; tmp };\n   |         +++++++++++  \
    \    ~~~~~~~~~~~~~~~~~~~\n30 -         index++;\n30 +         index += 1;\n  \
    \ | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpr25a0qsg.rs:19:19\n\
    \   |\n19 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message {\n        if letter == '\
    \ ' {\n            result.push_str(\" \");\n        } else {\n            if letter\
    \ in vowels {\n                vowel_counter += 1;\n                if vowel_counter\
    \ == 2 {\n                    result.push_str(&letters[letter_counter]);\n   \
    \                 letter_counter += 1;\n                }\n            } else\
    \ {\n                letter_counter += 1;\n            }\n            result.push_str(&letters[letter_counter]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp7l6y6d4i.rs:21:23\n\
    \   |\n21 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp7l6y6d4i.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            vowel_counter\
    \ += 2;\n        }\n        result.push(c);\n    }\n    for _ in 0..vowel_counter\
    \ {\n        result.push(*vowels.iter().next().unwrap());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TESTAA\"`,\n right: `\"tgst\"`', /tmp/tmp4n99ysay.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let\
    \ mut i = 0;\n    while i < message.len() {\n        let mut j = i;\n        while\
    \ j < message.len() {\n            let mut k = j;\n            while k < message.len()\
    \ {\n                if message[j] == vowels[k.wrapping_sub(vowels.len())] {\n\
    \                    result.push((letters[k.wrapping_sub(vowels.len())] as char));\n\
    \                    break;\n                }\n                k += 1;\n    \
    \        }\n            j += 1;\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpxge0rne9.rs:22:33\n\
    \   |\n22 |                     result.push((letters[k.wrapping_sub(vowels.len())]\
    \ as char));\n   |                                 ^                         \
    \                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n22 -                     result.push((letters[k.wrapping_sub(vowels.len())]\
    \ as char));\n22 +                     result.push(letters[k.wrapping_sub(vowels.len())]\
    \ as char);\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxge0rne9.rs:21:20\n   |\n21 |                 if message[j] ==\
    \ vowels[k.wrapping_sub(vowels.len())] {\n   |                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpxge0rne9.rs:21:34\n   |\n21 |                 if message[j] == vowels[k.wrapping_sub(vowels.len())]\
    \ {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpxge0rne9.rs:22:34\n   |\n22 |                     result.push((letters[k.wrapping_sub(vowels.len())]\
    \ as char));\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < message.len() {\n        if message[i] == ' ' {\n            result.push_str(&message[i..]);\n\
    \            break;\n        }\n        if message[i] in vowels {\n          \
    \  result.push_str(&letters[(j + message[i] - 'A') % 26]);\n            i += 1;\n\
    \            j += 1;\n        } else {\n            result.push_str(&letters[(j\
    \ + message[i] - 'a') % 26]);\n            i += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpqbdmt2r8.rs:22:23\n\
    \   |\n22 |         if message[i] in vowels {\n   |         --            ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpqbdmt2r8.rs:18:12\n   |\n18 |         if message[i] == ' ' {\n \
    \  |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n            continue;\n     \
    \   }\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter ==\
    \ 'o' || letter == 'u' {\n            result.push_str(&vowels[vowel_counter]);\n\
    \            vowel_counter = vowel_counter + 1;\n            continue;\n     \
    \   }\n        if letter == 'A' || letter == 'E' || letter == 'I' || letter ==\
    \ 'O' || letter == 'U' {\n            result.push_str(&vowels[vowel_counter]);\n\
    \            vowel_counter = vowel_counter + 1;\n            continue;\n     \
    \   }\n        if letter == 'b' || letter == 'c' || letter == 'd' || letter ==\
    \ 'f' || letter == 'g' || letter == 'h' || letter == 'j' || letter == 'k' || letter\
    \ == 'l' || letter == 'm' || letter == 'n' || letter == 'p' || letter == 'q' ||\
    \ letter == 'r' || letter == 's' || letter == 't' || letter == 'u' || letter ==\
    \ 'v' || letter == 'w' || letter == 'x' || letter == 'y' || letter == 'z' {\n\
    \            result.push_str(&letters[letter_counter]);\n            letter_counter\
    \ = letter_counter + 1;\n            continue;\n        }\n        result.push_str(&letters[letter_counter]);\n\
    \        letter_counter = letter_counter + 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4sxetctb.rs:23:29\n   |\n\
    23 |             result.push_str(&vowels[vowel_counter]);\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4sxetctb.rs:28:29\n   |\n28 |  \
    \           result.push_str(&vowels[vowel_counter]);\n   |                   \
    \          ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4sxetctb.rs:33:29\n   |\n33 |             result.push_str(&letters[letter_counter]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4sxetctb.rs:37:25\n\
    \   |\n37 |         result.push_str(&letters[letter_counter]);\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == vowels[vowels_index] {\n                result.push_str(vowels[vowels_index]);\n\
    \                vowels_index += 1;\n            } else {\n                result.push_str(letters[letters_index]);\n\
    \                letters_index += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp72rj6tdy.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[vowels_index]);\n   |            \
    \                     ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp72rj6tdy.rs:25:33\n   |\n25 |              \
    \   result.push_str(letters[letters_index]);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ letter in message.chars() {\n        if let Some(index) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&alphabet[index % alphabet.len()]);\n       \
    \ } else {\n            result.push_str(&letter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `binary_search` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp80rbw9im.rs:16:37\n   |\n16 |         if\
    \ let Some(index) = vowels.binary_search(&letter) {\n   |                    \
    \                 ^^^^^^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp80rbw9im.rs:19:29\n   |\n19 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter_counter < 2 {\n                result.push_str(&letters[letter_counter]);\n\
    \                letter_counter += 1;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            }\n        }\n    }\n    if\
    \ vowel_counter > 0 {\n        result.push_str(&vowels[vowel_counter]);\n    }\n\
    \    if letter_counter > 0 {\n        result.push_str(&letters[letter_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpivddfra5.rs:22:33\n   |\n\
    22 |                 result.push_str(&letters[letter_counter]);\n   |        \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpivddfra5.rs:25:33\n   |\n25 |\
    \                 result.push_str(&vowels[vowel_counter]);\n   |             \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpivddfra5.rs:31:25\n   |\n31 |\
    \         result.push_str(&vowels[vowel_counter]);\n   |                     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpivddfra5.rs:34:25\n   |\n34 |         result.push_str(&letters[letter_counter]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letters_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpy3mhm494.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpy3mhm494.rs:19:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut letters_index_3 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n20 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == c) {\n            result.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 2;\n            vowel_counter += 1;\n        }\
    \ else {\n            result.push_str(&letters[letter_counter]);\n           \
    \ letter_counter += 1;\n        }\n    }\n    if vowel_counter > 0 {\n       \
    \ result.push_str(&vowels[vowel_counter]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_ibno8r.rs:19:29\n   |\n\
    19 |             result.push_str(&letters[letter_counter]);\n   |            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2_ibno8r.rs:23:29\n   |\n23 |\
    \             result.push_str(&letters[letter_counter]);\n   |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2_ibno8r.rs:28:25\n   |\n28 |  \
    \       result.push_str(&vowels[vowel_counter]);\n   |                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map\
    \ = HashMap::new();\n    for vowel in vowels {\n        vowels_map.insert(vowel,\
    \ vowel);\n    }\n    let mut current_letter = String::new();\n    for letter\
    \ in message {\n        if let Some(vowel) = vowels_map.get(&letter) {\n     \
    \       result.push((vowels[vowels.iter().position(|x| *x == letter).unwrap()\
    \ + 1]).to_string());\n        } else {\n            result.push(letter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk0s21570.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpk0s21570.rs:19:19\n   |\n19 |   \
    \  for letter in message {\n   |                   ^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk0s21570.rs:21:25\n   |\n21 |             result.push((vowels[vowels.iter().position(|x|\
    \ *x == letter).unwrap() + 1]).to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_idx = 0;\n    let mut letters_idx\
    \ = 0;\n    let mut vowels_idx2 = 1;\n    let mut letters_idx2 = 1;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if letter == vowels[vowels_idx] {\n    \
    \            result.push_str(vowels[vowels_idx2]);\n                vowels_idx2\
    \ = vowels_idx2;\n            } else {\n                result.push_str(letters[letters_idx]);\n\
    \                letters_idx2 = letters_idx2;\n            }\n            vowels_idx2\
    \ = vowels_idx2;\n            letters_idx2 = letters_idx2;\n            vowels_idx2\
    \ = vowels_idx2 + 1;\n            letters_idx2 = letters_idx2 + 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzd9ow32f.rs:24:33\n   |\n\
    24 |                 result.push_str(vowels[vowels_idx2]);\n   |             \
    \                    ^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzd9ow32f.rs:27:33\n   |\n27 |              \
    \   result.push_str(letters[letters_idx]);\n   |                             \
    \    ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            vowel_counter\
    \ = vowel_counter + 1;\n        }\n        if vowel_counter == 2 {\n         \
    \   result.push((&vowels[vowel_counter - 2] + &vowels[vowel_counter - 1]).to_string());\n\
    \            vowel_counter = 0;\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmp50pkpdcn.rs:20:53\n\
    \   |\n20 |             result.push((&vowels[vowel_counter - 2] + &vowels[vowel_counter\
    \ - 1]).to_string());\n   |                          --------------------------\
    \ ^ -------------------------- &char\n   |                          |\n   |  \
    \                        &char\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&c) {\n            vowel_counter += 1;\n            result.push((vowel\
    \ - vowel_counter) % 26 + 'A');\n        } else {\n            letter_counter\
    \ += 1;\n            result.push((letters.binary_search(&c) - letter_counter)\
    \ % 26 + 'A');\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_iste1j.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Result<usize, usize>`\n  --> /tmp/tmpc_iste1j.rs:23:52\n   |\n23 |   \
    \          result.push((letters.binary_search(&c) - letter_counter) % 26 + 'A');\n\
    \   |                          ------------------------- ^ -------------- {integer}\n\
    \   |                          |\n   |                          Result<usize,\
    \ usize>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    for letter in message {\n        if letter == '\
    \ ' {\n            result.push_str(\" \");\n        } else {\n            if letter\
    \ == vowels[vowels_index] {\n                result.push_str(vowels[vowels_index]);\n\
    \                vowels_index += 1;\n            } else {\n                result.push_str(letters[letters_index]);\n\
    \                letters_index += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmf4wuh6n.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmf4wuh6n.rs:22:33\n   |\n22 |              \
    \   result.push_str(vowels[vowels_index]);\n   |                             \
    \    ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmf4wuh6n.rs:25:33\n   |\n25 |                 result.push_str(letters[letters_index]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,\
    \ 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\
    \ 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\
    \ 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n \
    \   let mut consonants_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\
    \ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\
    \ 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\
    \ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\
    \ 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 5\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmptav2va6f.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmptav2va6f.rs:17:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptav2va6f.rs:16:427\n\
    \   |\n16 | ..., 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',...\n \
    \  |                                                      ^^^ expected integer,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut letters = vec!['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n\
    \    let mut index = 0;\n    let mut count = 1;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&c) {\n            result.push_str(&letters[vowel]);\n\
    \            count += 1;\n        } else {\n            result.push_str(&letters[(index+count)\
    \ % letters.len()]);\n            count += 1;\n        }\n        index += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vkogf35.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3vkogf35.rs:22:29\n   |\n22 |             result.push_str(&letters[(index+count)\
    \ % letters.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut alphabet = vec!['A', 'E', 'I',\
    \ 'O', 'U'];\n    let mut i = 0;\n    while i < message.len() {\n        if let\
    \ Some(letter) = message.chars().nth(i) {\n            if let Some(vowel) = vowels.iter().nth(i\
    \ + 1) {\n                result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap() + 1).unwrap()).unwrap());\n                i += 2;\n\
    \            } else {\n                result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap()));\n                i += 1;\n            }\n\
    \        } else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp3s10mvu2.rs:22:29\n\
    \   |\n22 |                 result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap()));\n   |                             ^    \
    \                                                                            \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n22 -                 result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap()));\n22 +                 result.push(alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap());\n   | \n\nerror[E0599]: no method named `unwrap`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp3s10mvu2.rs:19:117\n\
    \   |\n19 |                 result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap() + 1).unwrap()).unwrap());\n   |                     \
    \                                                                            \
    \                    ^^^^^^ method not found in `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3s10mvu2.rs:22:29\n   |\n22 |                 result.push((alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap()));\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |                 result.push(*(alphabet.iter().nth(alphabet.iter().position(|x|\
    \ *x == letter).unwrap()).unwrap()));\n   |                             +\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n\
    \    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmps4y8d6qf.rs:19:1\n   |\n19 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmps4y8d6qf.rs:18:33\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n18 |     let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, \n   |           \
    \                      ^ unclosed delimiter\n19 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if vowels.contains(&letter) {\n                vowel_counter += 1;\n      \
    \          if vowel_counter == 2 && letters.contains(&(letter + letters[letter_counter\
    \ + 1])) {\n                    result.push_str(&letters[letter_counter + 1]);\n\
    \                } else {\n                    result.push_str(&letters[letter_counter]);\n\
    \                }\n            } else {\n                letter_counter += 1;\n\
    \                if letter_counter == 2 && letters.contains(&(letter + letters[letter_counter\
    \ - 1])) {\n                    result.push_str(&letters[letter_counter - 1]);\n\
    \                } else {\n                    result.push_str(&letters[letter_counter]);\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmprop9h7dn.rs:23:68\n\
    \   |\n23 |                 if vowel_counter == 2 && letters.contains(&(letter\
    \ + letters[letter_counter + 1])) {\n   |                                    \
    \                         ------ ^ --------------------------- char\n   |    \
    \                                                         |\n   |            \
    \                                                 char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprop9h7dn.rs:24:37\n   |\n24 |                     result.push_str(&letters[letter_counter\
    \ + 1]);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprop9h7dn.rs:26:37\n   |\n26 |                     result.push_str(&letters[letter_counter]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmprop9h7dn.rs:30:69\n\
    \   |\n30 |                 if letter_counter == 2 && letters.contains(&(letter\
    \ + letters[letter_counter - 1])) {\n   |                                    \
    \                          ------ ^ --------------------------- char\n   |   \
    \                                                           |\n   |          \
    \                                                    char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprop9h7dn.rs:31:37\n   |\n31 |                     result.push_str(&letters[letter_counter\
    \ - 1]);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprop9h7dn.rs:33:37\n   |\n33 |                     result.push_str(&letters[letter_counter]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter_counter < 2 {\n                result.push_str(&vowels[vowels_index]);\n\
    \            } else {\n                result.push_str(&vowels[vowels_index +\
    \ 1]);\n            }\n            result.push_str(&letter);\n            letter_counter\
    \ += 1;\n        }\n        vowels_index += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r7eglhx.rs:21:33\n   |\n\
    21 |                 result.push_str(&vowels[vowels_index]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7r7eglhx.rs:23:33\n   |\n23 |\
    \                 result.push_str(&vowels[vowels_index + 1]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7r7eglhx.rs:25:29\n   |\n25 |\
    \             result.push_str(&letter);\n   |                             ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut current_letter\
    \ = 0;\n    let mut current_vowel = 0;\n    for c in message.chars() {\n     \
    \   if let Some(letter) = letters.iter().position(|x| x == c) {\n            index\
    \ = letter;\n            current_letter = c;\n        } else {\n            index\
    \ = letters.len() - 1;\n            current_letter = c;\n        }\n        if\
    \ let Some(vowel) = vowels.iter().position(|x| x == c) {\n            current_vowel\
    \ = vowel;\n        } else {\n            current_vowel = vowels.len() - 1;\n\
    \        }\n        if index == current_vowel {\n            result.push(c);\n\
    \        } else {\n            result.push(letters[current_letter]);\n       \
    \     result.push(letters[current_vowel]);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_fvfbxy5.rs:19:61\n\
    \   |\n19 |         if let Some(letter) = letters.iter().position(|x| x == c)\
    \ {\n   |                                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_fvfbxy5.rs:21:30\n   |\n16 |  \
    \   let mut current_letter = 0;\n   |                              - expected\
    \ due to this value\n...\n21 |             current_letter = c;\n   |         \
    \                     ^ expected integer, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_fvfbxy5.rs:24:30\n   |\n16 |     let mut current_letter\
    \ = 0;\n   |                              - expected due to this value\n...\n\
    24 |             current_letter = c;\n   |                              ^ expected\
    \ integer, found `char`\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmp_fvfbxy5.rs:26:59\n   |\n26 |         if let Some(vowel) = vowels.iter().position(|x|\
    \ x == c) {\n   |                                                           ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  result.push_str(&letters[vowel + 2]);\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5uxm_cu.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmpc5uxm_cu.rs:20:30\n   |\n20 |   \
    \          result.push_str(&letters[letter]);\n   |                          \
    \    ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[char]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,\
    \ 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\
    \ 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\
    \ 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n \
    \   let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpj5l8lsat.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpj5l8lsat.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj5l8lsat.rs:16:424\n\
    \   |\n16 | ..., 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',...\n \
    \  |                                                      ^^^ expected integer,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut consonants = vec!['B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','V','W','X','Y','Z'];\n\
    \    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            encoded.push_str(&vowels[vowels.iter().position(|x| x == &letter).unwrap()\
    \ + 1]);\n        } else {\n            encoded.push_str(&consonants[consonants.iter().position(|x|\
    \ x == &letter).unwrap() + 1]);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4r2f33n.rs:17:30\n   |\n\
    17 |             encoded.push_str(&vowels[vowels.iter().position(|x| x == &letter).unwrap()\
    \ + 1]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb4r2f33n.rs:19:30\n   |\n19 |             encoded.push_str(&consonants[consonants.iter().position(|x|\
    \ x == &letter).unwrap() + 1]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let\
    \ mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut i = 0;\n\
    \    while i < message.len() {\n        if message[i] == vowels[vowel_counter]\
    \ {\n            vowel_counter++;\n            if vowel_counter == 2 {\n     \
    \           result.push((letters[letter_counter]).to_string());\n            \
    \    letter_counter = 0;\n                vowel_counter = 0;\n            } else\
    \ {\n                result.push((letters[letter_counter]).to_string());\n   \
    \             letter_counter++;\n            }\n        } else {\n           \
    \ vowel_counter = 0;\n            letter_counter = 0;\n            result.push((letters[letter_counter]).to_string());\n\
    \            letter_counter++;\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp30gubecq.rs:20:26\n\
    \   |\n20 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             vowel_counter++;\n\
    20 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp30gubecq.rs:33:27\n   |\n33 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n33 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    33 -             letter_counter++;\n33 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp30gubecq.rs:19:12\n\
    \   |\n19 |         if message[i] == vowels[vowel_counter] {\n   |           \
    \ ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp30gubecq.rs:19:26\n   |\n19 |         if message[i] == vowels[vowel_counter]\
    \ {\n   |                          ^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-s"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_counts = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_counts_reverse = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, 27, 28, 29, 30, 31, 32, 33, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp7gwlcuhe.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp7gwlcuhe.rs:17:41\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut letter_counts_reverse = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26...\n   |                                         ^ unclosed delimiter\n18\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            letter_counter += 1;\n        }\n        if vowels.contains(&c)\
    \ {\n            vowel_counter += 1;\n        }\n    }\n    for c in message.chars()\
    \ {\n        if letters.contains(&c) {\n            if letter_counter == 2 {\n\
    \                result += &letters[letter_counter - 1];\n                letter_counter\
    \ -= 1;\n            } else {\n                result += &letters[letter_counter];\n\
    \                letter_counter -= 1;\n            }\n        } else {\n     \
    \       if vowel_counter == 2 {\n                result += &vowels[vowel_counter\
    \ - 1];\n                vowel_counter -= 1;\n            } else {\n         \
    \       result += &vowels[vowel_counter];\n                vowel_counter -= 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5s6l8jnj.rs:28:27\n   |\n\
    28 |                 result += &letters[letter_counter - 1];\n   |           \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n \
    \  |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5s6l8jnj.rs:31:27\n   |\n31 |\
    \                 result += &letters[letter_counter];\n   |                  \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5s6l8jnj.rs:36:27\n   |\n36 |              \
    \   result += &vowels[vowel_counter - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5s6l8jnj.rs:39:27\n   |\n39 |                 result += &vowels[vowel_counter];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut letters =\
    \ vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,\
    \ 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,\
    \ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\
    \ 84, 85, 86, 87, 88, 89, 90, 91, 92, 9\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpt5ydlks2.rs:21:1\n   |\n21 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpt5ydlks2.rs:20:33\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n20 |     let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28...\n   |                                 ^ unclosed delimiter\n21 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter = String::new();\n\
    \    let mut letter_pos = 0;\n    for c in message.chars() {\n        if let Some(pos)\
    \ = vowels.iter().position(|&x| x == c) {\n            vowels_index[pos] = vowels_index[pos]\
    \ + 1;\n        }\n        if vowels_index[vowels_index.len() - 1] == 2 {\n  \
    \          vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 3 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 4 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 5 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 6 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 7 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 8 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 9 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 10 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 11 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 12 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 13 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 14 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 15 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 16 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 17 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - 1] == 18 {\n            vowels_index.pop();\n        }\n        if vowels_index[vowels_index.len()\
    \ - \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbn4e01cn.rs:83:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     for c in message.chars()\
    \ {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n83 | }\n   |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmpbn4e01cn.rs:74:1\n\
    \   |\n74 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpbn4e01cn.rs:73:24\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n73 |         if vowels_index[vowels_index.len() - \n  \
    \ |                        ^ unclosed delimiter\n74 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbn4e01cn.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters = vec!['A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_counter = 0;\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter2 = 0;\n    let mut vowel_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut vowel_counter3 = 0;\n    let mut letter_counter4 = 0;\n  \
    \  let mut vowel_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ vowel_counter5 = 0;\n    let mut letter_counter6 = 0;\n    let mut vowel_counter6\
    \ = 0;\n    let mut letter_counter7 = 0;\n    let mut vowel_counter7 = 0;\n  \
    \  let mut letter_counter8 = 0;\n    let mut vowel_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut vowel_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut vowel_counter10 = 0;\n    let mut letter_counter11 = 0;\n\
    \    let mut vowel_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut vowel_counter12 = 0;\n    let mut letter_counter13 = 0;\n    let mut vowel_counter13\
    \ = 0;\n    let mut letter_counter14 = 0;\n    let mut vowel_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut vowel_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut vowel_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut vowel\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx5d9q088.rs:50:18\n   |\n\
    50 |     let mut vowel\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5d9q088.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push('_');\n        } else {\n            if letter == vowels[index]\
    \ {\n                result.push(letters[(index + 1) % vowels.len()]);\n     \
    \       } else {\n                result.push(letter);\n            }\n      \
    \  }\n        index = (index + 1) % vowels.len();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp_ahy446w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut current_letter\
    \ = letters.clone();\n    let mut current_vowel = vowels.clone();\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&current_letter[index]);\n\
    \        }\n        if letter == ' ' {\n            result.push_str(\" \");\n\
    \        } else {\n            result.push_str(&current_vowel[index % vowels.len()]);\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppfijggt9.rs:22:29\n   |\n\
    22 |             result.push_str(&current_letter[index]);\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppfijggt9.rs:27:29\n   |\n27 |  \
    \           result.push_str(&current_vowel[index % vowels.len()]);\n   |     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_counter = vec![0];\n    let mut letter_counter_index\
    \ = vec![0];\n    let mut letter_counter_index2 = vec![0];\n    let mut letter_counter_index3\
    \ = vec![0];\n    let mut letter_counter_index4 = vec![0];\n    let mut letter_counter_index5\
    \ = vec![0];\n    let mut letter_counter_index6 = vec![0];\n    let mut letter_counter_index7\
    \ = vec![0];\n    let mut letter_counter_index8 = vec![0];\n    let mut letter_counter_index9\
    \ = vec![0];\n    let mut letter_counter_index10 = vec![0];\n    let mut letter_counter_index11\
    \ = vec![0];\n    let mut letter_counter_index12 = vec![0];\n    let mut letter_counter_index13\
    \ = vec![0];\n    let mut letter_counter_index14 = vec![0];\n    let mut letter_counter_index15\
    \ = vec![0];\n    let mut letter_counter_index16 = vec![0];\n    let mut letter_counter_index17\
    \ = vec![0];\n    let mut letter_counter_index18 = vec![0];\n    let mut letter_counter_index19\
    \ = vec![0];\n    let mut letter_counter_index20 = vec![0];\n    let mut letter_counter_index21\
    \ = vec![0];\n    let mut letter_counter_index22 = vec![0];\n    let mut letter_counter_index23\
    \ = vec![0];\n    let mut letter_counter_index24 = vec![0];\n    let mut letter_counter_index25\
    \ = vec![0];\n    let mut letter_counter_index26 = vec![0];\n    let mut letter_counter_index\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcygsoui0.rs:42:33\n   |\n\
    42 |     let mut letter_counter_index\n   |                                 ^\
    \ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcygsoui0.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let\
    \ mut vowels_index = vowels.len();\n    let mut letters_index = letters.len();\n\
    \    let mut vowels_count = vowels.len();\n    let mut letters_count = letters.len();\n\
    \    let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let mut vowels_count\
    \ = 0;\n    let mut letters_count = 0;\n    let mut vowels_index2 = 0;\n    let\
    \ mut letters_index2 = 0;\n    let mut vowels_count2 = 0;\n    let mut letters_count2\
    \ = 0;\n    let mut vowels_index3 = 0;\n    let mut letters_index3 = 0;\n    let\
    \ mut vowels_count3 = 0;\n    let mut letters_count3 = 0;\n    let mut vowels_index4\
    \ = 0;\n    let mut letters_index4 = 0;\n    let mut vowels_count4 = 0;\n    let\
    \ mut letters_count4 = 0;\n    let mut vowels_index5 = 0;\n    let mut letters_index5\
    \ = 0;\n    let mut vowels_count5 = 0;\n    let mut letters_count5 = 0;\n    let\
    \ mut vowels_index6 = 0;\n    let mut letters_index6 = 0;\n    let mut vowels_count6\
    \ = 0;\n    let mut letters_count6 = 0;\n    let mut vowels_index7 = 0;\n    let\
    \ mut letters_index7 = 0;\n    let mut vowels_count7 = 0;\n    let mut letters_count7\
    \ = 0;\n    let mut vowels_index8 = 0;\n    let mut letters_index8 = 0;\n    let\
    \ mut vowels_count8 = 0;\n    let mut letters_count8 = 0;\n    let mut vowels_index9\
    \ = 0;\n    let mut letters_index9 = 0;\n    let mut vowels_count9 = 0;\n    let\
    \ mut letters_count9 = 0;\n    let mut vowels_index10 = 0;\n    let mut letters_index10\
    \ = 0;\n    let mut vowels_count10 = 0;\n    let mut letters_count10 = 0;\n  \
    \  let mut vowels_index11 = 0;\n    let mut letters_index11 = 0;\n    let mut\
    \ vowels_count11 = 0;\n    let mut letters_count11 = 0;\n    let mut vowels_index12\
    \ = 0;\n    let mut letters_index12 = 0;\n    let mut vowels_count12 = 0;\n  \
    \  let mut letters_count12 = 0;\n    let mut vowels_index13 = 0;\n    let mut\
    \ letters_index13 = 0;\n    let mut vowels_count13 = 0;\n    let mut letters_count13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpt30qn4s0.rs:73:1\n  \
    \ |\n73 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp8tzmd69j.rs:44:1\n   |\n44 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp8tzmd69j.rs:43:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n43 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, \n   |                                ^ unclosed delimiter\n44 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'N', 'P', 'Q', 'R', 'S',\
    \ 'T', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2 = 0;\n\
    \    let mut vowel_counter3 = 0;\n    let mut consonant_counter3 = 0;\n    let\
    \ mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut consonant_counter5 = 0;\n    let mut vowel_counter6 = 0;\n\
    \    let mut consonant_counter6 = 0;\n    let mut vowel_counter7 = 0;\n    let\
    \ mut consonant_counter7 = 0;\n    let mut vowel_counter8 = 0;\n    let mut consonant_counter8\
    \ = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9 = 0;\n\
    \    let mut vowel_counter10 = 0;\n    let mut consonant_counter10 = 0;\n    let\
    \ mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut consonant_counter12 = 0;\n    let mut vowel_counter13\
    \ = 0;\n    let mut consonant_counter13 = 0;\n    let mut vowel_counter14 = 0;\n\
    \    let mut consonant_counter14 = 0;\n    let mut vowel_counter15 = 0;\n    let\
    \ mut consonant_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut\
    \ consonant_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut consonant_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut consonant_counter18 = 0;\n\
    \    let mut vowel_counter19 = 0;\n    let mut consonant_counter19 = 0;\n    let\
    \ mut vowel_counter20 = 0;\n    let mut consonant_counter20 = 0;\n    let mut\
    \ vowel_counter21 = 0;\n    let mut consonant_counter21 = 0;\n    let mut vowel_counter22\
    \ = 0;\n    let mut consonant_counter22 = 0;\n    let mu\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphjwalc32.rs:59:11\n   |\n\
    59 |     let mu\n   |           ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphjwalc32.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut vowels_index = vowels.len();\n    let mut letter_count\
    \ = message.len();\n    let mut letter_count_index = 0;\n    let mut letter_count_index2\
    \ = 0;\n    let mut letter_count_index3 = 0;\n    let mut letter_count_index4\
    \ = 0;\n    let mut letter_count_index5 = 0;\n    let mut letter_count_index6\
    \ = 0;\n    let mut letter_count_index7 = 0;\n    let mut letter_count_index8\
    \ = 0;\n    let mut letter_count_index9 = 0;\n    let mut letter_count_index10\
    \ = 0;\n    let mut letter_count_index11 = 0;\n    let mut letter_count_index12\
    \ = 0;\n    let mut letter_count_index13 = 0;\n    let mut letter_count_index14\
    \ = 0;\n    let mut letter_count_index15 = 0;\n    let mut letter_count_index16\
    \ = 0;\n    let mut letter_count_index17 = 0;\n    let mut letter_count_index18\
    \ = 0;\n    let mut letter_count_index19 = 0;\n    let mut letter_count_index20\
    \ = 0;\n    let mut letter_count_index21 = 0;\n    let mut letter_count_index22\
    \ = 0;\n    let mut letter_count_index23 = 0;\n    let mut letter_count_index24\
    \ = 0;\n    let mut letter_count_index25 = 0;\n    let mut letter_count_index26\
    \ = 0;\n    let mut letter_count_index27 = 0;\n    let mut letter_count_index28\
    \ = 0;\n    let mut letter_count_index29 = 0;\n    let mut letter_count_index30\
    \ = 0;\n    let mut letter_count_index31 = 0;\n    let mut letter_count_index32\
    \ = 0;\n    let mut letter_count_index33 = 0;\n    let mut letter_count_index34\
    \ = 0;\n    let mut letter_count_index35 = 0;\n    let mut letter_count_index36\
    \ = 0;\n    let mut letter_count_index37 = 0;\n    let mut letter_count_index38\
    \ = 0;\n    let mut letter_count_index39 = 0;\n    let mut letter_count_index40\
    \ = 0;\n    let mut letter_count_index41 = 0;\n    let mut letter_count_index42\
    \ = 0;\n    let mut letter_count_index43 = 0;\n    let mut letter_count_index44\
    \ = 0;\n    let mut letter_count_index45 = 0;\n    let mut letter_count_index46\
    \ = 0;\n    let mut letter_count_index47 = 0;\n    let mut letter_count_index48\
    \ = 0;\n    let mut letter_count_index49 = 0;\n    let mut letter_count_index50\
    \ = 0;\n    let mut letter_count_index51 = 0;\n    let mut letter_count_index52\
    \ = 0;\n    let mut letter_count_index53 = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvr2art0n.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvr2art0n.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut\
    \ vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsg6doik6.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A','E','I','O','U'];\n    let mut vowels_index = 0;\n    let mut letter_count\
    \ = 1;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            result.push((&vowels[vowels_index]).to_string());\n         \
    \   vowels_index += letter_count;\n            letter_count = 1;\n        } else\
    \ {\n            result.push((&letter).to_string());\n            letter_count\
    \ += 1;\n        }\n    }\n    result.push((&vowels[vowels_index]).to_string());\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5s2g7_8_.rs:18:25\n   |\n\
    18 |             result.push((&vowels[vowels_index]).to_string());\n   |     \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5s2g7_8_.rs:22:25\n\
    \   |\n22 |             result.push((&letter).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5s2g7_8_.rs:26:17\n   |\n26 |  \
    \   result.push((&vowels[vowels_index]).to_string());\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&c) {\n            result.push_str(&letters[vowel\
    \ + index]);\n            index = vowel + 1;\n        } else {\n            result.push_str(&letters[c]);\n\
    \            index = c;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn2c_qy_a.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the type `[char]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmpn2c_qy_a.rs:21:30\n   |\n21 |          \
    \   result.push_str(&letters[c]);\n   |                              ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpn2c_qy_a.rs:22:21\n   |\n15 |  \
    \   let mut index = 0;\n   |                     - expected due to this value\n\
    ...\n22 |             index = c;\n   |                     ^ expected integer,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,\
    \ 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\
    \ 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\
    \ 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n \
    \   let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_counter = 0;\n\
    \    let mut letters_counter = 0;\n    let mut vowels_index = 0;\n    let mut\
    \ letters_index = 0;\n    let mut vowels_counter = 0;\n    let mut letters_counter\
    \ = 0;\n    let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let\
    \ mut vowels_counter = 0;\n    let mut letters_counter = 0;\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpem3gp4wy.rs:28:26\n   |\n\
    28 |     let mut letters_index\n   |                          ^ help: add `;`\
    \ here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpem3gp4wy.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    for c in message.chars() {\n        if letters_index\
    \ == 0 {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' {\n                result.push(c);\n                vowels_index += 1;\n\
    \            }\n        } else {\n            if c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U' {\n                result.push(c);\n           \
    \     vowels_index += 1;\n            }\n        }\n        if letters_index ==\
    \ 2 {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n                result.push(c);\n                vowels_index += 1;\n   \
    \         }\n        } else {\n            if c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' {\n                result.push(c);\n               \
    \ vowels_index += 1;\n            }\n        }\n        if letters_index == 4\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                result.push(c);\n                vowels_index += 1;\n       \
    \     }\n        } else {\n            if c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U' {\n                result.push(c);\n                vowels_index\
    \ += 1;\n            }\n        }\n        if letters_index == 6 {\n         \
    \   if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n          \
    \      result.push(c);\n                vowels_index += 1;\n            }\n  \
    \      } else {\n            if c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' {\n                result.push(c);\n                vowels_index +=\
    \ 1;\n            }\n        }\n        if letters_index == 8 {\n            if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n               \
    \ result.push(c);\n                vowels_index += 1;\n            }\n       \
    \ } else {\n            if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U' {\n                result.push(c);\n                \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu72l8iga.rs:80:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     for c in message.chars()\
    \ {\n   |                              - unclosed delimiter\n...\n67 |       \
    \  } else {\n   |                - unclosed delimiter\n68 |             if c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n   |                \
    \                                                         - this delimiter might\
    \ not be properly closed...\n...\n71 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n80 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu72l8iga.rs:17:5\n   |\n11 |   fn encode(message: String)\
    \ -> String {\n   |                                 ------ expected `String` because\
    \ of return type\n...\n17 | /     for c in message.chars() {\n18 | |         if\
    \ letters_index == 0 {\n19 | |             if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n20 | |                 result.push(c);\n...  |\n\
    79 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")),\
    \ String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n80 | | }\n   | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            vowel_counter += 2;\n        } else {\n            vowel_counter\
    \ += 1;\n        }\n        if letters.contains(&c) {\n            letter_counter\
    \ += 2;\n        } else {\n            letter_counter += 1;\n        }\n    }\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  result += &vowels[vowel_counter];\n            vowel_counter += 2;\n      \
    \  } else {\n            result += &letters[letter_counter];\n            letter_counter\
    \ += 2;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcajamdhe.rs:31:23\n   |\n\
    31 |             result += &vowels[vowel_counter];\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcajamdhe.rs:34:23\n   |\n34 |             result += &letters[letter_counter];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpseovkux7.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[vowel_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpseovkux7.rs:25:33\n   |\n25 |  \
    \               result.push_str(letters[letter_counter]);\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                result.push_str(vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp75_qvhc0.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[vowel_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp75_qvhc0.rs:25:33\n   |\n25 |  \
    \               result.push_str(letters[letter_counter]);\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ 'S', 'T', 'W', 'V', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ consonant_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2\
    \ = 0;\n    let mut vowel_counter3 = 0;\n    let mut consonant_counter3 = 0;\n\
    \    let mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut consonant_counter5 = 0;\n    let mut vowel_counter6\
    \ = 0;\n    let mut consonant_counter6 = 0;\n    let mut vowel_counter7 = 0;\n\
    \    let mut consonant_counter7 = 0;\n    let mut vowel_counter8 = 0;\n    let\
    \ mut consonant_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9\
    \ = 0;\n    let mut vowel_counter10 = 0;\n    let mut consonant_counter10 = 0;\n\
    \    let mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let\
    \ mut vowel_counter12 = 0;\n    let mut consonant_counter12 = 0;\n    let mut\
    \ vowel_counter13 = 0;\n    let mut consonant_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut consonant_counter14 = 0;\n    let mut vowel_counter15 = 0;\n\
    \    let mut consonant_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let\
    \ mut consonant_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut\
    \ consonant_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut consonant_counter18\
    \ = 0;\n    let mut vowel_counter19 = 0;\n    let mut consonant_counter19 = 0;\n\
    \    let mut vowel_counter20 = 0;\n    let mut consonant_counter20 = 0;\n    let\
    \ mut vowel_counter21 = 0;\n    let mut consonant_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut consonant_counter22 = 0;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphakae2aw.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            vowel_counter\
    \ += 2;\n        }\n        result += if vowel_counter > 0 {\n            vowels[vowel_counter\
    \ - 1]\n        } else {\n            c\n        };\n        vowel_counter +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpph2t1_zr.rs:20:13\n   |\n\
    20 |             vowels[vowel_counter - 1]\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpph2t1_zr.rs:22:13\n\
    \   |\n22 |             c\n   |             ^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\
    \ 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\
    \ 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\
    \ 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,\
    \ 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,\
    \ 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,\
    \ 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,\
    \ 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\
    \ 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\
    \ 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,\
    \ 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227,\
    \ 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,\
    \ 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 25\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpbui6fz1u.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpbui6fz1u.rs:15:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n15 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n16 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4r_kjfhm.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            if vowel_counter < 2 {\n                result.push(*vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push(*letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        } else {\n     \
    \       result.push(*letter);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp2invv4h1.rs:20:29\n\
    \   |\n20 |                 result.push(*vowels[vowel_counter]);\n   |       \
    \                      ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp2invv4h1.rs:23:29\n   |\n23 |               \
    \  result.push(*letters[letter_counter]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp2invv4h1.rs:27:25\n\
    \   |\n27 |             result.push(*letter);\n   |                         ^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 =\
    \ 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n\
    \    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n \
    \   let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz0zxvxcq.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz0zxvxcq.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut\
    \ letter_counter = 0;\n    let mut letter_counter_index = 0;\n    let mut letter_counter_index2\
    \ = 0;\n    for letter in message.chars() {\n        if letter_counter_index ==\
    \ 0 {\n            letter_counter_index2 = letter_counter_index;\n        }\n\
    \        if letter_counter_index2 == 0 {\n            letter_counter_index2 =\
    \ letter_counter_index;\n        }\n        if letter_counter_index2 == letter_counter_index\
    \ {\n            letter_counter_index2 += 1;\n        }\n        if vowels.contains(&letter)\
    \ {\n            result.push((vowels[vowels_index] + letter).to_string());\n \
    \           vowels_index += 1;\n        } else {\n            result.push((vowels[vowels_index]\
    \ + letter).to_string());\n            vowels_index += 1;\n            result.push((vowels[vowels_index]\
    \ + letter).to_string());\n            vowels_index += 1;\n        }\n       \
    \ letter_counter += 1;\n        letter_counter_index += 1;\n        letter_counter_index2\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpc6c49i71.rs:29:47\n\
    \   |\n29 |             result.push((vowels[vowels_index] + letter).to_string());\n\
    \   |                          -------------------- ^ ------ char\n   |      \
    \                    |\n   |                          char\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmpc6c49i71.rs:32:47\n   |\n32 |          \
    \   result.push((vowels[vowels_index] + letter).to_string());\n   |          \
    \                -------------------- ^ ------ char\n   |                    \
    \      |\n   |                          char\n\nerror[E0369]: cannot add `char`\
    \ to `char`\n  --> /tmp/tmpc6c49i71.rs:34:47\n   |\n34 |             result.push((vowels[vowels_index]\
    \ + letter).to_string());\n   |                          --------------------\
    \ ^ ------ char\n   |                          |\n   |                       \
    \   char\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut index = 0;\n    let mut count\
    \ = 1;\n    let mut letter = String::new();\n    for ch in message.chars() {\n\
    \        if let Some(vowel) = vowels.binary_search(&ch) {\n            encoded.push_str(&vowels[vowel]);\n\
    \            count += 1;\n        } else {\n            encoded.push_str(&ch);\n\
    \        }\n        if count == 2 {\n            encoded.push_str(&vowels[vowels.binary_search(&letter)].to_string());\n\
    \            count += 1;\n            letter = String::new();\n        }\n   \
    \ }\n    encoded.push_str(&vowels[vowels.binary_search(&letter)].to_string());\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfm6fj83e.rs:18:16\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&ch) {\n   |          \
    \      ^^^^^^^^^^^   ------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfm6fj83e.rs:22:30\n   |\n22 |             encoded.push_str(&ch);\n \
    \  |                              ^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfm6fj83e.rs:25:59\n   |\n25 |             encoded.push_str(&vowels[vowels.binary_search(&letter)].to_string());\n\
    \   |                                                           ^^^^^^^ expected\
    \ `char`, found struct `String`\n   |\n   = note: expected reference `&char`\n\
    \              found reference `&String`\n\nerror[E0277]: the type `[char]` cannot\
    \ be indexed by `Result<usize, usize>`\n  --> /tmp/tmpfm6fj83e.rs:25:31\n   |\n\
    25 |             encoded.push_str(&vowels[vowels.binary_search(&letter)].to_string());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[char]>` is not implemented for `Result<usize, usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Result<usize, usize>>`\
    \ for `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfm6fj83e.rs:30:51\n\
    \   |\n30 |     encoded.push_str(&vowels[vowels.binary_search(&letter)].to_string());\n\
    \   |                                                   ^^^^^^^ expected `char`,\
    \ found struct `String`\n   |\n   = note: expected reference `&char`\n       \
    \       found reference `&String`\n\nerror[E0277]: the type `[char]` cannot be\
    \ indexed by `Result<usize, usize>`\n  --> /tmp/tmpfm6fj83e.rs:30:23\n   |\n30\
    \ |     encoded.push_str(&vowels[vowels.binary_sea"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = letters.len();\n    while i < message.len()\
    \ {\n        if message[i] == ' ' {\n            result.push_str(&message[..i]);\n\
    \            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == 'a' {\n            result.push_str(&vowels[(i + k) % l]);\n            i\
    \ += 1;\n            continue;\n        }\n        if message[i] == 'e' {\n  \
    \          result.push_str(&vowels[(i + k) % l]);\n            i += 1;\n     \
    \       continue;\n        }\n        if message[i] == 'i' {\n            result.push_str(&vowels[(i\
    \ + k) % l]);\n            i += 1;\n            continue;\n        }\n       \
    \ if message[i] == 'o' {\n            result.push_str(&vowels[(i + k) % l]);\n\
    \            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == 'u' {\n            result.push_str(&vowels[(i + k) % l]);\n            i\
    \ += 1;\n            continue;\n        }\n        if message[i] == 'A' {\n  \
    \          result.push_str(&letters[(i + j) % l]);\n            i += 1;\n    \
    \        continue;\n        }\n        if message[i] == 'B' {\n            result.push_str(&letters[(i\
    \ + j) % l]);\n            i += 1;\n            continue;\n        }\n       \
    \ if message[i] == 'C' {\n            result.push_str(&letters[(i + j) % l]);\n\
    \            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == 'D' {\n            result.push_str(&letters[(i + j) % l]);\n            i\
    \ += 1;\n            continue;\n        }\n        if message[i] == 'E' {\n  \
    \          result.push_str(&letters[(i + j) % l]);\n            i += 1;\n    \
    \        continue;\n        }\n        if message[i] == 'F' {\n            result.push_str(&letters[(i\
    \ + j) % l]);\n            i += 1;\n            continue;\n        }\n       \
    \ if message[i] == 'G' {\n            result.push_str(&letters[(i + j) % l]);\n\
    \            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == 'H' {\n            result.push_str(&letters[(i + j) % l\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp0_g7lv6.rs:96:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     while i < message.len()\
    \ {\n   |                             - unclosed delimiter\n...\n85 |        \
    \ if message[i] == 'H' {\n   |                              - this delimiter might\
    \ not be properly closed...\n86 |             result.push_str(&letters[(i + j)\
    \ % l\n87 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n96 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpp0_g7lv6.rs:86:37\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n86 |     \
    \        result.push_str(&letters[(i + j) % l\n   |                          \
    \           ^ unclosed delimiter\n87 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp0_g7lv6.rs:20:12\n\
    \   |\n20 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp0_g7lv6.rs:25:12\n   |\n25 |         if message[i] == 'a' {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ letter in message.chars() {\n        if let Some(index) = vowels.find(|c| c\
    \ == letter) {\n            result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \        } else {\n            result.push_str(&letters[letters.find(|c| c ==\
    \ letter).unwrap() + 1]);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmput1lvbay.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmput1lvbay.rs:19:30\n   |\n19 |             result.push_str(&letters[letters.find(|c|\
    \ c == letter).unwrap() + 1]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3877wcah.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3877wcah.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_counter += 1;\n        } else {\n            letter_counter\
    \ += 1;\n        }\n    }\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(&format!(\"{}\", letter));\n        }\
    \ else {\n            if letter_counter == 2 {\n                result.push_str(&format!(\"\
    {}{}\", letters[letter_counter - 1], letters[letter_counter]));\n            }\
    \ else {\n                result.push_str(&format!(\"{}{}\", letters[letter_counter],\
    \ letters[letter_counter + 1]));\n            }\n        }\n    }\n    if vowel_counter\
    \ == 2 {\n        result.push_str(&format!(\"{}{}\", letters[letter_counter -\
    \ 1], letters[letter_counter]));\n    } else {\n        result.push_str(&format!(\"\
    {}{}\", letters[letter_counter], letters[letter_counter + 1]));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"DEDEDEDEDE\"`,\n right: `\"tgst\"`', /tmp/tmpn9ruru6w.rs:45:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            vowel_counter++;\n       \
    \ }\n        if alphabet.contains(&letter) {\n            letter_counter++;\n\
    \        }\n    }\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            if letter_counter == 2 {\n                result.push((vowels[vowel_counter\
    \ - 1] + vowels[vowel_counter]) as char);\n            } else {\n            \
    \    result.push((vowels[vowel_counter - 1] + letter) as char);\n            }\n\
    \            vowel_counter++;\n            letter_counter = 0;\n        } else\
    \ {\n            result.push((letter + alphabet[letter_counter]) as char);\n \
    \           letter_counter++;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpwi9lp3rp.rs:19:26\n\
    \   |\n19 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             vowel_counter++;\n\
    19 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpwi9lp3rp.rs:22:27\n   |\n22 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n22 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             letter_counter++;\n22 +             letter_counter += 1;\n  \
    \ | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpwi9lp3rp.rs:32:26\n\
    \   |\n32 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n32 -             vowel_counter++;\n\
    32 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpwi9lp3rp.rs:36:27\n   |\n36 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n36 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    36 -             letter_counter++;\n36 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpwi9lp3rp.rs:28:56\n\
    \   |\n28 |                 result.push((vowels[vowel_counter - 1] + vowels[vowel_counter])\
    \ as char);\n   |                              ------------------------- ^ ---------------------\
    \ char\n   |                              |\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ result.push_str(\" \");\n        } else {\n            if letter in vowels {\n\
    \                result.push_str(&vowels[vowels.iter().position(|x| x == letter).unwrap()\
    \ + 1]);\n            } else {\n                result.push_str(&consonants[consonants.iter().position(|x|\
    \ x == letter).unwrap() + 1]);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp2b2j61jn.rs:20:23\n\
    \   |\n20 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    for c in message.chars() {\n        if vowels_map.contains_key(&c) {\n  \
    \          result.push(*vowels_map.get(&c));\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmplkqiwh0y.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n \
    \   let mut consonant_counter = 0;\n    for letter in message.chars() {\n    \
    \    if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            result.push((consonants[consonant_counter]).to_string());\n\
    \            consonant_counter += 1;\n        } else if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            result.push((vowels[vowel_counter]).to_string());\n\
    \            vowel_counter += 1;\n        } else {\n            result.push((letter).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp923amoy1.rs:19:25\n   |\n\
    19 |             result.push((consonants[consonant_counter]).to_string());\n \
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp923amoy1.rs:22:25\n\
    \   |\n22 |             result.push((vowels[vowel_counter]).to_string());\n  \
    \ |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp923amoy1.rs:25:25\n\
    \   |\n25 |             result.push((letter).to_string());\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map\
    \ = HashMap::new();\n    for vowel in vowels {\n        vowels_map.insert(vowel,\
    \ vowel);\n    }\n    let mut letter_map = HashMap::new();\n    for letter in\
    \ message {\n        letter_map.insert(letter, letter);\n    }\n    for letter\
    \ in message {\n        let mut new_letter = letter;\n        for vowel in vowels\
    \ {\n            let mut new_vowel = vowel;\n            if letter_map.contains_key(&vowel)\
    \ {\n                new_vowel = vowels_map.get(&vowel).unwrap();\n          \
    \  }\n            new_letter += new_vowel;\n        }\n        result += new_letter;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpr36e451q.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpr36e451q.rs:18:26\n\
    \   |\n18 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: `String` is\
    \ not an iterator\n  --> /tmp/tmpr36e451q.rs:19:19\n   |\n19 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpr36e451q.rs:22:19\n   |\n22 |     for letter in message\
    \ {\n   |                   ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: cannot add-assign `char` to `&str`\n  --> /tmp/tmpr36e451q.rs:29:24\n\
    \   |\n29 |             new_letter += new_vowel;\n   |                       \
    \ ^^ no implementation for `&str += char`\n   |\n   = help: the trait `AddAssign<char>`\
    \ is not implemented for `&str`\n   = help: the trait `AddAssign<&str>` is implemented\
    \ for `String`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowels_idx = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_idx_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_4 = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_idx_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_idx_7 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_8\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_9 = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_idx_10 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_11 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_idx_12 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_idx_13 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_14 = vec![0, 1,\
    \ 2, 3, 4];\n    let mut vowels_idx_15 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_16\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_17 = vec![0, 1, 2, 3, 4];\n \
    \   let mut vowels_idx_18 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_19 =\
    \ vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_20 = vec![0, 1, 2, 3, 4];\n   \
    \ let mut vowels_idx_21 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_22 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_idx_23 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_idx_24 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_25 = vec![0, 1,\
    \ 2, 3, 4];\n    let mut vowels_idx_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_28 = vec![0, 1, 2, 3, 4];\n \
    \   let mut vowels_idx_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_30 =\
    \ vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_31 = vec![0, 1, 2, 3, 4];\n   \
    \ let mut vowels_idx_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_idx_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph9u_db4y.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph9u_db4y.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[letters.iter().position(|x| x\
    \ == &letter).unwrap()]);\n        }\n    }\n    for vowel in vowels.iter() {\n\
    \        result.push_str(&vowels[vowels.iter().position(|x| x == &vowel).unwrap()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaskdqgu4.rs:20:29\n   |\n\
    20 |             result.push_str(&letters[letters.iter().position(|x| x == &letter).unwrap()]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: can't compare `char` with\
    \ `&char`\n  --> /tmp/tmpaskdqgu4.rs:24:62\n   |\n24 |         result.push_str(&vowels[vowels.iter().position(|x|\
    \ x == &vowel).unwrap()]);\n   |                                             \
    \                 ^^ no implementation for `char == &char`\n   |\n   = help: the\
    \ trait `PartialEq<&char>` is not implemented for `char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&&char>` for `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaskdqgu4.rs:24:25\n   |\n24 |         result.push_str(&vowels[vowels.iter().position(|x|\
    \ x == &vowel).unwrap()]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = \"aeiouAEIOU\".to_string();\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut letter_counter\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp26epdyou.rs:75:27\n   |\n\
    75 |     let mut letter_counter\n   |                           ^ help: add `;`\
    \ here\n76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp26epdyou.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ 'S', 'T', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0];\n    let\
    \ mut consonants_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut consonants_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowels_count_index\
    \ = vec![0];\n    let mut consonants_count_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc0n2m4c5.rs:49:18\n   |\n\
    49 |     let mut vowel\n   |                  ^ help: add `;` here\n50 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0n2m4c5.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index2 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index3 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index4\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index5 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index6 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index7\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index8 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index9 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index10\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index11 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index12 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ letter_counter_index13 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index14\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index15 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ letter_counter_index17 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index19 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index20 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ letter_counter_index21 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index22\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index23 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index24 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ letter_counter_index25 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index26\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index27 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ letter_counter_index29 = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_counter_index31 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter_index32 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpj0x8i48v.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  encoded.push_str(&consonants[vowel + 2]);\n        } else {\n            encoded.push_str(&consonants[index]);\n\
    \        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_b9wgqh8.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_b9wgqh8.rs:20:30\n   |\n20 |             encoded.push_str(&consonants[index]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    for letter in message.chars() {\n      \
    \  if let Some(vowel) = vowels.binary_search(&letter) {\n            let index\
    \ = vowel - 2;\n            result.push((letters[index] as char).to_string());\n\
    \        } else {\n            result.push((letters[letter] as char).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg014t76h.rs:16:16\n   |\n\
    16 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg014t76h.rs:18:25\n   |\n18 |             result.push((letters[index]\
    \ as char).to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: the type `[char]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmpg014t76h.rs:20:26\n   |\n20 |          \
    \   result.push((letters[letter] as char).to_string());\n   |                \
    \          ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[char]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg014t76h.rs:20:25\n\
    \   |\n20 |             result.push((letters[letter] as char).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    let mut letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n\
    \    let mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n\
    \    let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpylh4dt68.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylh4dt68.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter == vowels[vowel_counter] {\n                vowel_counter++;\n  \
    \              if vowel_counter == 2 {\n                    result.push_str(vowels[vowel_counter\
    \ - 1]);\n                    vowel_counter = 0;\n                }\n        \
    \    } else {\n                result.push_str(letters[letter_counter]);\n   \
    \             letter_counter++;\n                if letter_counter == 2 {\n  \
    \                  letter_counter = 0;\n                }\n            }\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_sdi1lw2.rs:22:30\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 vowel_counter++;\n22 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp_sdi1lw2.rs:29:31\n\
    \   |\n29 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    29 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    29 -                 letter_counter++;\n29 +                 letter_counter +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_sdi1lw2.rs:28:33\n\
    \   |\n28 |                 result.push_str(letters[letter_counter]);\n   |  \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    let mut vowels_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpwkphcf8x.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpwkphcf8x.rs:19:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n20 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter in vowels {\n                vowel_counter++;\n                result.push_str(&vowels[vowel_counter]);\n\
    \            } else {\n                letter_counter++;\n                result.push_str(&letters[letter_counter]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp1jzxhoxp.rs:21:23\n\
    \   |\n21 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            let index = vowels_index[vowels.iter().position(|x|\
    \ x == &letter).unwrap()];\n            result.push((&vowels[index]).to_string());\n\
    \            vowels_index[index] += 1;\n        } else {\n            result.push((&letter).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    if letter_counter > 0\
    \ {\n        result.push((&vowels[vowels_index.iter().position(|x| x == 0).unwrap()]).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_2cjinji.rs:19:25\n   |\n\
    19 |             result.push((&vowels[index]).to_string());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_2cjinji.rs:22:25\n   |\n22 |\
    \             result.push((&letter).to_string());\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0277]:\
    \ can't compare `&usize` with `{integer}`\n  --> /tmp/tmp_2cjinji.rs:27:65\n \
    \  |\n27 |         result.push((&vowels[vowels_index.iter().position(|x| x ==\
    \ 0).unwrap()]).to_string());\n   |                                          \
    \                       ^^ no implementation for `&usize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&usize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_2cjinji.rs:27:21\n\
    \   |\n27 |         result.push((&vowels[vowels_index.iter().position(|x| x ==\
    \ 0).unwrap()]).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7n0srdh9.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ 'S', 'T', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut\
    \ consonant_counter = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_counter += 1;\n            result.push((vowels[vowel_counter]\
    \ + consonants[consonant_counter]).to_string());\n            consonant_counter\
    \ += 1;\n        } else {\n            result.push(letter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpsr7pmopj.rs:20:48\n\
    \   |\n20 |             result.push((vowels[vowel_counter] + consonants[consonant_counter]).to_string());\n\
    \   |                          --------------------- ^ -----------------------------\
    \ char\n   |                          |\n   |                          char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_map = vec!['T', 'H', 'K', 'S', 'C', 'M', 'G', 'S', 'C',\
    \ 'G'];\n    for letter in message.chars() {\n        if let Some(index) = vowels_index[vowels.iter().position(|&x|\
    \ x == letter).unwrap()] {\n            result.push_str(&letter_map[index]);\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpheef9hpu.rs:17:16\n   |\n\
    17 |         if let Some(index) = vowels_index[vowels.iter().position(|&x| x ==\
    \ letter).unwrap()] {\n   |                ^^^^^^^^^^^   ---------------------------------------------------------------\
    \ this expression has type `{integer}`\n   |                |\n   |          \
    \      expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpheef9hpu.rs:20:29\n   |\n20 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = 0;\n    for letter\
    \ in message.chars() {\n        if vowels.contains(&letter) {\n            vowels_counter\
    \ += 1;\n        }\n    }\n    let mut letter_counter = 0;\n    for letter in\
    \ message.chars() {\n        if vowels.contains(&letter) {\n            if letter_counter\
    \ < vowels_counter {\n                result.push((letter + vowels[vowels_counter\
    \ - letter_counter]).to_string());\n            } else {\n                result.push((letter\
    \ + vowels[vowels_counter - letter_counter - 1]).to_string());\n            }\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpt4dw7pux.rs:24:37\n\
    \   |\n24 |                 result.push((letter + vowels[vowels_counter - letter_counter]).to_string());\n\
    \   |                              ------ ^ ---------------------------------------\
    \ char\n   |                              |\n   |                            \
    \  char\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpt4dw7pux.rs:26:37\n\
    \   |\n26 |                 result.push((letter + vowels[vowels_counter - letter_counter\
    \ - 1]).to_string());\n   |                              ------ ^ -------------------------------------------\
    \ char\n   |                              |\n   |                            \
    \  char\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let\
    \ mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut vowel_counter2\
    \ = 0;\n    let mut letter_counter2 = 0;\n    for letter in message {\n      \
    \  if letter in vowels {\n            vowel_counter += 1;\n            if vowel_counter\
    \ == 2 {\n                vowel_counter2 = 0;\n                letter_counter2\
    \ = 0;\n            }\n        }\n        if letter in letters {\n           \
    \ letter_counter += 1;\n            if letter_counter == 2 {\n               \
    \ letter_counter2 = 0;\n                vowel_counter2 = 0;\n            }\n \
    \       }\n        if letter in vowels {\n            vowel_counter2 += 1;\n \
    \           if vowel_counter2 == 2 {\n                vowel_counter2 = 0;\n  \
    \              letter_counter2 = 0;\n            }\n        }\n        if letter\
    \ in letters {\n            letter_counter2 += 1;\n            if letter_counter2\
    \ == 2 {\n                letter_counter2 = 0;\n                vowel_counter2\
    \ = 0;\n            }\n        }\n        if vowel_counter2 == 2 {\n         \
    \   vowel_counter2 = 0;\n            letter_counter2 = 0;\n        }\n       \
    \ if letter_counter2 == 2 {\n            letter_counter2 = 0;\n            vowel_counter2\
    \ = 0;\n        }\n        if vowel_counter == 2 {\n            vowel_counter\
    \ = 0;\n            letter_counter = 0;\n        }\n        if letter_counter\
    \ == 2 {\n            letter_counter = 0;\n            vowel_counter = 0;\n  \
    \      }\n        if vowel_counter2 == 2 {\n            vowel_counter2 = 0;\n\
    \            letter_counter2 = 0;\n        }\n        if letter_counter2 == 2\
    \ {\n            letter_counter2 = 0;\n            vowel_counter2 = 0;\n     \
    \   }\n        if vowel_counter == 2 {\n            vowel_counter = 0;\n     \
    \       letter_counter = 0;\n        }\n        if letter_counter == 2 {\n   \
    \         letter_counter = 0;\n            vowel_counter = 0;\n        }\n   \
    \     if vowel_counter2 == 2 {\n            vowel_counter2 = 0;\n            letter_counter2\
    \ = 0;\n        }\n        if letter_counter2 == 2 {\n            letter_counter2\
    \ = 0;\n            vowel_counter2 = 0;\n        }\n        if vowel_counter ==\
    \ 2 {\n            vowel_counter = 0;\n            letter_counter = 0;\n     \
    \   }\n        if letter_counter == 2 {\n            letter_counter = 0;\n   \
    \         vowel_counter = 0;\n        }\n        if vowel_counter2 == 2 {\n  \
    \          vowel_counter2 = 0;\n            letter_counter2 = 0;\n        }\n\
    \        if letter_counter2 == 2 {\n            letter_counter2 = 0;\n       \
    \     vowel_counter2 = 0;\n        }\n        if vowel_counter == 2 {\n      \
    \      vowel_counter = 0;\n            letter_counter = 0;\n        }\n      \
    \  if letter_counter == 2 {\n            letter_counter\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpq9am_c1y.rs:119:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n19  |     for letter in message\
    \ {\n    |                           - unclosed delimiter\n...\n108 |        \
    \ if letter_counter == 2 {\n    |                                - this delimiter\
    \ might not be properly closed...\n109 |             letter_counter\n110 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n119 | }\n\
    \    |   ^\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpq9am_c1y.rs:20:19\n\
    \   |\n20 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpq9am_c1y.rs:19:19\n\
    \   |\n19 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpq9am_c1y.rs:19:5\n    |\n11  |   fn encode(message:\
    \ String) -> String {\n    |                                 ------ expected `String`\
    \ because of return type\n...\n19  | /     for letter in message {\n20  | |  \
    \       if letter in vowels {\n21  | |             vowel_counter += 1;\n22  |\
    \ |             if vowel_counter == 2 {\n...   |\n118 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    119 | | }\n    | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter = String::new();\n\
    \    let mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let mut vowel_letter\
    \ = String::new();\n    let mut vowel_letter_pos = 0;\n    let mut letter_count\
    \ = vec![0];\n    let mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_letter = String::new();\n    let mut vowel_letter_pos = 0;\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_letter = String::new();\n    let mut vowel_letter_pos\
    \ = 0;\n    let mut letter_count = vec![0];\n    let mut letter_pos = 0;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_letter = String::new();\n    let mut\
    \ vowel_letter_pos = 0;\n    let mut letter_count = vec![0];\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut vowel_letter = String::new();\n\
    \    let mut vowel_letter_pos = 0;\n    let mut letter_count = vec![0];\n    let\
    \ mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let mut vowel_letter =\
    \ String::new();\n    let mut vowel_letter_pos = 0;\n    let mut letter_count\
    \ = vec![0];\n    let mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let\
    \ mut vowel_letter = String::new();\n    let mut vowel_letter_pos = 0;\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut vowel_letter = String::new();\n    let mut vowel_letter_pos\
    \ = 0;\n    let mut letter_count = vec![0];\n    let mut letter_pos = 0;\n   \
    \ let mut vowel_pos = 0;\n    let mut vowel_letter = String::new();\n    let mut\
    \ vowel_letter_pos = 0;\n    let mut letter_count = vec![0];\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut vowel_letter = String::new();\n\
    \    let mut vowel_letter_pos = 0;\n    let mut letter_count = vec![0];\n    let\
    \ mut letter_pos = \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmph6sdjx7e.rs:68:1\n\
    \   |\n68 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for\
    \ c in message.chars() {\n        if let Some(index) = vowels.find(|x| x == c)\
    \ {\n            result.push_str(&letters[(index + 1) % letters.len()]);\n   \
    \     } else {\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpu1yor7e9.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1yor7e9.rs:19:29\n\
    \   |\n19 |             result.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut vowels_index = vowels.len();\n    let mut vowels_index2\
    \ = vowels.len();\n    let mut vowels_index3 = vowels.len();\n    let mut vowels_index4\
    \ = vowels.len();\n    let mut vowels_index5 = vowels.len();\n    let mut vowels_index6\
    \ = vowels.len();\n    let mut vowels_index7 = vowels.len();\n    let mut vowels_index8\
    \ = vowels.len();\n    let mut vowels_index9 = vowels.len();\n    let mut vowels_index10\
    \ = vowels.len();\n    let mut vowels_index11 = vowels.len();\n    let mut vowels_index12\
    \ = vowels.len();\n    let mut vowels_index13 = vowels.len();\n    let mut vowels_index14\
    \ = vowels.len();\n    let mut vowels_index15 = vowels.len();\n    let mut vowels_index16\
    \ = vowels.len();\n    let mut vowels_index17 = vowels.len();\n    let mut vowels_index18\
    \ = vowels.len();\n    let mut vowels_index19 = vowels.len();\n    let mut vowels_index20\
    \ = vowels.len();\n    let mut vowels_index21 = vowels.len();\n    let mut vowels_index22\
    \ = vowels.len();\n    let mut vowels_index23 = vowels.len();\n    let mut vowels_index24\
    \ = vowels.len();\n    let mut vowels_index25 = vowels.len();\n    let mut vowels_index26\
    \ = vowels.len();\n    let mut vowels_index27 = vowels.len();\n    let mut vowels_index28\
    \ = vowels.len();\n    let mut vowels_index29 = vowels.len();\n    let mut vowels_index30\
    \ = vowels.len();\n    let mut vowels_index31 = vowels.len();\n    let mut vowels_index32\
    \ = vowels.len();\n    let mut vowels_index33 = vowels.len();\n    let mut vowels_index34\
    \ = vowels.len();\n    let mut vowels_index35 = vowels.len();\n    let mut vowels_index36\
    \ = vowels.len();\n    let mut vowels_index37 = vowels.len();\n    let mut vowels_index38\
    \ = vowels.len();\n    let mut vowels_index39 = vowels.len();\n\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6v4d4s75.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letter_map = HashMap::new();\n\
    \    let mut letter_counts = HashMap::new();\n    for letter in message.chars()\
    \ {\n        let mut new_letter = letter;\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            new_letter = vowels[vowel + 1];\n        }\n   \
    \     letter_counts.entry(new_letter).or_insert(0);\n        letter_map.entry(new_letter).or_insert(letter);\n\
    \    }\n    for letter in letter_map.keys() {\n        let mut count = 0;\n  \
    \      for vowel in vowels.iter() {\n            if letter_map.get(&vowel).unwrap()\
    \ == letter {\n                count += 1;\n            }\n        }\n       \
    \ if count > 1 {\n            let mut new_letter = letter;\n            if let\
    \ Some(vowel) = vowels.iter().position(|&x| x == letter) {\n                new_letter\
    \ = vowels[vowel + 1];\n            }\n            result += &letter_map.get(&letter).unwrap().to_string();\n\
    \            result += &new_letter.to_string();\n        } else {\n          \
    \  result += &letter_map.get(&letter).unwrap().to_string();\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp3iy35kn2.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp3iy35kn2.rs:15:29\n\
    \   |\n15 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  if letter_counter < 2 {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter++;\n            } else {\n                result.push_str(&vowels[vowel_counter\
    \ - 2]);\n                vowel_counter -= 2;\n            }\n            result.push_str(&letter);\n\
    \            letter_counter++;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp3tzgqdqo.rs:22:30\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 vowel_counter++;\n22 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp3tzgqdqo.rs:28:27\n\
    \   |\n28 |             letter_counter++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |       \
    \      { let tmp = letter_counter; letter_counter += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n28 -            \
    \ letter_counter++;\n28 +             letter_counter += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3tzgqdqo.rs:21:33\n   |\n21 |              \
    \   result.push_str(&vowels[vowel_counter]);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3tzgqdqo.rs:24:33\n   |\n24 |                 result.push_str(&vowels[vowel_counter\
    \ - 2]);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3tzgqdqo.rs:27:29\n\
    \   |\n27 |             result.push_str(&letter);\n   |                      \
    \       ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(index) = vowels.binary_search(&letter) {\n            result.push_str(&vowels_index[index]);\n\
    \            vowels_index[index] += 2;\n        } else {\n            result.push_str(&letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    if letter_counter > 0\
    \ {\n        result.push_str(&vowels_index[vowels.len() - 1]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpknaxxqjp.rs:17:16\n   |\n\
    17 |         if let Some(index) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpknaxxqjp.rs:21:29\n   |\n21 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpknaxxqjp.rs:26:25\n   |\n26 |\
    \         result.push_str(&vowels_index[vowels.len() - 1]);\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found integer\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&{integer}`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut\
    \ letter_counter = 0;\n    for letter in message.chars() {\n        if letter\
    \ == 'A' || letter == 'a' {\n            vowel_counter = 0;\n        }\n     \
    \   if letter == 'E' || letter == 'e' {\n            vowel_counter = 1;\n    \
    \    }\n        if letter == 'I' || letter == 'i' {\n            vowel_counter\
    \ = 2;\n        }\n        if letter == 'O' || letter == 'o' {\n            vowel_counter\
    \ = 3;\n        }\n        if letter == 'U' || letter == 'u' {\n            vowel_counter\
    \ = 4;\n        }\n        if vowel_counter == 0 {\n            result.push('A');\n\
    \        }\n        if vowel_counter == 1 {\n            result.push('B');\n \
    \       }\n        if vowel_counter == 2 {\n            result.push('C');\n  \
    \      }\n        if vowel_counter == 3 {\n            result.push('D');\n   \
    \     }\n        if vowel_counter == 4 {\n            result.push('E');\n    \
    \    }\n        if vowel_counter == 5 {\n            result.push('F');\n     \
    \   }\n        if vowel_counter == 6 {\n            result.push('G');\n      \
    \  }\n        if vowel_counter == 7 {\n            result.push('H');\n       \
    \ }\n        if vowel_counter == 8 {\n            result.push('I');\n        }\n\
    \        if vowel_counter == 9 {\n            result.push('J');\n        }\n \
    \       if vowel_counter == 10 {\n            result.push('K');\n        }\n \
    \       if vowel_counter == 11 {\n            result.push('L');\n        }\n \
    \       if vowel_counter == 12 {\n            result.push('M');\n        }\n \
    \       if vowel_counter == 13 {\n            result.push('N');\n        }\n \
    \       if vowel_counter == 14 {\n            result.push('O');\n        }\n \
    \       if vowel_counter == 15 {\n            result.push('P');\n        }\n \
    \       if vowel_counter == 16 {\n            result.push('Q');\n        }\n \
    \       if vowel_counter == 17 {\n            result.push('R');\n        }\n \
    \       if vowel_counter == 18 {\n            result.push('S');\n        }\n \
    \       if vowel_counter == 19 {\n            result.push('T');\n        }\n \
    \       if vowel_counter == 20 {\n            result.push('U');\n        }\n \
    \       if vowel_counter == 21 {\n            result.push('V');\n        }\n \
    \       if vowel_counter == 22 {\n            result.push('W');\n        }\n \
    \       if vowel_counter == 23 {\n            result.push('X');\n        }\n \
    \       if vowel_counter == 24 {\n            result.push('Y');\n        }\n \
    \       if vowel_counter == 25 {\n            result.\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpiknakaj0.rs:118:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n16  |     for letter in message.chars()\
    \ {\n    |                                   - unclosed delimiter\n...\n107 |\
    \         if vowel_counter == 25 {\n    |                                - this\
    \ delimiter might not be properly closed...\n108 |             result.\n109 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n118\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmpiknakaj0.rs:109:1\n\
    \    |\n109 | }\n    | ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpiknakaj0.rs:108:13\n\
    \    |\n107 | /         if vowel_counter == 25 {\n108 | |             result.\n\
    \    | |             ^^^^^^ expected `()`, found struct `String`\n109 | | }\n\
    \    | |_- expected this to be `()`\n    |\nhelp: you might have meant to return\
    \ this value\n    |\n108 |             return result;.\n    |             ++++++\
    \       +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpiknakaj0.rs:16:5\n\
    \    |\n11  |   fn encode(message: String) -> String {\n    |                \
    \                 ------ expected `String` because of return type\n...\n16  |\
    \ /     for letter in message.chars() {\n17  | |         if letter == 'A' || letter\
    \ == 'a' {\n18  | |             vowel_counter = 0;\n19  | |         }\n...   |\n\
    117 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")),\
    \ String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n118 | | }\n    | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&vowels[vowel + 2]);\n        } else {\n    \
    \        result.push_str(&letter);\n        }\n        letter_counter += 1;\n\
    \        if letter_counter > 2 {\n            result.push_str(&vowels[vowel -\
    \ 2]);\n            letter_counter = 0;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmp8ooaxs1m.rs:23:37\n\
    \   |\n23 |             result.push_str(&vowels[vowel - 2]);\n   |           \
    \                          ^^^^^ help: a local variable with a similar name exists:\
    \ `vowels`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ooaxs1m.rs:16:16\n\
    \   |\n16 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |\
    \                ^^^^^^^^^^^   ----------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8ooaxs1m.rs:19:29\n   |\n19 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_3 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_5 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_6 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_7 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_8 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_9 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31];\n    let mut letters_index_10 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\
    \ 30, 31];\n    let mut letters_index_11 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31];\n    let mut letters_index_12 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpnj0hk4c4.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    let mut letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n\
    \    let mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n\
    \    let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpynut_zax.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpynut_zax.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp74b1tv94.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74b1tv94.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmp4ym_8nmz.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\
    \ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\
    \ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\
    \ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\
    \ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\
    \ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\
    \ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\
    \ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\
    \ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpr7mnim4b.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpr7mnim4b.rs:15:32\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n15 |     let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28,...\n   |                                ^ unclosed delimiter\n16 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  result.push_str(&letters[vowel + 2]);\n        } else {\n            result.push_str(&letters[letter]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjope89c6.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmpjope89c6.rs:20:30\n   |\n20 |   \
    \          result.push_str(&letters[letter]);\n   |                          \
    \    ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[char]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
