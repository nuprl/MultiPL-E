name: HumanEval_97_multiply
language: rust
results:
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpk9dreis_.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpk9dreis_.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpk9dreis_.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpk9dreis_.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpos6lsvb3.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp192lp812.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a > b {\n            a -= b;\n        } else {\n       \
    \     b -= a;\n        }\n        product *= 10;\n    }\n    product\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp5797wpum.rs:16:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n16 |             a -= b;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp5797wpum.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b -= a;\n   |             ^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp2oo75ola.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp2oo75ola.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp2oo75ola.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    let mut product = a;\n    while product > b {\n        product /= 10;\n \
    \   }\n    while product < b {\n        product *= 10;\n    }\n    product\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmp8pnd3trx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= a / 10;\n            a /= 10;\n            b /= 10;\n\
    \        } else if b % 10 == 0 {\n            product *= b / 10;\n           \
    \ b /= 10;\n        } else {\n            product *= a / 10;\n            a /=\
    \ 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpwyk9y57d.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpwyk9y57d.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpwyk9y57d.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n18 |      \
    \       b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpwyk9y57d.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > b {\n        product -= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpg8i1z96i.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut b =\
    \ b % 10;\n        product = product * 10 + a + b;\n        a = a / 10;\n    \
    \    b = b / 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp3pkqzfki.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a * b as isize;\n    if a > b\
    \ {\n        product *= -1;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp6ntm2xhw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > b {\n        product -= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpe39tx9or.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => a,\n        1 => b * 10,\n        _ => a * 10 + b * 10,\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5600`,\n right: `16`', /tmp/tmpe2iigwcl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a / 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            a /= 10;\n            b /= 10;\n        }\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpadxgjyb4.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpadxgjyb4.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpadxgjyb4.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpadxgjyb4.rs:22:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n22 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpcpc0enwa.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpo4vanybz.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpo4vanybz.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpo4vanybz.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpo4vanybz.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!(\"Invalid input\");\n    }\n    let mut product = a as isize;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmprf7mmq99.rs:15:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a > b {\n            product *=\
    \ a % 10;\n            a /= 10;\n        } else {\n            product *= b %\
    \ 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpizijirks.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpizijirks.rs:17:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n17 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpl289jvp0.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n            product *=\
    \ a % 10;\n            a /= 10;\n        }\n        if b > 0 {\n            product\
    \ *= b % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp1q_co_ci.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp1q_co_ci.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpmh6t3rh0.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpoa4d80gr.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a.checked_mul(b.clone()).unwrap();\n\
    \    if product.is_zero() {\n        product = a.clone();\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpbvvl8kky.rs:11:16\n   |\n11 |     if product.is_zero()\
    \ {\n   |                ^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpti0bbv9i.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 {\n        product *= a % 10;\n        a /= 10;\n    }\n\
    \    while b > 0 {\n        product *= b % 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpds4z75lt.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpds4z75lt.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= b;\n            a /= 10;\n            b /= 10;\n \
    \       }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpe6blyffc.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpe6blyffc.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpe6blyffc.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpe6blyffc.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n            product *=\
    \ 10;\n        }\n        product += a;\n        a /= 10;\n        b /= 10;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp7x6r5k84.rs:16:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while b > 0 {\n\
    \        product *= 10;\n        product += b as isize % 10;\n        b = b /\
    \ 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n \
    \   assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpkvm4pg8d.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n17 |      \
    \   b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while product\
    \ < b {\n        product *= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmp5xyba8gj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpi04sr_fz.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpi04sr_fz.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpi04sr_fz.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x,\n        y => y * multiply(b, a - y),\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmp3wm3z69e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 {\n        product *= 10;\n        product += a % 10;\n\
    \        a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9zhsvcjp.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp9zhsvcjp.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp41tffusd.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpik1ww_ba.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 10 {\n        product /= 10;\n    }\n    while product <\
    \ 10 {\n        product *= 10;\n    }\n    product *= b;\n    product\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4120`,\n right: `16`', /tmp/tmpao4lhc7b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 {\n        product *= a % 10;\n        a /= 10;\n    }\n\
    \    while b > 0 {\n        product *= b % 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpur6v2kcq.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpur6v2kcq.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp195yko0q.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a > 0 &&\
    \ b > 0);\n    let mut product = a;\n    while product > 0 {\n        product\
    \ *= b;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp0r3w5hbt.rs:13:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    debug_assert!(a <= b);\n    debug_assert!(a <=\
    \ 10);\n    debug_assert!(b <= 10);\n    debug_assert!(a < b);\n    debug_assert!(a\
    \ < 10);\n    debug_assert!(b < 10);\n    let mut result = 1;\n    while a > 0\
    \ {\n        if a % 10 == 0 {\n            result *= b;\n        }\n        a\
    \ /= 10;\n        b /= 10;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp3fosu0uo.rs:23:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n23 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp3fosu0uo.rs:24:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n24 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpo7oj0dgw.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpo7oj0dgw.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= 10;\n            a /= 10;\n            b /= 10;\n    \
    \    } else {\n            product *= a % 10;\n            a /= 10;\n        }\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_51pe0ck.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp_51pe0ck.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_51pe0ck.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpktqjmjws.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpktqjmjws.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpktqjmjws.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n            product *=\
    \ a % 10;\n            a /= 10;\n        }\n        if b > 0 {\n            product\
    \ *= b % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp8klj3ki0.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp8klj3ki0.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a % 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            a %= 10;\n            b %= 10;\n        }\n    }\n    if\
    \ a > 0 {\n        product *= a;\n    }\n    if b > 0 {\n        product *= b;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmppe60av8z.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmppe60av8z.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmppe60av8z.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmppe60av8z.rs:22:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n22 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp2tw8sjx8.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmphp8tujga.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut carry = 0;\n        if a >\
    \ b {\n            carry = a % b;\n            a = a / b;\n        } else {\n\
    \            carry = b % a;\n            b = b / a;\n        }\n        product\
    \ = product + carry + 1;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `carry` is never read\n  --> /tmp/tmpg2gfzuf8.rs:12:17\n\
    \   |\n12 |         let mut carry = 0;\n   |                 ^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `a`\n\
    \  --> /tmp/tmpg2gfzuf8.rs:15:13\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |             - help: consider making this binding mutable: `mut\
    \ a`\n...\n15 |             a = a / b;\n   |             ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n\
    \  --> /tmp/tmpg2gfzuf8.rs:18:13\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                       - help: consider making this binding mutable:\
    \ `mut b`\n...\n18 |             b = b / a;\n   |             ^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpr7xct4fj.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpr7xct4fj.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpr7xct4fj.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpr7xct4fj.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a == 0 || b == 0 {\n        return 0;\n    }\n\
    \    let mut product = a as isize;\n    while product < b {\n        product *=\
    \ 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n \
    \   assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmphoz1a8hm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 {\n        product *= 10;\n        a -= 1;\n    }\n  \
    \  while b > 0 {\n        product *= 10;\n        b -= 1;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp679aukzx.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp679aukzx.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmptsyo6nnu.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while product\
    \ > 0 {\n        product /= 10;\n    }\n    product *= b;\n    product\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpqz8v5lks.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 || b > 0 {\n        let mut a = a % 10;\n        let mut b =\
    \ b % 10;\n        product = product * 10 + a as isize + b as isize;\n       \
    \ a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp_hnv4hy5.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    debug_assert!(a <= 10);\n    debug_assert!(b\
    \ <= 10);\n    let mut product: isize = 1;\n    while a > 0 {\n        product\
    \ *= b;\n        a -= 1;\n        b *= 10;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmppsjl9du4.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmppsjl9du4.rs:18:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n18 |         b *= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 {\n        product *= a % 10;\n        a /= 10;\n    }\n\
    \    while b > 0 {\n        product *= b % 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp7y30am_k.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp7y30am_k.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 {\n        product *= 10;\n        product += a % 10;\n\
    \        a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpv3hlkt9n.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpv3hlkt9n.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp2ruh8803.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x,\n        _ => a,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmp8ezuiq79.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpmklujzyo.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a % 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            a /= 10;\n            b /= 10;\n        }\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpl_fyft1p.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpl_fyft1p.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpl_fyft1p.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpl_fyft1p.rs:22:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n22 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a_digit = a % 10;\n      \
    \  let mut b_digit = b % 10;\n        product = product * 10 + a_digit + b_digit;\n\
    \        a = a / 10;\n        b = b / 10;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgu0d2b6u.rs:12:13\n\
    \   |\n12 |         let mut a_digit = a % 10;\n   |             ----^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmpgu0d2b6u.rs:13:13\n   |\n13 |         let mut b_digit\
    \ = b % 10;\n   |             ----^^^^^^^\n   |             |\n   |          \
    \   help: remove this `mut`\n\nerror[E0384]: cannot assign to immutable argument\
    \ `a`\n  --> /tmp/tmpgu0d2b6u.rs:15:9\n   |\n9  | fn multiply(a: isize, b: isize)\
    \ -> isize {\n   |             - help: consider making this binding mutable: `mut\
    \ a`\n...\n15 |         a = a / 10;\n   |         ^^^^^^^^^^ cannot assign to\
    \ immutable argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n\
    \  --> /tmp/tmpgu0d2b6u.rs:16:9\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                       - help: consider making this binding mutable:\
    \ `mut b`\n...\n16 |         b = b / 10;\n   |         ^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        product\
    \ = product * a + b;\n        a = a / 10;\n        b = b / 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpu6sxme2r.rs:17:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a + b;\n        a = a / 10;\n\
    \        b = b / 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpb7x5lmh4.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpxv6g7i_q.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a < b {\n        (a, b) = (b, a);\n    }\n  \
    \  let mut product: isize = 1;\n    while a > 0 {\n        product *= a % 10;\n\
    \        a /= 10;\n    }\n    while b > 0 {\n        product *= b % 10;\n    \
    \    b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp790b8fb_.rs:14:10\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         (a, b) = (b,\
    \ a);\n   |          ^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp790b8fb_.rs:14:13\n   |\n9 \
    \ | fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n14 |         (a, b) = (b,\
    \ a);\n   |             ^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `a`\n  --> /tmp/tmp790b8fb_.rs:19:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n19 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp790b8fb_.rs:23:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n23 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= 10;\n        }\n        a /= 10;\n        b /= 10;\n \
    \   }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp75ff733k.rs:15:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n15 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp75ff733k.rs:16:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n16 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmps6gc1obo.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a + b;\n        a = a / 10;\n\
    \        b = b / 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp8jdd2g6l.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp83s4swa0.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a > b {\n            product *=\
    \ a % 10;\n            a /= 10;\n        } else {\n            product *= b %\
    \ 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp3q781wnf.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp3q781wnf.rs:17:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n17 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while b > 0 {\n        product *= b as isize;\n        b -= 1;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpbkp6oj_o.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n13 |      \
    \   b -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= a / 10;\n            a /= 10;\n            b /= 10;\n\
    \        } else {\n            product *= a % 10;\n            a /= 10;\n    \
    \    }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpsb_dn167.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpsb_dn167.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpsb_dn167.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n            product *=\
    \ 10;\n        }\n        else {\n            b -= a;\n            product *=\
    \ 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpm2cn_wiy.rs:16:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmptq4dp4os.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmptq4dp4os.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmptq4dp4os.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmptq4dp4os.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 {\n        product *= b;\n        a -= 1;\n        b -=\
    \ 1;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n  \
    \  assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpsryqf40u.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpsryqf40u.rs:14:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n14 |         b -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmps4qmcl61.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmps4qmcl61.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmps4qmcl61.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmps4qmcl61.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > b {\n        product -= b;\n    }\n    while product < b\
    \ {\n        product += b;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `560`,\n right: `16`', /tmp/tmpgqoc4c6d.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpjdkqkk3y.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a_digit = a%10;\n        let\
    \ mut b_digit = b%10;\n        product = product * 10 + a_digit + b_digit;\n \
    \       a = a / 10;\n        b = b / 10;\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp3xucz7ry.rs:12:13\n\
    \   |\n12 |         let mut a_digit = a%10;\n   |             ----^^^^^^^\n  \
    \ |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmp3xucz7ry.rs:13:13\n   |\n13 |         let mut b_digit\
    \ = b%10;\n   |             ----^^^^^^^\n   |             |\n   |            \
    \ help: remove this `mut`\n\nerror[E0384]: cannot assign to immutable argument\
    \ `a`\n  --> /tmp/tmp3xucz7ry.rs:15:9\n   |\n9  | fn multiply(a: isize, b: isize)\
    \ -> isize {\n   |             - help: consider making this binding mutable: `mut\
    \ a`\n...\n15 |         a = a / 10;\n   |         ^^^^^^^^^^ cannot assign to\
    \ immutable argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n\
    \  --> /tmp/tmp3xucz7ry.rs:16:9\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                       - help: consider making this binding mutable:\
    \ `mut b`\n...\n16 |         b = b / 10;\n   |         ^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpjpr7i2p4.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp7tzijrvf.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        if\
    \ a > b {\n            a -= b;\n        } else {\n            b -= a;\n      \
    \  }\n        product *= a;\n        a /= 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp19qi7bd7.rs:22:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 {\n        product *= 10;\n        product += a % 10;\n\
    \        a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp0mr8imat.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp0mr8imat.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a = a / 10;\n        b = b / 10;\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp_qk3805h.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a = a / 10;\n        b = b / 10;\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpgnowyz_q.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x,\n        y => y * multiply(b, a - x),\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmppvr5xrsx.rs:13:34\n\
    \   |\n13 |         y => y * multiply(b, a - x),\n   |                       \
    \           ^ help: a local variable with a similar name exists: `a`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b.clone()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpfkk1trwh.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => 0,\n        1 => b,\n        _ => a * b,\n    }\n}\n\nfn main() {\n  \
    \  let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp_d68nb3f.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut result = 1;\n    while a > 0 && b > 0 {\n\
    \        let mut carry = 0;\n        if a > b {\n            carry = a % b;\n\
    \            a /= b;\n        } else {\n            carry = b % a;\n         \
    \   b /= a;\n        }\n        result *= carry + 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `carry` is never read\n  --> /tmp/tmpgz82if1k.rs:15:17\n\
    \   |\n15 |         let mut carry = 0;\n   |                 ^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `a`\n\
    \  --> /tmp/tmpgz82if1k.rs:18:13\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |             - help: consider making this binding mutable: `mut\
    \ a`\n...\n18 |             a /= b;\n   |             ^^^^^^ cannot assign to\
    \ immutable argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n\
    \  --> /tmp/tmpgz82if1k.rs:21:13\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                       - help: consider making this binding mutable:\
    \ `mut b`\n...\n21 |             b /= a;\n   |             ^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpvjvfp67o.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpodgi_fqx.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 && b > 0 {\n        product *= 10;\n        b -= 1;\n \
    \   }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpz72zc2dd.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n13 |      \
    \   b -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n            product *=\
    \ a % 10;\n            a /= 10;\n        }\n        if b > 0 {\n            product\
    \ *= b % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpg6luvgti.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpg6luvgti.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_in_zsz4.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp_in_zsz4.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_in_zsz4.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    let mut digits = a.to_string().chars().take(b);\n    while !digits.is_empty()\
    \ {\n        let digit = digits.next().unwrap();\n        product *= digit as\
    \ isize;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08gh8ujb.rs:11:49\n   |\n\
    11 |     let mut digits = a.to_string().chars().take(b);\n   |               \
    \                                  ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut digits = a.to_string().chars().take(b.try_into().unwrap());\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0599]: the method `is_empty` exists for struct `std::iter::Take<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp08gh8ujb.rs:12:19\n \
    \  |\n12 |       while !digits.is_empty() {\n   |                     ^^^^^^^^\
    \ method cannot be called on `std::iter::Take<Chars<'_>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `Chars<'_>: ExactSizeIterator`\n           which is required by `std::iter::Take<Chars<'_>>:\
    \ ExactSizeIterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpj5c3fwz6.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        product\
    \ = product * 10 + a / 10 + b / 10;\n        a = a % 10;\n        b = b % 10;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpzw7gpp5o.rs:17:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpelzyobxn.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 && b > 0 {\n        product *= 10;\n        product +=\
    \ b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmphme31s45.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n14 |      \
    \   b /= 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp2u0lkoxy.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp53y1k7e0.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 || b > 0 {\n        if a > 0 {\n            product *= a % 10;\n\
    \            a /= 10;\n        }\n        if b > 0 {\n            product *= b\
    \ % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp00chxcmb.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp00chxcmb.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= a / 10;\n            a /= 10;\n            b /= 10;\n\
    \        } else {\n            product *= a % 10;\n            a /= 10;\n    \
    \    }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_uy90klr.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp_uy90klr.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_uy90klr.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a % 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            a /= 10;\n            b /= 10;\n        }\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpa8v_7r5r.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpa8v_7r5r.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpa8v_7r5r.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpa8v_7r5r.rs:22:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n22 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 10 {\n        product /= 10;\n    }\n    product\
    \ *= b;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `412`,\n right: `16`', /tmp/tmppsunppk7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product += a % 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product += (b % 10) * 10;\n            a /= 10;\n           \
    \ b /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp3nhslnip.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp3nhslnip.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp3nhslnip.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp3nhslnip.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a == 0 || b == 0 {\n        return 0;\n    }\n\
    \    if a > b {\n        (a, b) = (b, a);\n    }\n    let mut product = a % 10;\n\
    \    product *= b;\n    product %= 10;\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpwz2s_fwo.rs:17:10\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |         (a, b) = (b,\
    \ a);\n   |          ^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpwz2s_fwo.rs:17:13\n   |\n9 \
    \ | fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         (a, b) = (b,\
    \ a);\n   |             ^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => a,\n        1 => b * 10,\n        _ => b * 10 + a,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4268`,\n right: `16`', /tmp/tmpw24fhej8.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product += a % 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product += (b % 10) * 10;\n            b /= 10;\n        }\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp7oo6i46r.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp7oo6i46r.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmp7oo6i46r.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n18 |      \
    \       b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => a,\n        1 => b * 10,\n        _ => b * 10 + a,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4268`,\n right: `16`', /tmp/tmpyc2x5s3j.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp4upk1_fx.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp4upk1_fx.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp4upk1_fx.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp4upk1_fx.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpc0oflu93.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > b {\n        product -= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmp1zsl2zc9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpmhv7sulh.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpw43_xldi.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpw43_xldi.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpw43_xldi.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpa0wir93c.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpxaw_2tlk.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpeenu1kp8.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        if\
    \ a > b {\n            a -= b;\n        } else {\n            b -= a;\n      \
    \  }\n        product *= a;\n        a /= 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpki08_abm.rs:22:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => 0,\n        1 => b * 10,\n        _ => b * 10 + a,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4268`,\n right: `16`', /tmp/tmpt3vxpupt.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpcy5ncugd.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while b > 0 {\n        product *= 10;\n        product += b as isize\
    \ % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmp1mawpxre.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n14 |      \
    \   b /= 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpgvbbxja2.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpgvbbxja2.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 && b > 0 {\n        if product % 10 == b % 10 {\n     \
    \       product /= 10;\n        } else {\n            product *= 10;\n       \
    \ }\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmp3arprlmm.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n17 |      \
    \   b /= 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpvl75an1y.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpvl75an1y.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpvl75an1y.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpvl75an1y.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a + b;\n        a /= 10;\n   \
    \     b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpmte5t2fe.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 {\n        product *= a % 10;\n        a /= 10;\n    }\n\
    \    while b > 0 {\n        product *= b % 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpu8cykg0l.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpu8cykg0l.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpx2rhbg65.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp_2u1eeft.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while product\
    \ > 0 {\n        product /= 10;\n    }\n    product *= b;\n    while product >\
    \ 0 {\n        product /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpm8zbbt9r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a % 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= b;\n            a /= 10;\n            b /= 10;\n \
    \       }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9q2som2r.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp9q2som2r.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9q2som2r.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp9q2som2r.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a / 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= a;\n            a /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpy09zuk4p.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpy09zuk4p.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpy09zuk4p.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp1icj6u2o.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp1icj6u2o.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp39e4w7e2.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp39e4w7e2.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!(\"Invalid input\");\n    }\n    let mut product = a as isize;\n\
    \    while b > 0 {\n        product *= 10;\n        product += b as isize;\n \
    \       b -= 1;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpvyprb8zg.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n17 |      \
    \   b -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpk33m6uq8.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        product\
    \ = product * 10 + a as isize * b as isize;\n        a /= 10;\n        b /= 10;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp7181ciju.rs:17:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpxitw3jjg.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpxitw3jjg.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        let mut a = a % 10;\n        let mut b = b % 10;\n        if\
    \ a > b {\n            a -= b;\n        } else {\n            b -= a;\n      \
    \  }\n        product *= a;\n        a /= 10;\n        b /= 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpnsxj0y8q.rs:22:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n            product *=\
    \ a % 10;\n            a /= 10;\n        }\n        if b > 0 {\n            product\
    \ *= b % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9nx651bd.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp9nx651bd.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp90r8bmwy.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 10 {\n        product /= 10;\n    }\n    while product <\
    \ 10 {\n        product *= 10;\n    }\n    product *= b;\n    product\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4120`,\n right: `16`', /tmp/tmpgggs2tsv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => b * 10 + a / 10,\n        1 => b * 10 + a / 10,\n        _ => b * 10 +\
    \ a / 10 + multiply(a % 10, b),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x,\n        y => y * multiply(b, a - x),\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpnbwgjp0c.rs:13:34\n\
    \   |\n13 |         y => y * multiply(b, a - x),\n   |                       \
    \           ^ help: a local variable with a similar name exists: `a`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    debug_assert!(a < b);\n    let mut product =\
    \ a;\n    while product < b {\n        product *= 10;\n    }\n    product\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmpsyl_p816.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n            product *=\
    \ 10;\n        }\n        else {\n            b -= a;\n            product *=\
    \ 10;\n        }\n        a /= 10;\n        b /= 10;\n    }\n    product\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a + b;\n        a /= 10;\n   \
    \     b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp64__h5v7.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    let mut product = a as isize;\n    while a >\
    \ 0 {\n        product *= b;\n        a -= 1;\n        b -= 1;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp71et71ox.rs:15:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n15 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp71et71ox.rs:16:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n16 |         b -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a % 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            a /= 10;\n            b /= 10;\n        }\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9ri9swv6.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp9ri9swv6.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp9ri9swv6.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp9ri9swv6.rs:22:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n22 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!(\"Invalid input\");\n    }\n    let mut product = a * b as isize;\n\
    \    if product > 100 {\n        product %= 100;\n        product *= 10;\n   \
    \ }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `760`,\n right: `16`', /tmp/tmpf5a4iehh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmptjh7slpf.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmptjh7slpf.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmptjh7slpf.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmptjh7slpf.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp6_yzozq_.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp6_yzozq_.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    let mut product = a;\n    while product > b {\n\
    \        product /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpi7ffv0n3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpkhtdl87y.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product: isize = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == b % 10 {\n            product *= a % 10;\n   \
    \         a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= a % 10;\n            a /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpeog_ih54.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpeog_ih54.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpeog_ih54.rs:21:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 10 {\n        product /= 10;\n    }\n    product\
    \ *= b;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `412`,\n right: `16`', /tmp/tmpdz3n7ufv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    let mut product = a as isize;\n    while b > 0 {\n        product *= 10;\n\
    \        product += b as isize;\n        b -= 1;\n    }\n    product\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpixs13qz4.rs:15:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n15 |      \
    \   b -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpgkj8c7h4.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x * multiply(b, a % b),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpj3_9c_o1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmppm43w2q4.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n            product *=\
    \ 10;\n        }\n        else {\n            b -= a;\n            product *=\
    \ 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmphl9zral7.rs:16:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product += a % 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product += a % 10;\n            a /= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmprkhn4z1z.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmprkhn4z1z.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmprkhn4z1z.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize * b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpupw83f3l.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product *= 10;\n        product += a % 10;\n     \
    \   a /= 10;\n    }\n    while b > 0 {\n        product *= 10;\n        product\
    \ += b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpp8a_ahug.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpp8a_ahug.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x * multiply(b, a / b),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpnxi5oldh.rs:10:11\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    let mut digits = &mut [0; 10];\n    let mut carry = 0;\n    while\
    \ a > 0 || b > 0 {\n        let mut a_digit = a % 10;\n        let mut b_digit\
    \ = b % 10;\n        let mut product = a_digit * b_digit + carry;\n        carry\
    \ = product / 10;\n        product = product % 10;\n        digits[9 - a_digit]\
    \ = product % 10;\n        a = a / 10;\n        b = b / 10;\n    }\n    digits[9]\
    \ = carry;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n   \
    \ assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp3xac9etf.rs:19:9\n   |\n19 |         digits[9 - a_digit] = product %\
    \ 10;\n   |         ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `[{integer}]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut b =\
    \ b % 10;\n        product = product * 10 + a + b;\n        a = a / 10;\n    \
    \    b = b / 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp_0y8dc3j.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a == 0 || b == 0 {\n        return 0;\n    }\n\
    \    if a > b {\n        (a, b) = (b, a);\n    }\n    let mut product = a % 10;\n\
    \    for &d in &b {\n        product *= d;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmpfxevl_r9.rs:20:15\n\
    \   |\n20 |     for &d in &b {\n   |               ^^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a == 0 || b == 0 {\n        return 0;\n    }\n\
    \    let mut product: isize = 1;\n    while a > 0 && b > 0 {\n        if a % 10\
    \ == b % 10 {\n            product *= a % 10;\n            a /= 10;\n        \
    \    b /= 10;\n        } else {\n            product *= b;\n            a /= 10;\n\
    \            b /= 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpupgc2o69.rs:20:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n20 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpupgc2o69.rs:21:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n21 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpupgc2o69.rs:24:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n24 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpupgc2o69.rs:25:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n25 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n            product *=\
    \ 10;\n        }\n        else {\n            b -= a;\n            product *=\
    \ 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp7tfjpev8.rs:16:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            a -= b;\n        } else {\n   \
    \         b -= a;\n        }\n        product *= a;\n        a /= 10;\n      \
    \  b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpdyyn3dhz.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= b;\n            a /= 10;\n            b /= 10;\n \
    \       }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmplnhx80rm.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmplnhx80rm.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmplnhx80rm.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmplnhx80rm.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp21p_8inu.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n\
    \            product *= a / 10;\n            a /= 10;\n            b /= 10;\n\
    \        } else {\n            product *= a % 10;\n            a /= 10;\n    \
    \    }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpag7e_ynj.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpag7e_ynj.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpag7e_ynj.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while product\
    \ < b {\n        product *= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmp6_pwp781.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > b {\n        product /= 10;\n    }\n    while product < b\
    \ {\n        product *= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmpfcixihqb.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 0 {\n        product *= b;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpc884gx0y.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n            product *=\
    \ a % 10;\n            a /= 10;\n        }\n        if b > 0 {\n            product\
    \ *= b % 10;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp74twlhmo.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp74twlhmo.rs:18:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n18 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    let mut carry = 0;\n    while a != 0 {\n        let digit = a % 10;\n   \
    \     product *= digit;\n        product += carry;\n        carry = product /\
    \ 10;\n        product %= 10;\n        a /= 10;\n    }\n    product *= b;\n  \
    \  product += carry;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpim2cqqob.rs:18:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b.clone()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpl_zfbexc.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmppb8vnkbg.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmppb8vnkbg.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmppb8vnkbg.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n            b %= 10;\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpa71ae7jx.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpa71ae7jx.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpa71ae7jx.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpa71ae7jx.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x * multiply(b, a - b),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5y1zleln.rs:12:30\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut product = a as isize;\n    while product\
    \ > 0 {\n        product /= 10;\n    }\n    product *= b;\n    product\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp7kc6ea5x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 && b > 0 {\n        product *= 10;\n        b -= 1;\n \
    \   }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmp9nxg16ew.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n13 |      \
    \   b -= 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a < b {\n        (a, b) = (b, a)\n    }\n   \
    \ let mut product = a * b as isize;\n    if product > 1000 {\n        product\
    \ -= 1000;\n        product *= 10;\n    }\n    product\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpzjncvcwl.rs:14:10\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         (a, b) = (b,\
    \ a)\n   |          ^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpzjncvcwl.rs:14:13\n   |\n9 \
    \ | fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n14 |         (a, b) = (b,\
    \ a)\n   |             ^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x * multiply(b, a - b),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm7qp4pgs.rs:12:30\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        product = product * 10 + a as isize + b as isize;\n   \
    \     a /= 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpebhvnjzf.rs:14:19\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n          \
    \  product *= a / 10;\n            a /= 10;\n            b /= 10;\n        } else\
    \ {\n            product *= a % 10;\n            a %= 10;\n        }\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpffa7j06a.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpffa7j06a.rs:15:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n15 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpffa7j06a.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut\
    \ b = b % 10;\n        if a > b {\n            product = product * 10 + a as isize;\n\
    \            a /= 10;\n        } else {\n            product = product * 10 +\
    \ b as isize;\n            b /= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp0fybe9e2.rs:15:23\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x * multiply(b, a / b),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmp_ds655f6.rs:10:11\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => a,\n        1 => b * 10,\n        _ => b * 10 + a,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4268`,\n right: `16`', /tmp/tmpivftonk3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    let mut carry = 0;\n    while b > 0 {\n        let digit = b % 10;\n    \
    \    product *= digit;\n        product += carry;\n        carry = digit > 9;\n\
    \        b /= 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4ix37yr.rs:16:17\n   |\n\
    11 |     let mut carry = 0;\n   |                     - expected due to this value\n\
    ...\n16 |         carry = digit > 9;\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 && b > 0 {\n        if product % 10 == b % 10 {\n     \
    \       product /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= 10;\n            b *= 10;\n        }\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpor3_emnf.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n14 |      \
    \       b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpor3_emnf.rs:17:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n17 |      \
    \       b *= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    if a < b {\n        let mut c = a;\n        a =\
    \ b;\n        b = c;\n    }\n    let mut product = 1;\n    while a > 0 {\n   \
    \     product *= a % 10;\n        a /= 10;\n    }\n    while b > 0 {\n       \
    \ product *= b % 10;\n        b /= 10;\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvh1_zedf.rs:14:13\n\
    \   |\n14 |         let mut c = a;\n   |             ----^\n   |             |\n\
    \   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `a`\n  -->\
    \ /tmp/tmpvh1_zedf.rs:15:9\n   |\n9  | fn multiply(a: isize, b: isize) -> isize\
    \ {\n   |             - help: consider making this binding mutable: `mut a`\n\
    ...\n15 |         a = b;\n   |         ^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpvh1_zedf.rs:16:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n16 |      \
    \   b = c;\n   |         ^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `a`\n  --> /tmp/tmpvh1_zedf.rs:21:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n21 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpvh1_zedf.rs:25:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n25 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 4 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    while product > 10 {\n        product /= 10;\n    }\n    product\
    \ *= b;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `412`,\n right: `16`', /tmp/tmprwakh8ud.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 && b > 0 {\n        let mut a = a % 10;\n        let mut b =\
    \ b % 10;\n        if a > b {\n            a -= b;\n        } else {\n       \
    \     b -= a;\n        }\n        product *= 10;\n        product += a;\n    \
    \    product += b;\n        a /= 10;\n        b /= 10;\n    }\n    product\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpm02j2b1y.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product > 0 {\n        product *= b;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpwhnhvi6b.rs:12:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
