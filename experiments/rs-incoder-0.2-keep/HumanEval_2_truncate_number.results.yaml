name: HumanEval_2_truncate_number
language: rust
results:
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut decimal_part = 0.0;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp9pis18jx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        integer\
    \ += remainder;\n        remainder -= 0.0;\n    }\n    integer + decimals\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    if exponent < 0 {\n        return result;\n\
    \    }\n    while exponent > 0 {\n        remainder += 1.0;\n        result *=\
    \ 10.0;\n        result -= remainder;\n        exponent = exponent - 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-123.0`,\n right: `0.5`', /tmp/tmp2haf09_7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp30_4gi7f.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        integer_part += number.mantissa() * (f64::pow(10.0,\
    \ exponent) - 1.0);\n        remainder += number.mantissa() * (f64::pow(10.0,\
    \ exponent - 1) - 1.0);\n        decimal_part += remainder;\n        exponent--;\n\
    \    }\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpd17ed65z.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpd17ed65z.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpd17ed65z.rs:13:32\n   |\n13 |         integer_part += number.mantissa()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n   |                                ^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no function or associated item named\
    \ `pow` found for type `f64` in the current scope\n  --> /tmp/tmpd17ed65z.rs:13:51\n\
    \   |\n13 |         integer_part += number.mantissa() * (f64::pow(10.0, exponent)\
    \ - 1.0);\n   |                                                   ^^^\n   |  \
    \                                                 |\n   |                    \
    \                               function or associated item not found in `f64`\n\
    \   |                                                   help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0599]: no method named `mantissa`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpd17ed65z.rs:14:29\n\
    \   |\n14 |         remainder += number.mantissa() * (f64::pow(10.0, exponent\
    \ - 1) - 1.0);\n   |                             ^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no function or associated item named `pow` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpd17ed65z.rs:14:48\n   |\n14 |\
    \         remainder += number.mantissa() * (f64::pow(10.0, exponent - 1) - 1.0);\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            function or associated item not found in `f64`\n   |            \
    \                                    help: there is an associated function with\
    \ a similar name: `powf`\n\nerror: ab"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += remainder;\n    decimal_part + integer_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpp8ohs2kh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut fraction = number.fract();\n\
    \    while exponent > 0 {\n        fraction *= 10.0;\n        remainder += fraction;\n\
    \        fraction -= remainder;\n        decimal_part += remainder;\n        remainder\
    \ = 0.0;\n        exponent--;\n    }\n    decimal_part + fraction\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp09cmtnc6.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder += 1.0;\n    \
    \    integer += remainder;\n        decimals += remainder;\n        number -=\
    \ remainder;\n    }\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: variable `decimals` is assigned to, but never used\n --> /tmp/tmpy6exl9m7.rs:8:13\n\
    \  |\n8 |     let mut decimals = 0.0;\n  |             ^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_decimals`\
    \ instead\n\nwarning: variable `integer` is assigned to, but never used\n -->\
    \ /tmp/tmpy6exl9m7.rs:9:13\n  |\n9 |     let mut integer = 0.0;\n  |         \
    \    ^^^^^^^\n  |\n  = note: consider using `_integer` instead\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpy6exl9m7.rs:15:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n15 | \
    \        number -= remainder;\n   |         ^^^^^^^^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.floor() as\
    \ i32;\n    let mut fraction = number.sub_f64();\n    while exponent > 0 {\n \
    \       result += (fraction.powi(exponent) as f64).recip();\n        exponent\
    \ = exponent - 1;\n        fraction = fraction.sub_f64();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sub_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpqtp1_1kq.rs:10:31\n   |\n10 |     let mut fraction = number.sub_f64();\n\
    \   |                               ^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += integer_part * 10.0;\n        integer_part = 0.0;\n \
    \       exponent--;\n    }\n    remainder += number.remainder(&mut integer_part);\n\
    \    decimal_part += integer_part * 10.0;\n    integer_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpvsd814p2.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpvsd814p2.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpvsd814p2.rs:13:29\n   |\n13 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `remainder` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpvsd814p2.rs:18:25\n   |\n18 |     remainder\
    \ += number.remainder(&mut integer_part);\n   |                         ^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.bit_count() - 1;\n    while exponent >= 0 {\n        let mut\
    \ part = number / 10.0;\n        result += (part * remainder).floor();\n     \
    \   remainder = part % 10.0;\n        number -= remainder * 10.0;\n        exponent--;\n\
    \    }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp9axzd6n0.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `bit_count` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp9axzd6n0.rs:10:31\n   |\n10 |     let mut exponent = number.bit_count()\
    \ - 1;\n   |                               ^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number.abs();\n   \
    \ while remainder > 1.0 {\n        leftover_part += 1.0;\n        remainder -=\
    \ 1.0;\n    }\n    while remainder > 0.1 {\n        leftover_part += 0.1;\n  \
    \      remainder -= 0.1;\n    }\n    while remainder > 0.01 {\n        leftover_part\
    \ += 0.01;\n        remainder -= 0.01;\n    }\n    while remainder > 0.001 {\n\
    \        leftover_part += 0.001;\n        remainder -= 0.001;\n    }\n    while\
    \ remainder > 0.0001 {\n        leftover_part += 0.0001;\n        remainder -=\
    \ 0.0001;\n    }\n    while remainder > 0.00001 {\n        leftover_part += 0.00001;\n\
    \        remainder -= 0.00001;\n    }\n    while remainder > 0.0000001 {\n   \
    \     leftover_part += 0.0000001;\n        remainder -= 0.0000001;\n    }\n  \
    \  while remainder > 0.000000001 {\n        leftover_part += 0.000000001;\n  \
    \      remainder -= 0.000000001;\n    }\n    while remainder > 0.0000000001 {\n\
    \        leftover_part += 0.0000000001;\n        remainder -= 0.0000000001;\n\
    \    }\n    while remainder > 0.00000000001 {\n        leftover_part += 0.00000000001;\n\
    \        remainder -= 0.00000000001;\n    }\n    while remainder > 0.000000000001\
    \ {\n        leftover_part += 0.000000000001;\n        remainder -= 0.000000000001;\n\
    \    }\n    while remainder > 0.0000000000001 {\n        leftover_part += 0.0000000000001;\n\
    \        remainder -= 0.0000000000001;\n    }\n    while remainder > 0.000000000000001\
    \ {\n        leftover_part += 0.000000000000001;\n        remainder -= 0.000000000000001;\n\
    \    }\n    while remainder > 0.0000000000000001 {\n        leftover_part += 0.0000000000000001;\n\
    \        remainder -= 0.0000000000000001;\n    }\n    while remainder > 0.00000000000000001\
    \ {\n        leftover_part += 0.00000000000000001;\n        remainder -= 0.00000000000000001;\n\
    \    }\n    while remainder > 0.000000000000000001 {\n        leftover_part +=\
    \ 0.000000000000000001;\n        remainder -= 0.000000000000000001;\n    }\n \
    \   while remainder > 0.0000000000000000001 {\n        leftover_part += 0.000000000000000000\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph8scwd02.rs:85:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n76 |     while remainder > 0.0000000000000000001\
    \ {\n   |                                             - this delimiter might not\
    \ be properly closed...\n77 |         leftover_part += 0.000000000000000000\n\
    78 | }\n   | - ...as it matches this but it has different indentation\n...\n85\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmph8scwd02.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += integer_part * std::pow::<f64>(10.0, exponent);\n   \
    \     integer_part += remainder;\n        exponent--;\n    }\n    decimal_part\
    \ + integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp52iywcso.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `pow` in crate `std`\n  --> /tmp/tmp52iywcso.rs:14:45\n\
    \   |\n14 |         decimal_part += integer_part * std::pow::<f64>(10.0, exponent);\n\
    \   |                                             ^^^ not found in `std`\n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp52iywcso.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp52iywcso.rs:13:29\n   |\n13 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut remainder_part = remainder % 10.0;\n    \
    \    remainder /= 10.0;\n        integer_part += remainder_part;\n        leftover_part\
    \ += remainder_part * 10.0;\n    }\n    integer_part += leftover_part;\n    decimal_part\
    \ = integer_part / 10.0;\n    integer_part %= 10.0;\n    leftover_part %= 10.0;\n\
    \    integer_part += leftover_part;\n    decimal_part += integer_part / 10.0;\n\
    \    integer_part %= 10.0;\n    leftover_part %= 10.0;\n    integer_part += leftover_part;\n\
    \    decimal_part += integer_part / 10.0;\n    integer_part %= 10.0;\n    leftover_part\
    \ %= 10.0;\n    integer_part += leftover_part;\n    decimal_part += integer_part\
    \ / 10.0;\n    integer_part %= 10.0;\n    leftover_part %= 10.0;\n    integer_part\
    \ += leftover_part;\n    decimal_part += integer_part / 10.0;\n    integer_part\
    \ %= 10.0;\n    leftover_part %= 10.0;\n    integer_part += leftover_part;\n \
    \   decimal_part += integer_part / 10.0;\n    integer_part %= 10.0;\n    leftover_part\
    \ %= 10.0;\n    integer_part += leftover_part;\n    decimal_part += integer_part\
    \ / 10.0;\n    integer_part %= 10.0;\n    leftover_part %= 10.0;\n    integer_part\
    \ += leftover_part;\n    decimal_part += integer_part / 10.0;\n    integer_part\
    \ %= 10.0;\n    leftover_part %= 10.0;\n    integer_part += leftover_part;\n \
    \   decimal_part += integer_part / 10.0;\n    integer_part %= 10.0;\n    leftover_part\
    \ %= 10.0;\n    integer_part += leftover_part;\n    decimal_part += integer_part\
    \ / 10.0;\n    integer_part %= 10.0;\n    leftover_part %= 10.0;\n    integer_part\
    \ += leftover_part;\n    decimal_part += integer_part / 10.0;\n    integer_part\
    \ %= 10.0;\n    leftover_part %= 10.0;\n    integer_part += leftover_part;\n \
    \   decimal_part += integer_part / 10.0;\n    integer_part %= 10.0;\n    leftover_part\
    \ %= 10.\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4at0wzd7.rs:65:5\n   |\n\
    7  | fn truncate_number(number: f64) -> f64 {\n   |                          \
    \          --- expected `f64` because of return type\n...\n65 |     leftover_part\
    \ %= 10.\n   |     ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number.abs();\n    while remainder > 1.0 {\n        integer_part\
    \ += 1.0;\n        remainder -= 1.0;\n    }\n    integer_part += remainder;\n\
    \    decimal_part = remainder - integer_part;\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp4kvzgbg_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.remainder(&mut result);\n        result *= 10.0;\n        exponent--;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpdlx6z9j_.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpdlx6z9j_.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpdlx6z9j_.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ result);\n   |                             ^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpo2udz7pu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer.saturating_add(remainder);\n        decimals = decimals.saturating_add(1.0);\n\
    \        number = number / 10.0;\n    }\n    integer.saturating_add(decimals)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `saturating_add` on ambiguous numeric type\
    \ `{float}`\n  --> /tmp/tmpxhm18i1p.rs:13:27\n   |\n13 |         integer = integer.saturating_add(remainder);\n\
    \   |                           ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a\
    \ type for this binding, like `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpxhm18i1p.rs:14:29\n   |\n\
    14 |         decimals = decimals.saturating_add(1.0);\n   |                  \
    \           ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `f32`\n   |\n8  |     let mut decimals: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `saturating_add` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpxhm18i1p.rs:17:13\n   |\n17 |     integer.saturating_add(decimals)\n\
    \   |             ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n   |      \
    \   ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        leftover_part += 1.0;\n        remainder -= 1.0;\n\
    \    }\n    while remainder > 0.0 {\n        integer_part += 1.0;\n        remainder\
    \ -= 0.0;\n    }\n    integer_part += leftover_part;\n    decimal_part = remainder;\n\
    \    integer_part * f64::from(f64::from(decimal_part))\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.ceil() as f64;\n\
    \    while exponent > 0 {\n        remainder *= 10.0;\n        remainder += fraction;\n\
    \        fraction *= 10.0;\n        exponent--;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp58utwxrn.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    if number < 0.0 {\n        integer_part =\
    \ -number;\n        decimal_part = -number;\n    } else {\n        integer_part\
    \ = number;\n    }\n\n    while integer_part > 0.0 {\n        remainder = integer_part\
    \ % 10.0;\n        integer_part = integer_part / 10.0;\n        decimal_part +=\
    \ remainder;\n    }\n\n    decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.888888888888889`,\n right: `0.5`', /tmp/tmp4uh6yn5r.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut fraction = number.fract();\n\
    \    while exponent > 0 {\n        remainder += fraction;\n        decimal_part\
    \ += remainder;\n        remainder *= 10.0;\n        exponent--;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp5bn43cyn.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.abs().floor()\
    \ as i32;\n    let mut remainder = number.abs().floor() as f64;\n    while exponent\
    \ > 0 {\n        if exponent % 2 == 1 {\n            result -= remainder;\n  \
    \      }\n        remainder *= 10.0;\n        result += (exponent - 1) / 2;\n\
    \        exponent = exponent / 2;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `i32` to `f64`\n  --> /tmp/tmppjhf3caj.rs:16:16\n\
    \   |\n16 |         result += (exponent - 1) / 2;\n   |                ^^ no implementation\
    \ for `f64 += i32`\n   |\n   = help: the trait `AddAssign<i32>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        integer += number % 10.0;\n\
    \        number /= 10.0;\n        decimals += number;\n        remainder += number;\n\
    \    }\n    decimals -= remainder;\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: variable `decimals` is assigned to, but never used\n --> /tmp/tmpz4vcyva6.rs:8:13\n\
    \  |\n8 |     let mut decimals = 0.0;\n  |             ^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_decimals`\
    \ instead\n\nwarning: value assigned to `decimals` is never read\n  --> /tmp/tmpz4vcyva6.rs:17:5\n\
    \   |\n17 |     decimals -= remainder;\n   |     ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpz4vcyva6.rs:13:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n13 | \
    \        number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_negative = false;\n    let mut remainder_positive\
    \ = false;\n    let mut exponent = number.f64();\n    let mut exponent = exponent.floor();\n\
    \    loop {\n        if exponent == 0.0 {\n            break;\n        }\n   \
    \     let mut remainder_power = 0.0;\n        let mut remainder_power_negative\
    \ = false;\n        let mut remainder_power_positive = false;\n        let mut\
    \ power = 1.0;\n        let mut power_negative = 1.0;\n        let mut power_positive\
    \ = 1.0;\n        let mut exponent = exponent.floor();\n        let mut exponent\
    \ = exponent.floor();\n        while exponent != 0.0 {\n            let mut remainder_power\
    \ = 0.0;\n            let mut remainder_power_negative = false;\n            let\
    \ mut remainder_power_positive = false;\n            let mut power = 1.0;\n  \
    \          let mut power_negative = 1.0;\n            let mut power_positive =\
    \ 1.0;\n            let mut exponent = exponent.floor();\n            let mut\
    \ exponent = exponent.floor();\n            while exponent != 0.0 {\n        \
    \        let mut remainder_power = 0.0;\n                let mut remainder_power_negative\
    \ = false;\n                let mut remainder_power_positive = false;\n      \
    \          let mut power = 1.0;\n                let mut power_negative = 1.0;\n\
    \                let mut power_positive = 1.0;\n                let mut exponent\
    \ = exponent.floor();\n                let mut exponent = exponent.floor();\n\
    \                while exponent != 0.0 {\n                    let mut remainder_power\
    \ = 0.0;\n                    let mut remainder_power_negative = false;\n    \
    \                let mut remainder_power_positive = false;\n                 \
    \   let mut power = 1.0;\n                    let mut power_negative = 1.0;\n\
    \                    let mut power_positive = 1.0;\n                    let mut\
    \ exponent = exponent.floor();\n                    let mut exponent = exponent.floor();\n\
    \                    while exponent != 0.0 {\n                        let mut\
    \ remainder_power = 0.0;\n                        let mut remainder_power_negative\
    \ = false;\n                        let mut remainder_power_positive = false;\n\
    \                        let mut power = 1.0;\n                        let mut\
    \ power_negative = 1.0;\n                        let mut power_positive = 1.0;\n\
    \                        let mut exponent = exponent.floor();\n              \
    \          let mut exponent = exponent.floor();\n                        while\
    \ exponent != 0.0 {\n                            let mut remainder_power = 0.0;\n\
    \                            \n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf4jm_9h1.rs:73:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n15 |     loop {\n   |       \
    \   - unclosed delimiter\n...\n27 |         while exponent != 0.0 {\n   |    \
    \                           - unclosed delimiter\n...\n36 |             while\
    \ exponent != 0.0 {\n   |                                   - unclosed delimiter\n\
    ...\n45 |                 while exponent != 0.0 {\n   |                      \
    \                 - unclosed delimiter\n...\n54 |                     while exponent\
    \ != 0.0 {\n   |                                           - unclosed delimiter\n\
    ...\n63 |                         while exponent != 0.0 {\n   |              \
    \                                 - this delimiter might not be properly closed...\n\
    ...\n66 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    73 | }\n   |   ^\n\nerror[E0599]: no method named `f64` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpf4jm_9h1.rs:13:31\n   |\n13 |     let mut exponent\
    \ = number.f64();\n   |                               ^^^ method not found in\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf4jm_9h1.rs:17:13\n \
    \  |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                    \
    \                --- expected `f64` because of return type\n...\n17 |        \
    \     break;\n   |             ^^^^^\n   |             |\n   |             expected\
    \ `f64`, found `()`\n   |             help: give it a value of the expected type:\
    \ `break 3.14159`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number.to_f64();\n    while mantissa\
    \ > 1.0 {\n        mantissa /= 10.0;\n        exponent++;\n    }\n    while mantissa\
    \ > 1.0 {\n        mantissa /= 10.0;\n        exponent--;\n    }\n    while mantissa\
    \ > 1.0 {\n        mantissa /= 10.0;\n        exponent++;\n    }\n    while mantissa\
    \ > 1.0 {\n        mantissa /= 10.0;\n        exponent--;\n    }\n    mantissa\
    \ -= 1.0;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent += 1;\n    exponent\
    \ %= 6;\n    exponent += 1;\n    exponent %= 6;\n    exponent \n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2oainrhc.rs:14:17\n\
    \   |\n14 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n14 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n14 -\
    \         exponent++;\n14 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmp2oainrhc.rs:18:19\n   |\n18 |         exponent--;\n\
    \   |                   ^ expected expression\n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp2oainrhc.rs:22:17\n   |\n22 |         exponent++;\n\
    \   |                 ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n22 |         { let tmp = exponent; exponent += 1; tmp };\n  \
    \ |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n22 -         exponent++;\n\
    22 +         exponent += 1;\n   | \n\nerror: expected expression, found `;`\n\
    \  --> /tmp/tmp2oainrhc.rs:26:19\n   |\n26 |         exponent--;\n   |       \
    \            ^ expected expression\n\nerror[E0599]: no method named `to_f64` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2oainrhc.rs:11:31\n   |\n\
    11 |     let mut mantissa = number.to_f64();\n   |                           \
    \    ^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmp2oainrhc.rs:103:5\n    |\n7   | fn truncate_number(number: f64) -> f64\
    \ {\n    |                                    --- expected `f64` because of return\
    \ type\n...\n103 |     exponent \n    |     ^^^^^^^^ expected `f64`, found integer\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        let mut remainder_part\
    \ = remainder;\n        remainder_part *= 10.0;\n        if remainder_part > number.f64::max_value()\
    \ {\n            remainder_part -= number.f64::max_value();\n        }\n     \
    \   result += remainder_part;\n        remainder /= 10.0;\n        exponent =\
    \ exponent.sub(f64::from(1.0));\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmptqcc8dxn.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: expected `{`, found `::`\n  --> /tmp/tmptqcc8dxn.rs:14:39\n\
    \   |\n14 |         if remainder_part > number.f64::max_value() {\n   |      \
    \   --                            ^^ expected `{`\n   |         |\n   |      \
    \   this `if` expression has a condition, but no block\n   |\nhelp: try placing\
    \ this code inside a block\n   |\n14 |         if remainder_part > number.f64{\
    \ ::max_value() } {\n   |                                       +            \
    \   +\n\nerror: invalid const generic expression\n  --> /tmp/tmptqcc8dxn.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         let mut remainder_part\
    \ = remainder;\n13 | |         remainder_part *= 10.0;\n14 | |         if remainder_part\
    \ > number.f64::max_value() {\n...  |\n19 | |         exponent = exponent.sub(f64::from(1.0));\n\
    20 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n11 ~     { while exponent > 0.0\
    \ {\n12 |         let mut remainder_part = remainder;\n13 |         remainder_part\
    \ *= 10.0;\n14 |         if remainder_part > number.f64::max_value() {\n15 | \
    \            remainder_part -= number.f64::max_value();\n16 |         }\n ...\n\
    \nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n\
    \  --> /tmp/tmptqcc8dxn.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = 0.0;\n    let mut bits =\
    \ 0.0;\n    let mut exponents = 0.0;\n    let mut bits_left = number.bits();\n\
    \    let mut bits_right = bits_left;\n    let mut bits_total = bits_left;\n  \
    \  let mut bits_total_left = bits_left;\n    let mut bits_total_right = bits_left;\n\
    \    let mut bits_total_total = bits_left;\n    let mut bits_total_total_left\
    \ = bits_left;\n    let mut bits_total_total_right = bits_left;\n    let mut bits_total_total_total\
    \ = bits_left;\n    let mut bits_total_total_total_left = bits_left;\n    let\
    \ mut bits_total_total_total_right = bits_left;\n    let mut bits_total_total_total_total\
    \ = bits_left;\n    let mut bits_total_total_total_total_left = bits_left;\n \
    \   let mut bits_total_total_total_total_right = bits_left;\n    let mut bits_total_total_total_total_total\
    \ = bits_left;\n    let mut bits_total_total_total_total_total_left = bits_left;\n\
    \    let mut bits_total_total_total_total_total_right = bits_left;\n    let mut\
    \ bits_total_total_total_total_total_total = bits_left;\n    let mut bits_total_total_total_total_total_total_left\
    \ = bits_left;\n    let mut bits_total_total_total_total_total_total_right = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total = bits_left;\n   \
    \ let mut bits_total_total_total_total_total_total_total_left = bits_left;\n \
    \   let mut bits_total_total_total_total_total_total_total_right = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total_total = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total_total_left = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total_total_right = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total_total_total = bits_left;\n\
    \    let mut bits_total_total_total_total_total_total_total_total_total_left =\
    \ bits_left;\n    let mut bits_total_total_total_total_total_total_total_total_total_right\
    \ = bits_left;\n    let mut bits_total_total_total_total_total_total_total_total_total_total\
    \ = bits_left;\n    let mut bits_total_total_total_total_total_total_total_total_total_total_left\
    \ = bits_left;\n    let mut bits_total_total_total_total_total_\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyxtiwdao.rs:45:48\n   |\n\
    45 |     let mut bits_total_total_total_total_total_\n   |                   \
    \                             ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `bits` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpyxtiwdao.rs:14:32\n   |\n14 |     let mut bits_left = number.bits();\n\
    \   |                                ^^^^ help: there is an associated function\
    \ with a similar name: `to_bits`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpyxtiwdao.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.ceil()\
    \ as f64;\n    while exponent > 0 {\n        mantissa = mantissa * 10.0;\n   \
    \     exponent = exponent - 1;\n    }\n    mantissa = mantissa * 10.0;\n    exponent\
    \ += 1;\n    while exponent < 0 {\n        mantissa = mantissa * 10.0;\n     \
    \   exponent = exponent + 1;\n    }\n    mantissa = mantissa * 10.0;\n    exponent\
    \ -= 1;\n    mantissa = mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n\
    \    mantissa = mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n  \
    \  mantissa = mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa\
    \ = mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa =\
    \ mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa = mantissa\
    \ * 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa = mantissa *\
    \ 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa = mantissa * 10.0;\n\
    \    mantissa = mantissa.round() as f64;\n    mantissa = mantissa * 10.0;\n  \
    \  mantissa = mantissa.round() as f64;\n    mantissa = mantissa * 10.0;\n    mantissa\
    \ = mantissa.round() as f64;\n    mantissa = mantissa * 10.0;\n    mantissa =\
    \ mantissa.round() as f64;\n    mantissa = mantissa * 10.0;\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa = mantissa * 10.0;\n    mantissa = mantissa.round() as\
    \ f64;\n    mantissa = mantissa * 10.0;\n    mantissa = mantissa.round() as f64;\n\
    \    mantissa = manti\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `manti` in this scope\n  --> /tmp/tmpqi3uuhbp.rs:52:16\n\
    \   |\n52 |     mantissa = manti\n   |                ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent).unwrap());\n        result += (number\
    \ - remainder).trunc();\n        exponent--;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmptkh1uwkm.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmptkh1uwkm.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmptkh1uwkm.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmptkh1uwkm.rs:12:66\n   |\n12 |\
    \         remainder += number.fract() * (f64::powf(10.0, exponent).unwrap());\n\
    \   |                                                                  ^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\n \
    \   while exponent > 0 {\n        remainder += 1.0;\n        integer_part += 1.0;\n\
    \        decimal_part += remainder;\n        remainder /= 10.0;\n        exponent--;\n\
    \    }\n\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2xk9g22g.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp2xk9g22g.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number > 0.0 {\n       \
    \ let remainder = number % 10.0;\n        result += (number - remainder) / 10.0;\n\
    \        number = remainder;\n        exponent++;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmp78_w_610.rs:10:47\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\n \
    \   while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += number.remainder(&mut remainder);\n        exponent--;\n\
    \    }\n\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpys1ls_40.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpys1ls_40.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpys1ls_40.rs:14:29\n   |\n14 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `remainder` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpys1ls_40.rs:15:32\n   |\n15 |         decimal_part\
    \ += number.remainder(&mut remainder);\n   |                                ^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    let mut fraction = number.fraction();\n \
    \   while exponent > 0 {\n        if exponent % 2 == 1 {\n            result +=\
    \ (fraction / 10.0);\n            fraction = fraction.trunc();\n        } else\
    \ {\n            result += (fraction / 10.0);\n            fraction = fraction.trunc();\n\
    \            exponent /= 2;\n        }\n    }\n    result + fraction\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpgrl0cm3y.rs:14:23\n\
    \   |\n14 |             result += (fraction / 10.0);\n   |                   \
    \    ^               ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n14 -             result += (fraction / 10.0);\n\
    14 +             result += fraction / 10.0;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmpgrl0cm3y.rs:17:23\n   |\n17 |         \
    \    result += (fraction / 10.0);\n   |                       ^              \
    \ ^\n   |\nhelp: remove these parentheses\n   |\n17 -             result += (fraction\
    \ / 10.0);\n17 +             result += fraction / 10.0;\n   | \n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpgrl0cm3y.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `fraction` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpgrl0cm3y.rs:11:31\n   |\n11 |     let mut fraction = number.fraction();\n\
    \   |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `fract`\n\nerror: aborting due to 2 previous errors; 2\
    \ warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent - 1;\n    let mut remainder_fraction = number.fract();\n    while remainder_exponent\
    \ > 0 {\n        remainder_fraction *= 10.0;\n        remainder_exponent -= 1;\n\
    \    }\n    if remainder_fraction != 0.0 {\n        remainder *= 10.0;\n     \
    \   remainder_fraction -= remainder;\n    }\n    decimal_part += remainder;\n\
    \    decimal_part / 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmpfduk8c69.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpdljua004.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number >= 1.0 {\n    \
    \    return number;\n    }\n\n    if number < 1.0 {\n        integer_part = number;\n\
    \        leftover_part = 0.0;\n    } else {\n        integer_part = 0.0;\n   \
    \     leftover_part = number;\n    }\n\n    while integer_part < 1.0 {\n     \
    \   integer_part *= 10.0;\n        leftover_part *= 10.0;\n    }\n\n    decimal_part\
    \ = integer_part - leftover_part;\n    decimal_part /= 10.0;\n\n    return decimal_part;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `decimal_part` is never read\n --> /tmp/tmpkokcwl9i.rs:8:13\n\
    \  |\n8 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_assignments)]` on by default\n  = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `integer_part`\
    \ is never read\n --> /tmp/tmpkokcwl9i.rs:9:13\n  |\n9 |     let mut integer_part\
    \ = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n  = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `leftover_part` is never read\n\
    \  --> /tmp/tmpkokcwl9i.rs:10:13\n   |\n10 |     let mut leftover_part = 0.0;\n\
    \   |             ^^^^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before\
    \ being read?\n\nwarning: value assigned to `leftover_part` is never read\n  -->\
    \ /tmp/tmpkokcwl9i.rs:13:9\n   |\n13 |         leftover_part = number;\n   | \
    \        ^^^^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmpkokcwl9i.rs:14:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n14 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 4 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        remainder += 1.0;\n        integer += remainder;\n        decimals\
    \ += remainder;\n        remainder /= 10.0;\n        exponent /= 10.0;\n    }\n\
    \    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpf408gbef.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    // We need to keep track of how many\
    \ digits we have\n    // to keep track of leftover part (always smaller than 1).\n\
    \    let mut num_digits = number.log10();\n    let mut num_digits_left = num_digits;\n\
    \n    // We need to keep track of how many digits we have\n    // to keep track\
    \ of integer part (always smaller than the number itself).\n    let mut num_digits_integer\
    \ = num_digits;\n\n    // We need to keep track of how many digits we have\n \
    \   // to keep track of decimal part (always smaller than 1).\n    let mut num_digits_decimal\
    \ = num_digits;\n\n    // We need to keep track of how many digits we have\n \
    \   // to keep track of integer part (always smaller than the number itself).\n\
    \    let mut num_digits_integer = num_digits;\n\n    // We need to keep track\
    \ of how many digits we have\n    // to keep track of decimal part (always smaller\
    \ than 1).\n    let mut num_digits_decimal = num_digits;\n\n    // We need to\
    \ keep track of how many digits we have\n    // to keep track of integer part\
    \ (always smaller than the number itself).\n    let mut num_digits_integer = num_digits;\n\
    \n    // We need to keep track of how many digits we have\n    // to keep track\
    \ of decimal part (always smaller than 1).\n    let mut num_digits_decimal = num_digits;\n\
    \n    // We need to keep track of how many digits we have\n    // to keep track\
    \ of integer part (always smaller than the number itself).\n    let mut num_digits_integer\
    \ = num_digits;\n\n    // We need to keep track of how many digits we have\n \
    \   // to keep track of decimal part (always smaller than 1).\n    let mut num_digits_decimal\
    \ = num_digits;\n\n    // We need to keep track of how many digits we have\n \
    \   // to keep track of integer part (always smaller than the number itself).\n\
    \    let mut num_digits_integer = num_digits;\n\n    // We need to keep track\
    \ of how many digits we have\n    // to keep track of decimal part (always smaller\
    \ than 1).\n    let mut num_digits_decimal = num_digits;\n\n    // We need to\
    \ keep track of how many digits we have\n    // to keep track of integer part\
    \ (always smaller than the number itself).\n    let mut num_digits_integer = num_digits;\n\
    \n    // We need to keep track of how many digits we have\n    // to keep track\
    \ of decimal part (always smaller than 1).\n    let mut num_digits_decimal = num_digits;\n\
    \n    // We need to keep track of how many digits we have\n    // to keep track\
    \ of integer part (always smaller than the number itself).\n    let mut num_\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbs75bpye.rs:67:17\n   |\n\
    67 |     let mut num_\n   |                 ^ help: add `;` here\n68 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpbs75bpye.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    let mut decimal\
    \ = number.fract();\n    if decimal < 1.0 {\n        integer = integer - decimal;\n\
    \    }\n    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpnsaxiruq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut max_integer_part = 0.0;\n    let\
    \ mut max_decimal_part = 0.0;\n    let mut max_leftover_part = 0.0;\n    let mut\
    \ min_integer_part = 0.0;\n    let mut min_decimal_part = 0.0;\n    let mut min_leftover_part\
    \ = 0.0;\n    let mut max_number = number;\n    let mut min_number = number;\n\
    \    let mut max_leftover_part = 0;\n    let mut min_leftover_part = 0;\n    let\
    \ mut max_decimal_part = 0;\n    let mut min_decimal_part = 0;\n    let mut max_integer_part\
    \ = 0;\n    let mut min_integer_part = 0;\n    let mut max_number = number;\n\
    \    let mut min_number = number;\n    let mut max_leftover_part = 0;\n    let\
    \ mut min_leftover_part = 0;\n    let mut max_decimal_part = 0;\n    let mut min_decimal_part\
    \ = 0;\n    let mut max_integer_part = 0;\n    let mut min_integer_part = 0;\n\
    \    while max_number > 0.0 {\n        let mut decimal_part = max_number % 1.0;\n\
    \        max_number /= 1.0;\n        max_decimal_part = max(max_decimal_part,\
    \ decimal_part);\n        max_integer_part = max(max_integer_part, integer_part);\n\
    \        leftover_part = max(leftover_part, max_leftover_part);\n        if max_number\
    \ < 1.0 {\n            max_number += 1.0;\n            max_integer_part = max(max_integer_part,\
    \ integer_part);\n            max_decimal_part = max(max_decimal_part, decimal_part);\n\
    \            leftover_part = max(leftover_part, max_leftover_part);\n        }\n\
    \    }\n    while min_number < 0.0 {\n        let mut decimal_part = min_number\
    \ % 1.0;\n        min_number /= 1.0;\n        min_decimal_part = min(min_decimal_part,\
    \ decimal_part);\n        min_integer_part = min(min_integer_part, integer_part);\n\
    \        leftover_part = min(leftover_part, min_leftover_part);\n        if min_number\
    \ > 0.0 {\n            min_number += 1.0;\n            min_integer_part = min(min_integer_part,\
    \ integer_part);\n            min_decimal_part = min(min_decimal_part, decimal_part);\n\
    \            leftover_part = min(leftover_part, min_leftover_part);\n        }\n\
    \    }\n    let mut integer_part = max_integer_part + min_integer_part;\n    let\
    \ mut decimal_part = max_decimal_part + min_decimal_part;\n    integer_part +=\
    \ leftover_part;\n    decimal_part += leftover_part;\n    integer_part += max_integer_part;\n\
    \    \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:36:28\n\
    \   |\n36 |         max_decimal_part = max(max_decimal_part, decimal_part);\n\
    \   |                            ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:37:28\n\
    \   |\n37 |         max_integer_part = max(max_integer_part, integer_part);\n\
    \   |                            ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:38:25\n\
    \   |\n38 |         leftover_part = max(leftover_part, max_leftover_part);\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:41:32\n\
    \   |\n41 |             max_integer_part = max(max_integer_part, integer_part);\n\
    \   |                                ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:42:32\n\
    \   |\n42 |             max_decimal_part = max(max_decimal_part, decimal_part);\n\
    \   |                                ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpt6bl68_1.rs:43:29\n\
    \   |\n43 |             leftover_part = max(leftover_part, max_leftover_part);\n\
    \   |                             ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpt6bl68_1.rs:49:28\n\
    \   |\n49 |         min_decimal_part = min(min_decimal_part, decimal_part);\n\
    \   |                            ^^^\n...\n67 | fn main() {\n   | ---------"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n       \
    \ let mut next_remainder = remainder * 10.0;\n        if next_remainder >= number\
    \ {\n            decimal_part += next_remainder - number;\n            remainder\
    \ = next_remainder;\n        } else {\n            decimal_part += number;\n \
    \           remainder = next_remainder;\n        }\n        number /= 10.0;\n\
    \        exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpez42k4mv.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: expected expression, found `;`\n  --> /tmp/tmpez42k4mv.rs:21:19\n\
    \   |\n21 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: invalid const generic expression\n  --> /tmp/tmpez42k4mv.rs:11:5\n  \
    \ |\n11 | /     while exponent > 0.0 {\n12 | |         let mut next_remainder\
    \ = remainder * 10.0;\n13 | |         if next_remainder >= number {\n14 | |  \
    \           decimal_part += next_remainder - number;\n...  |\n21 | |         exponent--;\n\
    22 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n11 ~     { while exponent > 0.0\
    \ {\n12 |         let mut next_remainder = remainder * 10.0;\n13 |         if\
    \ next_remainder >= number {\n14 |             decimal_part += next_remainder\
    \ - number;\n15 |             remainder = next_remainder;\n16 |         } else\
    \ {\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n  --> /tmp/tmpez42k4mv.rs:10:34\n   |\n10 |     let mut exponent\
    \ = number.f64::exp();\n   |                                  ^^ expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to 4 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmprl0n79s0.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    if exponent < 0 {\n        // number is negative\n\
    \        exponent = -exponent;\n    }\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        result *= 10.0;\n        result += (number % 1.0) * remainder;\n\
    \        number /= 10.0;\n        exponent--;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp026hoofe.rs:20:19\n\
    \   |\n20 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp026hoofe.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    while exponent > 0 {\n        let mut digit = last_digit as i32;\n\
    \        if digit == 10 {\n            digit = 0;\n            last_digit = 0;\n\
    \        }\n        last_digit = digit;\n        remainder *= 10.0;\n        remainder\
    \ += digit;\n        decimal_part += remainder;\n        exponent--;\n    }\n\
    \    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp07z73l21.rs:22:19\n\
    \   |\n22 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0277]: cannot add-assign `i32` to `{float}`\n  --> /tmp/tmp07z73l21.rs:20:19\n\
    \   |\n20 |         remainder += digit;\n   |                   ^^ no implementation\
    \ for `{float} += i32`\n   |\n   = help: the trait `AddAssign<i32>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    quotient += remainder;\n    quotient\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpvvxhfcpy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp4corjxsg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    let mut mantissa = number.f64::mantissa();\n\
    \    while exponent > 0.0 {\n        if exponent % 2 == 1 {\n            exponent\
    \ /= 2;\n            mantissa /= 10.0;\n        } else {\n            exponent\
    \ /= 2;\n            mantissa *= 10.0;\n        }\n        remainder += mantissa;\n\
    \    }\n    result = remainder + result;\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmphg0h8ua6.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), let mut mantissa = number.f64::mantissa();\n   |      \
    \                                   ~\n\nerror: expected one of `!`, `+`, `,`,\
    \ `->`, `::`, `:`, `=`, or `>`, found `;`\n  --> /tmp/tmphg0h8ua6.rs:11:46\n \
    \  |\n11 |     let mut mantissa = number.f64::mantissa();\n   |              \
    \                                ^ expected one of 8 possible tokens\n   |\nhelp:\
    \ use a comma to separate type parameters\n   |\n11 |     let mut mantissa = number.f64::mantissa(),\
    \ while exponent > 0.0 {\n   |                                              ~\n\
    \nerror: invalid const generic expression\n  --> /tmp/tmphg0h8ua6.rs:12:5\n  \
    \ |\n12 | /     while exponent > 0.0 {\n13 | |         if exponent % 2 == 1 {\n\
    14 | |             exponent /= 2;\n15 | |             mantissa /= 10.0;\n... \
    \ |\n20 | |         remainder += mantissa;\n21 | |     }\n   | |_____^\n   |\n\
    help: expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n12 ~     { while exponent > 0.0 {\n13 |         if exponent % 2 == 1 {\n\
    14 |             exponent /= 2;\n15 |             mantissa /= 10.0;\n16 |    \
    \     } else {\n17 |             exponent /= 2;\n ...\n\nerror: invalid const\
    \ generic expression\n  --> /tmp/tmphg0h8ua6.rs:11:5\n   |\n11 |     let mut mantissa\
    \ = number.f64::mantissa();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp:\
    \ expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n11 |     { let mut mantissa = number.f64 }::mantissa();\n   |     +   \
    \                            +\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`,\
    \ or an operator, found `::`\n  --> /tmp/tmphg0h8ua6.rs:10:34\n   |\n10 |    \
    \ let mut exponent = number.f64::exp();\n   |                                \
    \  ^^ expected one of `(`, `.`, `;`, "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.is_negative() ? -number.abs() as i32 : number.abs()\
    \ as i32;\n    while exponent > 0 {\n        remainder += 1.0;\n        decimal_part\
    \ += remainder;\n        exponent -= 1;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpolljsrpi.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.abs() as i32\
    \ : number.abs() as i32;\n   |                                               \
    \ ^^^^^^^^^^^^^^^^^^^---------\n   |                                         \
    \                          |\n   |                                           \
    \                        help: remove the type ascription\n\nerror[E0573]: expected\
    \ type, found local variable `number`\n  --> /tmp/tmpolljsrpi.rs:10:70\n   |\n\
    10 |     let mut exponent = number.is_negative() ? -number.abs() as i32 : number.abs()\
    \ as i32;\n   |                                                              \
    \        ^^^^^^ expecting a type here because of type ascription\n\nwarning: use\
    \ of deprecated associated function `core::f64::<impl f64>::is_negative`: renamed\
    \ to is_sign_negative\n  --> /tmp/tmpolljsrpi.rs:10:31\n   |\n10 |     let mut\
    \ exponent = number.is_negative() ? -number.abs() as i32 : number.abs() as i32;\n\
    \   |                               ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: the `?` operator can only be applied to values\
    \ that implement `Try`\n  --> /tmp/tmpolljsrpi.rs:10:24\n   |\n10 |     let mut\
    \ exponent = number.is_negative() ? -number.abs() as i32 : number.abs() as i32;\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be\
    \ applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpolljsrpi.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut decimal_part = 0.0;\n9  | |     let mut remainder\
    \ = 0.0;\n10 | |     let mut exponent = number.is_negative() ? -number.abs() as\
    \ i32 : number.abs() as i32;\n   | |                                         \
    \    ^ cannot use the `?` operator in a function that returns `f64`\n...  |\n\
    16 | |     decimal_part + remainder\n17 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpsgfjih30.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    if number < 0.0 {\n        integer_part =\
    \ -number;\n        decimal_part = 0.0;\n    } else {\n        integer_part =\
    \ number;\n    }\n\n    while integer_part > 0.0 {\n        remainder = integer_part\
    \ % 10.0;\n        integer_part = integer_part / 10.0;\n        decimal_part +=\
    \ remainder;\n    }\n\n    decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.888888888888889`,\n right: `0.5`', /tmp/tmpz7q1er75.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        integer_part += number.mantissa() * (f64::pow(10.0,\
    \ exponent) - 1.0);\n        remainder += number.mantissa();\n        decimal_part\
    \ += remainder * (f64::pow(10.0, exponent - 1) - 1.0);\n        exponent -= 1;\n\
    \    }\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5ylhhiwy.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp5ylhhiwy.rs:13:32\n   |\n13 |         integer_part += number.mantissa()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n   |                                ^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no function or associated item named\
    \ `pow` found for type `f64` in the current scope\n  --> /tmp/tmp5ylhhiwy.rs:13:51\n\
    \   |\n13 |         integer_part += number.mantissa() * (f64::pow(10.0, exponent)\
    \ - 1.0);\n   |                                                   ^^^\n   |  \
    \                                                 |\n   |                    \
    \                               function or associated item not found in `f64`\n\
    \   |                                                   help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0599]: no method named `mantissa`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp5ylhhiwy.rs:14:29\n\
    \   |\n14 |         remainder += number.mantissa();\n   |                    \
    \         ^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no function or associated\
    \ item named `pow` found for type `f64` in the current scope\n  --> /tmp/tmp5ylhhiwy.rs:15:43\n\
    \   |\n15 |         decimal_part += remainder * (f64::pow(10.0, exponent - 1)\
    \ - 1.0);\n   |                                           ^^^\n   |          \
    \                                 |\n   |                                    \
    \       function or associated item not found in `f64`\n   |                 \
    \                          help: there is an associated function with a similar\
    \ name: `powf`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        remainder += 1.0;\n        integer += remainder;\n        decimals\
    \ += remainder;\n        exponent = exponent - 1.0;\n    }\n    decimals\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmppnointx5.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ number.floor() as i32;\n    let mut remainder_fraction = number.floor() as i32;\n\
    \    while exponent > 0 {\n        remainder_fraction = remainder_fraction * 10.0;\n\
    \        remainder_exponent -= 1;\n        if remainder_exponent == 0 {\n    \
    \        decimal_part += remainder_fraction;\n            remainder_fraction =\
    \ 0.0;\n            remainder_exponent = -3;\n        }\n        exponent -= 1;\n\
    \    }\n    decimal_part + remainder_fraction\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `i32` by `{float}`\n  --> /tmp/tmpr50lygiy.rs:14:49\n\
    \   |\n14 |         remainder_fraction = remainder_fraction * 10.0;\n   |    \
    \                                             ^ no implementation for `i32 * {float}`\n\
    \   |\n   = help: the trait `Mul<{float}>` is not implemented for `i32`\n   =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n             <&'a\
    \ f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128\
    \ as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as\
    \ Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]:\
    \ cannot add-assign `i32` to `{float}`\n  --> /tmp/tmpr50lygiy.rs:17:26\n   |\n\
    17 |             decimal_part += remainder_fraction;\n   |                   \
    \       ^^ no implementation for `{float} += i32`\n   |\n   = help: the trait\
    \ `AddAssign<i32>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr50lygiy.rs:18:34\n   |\n12 |     let mut remainder_fraction\
    \ = number.floor() as i32;\n   |                                  ---------------------\
    \ expected due to this value\n...\n18 |             remainder_fraction = 0.0;\n\
    \   |                                  ^^^ expected `i32`, found floating-point\
    \ number\n\nerror[E0277]: cannot add `i32` to `{float}`\n  --> /tmp/tmpr50lygiy.rs:23:18\n\
    \   |\n23 |     decimal_part + remainder_fraction\n   |                  ^ no\
    \ implementation for `{float} + i32`\n   |\n   = help: the trait `Add<i32>` is\
    \ not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 a"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        let mut remainder_part\
    \ = remainder;\n        let mut integer_part = number.trunc();\n        if integer_part\
    \ == 0.0 {\n            integer_part = 1.0;\n        }\n        remainder_part\
    \ += integer_part;\n        result += (integer_part * remainder_part).recip();\n\
    \        exponent--;\n        remainder = remainder_part.recip();\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpy5w0mv2b.rs:19:19\n\
    \   |\n19 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpy5w0mv2b.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpk2twjtrm.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut remainder_sign = 1.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut exponent = exponent as i32;\n    let mut decimal_part_sign = 1.0;\n\
    \    let mut decimal_part_exponent = 1.0;\n    let mut decimal_part_exponent =\
    \ decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as i32;\n    let mut decimal_part_exponent = decimal_part_exponent as i32;\n\
    \    let mut decimal_part_exponent = decimal_part_exponent as i32;\n    let mut\
    \ decimal_part_exponent = decimal_part_exponent as i32;\n    let mut decimal_part_exponent\
    \ = decimal_part_exponent as i32;\n    let mut decimal_part_exponent = decimal_part_exponent\
    \ as \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpymb0g5s_.rs:47:1\n   |\n\
    47 | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 0.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpuruplc9_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        remainder -= 1.0;\n        integer_part += 1.0;\n\
    \        leftover_part += 1.0;\n    }\n    integer_part += leftover_part;\n  \
    \  decimal_part = remainder / integer_part;\n    integer_part -= decimal_part\
    \ * integer_part;\n    leftover_part -= decimal_part * leftover_part;\n    decimal_part\
    \ += leftover_part;\n    integer_part += 1.0;\n    leftover_part += 1.0;\n   \
    \ decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    integer_part += 1.0;\n    leftover_part\
    \ += 1.0;\n    decimal_part += leftover_part;\n    \n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk45z0kpt.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpygdaa_i8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_sign = 1.0;\n    let mut remainder_magnitude = 0.0;\n    let mut\
    \ integer_part = 0.0;\n    let mut integer_part_sign = 1.0;\n    let mut integer_part_magnitude\
    \ = 0.0;\n    let mut integer_part_magnitude_decimals = 0.0;\n    let mut integer_part_magnitude_remainder\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_sign = 1.0;\n    let mut\
    \ integer_part_magnitude_remainder_magnitude = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_decimals\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder = 0.0;\n\
    \    let mut integer_part_magnitude_remainder_magnitude_remainder_sign = 1.0;\n\
    \    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude =\
    \ 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_decimals\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_sign\
    \ = 1.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_decimals\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_sign\
    \ = 1.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_decimals\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_sign\
    \ = 1.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude\
    \ = 0.0;\n    let mut integer_part_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_remainder_magnitude_decimals\
    \ = 0.0;\n    let mut \n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3jh8y25k.rs:37:1\n\
    \   |\n37 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut sign = 1.0;\n    let mut exponent\
    \ = 0.0;\n    let mut mantissa = number.to_f64();\n    loop {\n        integer_part\
    \ += mantissa * sign;\n        leftover_part += mantissa;\n        mantissa *=\
    \ 10.0;\n        exponent += 1.0;\n        if mantissa < 1.0 {\n            break;\n\
    \        }\n        mantissa /= 10.0;\n        sign *= -1.0;\n    }\n    decimal_part\
    \ = leftover_part / integer_part;\n    decimal_part + integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp_d4cqkyr.rs:13:31\n   |\n13 |     let mut mantissa = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpsq6e2_ul.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        leftover_part += 1.0;\n\
    \    }\n    while remainder > 0.0 {\n        remainder -= 1.0;\n        integer_part\
    \ += 1.0;\n    }\n    integer_part += leftover_part;\n    decimal_part = remainder;\n\
    \    integer_part * f64::from(f64::from(decimal_part))\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2.0`,\n right: `0.5`', /tmp/tmplg832jlr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        integer += exponent / 10.0;\n        decimals += exponent % 10.0;\n\
    \        exponent = exponent / 10.0;\n    }\n    remainder += decimals;\n    integer\
    \ += remainder;\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpga85g2gf.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut remainder_sign = 1.0;\n    let mut last_digit\
    \ = 0.0;\n    let mut last_digit_sign = 1.0;\n    let mut last_digit_exponent\
    \ = 0.0;\n    let mut last_digit_remainder = 0.0;\n    let mut last_digit_remainder_sign\
    \ = 1.0;\n    let mut last_digit_remainder_exponent = 0.0;\n    let mut last_digit_remainder_remainder\
    \ = 0.0;\n    let mut last_digit_remainder_remainder_sign = 1.0;\n    let mut\
    \ last_digit_remainder_remainder_exponent = 0.0;\n    let mut last_digit_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digit_remainder_remainder_remainder_sign = 1.0;\n \
    \   let mut last_digit_remainder_remainder_remainder_exponent = 0.0;\n    let\
    \ mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n    let mut last_digit_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digit_remainder_remainder_remainder_exponent = 0.0;\n\
    \    let mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n    let\
    \ mut last_digit_remainder_remainder_remainder_sign = 1.0;\n    let mut last_digit_remainder_remainder_remainder_exponent\
    \ = 0.0;\n    let mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n\
    \    let mut last_digit_remainder_remainder_remainder_sign = 1.0;\n    let mut\
    \ last_digit_remainder_remainder_remainder_exponent = 0.0;\n    let mut last_digit_remainder_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digit_remainder_remainder_remainder_sign = 1.0;\n \
    \   let mut last_digit_remainder_remainder_remainder_exponent = 0.0;\n    let\
    \ mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n    let mut last_digit_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digit_remainder_remainder_remainder_exponent = 0.0;\n\
    \    let mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n    let\
    \ mut last_digit_remainder_remainder_remainder_sign = 1.0;\n    let mut last_digit_remainder_remainder_remainder_exponent\
    \ = 0.0;\n    let mut last_digit_remainder_remainder_remainder_remainder = 0.0;\n\
    \    let mut last_digit_remainder_remainder_remainder_sign = 1.0;\n    let mut\
    \ last_digit_remainder_remainder_remainder_exponent = 0.0;\n    let mut last_digit_remainder_\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwllvvloh.rs:45:34\n   |\n\
    45 |     let mut last_digit_remainder_\n   |                                 \
    \ ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpwllvvloh.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.is_negative() ? 1 : 0;\n   \
    \ while number > 0.0 {\n        remainder += 1.0;\n        number -= remainder;\n\
    \        integer += remainder;\n        decimals += remainder;\n        exponent++;\n\
    \    }\n    number + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmp1vpatymz.rs:11:47\n   |\n11 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut exponent = number.exponent();\n\
    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            integer_part\
    \ += number.fract().unwrap();\n        }\n        leftover_part += number.fract().unwrap();\n\
    \        decimal_part += number.fract().unwrap();\n        exponent /= 2;\n  \
    \  }\n\n    integer_part + leftover_part + decimal_part\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpk0z3ue8z.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpk0z3ue8z.rs:15:44\n\
    \   |\n15 |             integer_part += number.fract().unwrap();\n   |       \
    \                                     ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpk0z3ue8z.rs:17:41\n\
    \   |\n17 |         leftover_part += number.fract().unwrap();\n   |          \
    \                               ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpk0z3ue8z.rs:18:40\n\
    \   |\n18 |         decimal_part += number.fract().unwrap();\n   |           \
    \                             ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap());\n        } else {\n            truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        }\n        remainder = remainder.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        exponent = exponent / 2;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpu1o2cmey.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpu1o2cmey.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 0\
    \ {\n13 | |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap());\n14 | |         } else {\n...  |\n18 | |         exponent\
    \ = exponent / 2;\n19 | |     }\n   | |_____^\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n11 ~     { while\
    \ exponent > 0.0 {\n12 |         if exponent % 2 == 0 {\n13 |             truncated\
    \ = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap());\n14 |     \
    \    } else {\n15 |             truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    16 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n  --> /tmp/tmpu1o2cmey.rs:10:34\n   |\n10 |     let\
    \ mut exponent = number.f64::exp();\n   |                                  ^^\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpgjgsb2m0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number;\n    while mantissa >\
    \ 0.0 {\n        remainder += 1.0;\n        mantissa /= 10.0;\n        exponent++;\n\
    \    }\n    mantissa += remainder;\n    mantissa *= 10.0;\n    exponent -= 1;\n\
    \    mantissa = mantissa.round() as f64;\n    decimal_part = mantissa / 10.0;\n\
    \    mantissa %= 10.0;\n    exponent += 1;\n    decimal_part += mantissa;\n  \
    \  decimal_part /= 10.0;\n    decimal_part += remainder;\n    decimal_part *=\
    \ 10.0;\n    exponent -= 1;\n    decimal_part += 1.0;\n    decimal_part /= 10.0;\n\
    \    decimal_part += remainder;\n    decimal_part *= 10.0;\n    exponent -= 1;\n\
    \    decimal_part += 1.0;\n    decimal_part /= 10.0;\n    decimal_part += remainder;\n\
    \    decimal_part *= 10.0;\n    exponent -= 1;\n    decimal_part += 1.0;\n   \
    \ decimal_part /= 10.0;\n    decimal_part += remainder;\n    decimal_part *= 10.0;\n\
    \    exponent -= 1;\n    decimal_part += 1.0;\n    decimal_part /= 10.0;\n   \
    \ decimal_part += remainder;\n    decimal_part *= 10.0;\n    exponent -= 1;\n\
    \    decimal_part += 1.0;\n    decimal_part /= 10.0;\n    decimal_part += remainder;\n\
    \    decimal_part *= 10.0;\n    exponent -= 1;\n    decimal_part += 1.0;\n   \
    \ decimal_part /= 10.0;\n    decimal_part += remainder;\n    decimal_part *= 10.0;\n\
    \    exponent -= 1;\n    decimal_part += 1.0;\n    decimal_part /= 10.0;\n   \
    \ decimal_part += remainder;\n    decimal_part *= 10.0;\n    exponent -= 1;\n\
    \    decimal_part += 1.0;\n    decimal_part /= 10.0;\n    decimal_part += remainder;\n\
    \    decimal_part *= 10.0;\n    exponent -= 1;\n    decimal_part += 1.0;\n   \
    \ decimal_part /= 10.0;\n    decimal_part += remainder;\n    decimal_part *= 10.0;\n\
    \    exponent -= 1;\n    decimal_part += 1.0;\n    decimal_part /= 10.0;\n   \
    \ decimal_part += remainder;\n    decimal_part *= 10.0;\n    exponent -= 1;\n\
    \    decimal_part += 1.0;\n    decimal_part /= \n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd8hp2rcj.rs:15:17\n\
    \   |\n15 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n15 -\
    \         exponent++;\n15 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpd8hp2rcj.rs:81:1\n   |\n81 | }\n   | ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.to_f64();\n    while exponent > 0.0 {\n        let mut remainder_part\
    \ = remainder;\n        let mut integer_part = 0.0;\n        if exponent < 1.0\
    \ {\n            integer_part = exponent as f64;\n            exponent -= 1.0;\n\
    \        } else {\n            integer_part = 1.0;\n            exponent -= 2.0;\n\
    \        }\n        remainder_part += integer_part * number.to_f64();\n      \
    \  result = remainder_part + result;\n        remainder = 0.0;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpmf7q5mdx.rs:10:31\n   |\n10 |     let mut exponent = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpmf7q5mdx.rs:21:49\n\
    \   |\n21 |         remainder_part += integer_part * number.to_f64();\n   |  \
    \                                               ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut decimal_part);\n        number -= remainder;\n    \
    \    exponent -= 1;\n    }\n    number\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpew776r2z.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpew776r2z.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp0zbs9pv8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += 1.0;\n        integer_part += remainder;\n\
    \        remainder /= 10.0;\n        decimal_part += remainder;\n        exponent\
    \ -= 1;\n    }\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpljevdci4.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.floor() as f64;\n    while exponent\
    \ > 0 {\n        remainder *= 10.0;\n        decimal += remainder / 10.0;\n  \
    \      remainder %= 10.0;\n        exponent -= 1;\n    }\n    decimal\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmpx7dgcu6d.rs:13:9\n\
    \   |\n13 |         decimal += remainder / 10.0;\n   |         ^^^^^^^ help: a\
    \ local variable with a similar name exists: `decimals`\n\nerror[E0425]: cannot\
    \ find value `decimal` in this scope\n  --> /tmp/tmpx7dgcu6d.rs:17:5\n   |\n17\
    \ |     decimal\n   |     ^^^^^^^ help: a local variable with a similar name exists:\
    \ `decimals`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpw_4_selb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.floor() as i32;\n    let mut decimal_part = 0.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    while exponent > 0 {\n        let mut next_decimal_part\
    \ = 0.0;\n        let mut next_remainder = 0.0;\n        if exponent & 1 == 1\
    \ {\n            next_decimal_part = number;\n            next_remainder = 1.0;\n\
    \        } else {\n            next_decimal_part = remainder;\n            next_remainder\
    \ = truncated * 10.0;\n        }\n        let mut next_exponent = exponent - 1;\n\
    \        while next_exponent > 0 {\n            if next_exponent & 1 == 1 {\n\
    \                next_decimal_part *= 10.0;\n            } else {\n          \
    \      next_decimal_part /= 10.0;\n            }\n            next_exponent >>=\
    \ 1;\n        }\n        truncated = next_decimal_part + next_remainder;\n   \
    \     remainder = truncated - number;\n        exponent = next_exponent;\n   \
    \ }\n    truncated + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5.5`,\n right: `0.5`', /tmp/tmp7usyrrr5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number > 0.0 {\n       \
    \ remainder += 1.0;\n        result *= 10.0;\n        if number % 1.0 == 0.0 {\n\
    \            result -= remainder;\n            remainder = 0.0;\n        }\n \
    \       number /= 10.0;\n        exponent++;\n    }\n    result * remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmp04fvmygc.rs:10:47\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.ceil() as f64;\n    while exponent >\
    \ 0 {\n        if exponent % 2 == 1 {\n            decimals += remainder;\n  \
    \      }\n        remainder *= 10.0;\n        exponent /= 2;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `44.0`,\n right: `0.5`', /tmp/tmp84vefe3w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut remainder_sign = 1.0;\n    let mut\
    \ max_integer = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_decimal\
    \ = 0.0;\n    let mut min_decimal = 0.0;\n    let mut max_remainder = 0.0;\n \
    \   let mut min_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n    let\
    \ mut min_remainder_sign = 1.0;\n    let mut max_sign = 1.0;\n    let mut min_sign\
    \ = 1.0;\n    let mut max_exponent = 0.0;\n    let mut min_exponent = 0.0;\n \
    \   let mut max_exponent_increment = 0.0;\n    let mut min_exponent_increment\
    \ = 0.0;\n    let mut max_exponent_increment_sign = 1.0;\n    let mut min_exponent_increment_sign\
    \ = 1.0;\n    let mut max_decimal_sign = 1.0;\n    let mut min_decimal_sign =\
    \ 1.0;\n    let mut max_decimal_exponent = 0.0;\n    let mut min_decimal_exponent\
    \ = 0.0;\n    let mut max_decimal_exponent_increment = 0.0;\n    let mut min_decimal_exponent_increment\
    \ = 0.0;\n    let mut max_decimal_exponent_increment_sign = 1.0;\n    let mut\
    \ min_decimal_exponent_increment_sign = 1.0;\n    let mut max_integer = 0.0;\n\
    \    let mut min_integer = 0.0;\n    let mut max_decimal = 0.0;\n    let mut min_decimal\
    \ = 0.0;\n    let mut max_remainder = 0.0;\n    let mut min_remainder = 0.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut min_remainder_sign = 1.0;\n\
    \    let mut max_sign = 1.0;\n    let mut min_sign = 1.0;\n    let mut max_exponent\
    \ = 0.0;\n    let mut min_exponent = 0.0;\n    let mut max_exponent_increment\
    \ = 0.0;\n    let mut min_exponent_increment = 0.0;\n    let mut max_exponent_increment_sign\
    \ = 1.0;\n    let mut min_exponent_increment_sign = 1.0;\n    let mut max_decimal_sign\
    \ = 1.0;\n    let mut min_decimal_sign = 1.0;\n    let mut max_decimal_exponent\
    \ = 0.0;\n    let mut min_decimal_exponent = 0.0;\n    let mut max_decimal_exponent_increment\
    \ = 0.0;\n    let mut min_decimal_exponent_increment = 0.0;\n    let mut max_decimal_exponent_increment_sign\
    \ = 1.0;\n    let mut min_decimal_exponent_increment_sign = 1.0;\n    let mu\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk3labxxd.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk3labxxd.rs:7:36\n  |\n\
    7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------         \
    \        ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += 1.0;\n        integer_part += remainder;\n\
    \        remainder *= 10.0;\n        exponent--;\n    }\n    integer_part += remainder;\n\
    \    decimal_part = number.fract();\n    integer_part += decimal_part;\n    integer_part\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmplffc1j_2.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmplffc1j_2.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub(f64::from(number)).abs();\n\
    \    while fraction > 1.0 {\n        fraction = fraction.sub(f64::from(fraction)).abs();\n\
    \        exponent = exponent + 1;\n    }\n    if exponent > 0 {\n        result\
    \ = number.powf(f64::from(exponent));\n    }\n    while fraction > 0.0 {\n   \
    \     remainder = fraction.sub(f64::from(fraction)).abs();\n        result = remainder.powf(f64::from(exponent\
    \ - 1));\n        fraction = remainder;\n        exponent = exponent - 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sub` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpuy3q5lkb.rs:11:31\n    |\n11  |     let mut fraction =\
    \ number.sub(f64::from(number)).abs();\n    |                               ^^^\
    \ method not found in `f64`\n    |\n    = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Sub;\n\
    \    |\n\nerror[E0689]: can't call method `powf` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpuy3q5lkb.rs:21:28\n   |\n21 |         result = remainder.powf(f64::from(exponent\
    \ - 1));\n   |                            ^^^^\n   |\nhelp: you must specify a\
    \ type for this binding, like `f32`\n   |\n9  |     let mut remainder: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::MIN;\n    let mut remainder = f64::MIN;\n\
    \    let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut exponent = f64::MIN;\n\n    let mut decimal_power = f64::MIN;\n    let mut\
    \ decimal_remainder = f64::MIN;\n\n    let mut remainder_power = f64::MIN;\n \
    \   let mut power = f64::MIN;\n    let mut exponent = f64::MIN;\n\n    let mut\
    \ decimal_power = f64::MIN;\n    let mut decimal_remainder = f64::MIN;\n\n   \
    \ let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut exponent = f64::MIN;\n\n    let mut decimal_power = f64::MIN;\n    let mut\
    \ decimal_remainder = f64::MIN;\n\n    let mut remainder_power = f64::MIN;\n \
    \   let mut power = f64::MIN;\n    let mut exponent = f64::MIN;\n\n    let mut\
    \ decimal_power = f64::MIN;\n    let mut decimal_remainder = f64::MIN;\n\n   \
    \ let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut exponent = f64::MIN;\n\n    let mut decimal_power = f64::MIN;\n    let mut\
    \ decimal_remainder = f64::MIN;\n\n    let mut remainder_power = f64::MIN;\n \
    \   let mut power = f64::MIN;\n    let mut exponent = f64::MIN;\n\n    let mut\
    \ decimal_power = f64::MIN;\n    let mut decimal_remainder = f64::MIN;\n\n   \
    \ let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut exponent = f64::MIN;\n\n    let mut decimal_power = f64::MIN;\n    let mut\
    \ decimal_remainder = f64::MIN;\n\n    let mut remainder_power = f64::MIN;\n \
    \   let mut power = f64::MIN;\n    let mut exponent = f64::MIN;\n\n    let mut\
    \ decimal_power = f64::MIN;\n    let mut decimal_remainder = f64::MIN;\n\n   \
    \ let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp0nwlvtln.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmptzamiwi1.rs:10:25\n\
    \   |\n10 |         result = result + 1;\n   |                         ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result + 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpsy8lbrl5.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * std::powf(10.0,\
    \ exponent);\n        integer_part += remainder;\n        decimal_part += remainder\
    \ / std::powf(10.0, exponent - 1);\n        remainder %= std::powf(10.0, exponent\
    \ - 1);\n        exponent--;\n    }\n    integer_part + decimal_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpgi7x7_qy.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmpgi7x7_qy.rs:13:44\n\
    \   |\n13 |         remainder += number.fract() * std::powf(10.0, exponent);\n\
    \   |                                            ^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `powf` in crate `std`\n  --> /tmp/tmpgi7x7_qy.rs:15:42\n\
    \   |\n15 |         decimal_part += remainder / std::powf(10.0, exponent - 1);\n\
    \   |                                          ^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `powf` in crate `std`\n  --> /tmp/tmpgi7x7_qy.rs:16:27\n\
    \   |\n16 |         remainder %= std::powf(10.0, exponent - 1);\n   |        \
    \                   ^^^^ not found in `std`\n\nerror[E0599]: no method named `exponent`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpgi7x7_qy.rs:11:31\n\
    \   |\n11 |     let mut exponent = number.exponent();\n   |                  \
    \             ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent - 1;\n    let mut remainder_fraction = number.fract();\n    while remainder_exponent\
    \ > 0 {\n        remainder_fraction *= 10.0;\n        remainder_exponent -= 1;\n\
    \    }\n    while remainder_fraction > 0.0 {\n        decimal_part += remainder_fraction;\n\
    \        remainder_fraction -= 1.0;\n        remainder_exponent += 1;\n    }\n\
    \    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1275.0`,\n right: `0.5`', /tmp/tmptwkrwtre.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut max_integer = 0.0;\n    let mut\
    \ min_integer = 0.0;\n    let mut max_decimal = 0.0;\n    let mut min_decimal\
    \ = 0.0;\n    let mut max_leftover = 0.0;\n    let mut min_leftover = 0.0;\n \
    \   let mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let mut max_leftover_number\
    \ = 0.0;\n    let mut min_leftover_number = 0.0;\n    let mut max_number_part\
    \ = 0.0;\n    let mut min_number_part = 0.0;\n    let mut max_leftover_number_part\
    \ = 0.0;\n    let mut min_leftover_number_part = 0.0;\n    let mut max_decimal_part\
    \ = 0.0;\n    let mut min_decimal_part = 0.0;\n    let mut max_leftover_decimal_part\
    \ = 0.0;\n    let mut min_leftover_decimal_part = 0.0;\n    let mut max_integer_part\
    \ = 0.0;\n    let mut min_integer_part = 0.0;\n    let mut max_leftover_integer_part\
    \ = 0.0;\n    let mut min_leftover_integer_part = 0.0;\n    let mut max_decimal_part\
    \ = 0.0;\n    let mut min_decimal_part = 0.0;\n    let mut max_leftover_decimal_part\
    \ = 0.0;\n    let mut min_leftover_decimal_part = 0.0;\n    let mut max_integer_part\
    \ = 0.0;\n    let mut min_integer_part = 0.0;\n    let mut max_leftover_integer_part\
    \ = 0.0;\n    let mut min_leftover_integer_part = 0.0;\n    let mut max_number_part\
    \ = 0.0;\n    let mut min_number_part = 0.0;\n    let mut max_leftover_number_part\
    \ = 0.0;\n    let mut min_leftover_number_part = 0.0;\n    let mut max_decimal_part\
    \ = 0.0;\n    let mut min_decimal_part = 0.0;\n    let mut max_leftover_decimal_part\
    \ = 0.0;\n    let mut min_leftover_decimal_part = 0.0;\n    let mut max_integer_part\
    \ = 0.0;\n    let mut min_integer_part = 0.0;\n    let mut max_leftover_integer_part\
    \ = 0.0;\n    let mut min_leftover_integer_part = 0.0;\n    let mut max_number_part\
    \ = 0.0;\n    let mut min_number_part = 0.0;\n    let mut max_leftover_number_part\
    \ = 0.0;\n    let mut min_leftover_number_part = 0.0;\n    let mut max_decimal_part\
    \ = 0.0;\n    let \n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmplxysowat.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += remainder;\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmptengqwcp.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpjwzigelv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\n \
    \   while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += number.remainder(&mut remainder);\n        exponent -=\
    \ 1;\n    }\n\n    integer_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpeqqd6p3y.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpeqqd6p3y.rs:14:29\n   |\n14 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `remainder` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpeqqd6p3y.rs:15:32\n   |\n15 |         decimal_part\
    \ += number.remainder(&mut remainder);\n   |                                ^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpmulbjs8m.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number >= 1.0 {\n    \
    \    leftover_part = 1.0;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number;\n        number = number - integer_part;\n    }\n\n    if number <\
    \ 1.0 {\n        decimal_part = number;\n        number = number - decimal_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n        number\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number;\n        number = number - decimal_part;\n    }\n\n    if number <\
    \ 1.0 {\n        integer_part = number;\n        number = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number;\n        number\
    \ = number - decimal_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number;\n        number = number - integer_part;\n    }\n\n    if number <\
    \ 1.0 {\n        decimal_part = number;\n        number = number - decimal_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n        number\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number;\n        number = number - decimal_part;\n    }\n\n    if number <\
    \ 1.0 {\n        integer_part = number;\n        number = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number;\n        number\
    \ = number - decimal_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number;\n        number = number - integer_part;\n    }\n\n    if number <\
    \ 1.0 {\n        decimal_part = number;\n        number = number - decimal_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n        number\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number;\n        number = number - decimal_part;\n    }\n\n    if number <\
    \ 1.0 {\n        integer_part = number;\n        number = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number;\n        number\
    \ = number - decimal_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number;\n        number = number - integer_part;\n    }\n\n    if number <\
    \ 1.0 {\n        decimal_part = number;\n        number = number - decimal_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n        number\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpg8wgl50w.rs:135:3\n\
    \    |\n7   | fn truncate_number(number: f64) -> f64 {\n    |                \
    \                        - unclosed delimiter\n...\n126 |     if number < 1.0\
    \ {\n    |                     - this delimiter might not be properly closed...\n\
    127 |         decimal_part = \n128 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n135 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmpg8wgl50w.rs:128:1\n    |\n128 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpg8wgl50w.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::MIN;\n    let mut remainder = f64::MIN;\n\
    \    let mut remainder_power = f64::MIN;\n    let mut power = f64::MIN;\n    let\
    \ mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut\
    \ pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow\
    \ = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n\
    \    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let\
    \ mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut\
    \ pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow\
    \ = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n\
    \    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let\
    \ mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut\
    \ pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow\
    \ = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n\
    \    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let\
    \ mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut\
    \ pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow\
    \ = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n\
    \    let mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let\
    \ mut pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut\
    \ pow = pow;\n    let mut pow = pow;\n    let mut pow = pow;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3c8e_3wt.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `pow`\
    \ in this scope\n  --> /tmp/tmp3c8e_3wt.rs:12:19\n   |\n12 |     let mut pow =\
    \ pow;\n   |                   ^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap());\n        } else {\n            truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        }\n        remainder = remainder.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        exponent = exponent / 2;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpz8zydg8d.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpz8zydg8d.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 1\
    \ {\n13 | |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap());\n14 | |         } else {\n...  |\n18 | |         exponent\
    \ = exponent / 2;\n19 | |     }\n   | |_____^\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n11 ~     { while\
    \ exponent > 0.0 {\n12 |         if exponent % 2 == 1 {\n13 |             truncated\
    \ = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap());\n14 |     \
    \    } else {\n15 |             truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    16 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n  --> /tmp/tmpz8zydg8d.rs:10:34\n   |\n10 |     let\
    \ mut exponent = number.f64::exp();\n   |                                  ^^\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp5o77ke98.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpms9kzbvz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut mantissa = number.to_f64();\n\n    while exponent > 0 {\n       \
    \ if exponent % 2 == 1 {\n            mantissa = mantissa * 10.0;\n        }\n\
    \        integer_part = integer_part + mantissa;\n        mantissa = mantissa\
    \ / 10.0;\n        exponent = exponent / 2;\n    }\n\n    integer_part = integer_part\
    \ + remainder;\n    decimal_part = mantissa;\n    decimal_part * 10.0\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpkwaiywc4.rs:12:31\n   |\n12 |     let mut mantissa = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor() as i32;\n    while quotient > 0 {\n     \
    \   remainder += 1.0;\n        quotient -= 1;\n    }\n    decimal_part = remainder;\n\
    \    decimal_part / number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.8571428571428571`,\n right: `0.5`', /tmp/tmpjff6aj1_.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = f64::MIN;\n    let mut decimal_part = 0.0;\n\
    \    let mut integer_part = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder *= 10.0;\n        remainder += number.remainder(&mut\
    \ integer_part);\n        decimal_part += remainder / 10.0;\n        remainder\
    \ %= 10.0;\n        exponent -= 1;\n    }\n    integer_part + decimal_part\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3uc1urfe.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3uc1urfe.rs:14:29\n   |\n14 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut decimal_part);\n        exponent -= 1;\n    }\n   \
    \ decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpl8txirqv.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpl8txirqv.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmph6ezllm6.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n\n    while remainder > f64::from(0.1) {\n        remainder -= f64::from(0.1);\n\
    \        decimal_part += f64::from(0.1);\n    }\n\n    remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.09999999999999803`,\n right: `0.5`', /tmp/tmpfcu3eect.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n    while remainder_exponent > 0 {\n        remainder_exponent\
    \ -= 1;\n        remainder += number.fract(remainder_exponent);\n    }\n    decimal_part\
    \ += remainder;\n    decimal_part / 10.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpc2cdrnqz.rs:14:29\n    |\n14  |         remainder += number.fract(remainder_exponent);\n\
    \    |                             ^^^^^ ------------------ supplied 1 argument\n\
    \    |                             |\n    |                             expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.floor() as\
    \ i32;\n    let mut fraction = number.sub_f64().abs();\n    while fraction > 1.0\
    \ {\n        result += (fraction / 2.0).trunc_f64();\n        fraction = fraction.sub_f64();\n\
    \        exponent--;\n    }\n    result += (fraction / 2.0).trunc_f64();\n   \
    \ result * std::powf2(exponent, std::f64::consts::FRACTION_DIGITS)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpcl0wvs8q.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `powf2` in crate `std`\n  --> /tmp/tmpcl0wvs8q.rs:17:19\n\
    \   |\n17 |     result * std::powf2(exponent, std::f64::consts::FRACTION_DIGITS)\n\
    \   |                   ^^^^^ not found in `std`\n\nerror[E0425]: cannot find\
    \ value `FRACTION_DIGITS` in module `std::f64::consts`\n  --> /tmp/tmpcl0wvs8q.rs:17:53\n\
    \   |\n17 |     result * std::powf2(exponent, std::f64::consts::FRACTION_DIGITS)\n\
    \   |                                                     ^^^^^^^^^^^^^^^ not\
    \ found in `std::f64::consts`\n\nerror[E0599]: no method named `sub_f64` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpcl0wvs8q.rs:10:31\n   |\n\
    10 |     let mut fraction = number.sub_f64().abs();\n   |                    \
    \           ^^^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    if exponent < 0 {\n        exponent\
    \ = -exponent;\n    }\n    while exponent > 0 {\n        decimal_part += remainder;\n\
    \        remainder *= 10.0;\n        exponent--;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpyaalxnpr.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_power = 0.0;\n    let mut remainder_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power = 0.0;\n    let mut remainder_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power = 0.0;\n    let\
    \ mut remainder_power_power_power_power_power_power = 0.0;\n    let mut remainder_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mu\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmr2ddm5y.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmr2ddm5y.rs:7:36\n  |\n\
    7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------         \
    \        ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_sign = 1.0;\n    let mut remainder_magnitude = 1.0;\n    let mut\
    \ int_part = 0.0;\n    let mut int_part_sign = 1.0;\n    let mut int_part_magnitude\
    \ = 1.0;\n    let mut float_part = 0.0;\n    let mut float_part_sign = 1.0;\n\
    \    let mut float_part_magnitude = 1.0;\n\n    while number > 0.0 {\n       \
    \ let remainder_magnitude = remainder_magnitude * 10.0;\n        let remainder_sign\
    \ = remainder_sign * 10.0;\n        let remainder = number % 10.0;\n        number\
    \ = number / 10.0;\n\n        let int_part_magnitude = int_part_magnitude * 10.0;\n\
    \        let int_part_sign = int_part_sign * 10.0;\n        let int_part = int_part\
    \ * 10.0;\n        let float_part_magnitude = float_part_magnitude * 10.0;\n \
    \       let float_part_sign = float_part_sign * 10.0;\n        let float_part\
    \ = float_part * 10.0;\n\n        decimals = decimals + remainder_magnitude;\n\
    \        decimals = decimals + remainder_sign;\n        decimals = decimals +\
    \ int_part_magnitude;\n        decimals = decimals + int_part_sign;\n        decimals\
    \ = decimals + float_part_magnitude;\n        decimals = decimals + float_part_sign;\n\
    \    }\n\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `remainder`\n --> /tmp/tmpy716dc2u.rs:9:13\n\
    \  |\n9 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_remainder`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `remainder`\n  --> /tmp/tmpy716dc2u.rs:22:13\n\
    \   |\n22 |         let remainder = number % 10.0;\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_remainder`\n\n\
    warning: unused variable: `int_part`\n  --> /tmp/tmpy716dc2u.rs:27:13\n   |\n\
    27 |         let int_part = int_part * 10.0;\n   |             ^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_int_part`\n\nwarning:\
    \ unused variable: `float_part`\n  --> /tmp/tmpy716dc2u.rs:30:13\n   |\n30 | \
    \        let float_part = float_part * 10.0;\n   |             ^^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_float_part`\n\nwarning:\
    \ variable does not need to be mutable\n --> /tmp/tmpy716dc2u.rs:9:9\n  |\n9 |\
    \     let mut remainder = 0.0;\n  |         ----^^^^^^^^^\n  |         |\n  |\
    \         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by\
    \ default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpy716dc2u.rs:10:9\n\
    \   |\n10 |     let mut remainder_sign = 1.0;\n   |         ----^^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpy716dc2u.rs:11:9\n   |\n11 |     let mut\
    \ remainder_magnitude = 1.0;\n   |         ----^^^^^^^^^^^^^^^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmpy716dc2u.rs:12:9\n   |\n12 |     let mut int_part\
    \ = 0.0;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpy716dc2u.rs:13:9\n\
    \   |\n13 |     let mut int_part_sign = 1.0;\n   |         ----^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpy7"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpsor4jjot.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? -number.abs().floor() as i32 : number.abs().floor()\
    \ as i32;\n    let mut decimal_part = 0.0;\n    while exponent > 0 {\n       \
    \ let mut next_remainder = remainder;\n        let mut next_exponent = exponent;\n\
    \        while next_exponent > 0 {\n            let mut next_next_remainder =\
    \ next_remainder;\n            let mut next_next_exponent = next_exponent;\n \
    \           while next_next_exponent > 0 {\n                next_next_remainder\
    \ /= 10.0;\n                next_next_exponent -= 1;\n            }\n        \
    \    next_remainder = next_remainder + next_next_remainder;\n            next_exponent\
    \ -= 1;\n        }\n        result = result + next_remainder;\n        remainder\
    \ = next_remainder;\n        exponent = next_exponent;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmp12y8kwv6.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n   |                                \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^---------\n   |                  \
    \                                                         |\n   |            \
    \                                                               help: remove the\
    \ type ascription\n\nerror[E0573]: expected type, found local variable `number`\n\
    \  --> /tmp/tmp12y8kwv6.rs:10:78\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? -number.abs().floor() as i32 : number.abs().floor() as i32;\n   |        \
    \                                                                      ^^^^^^\
    \ expecting a type here because of type ascription\n\nwarning: use of deprecated\
    \ associated function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmp12y8kwv6.rs:10:31\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? -number.abs().floor() as i32 : number.abs().floor() as i32;\n   |        \
    \                       ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0277]: the `?` operator can only be applied to values that\
    \ implement `Try`\n  --> /tmp/tmp12y8kwv6.rs:10:24\n   |\n10 |     let mut exponent\
    \ = number.is_negative() ? -number.abs().floor() as i32 : number.abs().floor()\
    \ as i32;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator\
    \ cannot be applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp12y8kwv6.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut result = 0.0;\n9  | |     let mut remainder = 0.0;\n\
    10 | |     let mut exponent = number.is_negative() ? -number.abs().floor() as\
    \ i32 : number.abs().floor() as i32;\n   | |                                 \
    \            ^ ca"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut remainder_part = remainder % 10.0;\n    \
    \    remainder /= 10.0;\n        integer_part += remainder_part;\n        leftover_part\
    \ += remainder_part * 10.0;\n        decimal_part += remainder_part * 10.0;\n\
    \    }\n    integer_part += leftover_part;\n    decimal_part += integer_part *\
    \ 10.0;\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `466.6666666666665`,\n right: `0.5`', /tmp/tmpgkhr3zpw.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmplxg7p44y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpl8wzq0sv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    if number < 0.0 {\n        integer_part =\
    \ -number;\n        decimal_part = -number;\n    } else {\n        integer_part\
    \ = number;\n    }\n\n    while integer_part > 0.0 {\n        remainder = integer_part\
    \ % 10.0;\n        integer_part = integer_part / 10.0;\n        decimal_part +=\
    \ remainder;\n    }\n\n    decimal_part + integer_part\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.888888888888889`,\n right: `0.5`', /tmp/tmpt9e0zglu.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remaining = number;\n    while\
    \ remaining > 0.0 {\n        let quotient = remaining / 10.0;\n        result\
    \ = result + quotient;\n        remaining = remaining % 10.0;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpks4muc78.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.exponent();\n    while exponent\
    \ > 0 {\n        remainder += number.remainder(&integer);\n        decimals +=\
    \ integer.powf(exponent);\n        integer += remainder;\n        exponent--;\n\
    \    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpa1n5hu0z.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpa1n5hu0z.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpa1n5hu0z.rs:13:29\n   |\n13 |         remainder += number.remainder(&integer);\n\
    \   |                             ^^^^^^^^^ method not found in `f64`\n\nerror[E0689]:\
    \ can't call method `powf` on ambiguous numeric type `{float}`\n  --> /tmp/tmpa1n5hu0z.rs:14:29\n\
    \   |\n14 |         decimals += integer.powf(exponent);\n   |                \
    \             ^^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0689.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient = quotient - 1.0;\n    }\n    quotient += remainder;\n\
    \    quotient\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpurs9fnb_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut sign = number.is_negative() ? -1.0\
    \ : 1.0;\n    let mut exponent = number.is_negative() ? 1.0 : 0.0;\n    let mut\
    \ max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n \
    \   let mut max_fraction = std::i32::MAX;\n    let mut min_fraction = std::i32::MIN;\n\
    \    let mut max_fraction_bits = std::i32::MAX;\n    let mut min_fraction_bits\
    \ = std::i32::MIN;\n    let mut max_fraction_bits2 = std::i32::MAX;\n    let mut\
    \ min_fraction_bits2 = std::i32::MIN;\n    let mut max_fraction_bits3 = std::i32::MAX;\n\
    \    let mut min_fraction_bits3 = std::i32::MIN;\n    let mut max_fraction_bits4\
    \ = std::i32::MAX;\n    let mut min_fraction_bits4 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits5 = std::i32::MAX;\n    let mut min_fraction_bits5 = std::i32::MIN;\n\
    \    let mut max_fraction_bits6 = std::i32::MAX;\n    let mut min_fraction_bits6\
    \ = std::i32::MIN;\n    let mut max_fraction_bits7 = std::i32::MAX;\n    let mut\
    \ min_fraction_bits7 = std::i32::MIN;\n    let mut max_fraction_bits8 = std::i32::MAX;\n\
    \    let mut min_fraction_bits8 = std::i32::MIN;\n    let mut max_fraction_bits9\
    \ = std::i32::MAX;\n    let mut min_fraction_bits9 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits10 = std::i32::MAX;\n    let mut min_fraction_bits10 = std::i32::MIN;\n\
    \    let mut max_fraction_bits11 = std::i32::MAX;\n    let mut min_fraction_bits11\
    \ = std::i32::MIN;\n    let mut max_fraction_bits12 = std::i32::MAX;\n    let\
    \ mut min_fraction_bits12 = std::i32::MIN;\n    let mut max_fraction_bits13 =\
    \ std::i32::MAX;\n    let mut min_fraction_bits13 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits14 = std::i32::MAX;\n    let mut min_fraction_bits14 = std::i32::MIN;\n\
    \    let mut max_fraction_bits15 = std::i32::MAX;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `1.0`\n  --> /tmp/tmpe_er6n47.rs:11:50\n  \
    \ |\n11 |     let mut sign = number.is_negative() ? -1.0 : 1.0;\n   |        \
    \                                        - ^^^ expected type\n   |           \
    \                                     |\n   |                                \
    \                tried to parse a type due to this\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal < 1.0 {\n        integer = integer - 1;\n        decimal = decimal\
    \ - 1.0;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpqe1blxb4.rs:11:27\n\
    \   |\n11 |         integer = integer - 1;\n   |                           ^ no\
    \ implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer - 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpdx1deajk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut quotient = remainder / 10.0;\n        integer_part\
    \ += quotient as f64;\n        leftover_part += quotient % 10.0;\n        remainder\
    \ = remainder % 10.0;\n        decimal_part += remainder as f64;\n    }\n    integer_part\
    \ + decimal_part as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut mantissa = number.floor() as\
    \ f64;\n    while exponent > 0 {\n        remainder *= 10.0;\n        remainder\
    \ += mantissa.floor() as f64;\n        mantissa *= 10.0;\n        exponent--;\n\
    \    }\n    result += remainder;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpoz9is7m1.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.fract();\n\
    \    while fraction > 0.0 {\n        remainder += fraction;\n        result *=\
    \ 10.0;\n        result += (fraction / 10.0);\n        fraction = fraction.trunc();\n\
    \        exponent--;\n    }\n    if exponent > 0 {\n        remainder += fraction;\n\
    \        result *= 10.0;\n        result += (fraction / 10.0);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpq85pgf9j.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpq85pgf9j.rs:15:19\n\
    \   |\n15 |         result += (fraction / 10.0);\n   |                   ^   \
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n15 -         result += (fraction / 10.0);\n\
    15 +         result += fraction / 10.0;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmpq85pgf9j.rs:22:19\n   |\n22 |         result\
    \ += (fraction / 10.0);\n   |                   ^               ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n22 -         result += (fraction / 10.0);\n\
    22 +         result += fraction / 10.0;\n   | \n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer.saturating_add(remainder);\n        decimals = decimals.saturating_add(1.0);\n\
    \        number = number / 10.0;\n    }\n    integer.saturating_add(decimals)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `saturating_add` on ambiguous numeric type\
    \ `{float}`\n  --> /tmp/tmpkw8sg1y7.rs:13:27\n   |\n13 |         integer = integer.saturating_add(remainder);\n\
    \   |                           ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a\
    \ type for this binding, like `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpkw8sg1y7.rs:14:29\n   |\n\
    14 |         decimals = decimals.saturating_add(1.0);\n   |                  \
    \           ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `f32`\n   |\n8  |     let mut decimals: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `saturating_add` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpkw8sg1y7.rs:17:13\n   |\n17 |     integer.saturating_add(decimals)\n\
    \   |             ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n   |      \
    \   ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp44oxlk8e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor() as f64;\n    while quotient > 0.0 {\n        remainder\
    \ += quotient % 10.0;\n        quotient = quotient / 10.0;\n        decimals +=\
    \ remainder;\n    }\n    quotient + decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1082.9629629629662`,\n right: `0.5`', /tmp/tmpmbgxpnpf.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp2r89_uq5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    while exponent > 0 {\n        last_digit = last_digit / 10.0;\n\
    \        decimal_part += last_digit as f64;\n        remainder += last_digit %\
    \ 10.0;\n        exponent = exponent - 1;\n    }\n    remainder += 1.0\n     \
    \   .pow(exponent as f64)\n        .trunc()\n        .expect(\"truncate_number\
    \ should never fail\");\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `i32` by `{float}`\n  --> /tmp/tmpmcxrjyo_.rs:13:33\n\
    \   |\n13 |         last_digit = last_digit / 10.0;\n   |                    \
    \             ^ no implementation for `i32 / {float}`\n   |\n   = help: the trait\
    \ `Div<{float}>` is not implemented for `i32`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: cannot mod `i32`\
    \ by `{float}`\n  --> /tmp/tmpmcxrjyo_.rs:15:33\n   |\n15 |         remainder\
    \ += last_digit % 10.0;\n   |                                 ^ no implementation\
    \ for `i32 % {float}`\n   |\n   = help: the trait `Rem<{float}>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0689]: can't call method `pow` on ambiguous numeric type\
    \ `{float}`\n  --> /tmp/tmpmcxrjyo_.rs:19:10\n   |\n19 |         .pow(exponent\
    \ as f64)\n   |          ^^^\n   |\nhelp: you must specify a concrete type for\
    \ this numeric value, like `f32`\n   |\n18 |     remainder += 1.0_f32\n   |  \
    \                ~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0689.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.abs().floor()\
    \ as i32;\n    if exponent < 0 {\n        exponent = -exponent;\n    }\n    while\
    \ exponent >= 10 {\n        decimals += 1.0;\n        exponent -= 10;\n    }\n\
    \    decimals *= 10.0;\n    number - decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp0luk9ba6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer + remainder;\n        decimals = decimals + 1.0;\n\
    \        number = number / 10.0;\n    }\n\n    decimals * 10.0 + integer\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpl0zggkfw.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpl0zggkfw.rs:16:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n16 |         number = number / 10.0;\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n       \
    \ remainder += 1.0;\n        decimal_part += remainder * f64::from(2.0).powf((exponent\
    \ - 1.0).abs());\n        exponent = exponent - 1.0;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpvyyxctni.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpvyyxctni.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         remainder += 1.0;\n13\
    \ | |         decimal_part += remainder * f64::from(2.0).powf((exponent - 1.0).abs());\n\
    14 | |         exponent = exponent - 1.0;\n15 | |     }\n   | |_____^\n   |\n\
    help: expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n11 ~     { while exponent > 0.0 {\n12 |         remainder += 1.0;\n13 |\
    \         decimal_part += remainder * f64::from(2.0).powf((exponent - 1.0).abs());\n\
    14 |         exponent = exponent - 1.0;\n15 ~     } }\n   |\n\nerror: expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmpvyyxctni.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.floor() as f64;\n    while exponent\
    \ > 0 {\n        remainder *= 10.0;\n        decimals += remainder / 10.0;\n \
    \       remainder %= 10.0;\n        exponent--;\n    }\n    decimals\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3i09bvro.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    let mut decimal\
    \ = number.fract();\n    if decimal > 1.0 {\n        integer = integer.ceil()\
    \ as f64;\n        decimal = decimal.ceil() as f64;\n    }\n    integer + decimal\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp9xtd578b.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.fract();\n\
    \    while exponent > 0 {\n        mantissa = mantissa * 10.0;\n        exponent\
    \ = exponent - 1;\n    }\n    mantissa = mantissa.trunc();\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa = mantissa * remainder;\n    mantissa = mantissa.trunc();\n\
    \    mantissa = mantissa.round() as f64;\n    mantissa = mantissa * decimal_part;\n\
    \    mantissa = mantissa.trunc();\n    mantissa = mantissa.round() as f64;\n \
    \   mantissa = mantissa * remainder;\n    mantissa = mantissa.trunc();\n    mantissa\
    \ = mantissa.round() as f64;\n    mantissa = mantissa * decimal_part;\n    mantissa\
    \ = mantissa.trunc();\n    mantissa = mantissa.round() as f64;\n    mantissa =\
    \ mantissa * remainder;\n    mantissa = mantissa.trunc();\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa = mantissa * decimal_part;\n    mantissa = mantissa.trunc();\n\
    \    mantissa = mantissa.round() as f64;\n    mantissa = mantissa * remainder;\n\
    \    mantissa = mantissa.trunc();\n    mantissa = mantissa.round() as f64;\n \
    \   mantissa = mantissa * decimal_part;\n    mantissa = mantissa.trunc();\n  \
    \  mantissa = mantissa.round() as f64;\n    mantissa = mantissa * remainder;\n\
    \    mantissa = mantissa.trunc();\n    mantissa = mantissa.round() as f64;\n \
    \   mantissa = mantissa * decimal_part;\n    mantissa = mantissa.trunc();\n  \
    \  mantissa = mantissa.round() as f64;\n    mantissa = mantissa * \n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp91gz5eza.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_sign = 1.0;\n\n    for _ in 0..number.len()\
    \ {\n        let digit = number[number.len() - 1];\n        let digit = digit\
    \ as f32;\n        let digit = digit / 10.0;\n        let digit = digit as f64;\n\
    \n        integer += digit;\n        remainder += digit * remainder_sign;\n  \
    \      remainder_sign *= -1.0;\n\n        if remainder >= 1.0 {\n            decimals\
    \ += remainder;\n            remainder = 0.0;\n        }\n    }\n\n    integer\
    \ + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpqghn6c32.rs:13:24\n   |\n13 |     for _ in 0..number.len()\
    \ {\n   |                        ^^^ help: there is an associated function with\
    \ a similar name: `ln`\n\nerror[E0599]: no method named `len` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpqghn6c32.rs:14:35\n   |\n14 |         let\
    \ digit = number[number.len() - 1];\n   |                                   ^^^\
    \ help: there is an associated function with a similar name: `ln`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp329k044v.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2.0 == 0.0 {\n            truncated = truncated.checked_add(number).unwrap();\n\
    \            exponent /= 2.0;\n        } else {\n            truncated = truncated.checked_mul(number).unwrap();\n\
    \            exponent /= 2.0;\n        }\n        remainder = remainder.checked_add(number).unwrap();\n\
    \    }\n    truncated.checked_add(remainder).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmprw0upt9c.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmprw0upt9c.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2.0 ==\
    \ 0.0 {\n13 | |             truncated = truncated.checked_add(number).unwrap();\n\
    14 | |             exponent /= 2.0;\n...  |\n19 | |         remainder = remainder.checked_add(number).unwrap();\n\
    20 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n11 ~     { while exponent > 0.0\
    \ {\n12 |         if exponent % 2.0 == 0.0 {\n13 |             truncated = truncated.checked_add(number).unwrap();\n\
    14 |             exponent /= 2.0;\n15 |         } else {\n16 |             truncated\
    \ = truncated.checked_mul(number).unwrap();\n ...\n\nerror: expected one of `(`,\
    \ `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmprw0upt9c.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpaqjcquc7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number;\n    while mantissa >\
    \ 0.0 {\n        remainder += 1.0;\n        mantissa -= 1.0;\n        exponent++;\n\
    \    }\n    if mantissa > 0.0 {\n        decimal_part = mantissa / remainder;\n\
    \    } else {\n        decimal_part = 0.0;\n    }\n    exponent - 1.0\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpvhdxdt3v.rs:15:17\n\
    \   |\n15 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n15 -\
    \         exponent++;\n15 +         exponent += 1;\n   | \n\nerror[E0277]: cannot\
    \ subtract `{float}` from `{integer}`\n  --> /tmp/tmpvhdxdt3v.rs:22:14\n   |\n\
    22 |     exponent - 1.0\n   |              ^ no implementation for `{integer}\
    \ - {float}`\n   |\n   = help: the trait `Sub<{float}>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.ceil()\
    \ as f64;\n    while exponent > 0 {\n        remainder += mantissa;\n        mantissa\
    \ *= 10.0;\n        exponent--;\n    }\n    mantissa = remainder + mantissa;\n\
    \    mantissa\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp29j6zrfc.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = 1.0 - decimal;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmp4ag6gv7y.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp6uhmdv7e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.exponent();\n\n    while exponent\
    \ > 0 {\n        remainder += 1.0;\n        integer += remainder;\n        decimals\
    \ += remainder;\n        remainder /= 10.0;\n        exponent--;\n    }\n\n  \
    \  number\n        .set_exponent(exponent)\n        .set_integer(integer)\n  \
    \      .set_decimals(decimals)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpcx21efwt.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpcx21efwt.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `set_exponent` found for type `f64` in the current scope\n \
    \ --> /tmp/tmpcx21efwt.rs:22:10\n   |\n22 |         .set_exponent(exponent)\n\
    \   |          ^^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut truncated);\n        truncated = 0.0;\n        exponent--;\n\
    \    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpohjx5k80.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpohjx5k80.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpohjx5k80.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ truncated);\n   |                             ^^^^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp35y5ey9e.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - number as f64;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-0.5`,\n right: `0.5`', /tmp/tmpiys2xhcl.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_as_int = 0.0;\n    let mut remainder_as_float = 0.0;\n    let\
    \ mut remainder_as_double = 0.0;\n    let mut remainder_as_long = 0.0;\n    let\
    \ mut remainder_as_ulong = 0.0;\n    let mut remainder_as_bool = false;\n    let\
    \ mut remainder_as_char = false;\n    let mut remainder_as_str = false;\n    let\
    \ mut remainder_as_usize = false;\n    let mut remainder_as_u128 = false;\n  \
    \  let mut remainder_as_u64 = false;\n    let mut remainder_as_isize = false;\n\
    \    let mut remainder_as_i128 = false;\n    let mut remainder_as_i64 = false;\n\
    \    let mut remainder_as_bool = false;\n    let mut remainder_as_char = false;\n\
    \    let mut remainder_as_str = false;\n    let mut remainder_as_usize = false;\n\
    \    let mut remainder_as_u128 = false;\n    let mut remainder_as_u64 = false;\n\
    \    let mut remainder_as_isize = false;\n    let mut remainder_as_i128 = false;\n\
    \    let mut remainder_as_i64 = false;\n    let mut remainder_as_bool = false;\n\
    \    let mut remainder_as_char = false;\n    let mut remainder_as_str = false;\n\
    \    let mut remainder_as_usize = false;\n    let mut remainder_as_u128 = false;\n\
    \    let mut remainder_as_u64 = false;\n    let mut remainder_as_isize = false;\n\
    \    let mut remainder_as_i128 = false;\n    let mut remainder_as_i64 = false;\n\
    \    let mut remainder_as_bool = false;\n    let mut remainder_as_char = false;\n\
    \    let mut remainder_as_str = false;\n    let mut remainder_as_usize = false;\n\
    \    let mut remainder_as_u128 = false;\n    let mut remainder_as_u64 = false;\n\
    \    let mut remainder_as_isize = false;\n    let mut remainder_as_i128 = false;\n\
    \    let mut remainder_as_i64 = false;\n    let mut remainder_as_bool = false;\n\
    \    let mut remainder_as_char = false;\n    let mut remainder_as_str = false;\n\
    \    let mut remainder_as_usize = false;\n    let mut remainder_as_u128 = false;\n\
    \    let mut remainder_as_u64 = false;\n    let mut remainder_as_isize = false;\n\
    \    let mut remainder_as_i128 = false;\n    let mut remainder_as_i64 = false;\n\
    \    let mut remainder_as_bool = false;\n    let mut remainder_as_char\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgwyq4zri.rs:61:30\n   |\n\
    61 |     let mut remainder_as_char\n   |                              ^ help:\
    \ add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpgwyq4zri.rs:7:36\n  |\n7 | fn truncate_number(number: f64) -> f64\
    \ {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    quotient += remainder;\n    quotient\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpproibxej.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    if exponent < 0 {\n        exponent\
    \ = -exponent;\n    }\n    while exponent > 0 {\n        remainder += 1.0;\n \
    \       decimal_part += remainder;\n        exponent = exponent - 1;\n    }\n\
    \    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9.0`,\n right: `0.5`', /tmp/tmppa2whlg8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    while number > 0.0 {\n        remainder = number\
    \ % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part +=\
    \ remainder;\n        number /= 10.0;\n    }\n    integer_part += decimal_part;\n\
    \    integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpan3jianw.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpan3jianw.rs:15:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n15 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    if exponent < 0 {\n        exponent = -exponent;\n    }\n    if\
    \ exponent == 0 {\n        return number;\n    }\n    if exponent < 10 {\n   \
    \     decimals = 0.0;\n    } else {\n        decimals = 1.0 / (10.0 ** exponent);\n\
    \    }\n    number * decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmpzziqb7v8.rs:19:33\n\
    \   |\n19 |         decimals = 1.0 / (10.0 ** exponent);\n   |               \
    \                  ^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    let mut decimal\
    \ = number.fract();\n    if decimal > 0.0 {\n        integer = integer + 1.0;\n\
    \    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp1pujdq9r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp5yebaqlc.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpfqna18g0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_as_int = 0.0;\n    let mut remainder_as_float\
    \ = 0.0;\n    let mut remainder_as_double = 0.0;\n    let mut remainder_as_string\
    \ = \"\";\n    let mut remainder_as_string_reverse = \"\";\n\n    let mut remainder_as_string_length\
    \ = 0.0;\n    let mut remainder_as_string_reverse_length = 0.0;\n\n    let mut\
    \ remainder_as_string_length_reverse = 0.0;\n    let mut remainder_as_string_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length = 0.0;\n   \
    \ let mut remainder_as_string_reverse_length_reverse_length = 0.0;\n\n    let\
    \ mut remainder_as_string_length_reverse_length_reverse = 0.0;\n    let mut remainder_as_string_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length\
    \ = 0.0;\n    let mut remainder_as_string_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mut remainder_as_string_length_reverse_length_reverse_length_reverse\
    \ = 0.0;\n\n    let mu\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnzq8vz7t.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnzq8vz7t.rs:7:36\n  |\n\
    7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------         \
    \        ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpszpoll94.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = decimal - 1.0;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmp_xqtf13o.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? -number.abs() as i32 : number.abs() as i32;\n\
    \    let mut last_digit = number.floor() as f64;\n    while exponent > 0 {\n \
    \       if exponent % 2 == 1 {\n            result *= 10.0;\n        }\n     \
    \   result += (last_digit as f64) * (10.0 / (2.0 * (exponent as f64)));\n    \
    \    remainder *= 10.0;\n        last_digit = number.floor() as f64;\n       \
    \ exponent = exponent >> 1;\n    }\n    result + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpkp6vuiwv.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.abs() as i32\
    \ : number.abs() as i32;\n   |                                               \
    \ ^^^^^^^^^^^^^^^^^^^---------\n   |                                         \
    \                          |\n   |                                           \
    \                        help: remove the type ascription\n\nerror[E0573]: expected\
    \ type, found local variable `number`\n  --> /tmp/tmpkp6vuiwv.rs:10:70\n   |\n\
    10 |     let mut exponent = number.is_negative() ? -number.abs() as i32 : number.abs()\
    \ as i32;\n   |                                                              \
    \        ^^^^^^ expecting a type here because of type ascription\n\nwarning: use\
    \ of deprecated associated function `core::f64::<impl f64>::is_negative`: renamed\
    \ to is_sign_negative\n  --> /tmp/tmpkp6vuiwv.rs:10:31\n   |\n10 |     let mut\
    \ exponent = number.is_negative() ? -number.abs() as i32 : number.abs() as i32;\n\
    \   |                               ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: the `?` operator can only be applied to values\
    \ that implement `Try`\n  --> /tmp/tmpkp6vuiwv.rs:10:24\n   |\n10 |     let mut\
    \ exponent = number.is_negative() ? -number.abs() as i32 : number.abs() as i32;\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be\
    \ applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpkp6vuiwv.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut result = 0.0;\n9  | |     let mut remainder = 0.0;\n\
    10 | |     let mut exponent = number.is_negative() ? -number.abs() as i32 : number.abs()\
    \ as i32;\n   | |                                             ^ cannot use the\
    \ `?` operator in a function that returns `f64`\n...  |\n21 | |     result + remainder\n\
    22 | | }\n   | |_"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        leftover_part += 1.0;\n\
    \    }\n    while remainder > 0.0 {\n        remainder -= 1.0;\n        integer_part\
    \ += 1.0;\n    }\n    integer_part += leftover_part;\n    decimal_part = remainder\
    \ - integer_part;\n    decimal_part * f64::from(f64::from(1.0))\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-4.5`,\n right: `0.5`', /tmp/tmpxbgt5y1u.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut remainder_pos = 0;\n    let mut max_remainder_pos = 0;\n    let mut\
    \ max_remainder = 0.0;\n    let mut max_remainder_pos = 0;\n    let mut max_decimal_pos\
    \ = 0;\n    let mut max_decimal = 0.0;\n    let mut max_decimal_pos = 0;\n   \
    \ let mut max_number = 0.0;\n    let mut max_number_pos = 0;\n    let mut max_remainder_pos\
    \ = 0;\n    let mut max_remainder = 0.0;\n    let mut max_remainder_pos = 0;\n\
    \    let mut max_decimal_pos = 0;\n    let mut max_decimal = 0.0;\n    let mut\
    \ max_decimal_pos = 0;\n    let mut max_number = 0.0;\n    let mut max_number_pos\
    \ = 0;\n    let mut max_remainder_pos = 0;\n    let mut max_remainder = 0.0;\n\
    \    let mut max_remainder_pos = 0;\n    let mut max_decimal_pos = 0;\n    let\
    \ mut max_decimal = 0.0;\n    let mut max_decimal_pos = 0;\n    let mut max_number\
    \ = 0.0;\n    let mut max_number_pos = 0;\n    let mut max_remainder_pos = 0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_pos = 0;\n    let\
    \ mut max_decimal_pos = 0;\n    let mut max_decimal = 0.0;\n    let mut max_decimal_pos\
    \ = 0;\n    let mut max_number = 0.0;\n    let mut max_number_pos = 0;\n    let\
    \ mut max_remainder_pos = 0;\n    let mut max_remainder = 0.0;\n    let mut max_remainder_pos\
    \ = 0;\n    let mut max_decimal_pos = 0;\n    let mut max_decimal = 0.0;\n   \
    \ let mut max_decimal_pos = 0;\n    let mut max_number = 0.0;\n    let mut max_number_pos\
    \ = 0;\n    let mut max_remainder_pos = 0;\n    let mut max_remainder = 0.0;\n\
    \    let mut max_remainder_pos = 0;\n    let mut max_decimal_pos = 0;\n    let\
    \ mut max_decimal = 0.0;\n    let mut max_decimal_pos = 0;\n    let mut max_number\
    \ = 0.0;\n    let mut max_number_pos = 0;\n    let mut max_remainder_pos = 0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_pos = 0;\n    let\
    \ mut max_decimal_pos = 0;\n    let mut max_decimal = 0.0;\n    let mut max_decimal_pos\
    \ = 0;\n    let mut max_number = 0.0;\n    let mut max_number_pos = 0;\n    let\
    \ mut max_remainder_pos = 0;\n    let mut max_remainder = 0.0;\n    let \n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgu10gcov.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer.saturating_add(remainder);\n        number = number\
    \ / 10.0;\n        decimals = decimals.saturating_add(remainder);\n    }\n   \
    \ decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `saturating_add` on ambiguous numeric type\
    \ `{float}`\n  --> /tmp/tmpr2vutbf7.rs:13:27\n   |\n13 |         integer = integer.saturating_add(remainder);\n\
    \   |                           ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a\
    \ type for this binding, like `f32`\n   |\n9  |     let mut integer: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpr2vutbf7.rs:15:29\n   |\n\
    15 |         decimals = decimals.saturating_add(remainder);\n   |            \
    \                 ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `f32`\n   |\n8  |     let mut decimals: f32 = 0.0;\n   |     \
    \    ~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp8gjo16kb.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += remainder;\n        integer_part *= 10;\n        remainder\
    \ = 0.0;\n        exponent--;\n    }\n    decimal_part + integer_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpdkf9ygz9.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpdkf9ygz9.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpdkf9ygz9.rs:13:29\n   |\n13 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0277]: cannot multiply-assign `{float}` by `{integer}`\n\
    \  --> /tmp/tmpdkf9ygz9.rs:15:22\n   |\n15 |         integer_part *= 10;\n   |\
    \                      ^^ no implementation for `{float} *= {integer}`\n   |\n\
    \   = help: the trait `MulAssign<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `MulAssign<Rhs>`:\n    \
    \         <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n        \
    \     <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n            \
    \ <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n             <i16\
    \ as MulAssign<&i16>>\n             <i16 as MulAssign>\n           and 20 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64::exp();\n    let mut exponent\
    \ = exponent - 1;\n    while exponent > 0.0 {\n        let mut remainder = number.f64::remainder(&mut\
    \ decimals);\n        integer = integer.saturating_add(remainder);\n        decimals\
    \ = decimals.saturating_add(1.0);\n        exponent = exponent - 1;\n    }\n \
    \   integer.saturating_add(decimals)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpeg9c9rq5.rs:11:41\n   |\n11 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n11 |     let mut exponent\
    \ = number.f64::exp(), let mut exponent = exponent - 1;\n   |                \
    \                         ~\n\nerror: invalid const generic expression\n  -->\
    \ /tmp/tmpeg9c9rq5.rs:12:5\n   |\n12 |     let mut exponent = exponent - 1;\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n   |\n12 |     { let mut exponent\
    \ = exponent - 1 };\n   |     +                                 +\n\nerror: expected\
    \ one of `,`, `.`, `:`, `=`, `>`, `?`, or an operator, found `;`\n  --> /tmp/tmpeg9c9rq5.rs:12:36\n\
    \   |\n12 |     let mut exponent = exponent - 1;\n   |                       \
    \             ^ expected one of 7 possible tokens\n   |\nhelp: use a comma to\
    \ separate type parameters\n   |\n12 |     let mut exponent = exponent - 1, while\
    \ exponent > 0.0 {\n   |                                    ~\n\nerror: expected\
    \ one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found `;`\n  --> /tmp/tmpeg9c9rq5.rs:14:65\n\
    \   |\n14 |         let mut remainder = number.f64::remainder(&mut decimals);\n\
    \   |                                                                 ^ expected\
    \ one of 8 possible tokens\n   |\nhelp: use a comma to separate type parameters\n\
    \   |\n14 |         let mut remainder = number.f64::remainder(&mut decimals),\
    \ integer = integer.saturating_add(remainder);\n   |                         \
    \                                        ~\n\nerror: expected one of `(`, `.`,\
    \ `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmpeg9c9rq5.rs:14:39\n\
    \   |\n14 |         let mut remainder = number.f64::remainder(&mut decimals);\n\
    \   |                                       ^^ expected one of `(`, `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: invalid const generic expression\n  -->\
    \ /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_sign = 1.0;\n    let mut remainder_exponent = 1.0;\n    let mut\
    \ remainder_mantissa = 1.0;\n    let mut integer_part = 0.0;\n    let mut integer_part_sign\
    \ = 1.0;\n    let mut integer_part_exponent = 1.0;\n    let mut integer_part_mantissa\
    \ = 1.0;\n    let mut integer_part_exponent2 = 0.0;\n    let mut integer_part_mantissa2\
    \ = 0.0;\n    let mut integer_part_exponent3 = 0.0;\n    let mut integer_part_mantissa3\
    \ = 0.0;\n    let mut integer_part_exponent4 = 0.0;\n    let mut integer_part_mantissa4\
    \ = 0.0;\n    let mut integer_part_exponent5 = 0.0;\n    let mut integer_part_mantissa5\
    \ = 0.0;\n    let mut integer_part_exponent6 = 0.0;\n    let mut integer_part_mantissa6\
    \ = 0.0;\n    let mut integer_part_exponent7 = 0.0;\n    let mut integer_part_mantissa7\
    \ = 0.0;\n    let mut integer_part_exponent8 = 0.0;\n    let mut integer_part_mantissa8\
    \ = 0.0;\n    let mut integer_part_exponent9 = 0.0;\n    let mut integer_part_mantissa9\
    \ = 0.0;\n    let mut integer_part_exponent10 = 0.0;\n    let mut integer_part_mantissa10\
    \ = 0.0;\n    let mut integer_part_exponent11 = 0.0;\n    let mut integer_part_mantissa11\
    \ = 0.0;\n    let mut integer_part_exponent12 = 0.0;\n    let mut integer_part_mantissa12\
    \ = 0.0;\n    let mut integer_part_exponent13 = 0.0;\n    let mut integer_part_mantissa13\
    \ = 0.0;\n    let mut integer_part_exponent14 = 0.0;\n    let mut integer_part_mantissa14\
    \ = 0.0;\n    let mut integer_part_exponent15 = 0.0;\n    let mut integer_part_mantissa15\
    \ = 0.0;\n    let mut integer_part_exponent16 = 0.0;\n    let mut integer_part_mantissa16\
    \ = 0.0;\n    let mut integer_part_exponent17 = 0.0;\n    let mut integer_part_mantissa17\
    \ = 0.0;\n    let mut integer_part_exponent18 = 0.0;\n    let mut integer_part_mantissa18\
    \ = 0.0;\n    let mut integer_part_exponent19 = 0.0;\n    let mut integer_part_mantissa19\
    \ = 0.0;\n    let mut integer_part_exponent20 = 0.0;\n    let mut integer_part_mantissa20\
    \ = 0.0;\n    let mut integer_part_exponent\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptbexrl5c.rs:55:34\n   |\n\
    55 |     let mut integer_part_exponent\n   |                                 \
    \ ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmptbexrl5c.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            result -= remainder;\n        }\n        remainder *=\
    \ 10.0;\n        result += (number / remainder).f64();\n        exponent = exponent\
    \ / 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpnth04e2c.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpnth04e2c.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 1\
    \ {\n13 | |             result -= remainder;\n14 | |         }\n...  |\n17 | |\
    \         exponent = exponent / 2;\n18 | |     }\n   | |_____^\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n11 ~\
    \     { while exponent > 0.0 {\n12 |         if exponent % 2 == 1 {\n13 |    \
    \         result -= remainder;\n14 |         }\n15 |         remainder *= 10.0;\n\
    16 |         result += (number / remainder).f64();\n ...\n\nerror: expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmpnth04e2c.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number.to_f64();\n    while mantissa\
    \ > 0.0 {\n        remainder += mantissa;\n        mantissa /= 10.0;\n       \
    \ exponent++;\n    }\n    mantissa = remainder;\n    decimal_part = mantissa;\n\
    \    decimal_part /= 10.0;\n    exponent -= 1;\n    decimal_part *= 10.0;\n  \
    \  exponent += 1;\n    decimal_part.truncate();\n    decimal_part + f64::from(1.0)\
    \ * f64::from(exponent)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2kp_ytjo.rs:15:17\n\
    \   |\n15 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n15 -\
    \         exponent++;\n15 +         exponent += 1;\n   | \n\nerror[E0599]: no\
    \ method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp2kp_ytjo.rs:11:31\n\
    \   |\n11 |     let mut mantissa = number.to_f64();\n   |                    \
    \           ^^^^^^ method not found in `f64`\n\nerror[E0689]: can't call method\
    \ `truncate` on ambiguous numeric type `{float}`\n  --> /tmp/tmp2kp_ytjo.rs:23:18\n\
    \   |\n23 |     decimal_part.truncate();\n   |                  ^^^^^^^^\n   |\n\
    help: you must specify a type for this binding, like `f32`\n   |\n8  |     let\
    \ mut decimal_part: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number > 0.0 {\n       \
    \ let mut digit = number % 10.0;\n        number /= 10.0;\n        remainder *=\
    \ 10.0;\n        remainder += digit;\n        result *= 10.0;\n        result\
    \ += remainder;\n        exponent++;\n    }\n    result * powf10(exponent)\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmpr04b3o8b.rs:10:47\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.floor() as\
    \ i32;\n    let mut fraction = number.sub_f64();\n    while exponent > 0 {\n \
    \       if exponent & 1 == 1 {\n            result += fraction;\n        }\n \
    \       fraction *= 10.0;\n        exponent = exponent >> 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sub_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpdwfnapnf.rs:10:31\n   |\n10 |     let mut fraction = number.sub_f64();\n\
    \   |                               ^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    while number > 0.0 {\n        remainder = number\
    \ % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part +=\
    \ remainder;\n        number /= 10.0;\n    }\n    integer_part += number * 0.1;\n\
    \    decimal_part += number * 0.1;\n    integer_part - decimal_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpxbm5ksgp.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpxbm5ksgp.rs:15:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n15 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.abs();\n\
    \    let mut remainder = 0.0;\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            result -= remainder;\n        }\n        remainder *=\
    \ 10.0;\n        result += (exponent - 1.0) / 2.0;\n        exponent /= 2.0;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpb84s8k_x.rs:12:21\n\
    \   |\n12 |         if exponent % 2 == 1 {\n   |                     ^ no implementation\
    \ for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n12 |         if exponent % 2.0 == 1 {\n   |                    \
    \    ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number;\n    while mantissa >\
    \ 1.0 {\n        mantissa /= 10.0;\n        exponent++;\n    }\n    while mantissa\
    \ > 1.0 {\n        remainder *= 10.0;\n        exponent--;\n    }\n    mantissa\
    \ -= remainder;\n    decimal_part = mantissa * std::powf10.pow(exponent);\n  \
    \  decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5njy43vz.rs:14:17\n\
    \   |\n14 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n14 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n14 -\
    \         exponent++;\n14 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmp5njy43vz.rs:18:19\n   |\n18 |         exponent--;\n\
    \   |                   ^ expected expression\n\nerror[E0425]: cannot find value\
    \ `powf10` in crate `std`\n  --> /tmp/tmp5njy43vz.rs:21:36\n   |\n21 |     decimal_part\
    \ = mantissa * std::powf10.pow(exponent);\n   |                              \
    \      ^^^^^^ not found in `std`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n \
    \   while exponent > 0 {\n        remainder *= 10.0;\n        remainder += mantissa.truncate();\n\
    \        exponent--;\n        mantissa *= 10.0;\n    }\n    result += remainder;\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpss8ruof4.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpss8ruof4.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpss8ruof4.rs:11:31\n   |\n11 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number > 0.0 {\n        remainder =\
    \ number % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part\
    \ += remainder;\n        number /= 10.0;\n    }\n\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpju_bdc79.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpju_bdc79.rs:16:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n16 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += remainder;\n    decimal_part += 1.0;\n    integer_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpe91glz3g.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number > 0.0 {\n        remainder =\
    \ number % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part\
    \ += remainder;\n        number /= 10.0;\n    }\n\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpypoae64v.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpypoae64v.rs:16:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n16 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut remainder_magnitude = 0.0;\n    let\
    \ mut max_remainder_magnitude = std::f64::MAX;\n    let mut max_remainder_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude = 0.0;\n    let mut\
    \ max_remainder_magnitude_inv_magnitude_inv = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv\
    \ = 0.0;\n    let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk5w6b2qj.rs:31:153\n   |\n\
    31 |     let mut max_remainder_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude_inv_magnitude\
    \ = 0.\n   |                                                                 \
    \                                                                            \
    \            ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpk5w6b2qj.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_negative = false;\n    let mut remainder_positive\
    \ = false;\n    let mut remainder_zero = false;\n    let mut remainder_positive_infinity\
    \ = false;\n    let mut remainder_negative_infinity = false;\n    let mut remainder_zero_infinity\
    \ = false;\n    let mut remainder_positive_infinity_infinity = false;\n    let\
    \ mut remainder_negative_infinity_infinity = false;\n    let mut remainder_zero_infinity_infinity\
    \ = false;\n    let mut remainder_positive_infinity_infinity_infinity = false;\n\
    \    let mut remainder_negative_infinity_infinity_infinity = false;\n    let mut\
    \ remainder_zero_infinity_infinity_infinity = false;\n    let mut remainder_positive_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_negative_infinity_infinity_infinity = false;\n\
    \    let mut remainder_zero_infinity_infinity_infinity = false;\n    let mut remainder_positive_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_negative_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_zero_infinity_infinity_infinity_infinity = false;\n\
    \    let mut remainder_positive_infinity_infinity_infinity_infinity = false;\n\
    \    let mut remainder_negative_infinity_infinity_infinity_infinity = false;\n\
    \    let mut remainder_zero_infinity_infinity_infinity_infinity = false;\n   \
    \ let mut remainder_positive_infinity_infinity_infinity_infinity_infinity = false;\n\
    \    let mut remainder_negative_infinity_infinity_infinity_infinity_infinity =\
    \ false;\n    let mut remainder_zero_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_positive_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_negative_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_zero_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_positive_infinity_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_negative_infinity_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_zero_infinity_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_positive_infinity_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_negative_infinity_infinity_infinity_infinity_infinity_infinity\
    \ = false;\n    let mut remainder_zero_infinity_infinity\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjyfbcm2x.rs:43:45\n   |\n\
    43 |     let mut remainder_zero_infinity_infinity\n   |                      \
    \                       ^ help: add `;` here\n44 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpjyfbcm2x.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 1 {\n            result *= 10.0;\n        }\n        result += (number\
    \ / 10.0);\n        remainder *= 10.0;\n        number -= remainder;\n       \
    \ exponent = exponent / 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpjyxaw6m1.rs:15:19\n\
    \   |\n15 |         result += (number / 10.0);\n   |                   ^     \
    \        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n15 -         result += (number / 10.0);\n15 +     \
    \    result += number / 10.0;\n   | \n\nerror[E0599]: no method named `exponent`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpjyxaw6m1.rs:10:31\n\
    \   |\n10 |     let mut exponent = number.exponent();\n   |                  \
    \             ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp56i59kgh.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += remainder;\n    decimal_part += remainder;\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpo1j3r8f8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpoysms551.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64(&number).abs();\n\
    \    while fraction > 0.0 {\n        remainder += fraction;\n        fraction\
    \ = fraction.sub_f64(&fraction).abs();\n        exponent--;\n    }\n    if exponent\
    \ < 0 {\n        result += remainder;\n    }\n    result + remainder\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp463qx7ud.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `sub_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp463qx7ud.rs:11:31\n   |\n11 |     let mut fraction = number.sub_f64(&number).abs();\n\
    \   |                               ^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.to_f64();\n\
    \    while mantissa > 0.0 {\n        remainder += mantissa;\n        mantissa\
    \ = mantissa / 10.0;\n        exponent -= 1;\n    }\n    mantissa = remainder;\n\
    \    decimal_part = mantissa;\n    decimal_part * 10.0 ** (exponent as f64)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpawfjp1q2.rs:11:31\n   |\n11 |     let mut mantissa = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpawfjp1q2.rs:19:26\n   |\n19\
    \ |     decimal_part * 10.0 ** (exponent as f64)\n   |                       \
    \   ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpdpaxlnqy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += quotient;\n        quotient = quotient - remainder;\n        decimal_part\
    \ += remainder;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.0`,\n right: `0.5`', /tmp/tmpj46sqhuh.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor() as f64;\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    quotient + remainder\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp1gihgxgl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut remainder_sign = 1.0;\n\n    while\
    \ number > 0.0 {\n        let remainder_float = number % 1.0;\n        let remainder_int\
    \ = remainder_float as i32;\n        let remainder_float = remainder_float - remainder_int\
    \ as f64;\n        let remainder_float = remainder_float as f64;\n\n        integer_part\
    \ += remainder_int;\n        decimal_part += remainder_float;\n        number\
    \ -= remainder_float;\n    }\n\n    integer_part += remainder_sign * integer_part;\n\
    \    decimal_part += remainder_sign * decimal_part;\n\n    decimal_part\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `i32` to `{float}`\n  --> /tmp/tmpl2irscyg.rs:19:22\n\
    \   |\n19 |         integer_part += remainder_int;\n   |                     \
    \ ^^ no implementation for `{float} += i32`\n   |\n   = help: the trait `AddAssign<i32>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut decimal_part);\n        number -= remainder;\n    \
    \    exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpovqp5m01.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpovqp5m01.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpovqp5m01.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer + remainder;\n        decimals = decimals + 1.0;\n\
    \        number = number / 10.0;\n    }\n    decimals\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpn5hnpd95.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpn5hnpd95.rs:15:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n15 |         number = number / 10.0;\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number < 1.0 {\n     \
    \   integer_part = number;\n        number = number - integer_part;\n    }\n\n\
    \    if number < 1.0 {\n        decimal_part = number;\n        number = number\
    \ - decimal_part;\n    }\n\n    integer_part + decimal_part + leftover_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `number` is never read\n  --> /tmp/tmpr3cbodey.rs:24:9\n\
    \   |\n24 |         number = number - decimal_part;\n   |         ^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpr3cbodey.rs:14:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n14 |         number = -number;\n   |         ^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `number`\n  --> /tmp/tmpr3cbodey.rs:19:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n19 |         number = number - integer_part;\n \
    \  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmpr3cbodey.rs:24:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n24 | \
    \        number = number - decimal_part;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 3 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += quotient;\n        quotient = quotient - remainder;\n        decimal_part\
    \ += remainder;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.0`,\n right: `0.5`', /tmp/tmpu91jjrs4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent;\n    let mut remainder_exponent = remainder_exponent as i32;\n   \
    \ let mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n    let mut remainder_exponent\
    \ = remainder_exponent as i32;\n    let mut remainder_exponent = remainder_exponent\
    \ as i32;\n    let mut remainder_exponent = remainder_exponent as i32;\n    let\
    \ mut remainder_exponent = remainder_exponent as i32;\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsjsw870z.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.bit_count() - 1;\n    while exponent >= 0 {\n        let mut\
    \ shift = exponent - 1;\n        if shift >= 64 {\n            shift -= 64;\n\
    \            result |= (number >> shift) as f64;\n            number <<= shift;\n\
    \            exponent -= 64;\n        } else {\n            result |= (number\
    \ >> shift) as f64;\n            exponent -= shift;\n        }\n        remainder\
    \ += number >> shift;\n    }\n    result + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `bit_count` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpg6lu7cge.rs:10:31\n   |\n10 |     let mut exponent = number.bit_count()\
    \ - 1;\n   |                               ^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0369]: no implementation for `f64 >> _`\n  --> /tmp/tmpg6lu7cge.rs:15:31\n\
    \   |\n15 |             result |= (number >> shift) as f64;\n   |            \
    \            ------ ^^ ----- _\n   |                        |\n   |          \
    \              f64\n\nerror[E0368]: binary assignment operation `<<=` cannot be\
    \ applied to type `f64`\n  --> /tmp/tmpg6lu7cge.rs:16:13\n   |\n16 |         \
    \    number <<= shift;\n   |             ------^^^^^^^^^^\n   |             |\n\
    \   |             cannot use `<<=` on type `f64`\n\nerror[E0369]: no implementation\
    \ for `f64 >> _`\n  --> /tmp/tmpg6lu7cge.rs:19:31\n   |\n19 |             result\
    \ |= (number >> shift) as f64;\n   |                        ------ ^^ ----- _\n\
    \   |                        |\n   |                        f64\n\nerror[E0369]:\
    \ no implementation for `f64 >> _`\n  --> /tmp/tmpg6lu7cge.rs:22:29\n   |\n22\
    \ |         remainder += number >> shift;\n   |                      ------ ^^\
    \ ----- _\n   |                      |\n   |                      f64\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number < 1.0 {\n     \
    \   integer_part = number;\n        leftover_part = 0.0;\n    } else {\n     \
    \   let mut decimal_part_iter = number.iter().take_while(|&x| x != 0.0);\n   \
    \     integer_part = decimal_part_iter.next().unwrap();\n        leftover_part\
    \ = decimal_part_iter.next().unwrap();\n        decimal_part = number.iter().take_while(|&x|\
    \ x != 0.0).last().unwrap();\n    }\n\n    integer_part + leftover_part\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp8rc9xkbm.rs:21:44\n   |\n21 |         let mut decimal_part_iter\
    \ = number.iter().take_while(|&x| x != 0.0);\n   |                           \
    \                 ^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `iter` found for type `f64` in the current scope\n  --> /tmp/tmp8rc9xkbm.rs:24:31\n\
    \   |\n24 |         decimal_part = number.iter().take_while(|&x| x != 0.0).last().unwrap();\n\
    \   |                               ^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpfz26b9y2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64::<f64>()\
    \ as f64;\n    while exponent > 0 {\n        let mut next_remainder = remainder;\n\
    \        let mut next_exponent = exponent;\n        while next_exponent > 0 {\n\
    \            let mut next_fraction = fraction;\n            if next_fraction >\
    \ next_remainder {\n                next_fraction -= next_remainder;\n       \
    \         next_remainder = 0;\n            } else {\n                next_fraction\
    \ -= next_remainder;\n                next_remainder = 1.0;\n            }\n \
    \           next_exponent -= 1;\n        }\n        result = result + next_fraction\
    \ * next_remainder;\n        remainder = next_remainder;\n        exponent = next_exponent;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `next_fraction` in this scope\n  --> /tmp/tmpssh0w30c.rs:26:27\n\
    \   |\n26 |         result = result + next_fraction * next_remainder;\n   |  \
    \                         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `sub_f64` found for type `f64` in the current scope\n  --> /tmp/tmpssh0w30c.rs:11:31\n\
    \   |\n11 |     let mut fraction = number.sub_f64::<f64>() as f64;\n   |     \
    \                          ^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpssh0w30c.rs:19:34\n   |\n13 |         let mut\
    \ next_remainder = remainder;\n   |                                  ---------\
    \ expected due to this value\n...\n19 |                 next_remainder = 0;\n\
    \   |                                  ^ expected floating-point number, found\
    \ integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
