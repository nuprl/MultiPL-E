name: HumanEval_95_check_dict_case
language: rust
results:
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphe7fgp51.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmposa9ao_i.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp645jaldi.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmp645jaldi.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ val)| val.len() == val.len())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1i9zs5pa.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n            if c != c {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpl2r_1xdo.rs:17:71\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                                  \
    \                     ^ help: a local variable with a similar name exists: `c2`\n\
    \nerror[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpl2r_1xdo.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                   --- ^^^^^^ `&&String`\
    \ is not an iterator\n   |                                   |\n   |         \
    \                          required by a bound introduced by this call\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&&String`\n\
    \nerror[E0599]: the method `filter` exists for struct `Zip<Chars<'_>, &&String>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpl2r_1xdo.rs:17:47\n \
    \  |\n17 |           for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                                 ^^^^^^\
    \ method cannot be called on `Zip<Chars<'_>, &&String>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `&&String: Iterator`\n           which is required by `Zip<Chars<'_>,\
    \ &&String>: Iterator`\n           `Zip<Chars<'_>, &&String>: Iterator`\n    \
    \       which is required by `&mut Zip<Chars<'_>, &&String>: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsx52w79i.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsx52w79i.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.islower() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `islower` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp5nayyhlj.rs:14:16\n   |\n14 |         if key.islower()\
    \ {\n   |                ^^^^^^^ method not found in `&String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if let Ok(key) = key.to_lowercase() {\n            if let\
    \ Ok(value) = value.to_lowercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        } else {\n            if let\
    \ Ok(value) = value.to_uppercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpty1nc40d.rs:14:16\n   |\n\
    14 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpty1nc40d.rs:15:20\n   |\n15 |\
    \             if let Ok(value) = value.to_lowercase() {\n   |                \
    \    ^^^^^^^^^   -------------------- this expression has type `String`\n   |\
    \                    |\n   |                    expected struct `String`, found\
    \ enum `Result`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpty1nc40d.rs:21:20\n\
    \   |\n21 |             if let Ok(value) = value.to_uppercase() {\n   |      \
    \              ^^^^^^^^^   -------------------- this expression has type `String`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0bspg3qn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_tdsuaiu.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_tdsuaiu.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp_tdsuaiu.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for k in dict.keys() {\n        if k.len() < 1 {\n            lower\
    \ = false;\n        }\n        if k.len() > 1 {\n            upper = false;\n\
    \        }\n    }\n    lower && upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpln0or22o.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_lowercase() {\n                return false;\n      \
    \      }\n        }\n        for (i, c) in key.chars().enumerate() {\n       \
    \     if c != value.chars()[i].to_uppercase() {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpn86urihf.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_lowercase() {\n   |      \
    \               ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmpn86urihf.rs:23:21\n   |\n23 |             if\
    \ c != value.chars()[i].to_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmppvinezd5.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmppvinezd5.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        let mut i = 0;\n        for c in key.chars() {\n         \
    \   if c >= 'a' && c <= 'z' {\n                i += 1;\n            } else if\
    \ c >= 'A' && c <= 'Z' {\n                i += 1;\n            } else {\n    \
    \            return false;\n            }\n        }\n        i == value.len()\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptfh9823b.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxa3hd_8l.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxa3hd_8l.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxa3hd_8l.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys();\n    while\
    \ let Some(key) = keys.next() {\n        if key.len() != 1 {\n            return\
    \ false;\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n           \
    \ return false;\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp0pbdmosq.rs:21:12\n   |\n21 |         if key[0] >= 'a' && key[0] <=\
    \ 'z' {\n   |            ^^^^^^ `String` cannot be indexed by `{integer}`\n  \
    \ |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0pbdmosq.rs:21:29\n   |\n21 |         if key[0] >= 'a' && key[0]\
    \ <= 'z' {\n   |                             ^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0pbdmosq.rs:24:12\n   |\n24 |         if key[0] >= 'A' && key[0]\
    \ <= 'Z' {\n   |            ^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpu77mgl0a.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpu77mgl0a.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppw396q0_.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppw396q0_.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9iacjnj2.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() > 0 && key.chars().all(|c| c.is_lowercase())\
    \ {\n            true\n        } else if key.len() > 0 && key.chars().all(|c|\
    \ c.is_uppercase()) {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpse23g8pg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb0386xl.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n\
    \   |                      ^^^^^^-\n   |                      |     |\n   |  \
    \                    |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        match value.to_lowercase() {\n            true => true,\n\
    \            false => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2fvi6ka.rs:15:13\n   |\n\
    14 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n15 |             true => true,\n   |    \
    \         ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2fvi6ka.rs:16:13\n   |\n14 |         match value.to_lowercase()\
    \ {\n   |               -------------------- this expression has type `String`\n\
    15 |             true => true,\n16 |             false => false,\n   |       \
    \      ^^^^^ expected struct `String`, found `bool`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpz23c3s_x.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpz23c3s_x.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpkq1x497f.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        let mut i = 0;\n        while i < key.len() {\n          \
    \  if key[i] >= 'A' && key[i] <= 'Z' {\n                i += 1;\n            \
    \    continue;\n            }\n            if key[i] >= 'a' && key[i] <= 'z' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if key[i] >= '0' && key[i] <= '9' {\n                i += 1;\n           \
    \     continue;\n            }\n            return false;\n        }\n       \
    \ return true;\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp42e__9pu.rs:19:16\n\
    \   |\n19 |             if key[i] >= 'A' && key[i] <= 'Z' {\n   |            \
    \    ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp42e__9pu.rs:19:33\n   |\n19 |             if key[i] >= 'A' && key[i]\
    \ <= 'Z' {\n   |                                 ^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp42e__9pu.rs:23:16\n   |\n23 |             if key[i] >= 'a' && key[i]\
    \ <= 'z' {\n   |                ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6p9r053p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for k in dict.keys() {\n        if k.len() < 1 {\n            return\
    \ false;\n        }\n        if k.len() > 1 && k.to_lowercase() == k {\n     \
    \       lower = false;\n        }\n        if k.len() > 1 && k.to_uppercase()\
    \ == k {\n            upper = false;\n        }\n    }\n    lower && upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpg8mp558r.rs:22:44\n\
    \   |\n22 |         if k.len() > 1 && k.to_lowercase() == k {\n   |          \
    \                                  ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpg8mp558r.rs:25:44\n   |\n25 |       \
    \  if k.len() > 1 && k.to_uppercase() == k {\n   |                           \
    \                 ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxe3y5fpk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpbrpkep5n.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpbrpkep5n.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkdzw32ea.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(key) => value.to_lowercase() == key,\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dkce_eb.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1dkce_eb.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(key)\
    \ => value.to_lowercase() == key,\n   |             ^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpy252nmj6.rs:13:40\n   |\n13 |     dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n   |                \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpy252nmj6.rs:13:64\n\
    \   |\n13 |     dict.iter().all(|(_, value)| value.is_lowercase() || value.is_uppercase())\n\
    \   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg5nz9xp6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpimyxkma5.rs:13:40\n   |\n13 |     dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n   |                \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpimyxkma5.rs:13:64\n\
    \   |\n13 |     dict.iter().all(|(_, value)| value.is_lowercase() || value.is_uppercase())\n\
    \   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg112_yuu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(k);\n        if v.is_none() {\n            return false;\n    \
    \    }\n        let v = v.unwrap();\n        if v.len() != 1 {\n            return\
    \ false;\n        }\n        let c = v.chars().next().unwrap();\n        if c\
    \ >= 'a' && c <= 'z' {\n            continue;\n        }\n        if c >= 'A'\
    \ && c <= 'Z' {\n            continue;\n        }\n        return false;\n   \
    \ }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `dict` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpnb719r7k.rs:17:17\n   |\n12 | fn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n   |                    ---- help: consider\
    \ changing this to be mutable: `mut dict`\n...\n17 |         let v = dict.get_mut(k);\n\
    \   |                 ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ig7xdu6.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n\
    \   |                      ^^^^^^-\n   |                      |     |\n   |  \
    \                    |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfhz4sjes.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa5qzocne.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpa5qzocne.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmputf8j8nj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b)\
    \ {\n            if !c.is_ascii_lowercase() && !c.is_ascii_uppercase() {\n   \
    \             return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmp2_f2ngdp.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b)\
    \ {\n   |                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `zip` exists for struct `Zip<Chars<'_>, &&String>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp2_f2ngdp.rs:17:47\n   |\n17 |     \
    \      for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b) {\n   |    \
    \                                             ^^^ method cannot be called on `Zip<Chars<'_>,\
    \ &&String>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `&&String: Iterator`\n           which\
    \ is required by `Zip<Chars<'_>, &&String>: Iterator`\n           `Zip<Chars<'_>,\
    \ &&String>: Iterator`\n           which is required by `&mut Zip<Chars<'_>, &&String>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpn82uprpc.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpn82uprpc.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(lower) => value == lower,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1xmr6oew.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xmr6oew.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for entry in dict.iter() {\n        if\
    \ entry.key().is_lowercase() {\n            return true;\n        }\n        if\
    \ entry.key().is_uppercase() {\n            return true;\n        }\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmp_rzgs9lh.rs:17:18\n   |\n17 |         if\
    \ entry.key().is_lowercase() {\n   |                  ^^^ method not found in\
    \ `(&String, &String)`\n\nerror[E0599]: no method named `key` found for tuple\
    \ `(&String, &String)` in the current scope\n  --> /tmp/tmp_rzgs9lh.rs:20:18\n\
    \   |\n20 |         if entry.key().is_uppercase() {\n   |                  ^^^\
    \ method not found in `(&String, &String)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ val)| val.len() == val.to_lowercase().len())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppavtbpru.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(lower) => value == lower,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpknc0yk2h.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpknc0yk2h.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == value,\n            false => value.to_uppercase() == value,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp0iaif9.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n   |             ^^^^ expected struct `String`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwp0iaif9.rs:16:13\n   |\n14 |  \
    \       match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n16 |             false => value.to_uppercase() == value,\n   |  \
    \           ^^^^^ expected struct `String`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `&String`\n  --> /tmp/tmpwp0iaif9.rs:15:42\n   |\n15 |\
    \             true => value.to_lowercase() == value,\n   |                   \
    \                       ^^ no implementation for `String == &String`\n   |\n \
    \  = help: the trait `PartialEq<&String>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpwp0iaif9.rs:16:43\n   |\n16 |       \
    \      false => value.to_uppercase() == value,\n   |                         \
    \                  ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n        "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpajt1m362.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_,\
    \ value)| {\n        match value.to_lowercase() {\n            true => true,\n\
    \            false => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmparh4qwjo.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(_, value)| {\n   |                      ^^^^^^^^^^-\n\
    \   |                      |         |\n   |                      |         expected\
    \ due to this\n   |                      expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(lower) => value == lower,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp040npmeu.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp040npmeu.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpum0o70bf.rs:13:40\n   |\n13 |     dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n   |                \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpum0o70bf.rs:13:64\n\
    \   |\n13 |     dict.iter().all(|(_, value)| value.is_lowercase() || value.is_uppercase())\n\
    \   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpez3cyfxd.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|(key, value)| {\n        match key.to_lowercase() {\n  \
    \          \"name\" => value.to_lowercase() == \"john\".to_lowercase(),\n    \
    \        \"age\" => value.to_lowercase() == \"36\".to_lowercase(),\n         \
    \   \"city\" => value.to_lowercase() == \"houston\".to_lowercase(),\n        \
    \    _ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22lobexn.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             \"name\" => value.to_lowercase()\
    \ == \"john\".to_lowercase(),\n   |             ^^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22lobexn.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             \"name\" => value.to_lowercase()\
    \ == \"john\".to_lowercase(),\n16 |             \"age\" => value.to_lowercase()\
    \ == \"36\".to_lowercase(),\n   |             ^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22lobexn.rs:17:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n17 |             \"city\" => value.to_lowercase()\
    \ == \"houston\".to_lowercase(),\n   |             ^^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_h9ipww.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9_h9ipww.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj1_26j0j.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1_26j0j.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpj1_26j0j.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.to_lowercase().is_ok() && value.to_uppercase().is_ok()\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0vul_ios.rs:14:30\n   |\n14 |         value.to_lowercase().is_ok()\
    \ && value.to_uppercase().is_ok()\n   |                              ^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `is_ok` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp0vul_ios.rs:14:62\n   |\n14 | \
    \        value.to_lowercase().is_ok() && value.to_uppercase().is_ok()\n   |  \
    \                                                            ^^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4vz04d23.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n\n    for k in dict.keys() {\n        let v\
    \ = dict.get_mut(k);\n        if v.len() != 1 {\n            return false;\n \
    \       }\n        if v.len() == 1 && v[0].is_lowercase() {\n            continue;\n\
    \        }\n        if v.len() == 1 && v[0].is_uppercase() {\n            continue;\n\
    \        }\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpv2wo2ib0.rs:19:14\n   |\n19 |         if v.len() != 1 {\n\
    \   |              ^^^ method not found in `Option<&mut String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpv2wo2ib0.rs:22:14\n\
    \   |\n22 |         if v.len() == 1 && v[0].is_lowercase() {\n   |           \
    \   ^^^ method not found in `Option<&mut String>`\n\nerror[E0608]: cannot index\
    \ into a value of type `Option<&mut String>`\n  --> /tmp/tmpv2wo2ib0.rs:22:28\n\
    \   |\n22 |         if v.len() == 1 && v[0].is_lowercase() {\n   |           \
    \                 ^^^^\n\nerror[E0599]: no method named `len` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpv2wo2ib0.rs:25:14\n   |\n25 |         if\
    \ v.len() == 1 && v[0].is_uppercase() {\n   |              ^^^ method not found\
    \ in `Option<&mut String>`\n\nerror[E0608]: cannot index into a value of type\
    \ `Option<&mut String>`\n  --> /tmp/tmpv2wo2ib0.rs:25:28\n   |\n25 |         if\
    \ v.len() == 1 && v[0].is_uppercase() {\n   |                            ^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpza8serlo.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(lower) => value == lower,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2f07efh6.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2f07efh6.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => value == key.to_uppercase(),\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4_cv73bv.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4_cv73bv.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmp4_cv73bv.rs:16:27\n   |\n16 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp4j7tu31r.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmp4j7tu31r.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|&key| key.len() == key.to_lowercase().len())\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpbq5jerdn.rs:13:42\n\
    \   |\n13 |     !dict.is_empty() && dict.keys().all(|&key| key.len() == key.to_lowercase().len())\n\
    \   |                                          ^---\n   |                    \
    \                      ||\n   |                                          |data\
    \ moved here\n   |                                          |move occurs because\
    \ `key` has type `String`, which does not implement the `Copy` trait\n   |   \
    \                                       help: consider removing the `&`: `key`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpao2c0r4c.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp896xmub6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmptjiw69hf.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmptjiw69hf.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppsnfkmcl.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpisj1m3k1.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpisj1m3k1.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1cjdb9p.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmply49rnmb.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n\
    \    let mut keys_lower = keys.iter().map(|&x| x.to_lowercase()).collect::<Vec<_>>();\n\
    \    let mut keys_upper = keys.iter().map(|&x| x.to_uppercase()).collect::<Vec<_>>();\n\
    \    \n    if keys_lower.is_empty() && keys_upper.is_empty() {\n        return\
    \ true;\n    }\n    \n    if keys_lower.is_empty() {\n        return false;\n\
    \    }\n    \n    if keys_upper.is_empty() {\n        return false;\n    }\n \
    \   \n    if keys_lower.len() != keys_upper.len() {\n        return false;\n \
    \   }\n    \n    for key in keys {\n        if keys_lower.contains(&key) || keys_upper.contains(&key)\
    \ {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph2tw1a_v.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get(k);\n        if k.len() != v.len() {\n            return false;\n \
    \       }\n        for (i, c) in k.chars().zip(v.chars()).zip(|(a, b)| a == b).take(k.len())\
    \ {\n            if c != i {\n                return false;\n            }\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpgrv8ru7f.rs:18:25\n   |\n18 |         if k.len() != v.len()\
    \ {\n   |                         ^^^ method not found in `Option<&String>`\n\n\
    error[E0599]: no method named `chars` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpgrv8ru7f.rs:21:39\n   |\n21 |         for (i, c) in k.chars().zip(v.chars()).zip(|(a,\
    \ b)| a == b).take(k.len()) {\n   |                                       ^^^^^\
    \ method not found in `Option<&String>`\n\nerror[E0277]: `[closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]` is not an iterator\n  --> /tmp/tmpgrv8ru7f.rs:21:48\n   |\n21 |    \
    \     for (i, c) in k.chars().zip(v.chars()).zip(|(a, b)| a == b).take(k.len())\
    \ {\n   |                                                ^^^ `[closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `[closure@/tmp/tmpgrv8ru7f.rs:21:52: 21:67]`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `[closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]`\n\nerror[E0599]: the method `take` exists for struct `Zip<Zip<Chars<'_>,\
    \ _>, [closure@/tmp/tmpgrv8ru7f.rs:21:52: 21:67]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpgrv8ru7f.rs:21:69\n   |\n21 |           for (i,\
    \ c) in k.chars().zip(v.chars()).zip(|(a, b)| a == b).take(k.len()) {\n   |  \
    \                                                    ---------------  ^^^^ method\
    \ cannot be called on `Zip<Zip<Chars<'_>, _>, [closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]>` due to unsatisfied trait bounds\n   |                             \
    \                         |\n   |                                            \
    \          doesn't satisfy `_: Iterator`\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `[closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]: Iterator`\n           which is required by `Zip<Zip<Chars<'_>, _>, [closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]>: Iterator`\n           `Zip<Zip<Chars<'_>, _>, [closure@/tmp/tmpgrv8ru7f.rs:21:52:\
    \ 21:67]>: Ite"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        let mut value = value.to_lowercase();\n        if value.is_uppercase()\
    \ {\n            value = value.to_uppercase();\n        }\n        value == value\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8rzkuinq.rs:15:18\n   |\n15 |         if\
    \ value.is_uppercase() {\n   |                  ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_uppercase`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpg1dewy3b.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpg1dewy3b.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n            if c != c {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpdtk733rz.rs:17:71\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                                  \
    \                     ^ help: a local variable with a similar name exists: `c2`\n\
    \nerror[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpdtk733rz.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                   --- ^^^^^^ `&&String`\
    \ is not an iterator\n   |                                   |\n   |         \
    \                          required by a bound introduced by this call\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&&String`\n\
    \nerror[E0599]: the method `filter` exists for struct `Zip<Chars<'_>, &&String>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpdtk733rz.rs:17:47\n \
    \  |\n17 |           for (i, c) in key.chars().zip(&value).filter(|&(_, c2)| c2\
    \ != c).enumerate() {\n   |                                                 ^^^^^^\
    \ method cannot be called on `Zip<Chars<'_>, &&String>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `&&String: Iterator`\n           which is required by `Zip<Chars<'_>,\
    \ &&String>: Iterator`\n           `Zip<Chars<'_>, &&String>: Iterator`\n    \
    \       which is required by `&mut Zip<Chars<'_>, &&String>: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.islower() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `islower` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmppyf02g6g.rs:14:16\n   |\n14 |         if key.islower()\
    \ {\n   |                ^^^^^^^ method not found in `&String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|key| key.is_ascii() && \n        key.to_lowercase() == key\
    \ || key.to_uppercase() == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpyiauxn0u.rs:14:28\n\
    \   |\n14 |         key.to_lowercase() == key || key.to_uppercase() == key)\n\
    \   |                            ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpyiauxn0u.rs:14:57\n   |\n14 |       \
    \  key.to_lowercase() == key || key.to_uppercase() == key)\n   |             \
    \                                            ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == value,\n            false => value.to_uppercase() == value,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpceosvjs4.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n   |             ^^^^ expected struct `String`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpceosvjs4.rs:16:13\n   |\n14 |  \
    \       match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n16 |             false => value.to_uppercase() == value,\n   |  \
    \           ^^^^^ expected struct `String`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `&String`\n  --> /tmp/tmpceosvjs4.rs:15:42\n   |\n15 |\
    \             true => value.to_lowercase() == value,\n   |                   \
    \                       ^^ no implementation for `String == &String`\n   |\n \
    \  = help: the trait `PartialEq<&String>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpceosvjs4.rs:16:43\n   |\n16 |       \
    \      false => value.to_uppercase() == value,\n   |                         \
    \                  ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n        "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0s2zq6mt.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s2zq6mt.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp0s2zq6mt.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n            if !c.is_ascii_lowercase() && !c.is_ascii_uppercase() {\n   \
    \             return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpscitq31r.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n   |                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `zip` exists for struct `Zip<Chars<'_>, &&String>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpscitq31r.rs:17:47\n   |\n17 |     \
    \      for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n   |                                                 ^^^ method cannot be\
    \ called on `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `&&String:\
    \ Iterator`\n           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n\
    \           `Zip<Chars<'_>, &&String>: Iterator`\n           which is required\
    \ by `&mut Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        key.to_lowercase(&mut lower);\n        value.to_uppercase(&mut upper);\n\
    \        lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpi0fr58ta.rs:16:13\n    |\n16  |         key.to_lowercase(&mut\
    \ lower);\n    |             ^^^^^^^^^^^^ ---------- supplied 1 argument\n   \
    \ |             |\n    |             expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpi0fr58ta.rs:17:15\n    |\n17  |      \
    \   value.to_uppercase(&mut upper);\n    |               ^^^^^^^^^^^^ ----------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        let mut value = value.to_lowercase();\n        if value.is_uppercase()\
    \ {\n            value = value.to_uppercase();\n        }\n        key == value\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp259cjpu5.rs:15:18\n   |\n15 |         if\
    \ value.is_uppercase() {\n   |                  ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_uppercase`\n\nerror[E0277]: can't\
    \ compare `&String` with `String`\n  --> /tmp/tmp259cjpu5.rs:18:13\n   |\n18 |\
    \         key == value\n   |             ^^ no implementation for `&String ==\
    \ String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented for\
    \ `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_lowercase() {\n                return false;\n      \
    \      }\n        }\n        for (i, c) in key.chars().enumerate() {\n       \
    \     if c != value.chars()[i].to_uppercase() {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpuaf03ro6.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_lowercase() {\n   |      \
    \               ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmpuaf03ro6.rs:23:21\n   |\n23 |             if\
    \ c != value.chars()[i].to_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78rcyukw.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(k).unwrap();\n        if v.len() != 0 {\n            if v.len()\
    \ != 1 && v.len() != 2 {\n                return false;\n            }\n     \
    \       if v.len() == 1 {\n                if v.len() == 1 && k.len() == 1 {\n\
    \                    if !k.is_lowercase() {\n                        return false;\n\
    \                    }\n                }\n                if v.len() == 1 &&\
    \ k.len() == 2 {\n                    if !k.is_uppercase() {\n               \
    \         return false;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpyrhikw4o.rs:24:27\n   |\n24 |          \
    \           if !k.is_lowercase() {\n   |                           ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpyrhikw4o.rs:29:27\n   |\n29 |             \
    \        if !k.is_uppercase() {\n   |                           ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n            if !c.is_ascii_lowercase() && !c.is_ascii_uppercase() {\n   \
    \             return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmppxpxcl0o.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n   |                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `zip` exists for struct `Zip<Chars<'_>, &&String>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmppxpxcl0o.rs:17:47\n   |\n17 |     \
    \      for (i, c) in key.chars().zip(&value).zip(|(a, b)| a == b).take(key.len())\
    \ {\n   |                                                 ^^^ method cannot be\
    \ called on `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `&&String:\
    \ Iterator`\n           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n\
    \           `Zip<Chars<'_>, &&String>: Iterator`\n           which is required\
    \ by `&mut Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_ascii_lowercase().unwrap() {\n                return\
    \ false;\n            }\n        }\n        for (i, c) in key.chars().enumerate()\
    \ {\n            if c != value.chars()[i].to_ascii_uppercase().unwrap() {\n  \
    \              return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpv1gxosdc.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_ascii_lowercase().unwrap()\
    \ {\n   |                     ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `Chars<'_>`\n  --> /tmp/tmpv1gxosdc.rs:23:21\n   |\n23 |   \
    \          if c != value.chars()[i].to_ascii_uppercase().unwrap() {\n   |    \
    \                 ^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_dp16zxs.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplqpz8bfu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpuh6x06pr.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpuh6x06pr.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3orqys7f.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.islower() {\n        \
    \    lower = false;\n        }\n        if key.isupper() {\n            upper\
    \ = false;\n        }\n    }\n    lower && upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `islower` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpp2qjb0yg.rs:19:16\n   |\n19 |         if key.islower()\
    \ {\n   |                ^^^^^^^ method not found in `&String`\n\nerror[E0599]:\
    \ no method named `isupper` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpp2qjb0yg.rs:22:16\n   |\n22 |         if key.isupper() {\n   |\
    \                ^^^^^^^ method not found in `&String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8mfq5mu9.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppvegzxth.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7sboz8wk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut upper_case = true;\n    let mut\
    \ lower_case = true;\n    for k in dict.keys() {\n        if k.len() > 1 && k.to_lowercase()\
    \ == k {\n            lower_case = false;\n        }\n        if k.len() > 1 &&\
    \ k.to_uppercase() == k {\n            upper_case = false;\n        }\n    }\n\
    \    lower_case && upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpcxj2ugav.rs:19:44\n\
    \   |\n19 |         if k.len() > 1 && k.to_lowercase() == k {\n   |          \
    \                                  ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpcxj2ugav.rs:22:44\n   |\n22 |       \
    \  if k.len() > 1 && k.to_uppercase() == k {\n   |                           \
    \                 ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == value,\n            false => value.to_uppercase() == value,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptd5h3dlk.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n   |             ^^^^ expected struct `String`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptd5h3dlk.rs:16:13\n   |\n14 |  \
    \       match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n16 |             false => value.to_uppercase() == value,\n   |  \
    \           ^^^^^ expected struct `String`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `&String`\n  --> /tmp/tmptd5h3dlk.rs:15:42\n   |\n15 |\
    \             true => value.to_lowercase() == value,\n   |                   \
    \                       ^^ no implementation for `String == &String`\n   |\n \
    \  = help: the trait `PartialEq<&String>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmptd5h3dlk.rs:16:43\n   |\n16 |       \
    \      false => value.to_uppercase() == value,\n   |                         \
    \                  ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n        "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        match value.to_lowercase() {\n            true => true,\n\
    \            false => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4aoe68zw.rs:15:13\n   |\n\
    14 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n15 |             true => true,\n   |    \
    \         ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4aoe68zw.rs:16:13\n   |\n14 |         match value.to_lowercase()\
    \ {\n   |               -------------------- this expression has type `String`\n\
    15 |             true => true,\n16 |             false => false,\n   |       \
    \      ^^^^^ expected struct `String`, found `bool`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).enumerate() {\n    \
    \        if c != c.to_lowercase() || c != c.to_uppercase() {\n               \
    \ return false;\n            }\n        }\n        true\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmp3xni1sm_.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).enumerate() {\n   |\
    \                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `enumerate` exists for struct `Zip<Chars<'_>, &&String>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp3xni1sm_.rs:17:47\n   |\n17 |\
    \           for (i, c) in key.chars().zip(&value).enumerate() {\n   |        \
    \                                         ^^^^^^^^^ method cannot be called on\
    \ `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `&&String: Iterator`\n\
    \           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n      \
    \     `Zip<Chars<'_>, &&String>: Iterator`\n           which is required by `&mut\
    \ Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).enumerate() {\n    \
    \        if c != c.to_lowercase() || c != c.to_uppercase() {\n               \
    \ return false;\n            }\n        }\n        true\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpnic43p2o.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).enumerate() {\n   |\
    \                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `enumerate` exists for struct `Zip<Chars<'_>, &&String>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpnic43p2o.rs:17:47\n   |\n17 |\
    \           for (i, c) in key.chars().zip(&value).enumerate() {\n   |        \
    \                                         ^^^^^^^^^ method cannot be called on\
    \ `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `&&String: Iterator`\n\
    \           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n      \
    \     `Zip<Chars<'_>, &&String>: Iterator`\n           which is required by `&mut\
    \ Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ val)| val.to_lowercase() == val)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpesfn4b2l.rs:13:51\n\
    \   |\n13 |     dict.iter().all(|(_, val)| val.to_lowercase() == val)\n   |  \
    \                                                 ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            None => false,\n\
    \            Some(lower) => value == lower,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmz4jxu8a.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmz4jxu8a.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             None => false,\n16 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        let mut lower = key.to_lowercase();\n        let mut upper\
    \ = key.to_uppercase();\n        lower.replace(&mut upper, \"\");\n        lower\
    \ == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   -->\
    \ /tmp/tmp7ghl3mws.rs:16:23\n    |\n16  |         lower.replace(&mut upper, \"\
    \");\n    |               ------- ^^^^^^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `String`\n    |               |\n    |               required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `FnMut<(char,)>` is not\
    \ implemented for `String`\n    = help: the following other types implement trait\
    \ `Pattern<'a>`:\n              &'b String\n              &'b str\n          \
    \    &'c &'b str\n    = note: required because of the requirements on the impl\
    \ of `FnOnce<(char,)>` for `&mut String`\n    = note: required because of the\
    \ requirements on the impl of `Pattern<'_>` for `&mut String`\nnote: required\
    \ by a bound in `str::<impl str>::replace`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|&(k, _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptzkve6lk.rs:13:42\n   |\n\
    13 |     !dict.is_empty() && dict.iter().all(|&(k, _)| k.is_ascii_lowercase()\
    \ || k.is_ascii_uppercase())\n   |                                          ^^^^^^-\n\
    \   |                                          |     |\n   |                 \
    \                         |     expected due to this\n   |                   \
    \                       expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(&String, &String)`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp_a1fsp4o.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmp_a1fsp4o.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_upper = false;\n    let mut\
    \ is_lower = false;\n    for key in dict.keys() {\n        if key.len() > 0 {\n\
    \            if key[0] >= 'A' && key[0] <= 'Z' {\n                is_upper = true;\n\
    \            } else if key[0] >= 'a' && key[0] <= 'z' {\n                is_lower\
    \ = true;\n            } else {\n                return false;\n            }\n\
    \        }\n    }\n    if is_upper && is_lower {\n        return true;\n    }\n\
    \    if is_upper {\n        return true;\n    }\n    if is_lower {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpz_ob3vrc.rs:20:16\n   |\n20 |             if key[0] >= 'A' && key[0]\
    \ <= 'Z' {\n   |                ^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpz_ob3vrc.rs:20:33\n   |\n20 |             if key[0] >= 'A' && key[0]\
    \ <= 'Z' {\n   |                                 ^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpz_ob3vrc.rs:22:23\n   |\n22 |             } else if key[0] >= 'a'\
    \ && key[0] <= 'z' {\n   |                       ^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usiz"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(&k).unwrap();\n        if v.len() != 1 {\n            return false;\n\
    \        }\n        let c = v.chars().next().unwrap();\n        if c < 'a' ||\
    \ c > 'z' {\n            return false;\n        }\n    }\n    for k in dict.keys()\
    \ {\n        let v = dict.get_mut(&k).unwrap();\n        if v.len() != 1 {\n \
    \           return false;\n        }\n        let c = v.chars().next().unwrap();\n\
    \        if c < 'A' || c > 'Z' {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n\
    \   --> /tmp/tmpil5lqdfz.rs:17:30\n    |\n17  |         let v = dict.get_mut(&k).unwrap();\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n \
    \  --> /tmp/tmpil5lqdfz.rs:27:30\n    |\n27  |         let v = dict.get_mut(&k).unwrap();\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1syqvj2u.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(&k);\n        if let Some(v) = v.to_owned() {\n            if v.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n\
    \   --> /tmp/tmpw9vabkc_.rs:17:30\n    |\n17  |         let v = dict.get_mut(&k);\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror[E0599]: the method `to_owned` exists for enum `Option<&mut String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpw9vabkc_.rs:18:28\n    |\n\
    18  |           if let Some(v) = v.to_owned() {\n    |                       \
    \       ^^^^^^^^ method cannot be called on `Option<&mut String>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&mut String>: Clone`\n            which is required by `Option<&mut\
    \ String>: ToOwned`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n\
    \    let mut keys_lower = keys.iter().map(|&x| x.to_lowercase()).collect::<Vec<_>>();\n\
    \    let mut keys_upper = keys.iter().map(|&x| x.to_uppercase()).collect::<Vec<_>>();\n\
    \    let mut keys_all = keys.iter().cloned().collect::<Vec<_>>();\n    keys_lower.sort();\n\
    \    keys_upper.sort();\n    keys_all.sort();\n    if keys_lower == keys_all {\n\
    \        return true;\n    }\n    if keys_upper == keys_all {\n        return\
    \ true;\n    }\n    if keys_lower == keys_upper {\n        return true;\n    }\n\
    \    if keys_lower == keys_all {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpl09vion3.rs:23:19\n\
    \   |\n23 |     if keys_lower == keys_all {\n   |                   ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<Vec<&String>>` for `Vec<String>`\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpl09vion3.rs:26:19\n   |\n26 |     if\
    \ keys_upper == keys_all {\n   |                   ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<Vec<&String>>` for `Vec<String>`\n\
    \nerror[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpl09vion3.rs:32:19\n\
    \   |\n32 |     if keys_lower == keys_all {\n   |                   ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() == 0 {\n            return false;\n        }\n\
    \        if key.to_lowercase() == key {\n            return true;\n        }\n\
    \        if key.to_uppercase() == key {\n            return true;\n        }\n\
    \        return false;\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpsi4zq876.rs:17:31\n\
    \   |\n17 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpsi4zq876.rs:20:31\n   |\n20 |         if key.to_uppercase() ==\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys();\n    while\
    \ let Some(key) = keys.next() {\n        if key.to_lowercase() == key {\n    \
    \        continue;\n        }\n        if key.to_uppercase() == key {\n      \
    \      continue;\n        }\n        return false;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpuw4jib78.rs:18:31\n\
    \   |\n18 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpuw4jib78.rs:21:31\n   |\n21 |         if key.to_uppercase() ==\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(&k);\n        if v.is_none() {\n            return false;\n   \
    \     }\n        match v.unwrap().to_lowercase() {\n            true => {}\n \
    \           false => return false,\n        }\n        match v.unwrap().to_uppercase()\
    \ {\n            true => {}\n            false => return false,\n        }\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n\
    \   --> /tmp/tmpxh20kzrh.rs:17:30\n    |\n17  |         let v = dict.get_mut(&k);\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxh20kzrh.rs:22:13\n   |\n21 |\
    \         match v.unwrap().to_lowercase() {\n   |               -------------------------\
    \ this expression has type `String`\n22 |             true => {}\n   |       \
    \      ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxh20kzrh.rs:23:13\n   |\n21 |         match v.unwrap().to_lowercase()\
    \ {\n   |               ------------------------- this expression has type `String`\n\
    22 |             true => {}\n23 |             false => return false,\n   |   \
    \          ^^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxh20kzrh.rs:26:13\n   |\n25 |         match v.unwrap().to_uppercase()\
    \ {\n   |               ------------------------- this expression has type `String`\n\
    26 |             true => {}\n   |             ^^^^ expected struct `String`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxh20kzrh.rs:27:13\n\
    \   |\n25 |         match v.unwrap().to_uppercase() {\n   |               -------------------------\
    \ this expression has type `String`\n26 |             true => {}\n27 |       \
    \      false => return false,\n   |             ^^^^^ expected struct `String`,\
    \ found `bool`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpub7z8_sw.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        key.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0hge56fa.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5b7jnrod.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpt8rorbr_.rs:13:40\n   |\n13 |     dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n   |                \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpt8rorbr_.rs:13:64\n\
    \   |\n13 |     dict.iter().all(|(_, value)| value.is_lowercase() || value.is_uppercase())\n\
    \   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut res = true;\n    for k in dict.keys()\
    \ {\n        if k.len() != 1 {\n            res = false;\n            break;\n\
    \        }\n        if k.to_lowercase() != k {\n            res = false;\n   \
    \         break;\n        }\n    }\n    for k in dict.keys() {\n        if k.len()\
    \ != 1 {\n            res = false;\n            break;\n        }\n        if\
    \ k.to_uppercase() != k {\n            res = false;\n            break;\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpq6u70wfs.rs:22:29\n\
    \   |\n22 |         if k.to_lowercase() != k {\n   |                         \
    \    ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpq6u70wfs.rs:32:29\n   |\n32 |         if k.to_uppercase() != k\
    \ {\n   |                             ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_yjflqps.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == value,\n            false => value.to_uppercase() == value,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6c0e77o.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n   |             ^^^^ expected struct `String`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd6c0e77o.rs:16:13\n   |\n14 |  \
    \       match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == value,\n16 |             false => value.to_uppercase() == value,\n   |  \
    \           ^^^^^ expected struct `String`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `&String`\n  --> /tmp/tmpd6c0e77o.rs:15:42\n   |\n15 |\
    \             true => value.to_lowercase() == value,\n   |                   \
    \                       ^^ no implementation for `String == &String`\n   |\n \
    \  = help: the trait `PartialEq<&String>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpd6c0e77o.rs:16:43\n   |\n16 |       \
    \      false => value.to_uppercase() == value,\n   |                         \
    \                  ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n        "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2i4nf9q_.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzwg2oo_y.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if let Ok(key) = key.to_lowercase() {\n            true\n\
    \        } else if let Ok(key) = key.to_uppercase() {\n            true\n    \
    \    } else {\n            false\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz49u5w2a.rs:14:16\n   |\n\
    14 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz49u5w2a.rs:16:23\n   |\n16 |\
    \         } else if let Ok(key) = key.to_uppercase() {\n   |                 \
    \      ^^^^^^^   ------------------ this expression has type `String`\n   |  \
    \                     |\n   |                       expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rggg6yj.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_lowercase() {\n                return false;\n      \
    \      }\n        }\n        for (i, c) in key.chars().enumerate() {\n       \
    \     if c != value.chars()[i].to_uppercase() {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpoaelfc9v.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_lowercase() {\n   |      \
    \               ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmpoaelfc9v.rs:23:21\n   |\n23 |             if\
    \ c != value.chars()[i].to_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwbomp74.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwbomp74.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmptwbomp74.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for entry in dict.iter() {\n        let\
    \ key = entry.key();\n        let value = entry.value();\n        if key.len()\
    \ != 1 || value.len() != 1 {\n            return false;\n        }\n        let\
    \ first_char = key[0];\n        let second_char = value[0];\n        if first_char\
    \ != second_char {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmp9e_8gflf.rs:17:25\n   |\n17 |         let\
    \ key = entry.key();\n   |                         ^^^ method not found in `(&String,\
    \ &String)`\n\nerror[E0599]: no method named `value` found for tuple `(&String,\
    \ &String)` in the current scope\n  --> /tmp/tmp9e_8gflf.rs:18:27\n   |\n18 |\
    \         let value = entry.value();\n   |                           ^^^^^ method\
    \ not found in `(&String, &String)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp0qnafzcy.rs:13:40\n   |\n13 |     dict.iter().all(|(_,\
    \ value)| value.is_lowercase() || value.is_uppercase())\n   |                \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmp0qnafzcy.rs:13:64\n\
    \   |\n13 |     dict.iter().all(|(_, value)| value.is_lowercase() || value.is_uppercase())\n\
    \   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_lowercase() {\n                return false;\n      \
    \      }\n        }\n        for (i, c) in key.chars().enumerate() {\n       \
    \     if c != value.chars()[i].to_uppercase() {\n                return false;\n\
    \            }\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmps9ewm2k6.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_lowercase() {\n   |      \
    \               ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmps9ewm2k6.rs:23:21\n   |\n23 |             if\
    \ c != value.chars()[i].to_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.to_lowercase().is_ok() && value.to_uppercase().is_ok()\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpix96nhjr.rs:14:30\n   |\n14 |         value.to_lowercase().is_ok()\
    \ && value.to_uppercase().is_ok()\n   |                              ^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `is_ok` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpix96nhjr.rs:14:62\n   |\n14 | \
    \        value.to_lowercase().is_ok() && value.to_uppercase().is_ok()\n   |  \
    \                                                            ^^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        let mut lower = value.to_lowercase();\n        let mut upper\
    \ = value.to_uppercase();\n        lower.chars().all(|c| !upper.contains(c));\n\
    \        upper.chars().all(|c| !lower.contains(c));\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84e3i2b7.rs:13:34\n   |\n\
    13 |       dict.iter().all(|(_, value)| {\n   |  __________________________________^\n\
    14 | |         let mut lower = value.to_lowercase();\n15 | |         let mut upper\
    \ = value.to_uppercase();\n16 | |         lower.chars().all(|c| !upper.contains(c));\n\
    17 | |         upper.chars().all(|c| !lower.contains(c));\n   | |            \
    \                                      - help: remove this semicolon\n18 | | \
    \    })\n   | |_____^ expected `bool`, found `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3qgnynij.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|&k| k.is_ascii() && k.to_lowercase() == k)\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmp8_qmu_96.rs:13:42\n\
    \   |\n13 |     !dict.is_empty() && dict.keys().all(|&k| k.is_ascii() && k.to_lowercase()\
    \ == k)\n   |                                          ^-\n   |              \
    \                            ||\n   |                                        \
    \  |data moved here\n   |                                          |move occurs\
    \ because `k` has type `String`, which does not implement the `Copy` trait\n \
    \  |                                          help: consider removing the `&`:\
    \ `k`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuklav2fy.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|key| key.to_lowercase() == key)\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpazkc_uar.rs:13:66\n\
    \   |\n13 |     !dict.is_empty() && dict.keys().all(|key| key.to_lowercase() ==\
    \ key)\n   |                                                                 \
    \ ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.to_lowercase() == value\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp9gz41swm.rs:14:30\n\
    \   |\n14 |         value.to_lowercase() == value\n   |                      \
    \        ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnmx43izx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpqvp4_ncb.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpqvp4_ncb.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for entry in dict.iter() {\n        if\
    \ entry.key().is_lowercase() {\n            return true;\n        }\n        if\
    \ entry.key().is_uppercase() {\n            return true;\n        }\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpfhqx1coz.rs:17:18\n   |\n17 |         if\
    \ entry.key().is_lowercase() {\n   |                  ^^^ method not found in\
    \ `(&String, &String)`\n\nerror[E0599]: no method named `key` found for tuple\
    \ `(&String, &String)` in the current scope\n  --> /tmp/tmpfhqx1coz.rs:20:18\n\
    \   |\n20 |         if entry.key().is_uppercase() {\n   |                  ^^^\
    \ method not found in `(&String, &String)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpe3g2lqxb.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpe3g2lqxb.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        key.to_lowercase(&mut lower);\n        value.to_uppercase(&mut upper);\n\
    \        lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpiiawky62.rs:16:13\n    |\n16  |         key.to_lowercase(&mut\
    \ lower);\n    |             ^^^^^^^^^^^^ ---------- supplied 1 argument\n   \
    \ |             |\n    |             expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpiiawky62.rs:17:15\n    |\n17  |      \
    \   value.to_uppercase(&mut upper);\n    |               ^^^^^^^^^^^^ ----------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3ar5ah0.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi1h5d09m.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii_lowercase() || k.is_ascii_uppercase())\n\
    \   |                      ^^^^^^-\n   |                      |     |\n   |  \
    \                    |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key {\n            key if key.len() == key.to_lowercase().len()\
    \ => true,\n            key if key.len() == key.to_uppercase().len() => true,\n\
    \            _ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppa8kag2w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpxfxn4pb5.rs:13:52\n   |\n13 |\
    \     !dict.is_empty() && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpxfxn4pb5.rs:13:78\n   |\n13 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    \   |                                                                        \
    \      ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_3081ln.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get(k);\n        if k.len() != v.len() {\n            return false;\n \
    \       }\n        for (i, c) in v.chars().zip(k.chars()).filter(|&(a, b)| a ==\
    \ b).enumerate() {\n            if c != b {\n                return false;\n \
    \           }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmps0r22orz.rs:22:21\n\
    \   |\n22 |             if c != b {\n   |                     ^ help: a local\
    \ variable with a similar name exists: `c`\n\nerror[E0599]: no method named `len`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmps0r22orz.rs:18:25\n\
    \   |\n18 |         if k.len() != v.len() {\n   |                         ^^^\
    \ method not found in `Option<&String>`\n\nerror[E0599]: no method named `chars`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmps0r22orz.rs:21:25\n\
    \   |\n21 |         for (i, c) in v.chars().zip(k.chars()).filter(|&(a, b)| a\
    \ == b).enumerate() {\n   |                         ^^^^^ method not found in\
    \ `Option<&String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).enumerate() {\n    \
    \        if c != c.to_lowercase() || c != c.to_uppercase() {\n               \
    \ return false;\n            }\n        }\n        true\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpbmifvg9h.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).enumerate() {\n   |\
    \                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `enumerate` exists for struct `Zip<Chars<'_>, &&String>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpbmifvg9h.rs:17:47\n   |\n17 |\
    \           for (i, c) in key.chars().zip(&value).enumerate() {\n   |        \
    \                                         ^^^^^^^^^ method cannot be called on\
    \ `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `&&String: Iterator`\n\
    \           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n      \
    \     `Zip<Chars<'_>, &&String>: Iterator`\n           which is required by `&mut\
    \ Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpz5jfy9in.rs:13:52\n   |\n13 |\
    \     !dict.is_empty() && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpz5jfy9in.rs:13:78\n   |\n13 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_ascii_lowercase() || v.is_ascii_uppercase())\n\
    \   |                                                                        \
    \      ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2kwl5o6.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2kwl5o6.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpf2kwl5o6.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == true,\n            false => value.to_uppercase() == true,\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxw_91c46.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == true,\n   |             ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxw_91c46.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             true => value.to_lowercase() == true,\n\
    16 |             false => value.to_uppercase() == true,\n   |             ^^^^^\
    \ expected struct `String`, found `bool`\n\nerror[E0277]: can't compare `String`\
    \ with `bool`\n  --> /tmp/tmpxw_91c46.rs:15:42\n   |\n15 |             true =>\
    \ value.to_lowercase() == true,\n   |                                        \
    \  ^^ no implementation for `String == bool`\n   |\n   = help: the trait `PartialEq<bool>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `bool`\n\
    \  --> /tmp/tmpxw_91c46.rs:16:43\n   |\n16 |             false => value.to_uppercase()\
    \ == true,\n   |                                           ^^ no implementation\
    \ for `String == bool`\n   |\n   = help: the trait `PartialEq<bool>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as Partial"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|(key, value)| {\n        match key.to_lowercase() {\n  \
    \          Some(lower) => value == lower,\n            None => key.to_uppercase()\
    \ == value,\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0gbpvty.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf0gbpvty.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => key.to_uppercase() == value,\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `String`\
    \ with `&String`\n  --> /tmp/tmpf0gbpvty.rs:16:40\n   |\n16 |             None\
    \ => key.to_uppercase() == value,\n   |                                      \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmxwkpt0.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0mr8cy4m.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0mr8cy4m.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkn7qd6rc.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(k);\n        if v.len() != 1 {\n            return false;\n   \
    \     }\n        let c = v.chars().next().unwrap();\n        if c < 'a' || c >\
    \ 'z' {\n            return false;\n        }\n    }\n    for k in dict.keys()\
    \ {\n        let v = dict.get_mut(k);\n        if v.len() != 1 {\n           \
    \ return false;\n        }\n        let c = v.chars().next().unwrap();\n     \
    \   if c > 'A' || c < 'Z' {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp4jc819z_.rs:18:14\n   |\n18 |         if v.len() != 1 {\n\
    \   |              ^^^ method not found in `Option<&mut String>`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp4jc819z_.rs:21:19\n   |\n21 |         let c = v.chars().next().unwrap();\n\
    \   |                   ^^^^^ method not found in `Option<&mut String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp4jc819z_.rs:28:14\n\
    \   |\n28 |         if v.len() != 1 {\n   |              ^^^ method not found\
    \ in `Option<&mut String>`\n\nerror[E0599]: no method named `chars` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmp4jc819z_.rs:31:19\n   |\n\
    31 |         let c = v.chars().next().unwrap();\n   |                   ^^^^^\
    \ method not found in `Option<&mut String>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfeabm46x.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|&k| k.is_ascii() && k.to_lowercase() == k)\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpmlf7wsq5.rs:13:42\n\
    \   |\n13 |     !dict.is_empty() && dict.keys().all(|&k| k.is_ascii() && k.to_lowercase()\
    \ == k)\n   |                                          ^-\n   |              \
    \                            ||\n   |                                        \
    \  |data moved here\n   |                                          |move occurs\
    \ because `k` has type `String`, which does not implement the `Copy` trait\n \
    \  |                                          help: consider removing the `&`:\
    \ `k`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() == 0 {\n            return false;\n        }\n\
    \        match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => value == key.to_uppercase(),\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprslfkgok.rs:18:13\n   |\n\
    17 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n18 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprslfkgok.rs:19:13\n   |\n17 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n18 |             Some(lower) => value == lower,\n\
    19 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmprslfkgok.rs:19:27\n   |\n19 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaqm_1653.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwz0pbojc.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpsy1y3np7.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpsy1y3np7.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().zip(&value).enumerate() {\n    \
    \        if c != c.to_lowercase() || c != c.to_uppercase() {\n               \
    \ return false;\n            }\n        }\n        true\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&String` is not an iterator\n  --> /tmp/tmp0n_vvsd2.rs:17:39\n\
    \   |\n17 |         for (i, c) in key.chars().zip(&value).enumerate() {\n   |\
    \                                   --- ^^^^^^ `&&String` is not an iterator\n\
    \   |                                   |\n   |                              \
    \     required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&&String`\n\nerror[E0599]:\
    \ the method `enumerate` exists for struct `Zip<Chars<'_>, &&String>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp0n_vvsd2.rs:17:47\n   |\n17 |\
    \           for (i, c) in key.chars().zip(&value).enumerate() {\n   |        \
    \                                         ^^^^^^^^^ method cannot be called on\
    \ `Zip<Chars<'_>, &&String>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `&&String: Iterator`\n\
    \           which is required by `Zip<Chars<'_>, &&String>: Iterator`\n      \
    \     `Zip<Chars<'_>, &&String>: Iterator`\n           which is required by `&mut\
    \ Zip<Chars<'_>, &&String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5rqio5.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        let v =\
    \ dict.get_mut(&k).unwrap();\n        if v.len() != 1 {\n            return false;\n\
    \        }\n        if v.chars().all(|c| c.is_lowercase()) {\n            return\
    \ true;\n        }\n        if v.chars().all(|c| c.is_uppercase()) {\n       \
    \     return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n\
    \   --> /tmp/tmpaj8_lgy3.rs:17:30\n    |\n17  |         let v = dict.get_mut(&k).unwrap();\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].unwrap() {\n                return false;\n            }\n\
    \        }\n        true\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp8lvlsymq.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].unwrap() {\n   |            \
    \         ^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() == 0 {\n            return false;\n        }\n\
    \        if key.to_lowercase() == key {\n            return true;\n        }\n\
    \        if key.to_uppercase() == key {\n            return true;\n        }\n\
    \        return false;\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgy9vvlhq.rs:17:31\n\
    \   |\n17 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpgy9vvlhq.rs:20:31\n   |\n20 |         if key.to_uppercase() ==\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv2050do3.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv2050do3.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys();\n    while\
    \ let Some(key) = keys.next() {\n        if key.len() != 1 && key.len() != 2 {\n\
    \            return false;\n        }\n        if key.len() == 1 && key[0] >=\
    \ 'a' && key[0] <= 'z' {\n            continue;\n        }\n        if key.len()\
    \ == 2 && key[0] >= 'A' && key[0] <= 'Z' {\n            continue;\n        }\n\
    \        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp3ibc7i2d.rs:21:30\n   |\n21 |         if key.len() == 1 && key[0] >=\
    \ 'a' && key[0] <= 'z' {\n   |                              ^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3ibc7i2d.rs:21:47\n   |\n21 |         if key.len() == 1 && key[0]\
    \ >= 'a' && key[0] <= 'z' {\n   |                                            \
    \   ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3ibc7i2d.rs:24:30\n   |\n24 |         if key.len() == 2 && key[0]\
    \ >= 'A' && key[0] <= 'Z' {\n   |                              ^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Inde"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ if key.is_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmptm088_9z.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmptm088_9z.rs:16:23\n\
    \   |\n16 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6x3yqlz.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8mx08jbu.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut keys = dict.keys().cloned().collect::<Vec<_>>();\n\
    \    keys.sort();\n    for k in keys {\n        if k.len() != 1 && k.len() !=\
    \ 2 {\n            return false;\n        }\n        if k.len() == 1 && k.to_lowercase().is_empty()\
    \ {\n            return false;\n        }\n        if k.len() == 2 && k.to_uppercase().is_empty()\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwc745gno.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_ascii())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy3o6dvbs.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_ascii())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptx_apv6m.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkaz0d8fy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpqlgmfleo.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpqlgmfleo.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for k in dict.keys() {\n        if k.len() != 1 {\n           \
    \ lower = false;\n        }\n        if k.len() != 2 {\n            upper = false;\n\
    \        }\n    }\n    lower && upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmy4agqow.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmppnlh2nia.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpec_s8hmv.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => value == key.to_uppercase(),\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0tx3cms4.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0tx3cms4.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmp0tx3cms4.rs:16:27\n   |\n16 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.is_lowercase() {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp2vqi1112.rs:14:16\n   |\n14 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|key| key.is_lowercase() || key.is_uppercase())\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpiet3p20e.rs:13:51\n   |\n13 |     !dict.is_empty()\
    \ && dict.keys().all(|key| key.is_lowercase() || key.is_uppercase())\n   |   \
    \                                                ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no\
    \ method named `is_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpiet3p20e.rs:13:73\n   |\n13 |     !dict.is_empty() && dict.keys().all(|key|\
    \ key.is_lowercase() || key.is_uppercase())\n   |                            \
    \                                             ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.keys().all(|key| key.to_lowercase() == key)\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp_mbqv8w8.rs:13:66\n\
    \   |\n13 |     !dict.is_empty() && dict.keys().all(|key| key.to_lowercase() ==\
    \ key)\n   |                                                                 \
    \ ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp1qv2r0r5.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmp1qv2r0r5.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ag38a2b.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ag38a2b.rs:16:13\n\
    \   |\n14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n16 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp_ag38a2b.rs:16:42\n   |\n\
    16 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if let Ok(key) = key.to_lowercase() {\n            if let\
    \ Ok(value) = value.to_lowercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        } else {\n            if let\
    \ Ok(value) = value.to_uppercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_x53jpf.rs:14:16\n   |\n\
    14 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw_x53jpf.rs:15:20\n   |\n15 |\
    \             if let Ok(value) = value.to_lowercase() {\n   |                \
    \    ^^^^^^^^^   -------------------- this expression has type `String`\n   |\
    \                    |\n   |                    expected struct `String`, found\
    \ enum `Result`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_x53jpf.rs:21:20\n\
    \   |\n21 |             if let Ok(value) = value.to_uppercase() {\n   |      \
    \              ^^^^^^^^^   -------------------- this expression has type `String`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj02m8r0d.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key {\n            String::from(\"a\") | String::from(\"\
    A\") | String::from(\"b\") | String::from(\"B\") | String::from(\"c\") | String::from(\"\
    C\") | String::from(\"d\") | String::from(\"D\") | String::from(\"e\") | String::from(\"\
    E\") | String::from(\"f\") | String::from(\"F\") | String::from(\"g\") | String::from(\"\
    G\") | String::from(\"h\") | String::from(\"H\") | String::from(\"i\") | String::from(\"\
    I\") | String::from(\"j\") | String::from(\"J\") | String::from(\"k\") | String::from(\"\
    K\") | String::from(\"l\") | String::from(\"L\") | String::from(\"m\") | String::from(\"\
    M\") | String::from(\"n\") | String::from(\"N\") | String::from(\"o\") | String::from(\"\
    O\") | String::from(\"p\") | String::from(\"P\") | String::from(\"q\") | String::from(\"\
    Q\") | String::from(\"r\") | String::from(\"R\") | String::from(\"s\") | String::from(\"\
    S\") | String::from(\"t\") | String::from(\"T\") | String::from(\"u\") | String::from(\"\
    U\") | String::from(\"v\") | String::from(\"V\") | String::from(\"w\") | String::from(\"\
    W\") | String::from(\"x\") | String::from(\"X\") | String::from(\"y\") | String::from(\"\
    Y\") | String::from(\"z\") | String::from(\"Z\") | String::from(\"A\") | String::from(\"\
    B\") | String::from(\"C\") | String::from(\"D\") | String::from(\"E\") | String::from(\"\
    F\") | String::from(\"G\") | String::from(\"H\") | String::from(\"I\") | String::from(\"\
    J\") | String::from(\"K\") | String::from(\"L\") | String::from(\"M\") | String::from(\"\
    N\") | String::from(\"O\") | String::from(\"P\") | String::from(\"Q\") | String::from(\"\
    R\") | String::from(\"S\") | \n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9k22tfgo.rs:27:3\n\
    \   |\n12 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - unclosed delimiter\n\
    13 |     dict.iter().all(|(key, value)| {\n   |                    -         \
    \      - unclosed delimiter\n   |                    |\n   |                 \
    \   unclosed delimiter\n14 |         match key {\n   |                   - this\
    \ delimiter might not be properly closed...\n15 |             String::from(\"\
    a\") | String::from(\"A\") | Stri...\n16 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n27 | }\n   |   ^\n\nerror: a trailing `|`\
    \ is not allowed in an or-pattern\n  --> /tmp/tmp9k22tfgo.rs:15:1431\n   |\n15\
    \ | ...   String::from(\"a\") | String::from(\"A\") | String::from(\"b\") | String::from(\"\
    B\") | String::from(\"c\") | String::from(\"C\") | String::from(\"d\") | String::from(\"\
    D\") | String::from(\"e\") | String::from(\"E\") | String::from(\"f\") | String::from(\"\
    F\") | String::from(\"g\") | String::from(\"G\") | String::from(\"h\") | String::from(\"\
    H\") | String::from(\"i\") | String::from(\"I\") | String::from(\"j\") | String::from(\"\
    J\") | String::from(\"k\") | String::from(\"K\") | String::from(\"l\") | String::from(\"\
    L\") | String::from(\"m\") | String::from(\"M\") | String::from(\"n\") | String::from(\"\
    N\") | String::from(\"o\") | String::from(\"O\") | String::from(\"p\") | String::from(\"\
    P\") | String::from(\"q\") | String::from(\"Q\") | String::from(\"r\") | String::from(\"\
    R\") | String::from(\"s\") | String::from(\"S\") | String::from(\"t\") | String::from(\"\
    T\") | String::from(\"u\") | String::from(\"U\") | String::from(\"v\") | String::from(\"\
    V\") | String::from(\"w\") | String::from(\"W\") | String::from(\"x\") | String::from(\"\
    X\") | String::from(\"y\") | String::from(\"Y\") | String::from(\"z\") | String::from(\"\
    Z\") | String::from(\"A\") | String::from(\"B\") | String::from(\"C\") | String::from(\"\
    D\") | String::from(\"E\") | String::from(\"F\") | String::from(\"G\") | String::from(\"\
    H\") | String::from(\"I\") | String::from(\"J\") | String::from(\"K\") | String::from(\"\
    L\") | String:"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if let Ok(key) = key.to_lowercase() {\n            if let\
    \ Ok(value) = value.to_lowercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        } else {\n            if let\
    \ Ok(value) = value.to_uppercase() {\n                true\n            } else\
    \ {\n                false\n            }\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnelopa5v.rs:14:16\n   |\n\
    14 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnelopa5v.rs:15:20\n   |\n15 |\
    \             if let Ok(value) = value.to_lowercase() {\n   |                \
    \    ^^^^^^^^^   -------------------- this expression has type `String`\n   |\
    \                    |\n   |                    expected struct `String`, found\
    \ enum `Result`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnelopa5v.rs:21:20\n\
    \   |\n21 |             if let Ok(value) = value.to_uppercase() {\n   |      \
    \              ^^^^^^^^^   -------------------- this expression has type `String`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n\n    for k in dict.keys() {\n        let v\
    \ = dict.get_mut(&k);\n        if let Some(v) = v {\n            if v.len() !=\
    \ 0 {\n                return false;\n            }\n        }\n    }\n\n    for\
    \ k in dict.keys() {\n        let v = dict.get_mut(&k);\n        if let Some(v)\
    \ = v {\n            if v.len() == 0 {\n                return false;\n      \
    \      }\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n\
    \   --> /tmp/tmp06wwq7rs.rs:18:30\n    |\n18  |         let v = dict.get_mut(&k);\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror[E0277]: the trait bound `String: Borrow<&String>` is not satisfied\n \
    \  --> /tmp/tmp06wwq7rs.rs:27:30\n    |\n27  |         let v = dict.get_mut(&k);\n\
    \    |                      ------- ^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get_mut`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for k in dict.keys() {\n        if k.len() > 1 && k.to_lowercase()\
    \ == k {\n            lower = false;\n        }\n        if k.len() > 1 && k.to_uppercase()\
    \ == k {\n            upper = false;\n        }\n    }\n    lower && upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpjq68xbuw.rs:19:44\n\
    \   |\n19 |         if k.len() > 1 && k.to_lowercase() == k {\n   |          \
    \                                  ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpjq68xbuw.rs:22:44\n   |\n22 |       \
    \  if k.len() > 1 && k.to_uppercase() == k {\n   |                           \
    \                 ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for k in dict.keys() {\n        if k.len()\
    \ != 1 {\n            return false;\n        }\n        let v = dict.get_mut(k).unwrap();\n\
    \        if v.len() != 1 {\n            return false;\n        }\n        let\
    \ c = v.chars().next().unwrap();\n        if c != c.to_lowercase() {\n       \
    \     return false;\n        }\n    }\n    for k in dict.keys() {\n        if\
    \ k.len() != 1 {\n            return false;\n        }\n        let v = dict.get_mut(k).unwrap();\n\
    \        if v.len() != 1 {\n            return false;\n        }\n        let\
    \ c = v.chars().next().unwrap();\n        if c != c.to_uppercase() {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqxr6mdpx.rs:25:17\n   |\n\
    25 |         if c != c.to_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqxr6mdpx.rs:38:17\n   |\n38 |         if c != c.to_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            true => value.to_lowercase()\
    \ == true,\n            false => value.to_uppercase() == true,\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbum20x4e.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             true => value.to_lowercase()\
    \ == true,\n   |             ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbum20x4e.rs:16:13\n   |\n14 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n15 |             true => value.to_lowercase() == true,\n\
    16 |             false => value.to_uppercase() == true,\n   |             ^^^^^\
    \ expected struct `String`, found `bool`\n\nerror[E0277]: can't compare `String`\
    \ with `bool`\n  --> /tmp/tmpbum20x4e.rs:15:42\n   |\n15 |             true =>\
    \ value.to_lowercase() == true,\n   |                                        \
    \  ^^ no implementation for `String == bool`\n   |\n   = help: the trait `PartialEq<bool>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `bool`\n\
    \  --> /tmp/tmpbum20x4e.rs:16:43\n   |\n16 |             false => value.to_uppercase()\
    \ == true,\n   |                                           ^^ no implementation\
    \ for `String == bool`\n   |\n   = help: the trait `PartialEq<bool>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as Partial"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.is_lowercase() || value.is_uppercase()\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpl1vky6_e.rs:14:15\n   |\n14 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpl1vky6_e.rs:14:39\n\
    \   |\n14 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(_,\
    \ value)| {\n        value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_6hb5bin.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(lower) => value\
    \ == lower,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvmietkc2.rs:15:13\n   |\n\
    14 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n15 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvmietkc2.rs:16:13\n   |\n14 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n15 |             Some(lower) => value == lower,\n\
    16 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    !dict.is_empty()\
    \ && dict.iter().all(|(_, val)| val.len() == 1)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8143cfc0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k,\
    \ _)| k.is_lowercase() || k.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4r4ky2he.rs:13:22\n   |\n\
    13 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key,\
    \ value)| {\n        if key.len() != value.len() {\n            return false;\n\
    \        }\n        for (i, c) in key.chars().enumerate() {\n            if c\
    \ != value.chars()[i].to_ascii_lowercase().unwrap() {\n                return\
    \ false;\n            }\n        }\n        for (i, c) in key.chars().enumerate()\
    \ {\n            if c != value.chars()[i].to_ascii_uppercase().unwrap() {\n  \
    \              return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp7uty5hl0.rs:18:21\n\
    \   |\n18 |             if c != value.chars()[i].to_ascii_lowercase().unwrap()\
    \ {\n   |                     ^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `Chars<'_>`\n  --> /tmp/tmp7uty5hl0.rs:23:21\n   |\n23 |   \
    \          if c != value.chars()[i].to_ascii_uppercase().unwrap() {\n   |    \
    \                 ^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
