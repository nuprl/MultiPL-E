name: HumanEval_56_correct_bracketing
language: rust
results:
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n    loop {\n        if stack.len()\
    \ == 0 {\n            return false;\n        }\n        let mut opening = stack.pop().unwrap();\n\
    \        if opening == '<' {\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n        } else {\n            if\
    \ opening != '>' {\n                return false;\n            }\n           \
    \ stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpuu2tfb9e.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `Vec<char>` with\
    \ `char`\n  --> /tmp/tmpuu2tfb9e.rs:19:20\n   |\n19 |         if opening == '<'\
    \ {\n   |                    ^^ no implementation for `Vec<char> == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `Vec<char>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpuu2tfb9e.rs:20:59\n\
    \   |\n20 |             stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `char`\n  --> /tmp/tmpuu2tfb9e.rs:22:24\n   |\n\
    22 |             if opening != '>' {\n   |                        ^^ no implementation\
    \ for `Vec<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: no method\
    \ named `is_asci"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len: usize\
    \ = 0;\n    let mut open_brackets_len2: usize = 0;\n    let mut close_brackets_len2:\
    \ usize = 0;\n    let mut open_brackets_len3: usize = 0;\n    let mut close_brackets_len3:\
    \ usize = 0;\n    let mut open_brackets_len4: usize = 0;\n    let mut close_brackets_len4:\
    \ usize = 0;\n    let mut open_brackets_len5: usize = 0;\n    let mut close_brackets_len5:\
    \ usize = 0;\n    let mut open_brackets_len6: usize = 0;\n    let mut close_brackets_len6:\
    \ usize = 0;\n    let mut open_brackets_len7: usize = 0;\n    let mut close_brackets_len7:\
    \ usize = 0;\n    let mut open_brackets_len8: usize = 0;\n    let mut close_brackets_len8:\
    \ usize = 0;\n    let mut open_brackets_len9: usize = 0;\n    let mut close_brackets_len9:\
    \ usize = 0;\n    let mut open_brackets_len10: usize = 0;\n    let mut close_brackets_len10:\
    \ usize = 0;\n    let mut open_brackets_len11: usize = 0;\n    let mut close_brackets_len11:\
    \ usize = 0;\n    let mut open_brackets_len12: usize = 0;\n    let mut close_brackets_len12:\
    \ usize = 0;\n    let mut open_brackets_len13: usize = 0;\n    let mut close_brackets_len13:\
    \ usize = 0;\n    let mut open_brackets_len14: usize = 0;\n    let mut close_brackets_len14:\
    \ usize = 0;\n    let mut open_brackets_len15: usize = 0;\n    let mut close_brackets_len15:\
    \ usize = 0;\n    let mut open_brackets_len16: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw6vrozut.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6vrozut.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmporpb9t8i.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last_mut()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpdhf7vy_3.rs:15:30\n   |\n14 |     while let Some(open)\
    \ = stack.last() {\n   |                            ------------ immutable borrow\
    \ occurs here\n15 |         if let Some(close) = stack.last_mut() {\n   |    \
    \                          ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n16 | \
    \            if open != close {\n   |                ---- immutable borrow later\
    \ used here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp58_xxjrd.rs:44:44\n   |\n\
    44 |     let mut open_brackets_count_stack = Vec\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmp58_xxjrd.rs:44:41\n\
    \    |\n44  |       let mut open_brackets_count_stack = Vec\n    |           \
    \                                ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp58_xxjrd.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.peekable();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.peekable();\n    let mut open_brackets_iter = open_brackets_iter.peekable();\n\
    \    let mut close_brackets_iter = close_brackets_iter.peekable();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.peekable();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.peekable();\n    let mut open_brackets_iter = open_brackets_iter.peekable();\n\
    \    let mut close_brackets_iter = close_brackets_iter.peekable();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.peekable();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.peekable();\n    let mut open_brackets_iter = open_brackets_iter.peekable();\n\
    \    let mut close_brackets_iter = close_brackets_iter.peekable();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.peekable();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.peekable();\n    let mut open_brackets_iter = open_brackets_iter.peekable();\n\
    \    let mut close_brackets_iter = close_brackets_iter.peekable();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.peekable();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.peekable();\n    let mut open_brackets_iter = open_brackets_iter.peekable();\n\
    \    let mut close_brackets_iter = close_brackets_iter.peekable\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphu0askg5.rs:37:63\n   |\n\
    37 |     let mut close_brackets_iter = close_brackets_iter.peekable\n   |    \
    \                                                           ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0615]: attempted to take value of method\
    \ `peekable` on type `Peekable<Peekable<Peekable<Peekable<Peekable<Peekable<Peekable<Peekable<Peekable<std::vec::IntoIter<(usize,\
    \ char)>>>>>>>>>>`\n  --> /tmp/tmphu0askg5.rs:37:55\n   |\n37 |     let mut close_brackets_iter\
    \ = close_brackets_iter.peekable\n   |                                       \
    \                ^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to\
    \ call the method\n   |\n37 |     let mut close_brackets_iter = close_brackets_iter.peekable()\n\
    \   |                                                               ++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphu0askg5.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0615.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            if top != 0 {\n                return false;\n            }\n   \
    \     } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(ch as usize);\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe9eyza_v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            let mut last = stack.last().unwrap();\n            if\
    \ last != c {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpder_usx0.rs:21:21\n\
    \   |\n21 |             if last != c {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != '>' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdefr9xku.rs:15:17\n\
    \   |\n15 |         if open != '>' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push('>');\n            close_brackets.push('<');\n\
    \        } else if bracket == '>' {\n            open_brackets.push('<');\n  \
    \          close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpye5_o5yx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_size\
    \ = Vec::new();\n    let mut close_brackets_size = Vec::new();\n    let mut open_brackets_pos\
    \ = Vec::new();\n    let mut close_brackets_pos = Vec::new();\n    let mut open_brackets_len\
    \ = Vec::new();\n    let mut close_brackets_len = Vec::new();\n    let mut open_brackets_len_pos\
    \ = Vec::new();\n    let mut close_brackets_len_pos = Vec::new();\n    let mut\
    \ open_brackets_len_len = Vec::new();\n    let mut close_brackets_len_len = Vec::new();\n\
    \    let mut open_brackets_len_len_pos = Vec::new();\n    let mut close_brackets_len_len_pos\
    \ = Vec::new();\n    let mut open_brackets_len_len_len = Vec::new();\n    let\
    \ mut close_brackets_len_len_len = Vec::new();\n    let mut open_brackets_len_len_len_pos\
    \ = Vec::new();\n    let mut close_brackets_len_len_len_pos = Vec::new();\n  \
    \  let mut open_brackets_len_len_len_len = Vec::new();\n    let mut close_brackets_len_len_len_len\
    \ = Vec::new();\n    let mut open_brackets_len_len_len_len_pos = Vec::new();\n\
    \    let mut close_brackets_len_len_len_len_pos = Vec::new();\n    let mut open_brackets_len_len_len_len_len\
    \ = Vec::new();\n    let mut close_brackets_len_len_len_len_len = Vec::new();\n\
    \    let mut open_brackets_len_len_len_len_len_pos = Vec::new();\n    let mut\
    \ close_brackets_len_len_len_len_len_pos = Vec::new();\n    let mut open_brackets_len_len_len_len_len_len\
    \ = Vec::new();\n    let mut close_brackets_len_len_len_len_len_len = Vec::new();\n\
    \    let mut open_brackets_len_len_len_len_len_len_pos = Vec::new();\n    let\
    \ mut close_brackets_len_len_len_len_len_len_pos = Vec::new();\n    let mut open_brackets_len_len_len_len_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4fzutkxf.rs:43:43\n   |\n\
    43 |     let mut open_brackets_len_len_len_len_\n   |                        \
    \                   ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4fzutkxf.rs:11:44\n   |\n11 | fn\
    \ correct_bracketing(brackets: String) -> bool {\n   |    ------------------ \
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpkpwj2_sw.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut closed_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut i = 0;\n    while i < brackets.len() {\n   \
    \     if open_brackets_size == closed_brackets_size {\n            open_brackets\
    \ += &brackets[i..];\n            i += open_brackets_size;\n            open_brackets_size\
    \ = 0;\n            closed_brackets_size = 0;\n        } else if open_brackets_size\
    \ > closed_brackets_size {\n            open_brackets += &brackets[i..];\n   \
    \         i += open_brackets_size;\n            open_brackets_size = 0;\n    \
    \    } else {\n            closed_brackets += &brackets[i..];\n            i +=\
    \ closed_brackets_size;\n            closed_brackets_size = 0;\n        }\n  \
    \  }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_k3ch0mj.rs:14:64\n\
    \   |\n14 |     let mut open_brackets_size = brackets.chars().filter(|c| c ==\
    \ '<').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp_k3ch0mj.rs:15:66\n   |\n15 |     let mut closed_brackets_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n   |                     \
    \                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets_len = String::new();\n    let mut closing_brackets_len = String::new();\n\
    \    let mut opening_brackets_len_len = String::new();\n    let mut closing_brackets_len_len\
    \ = String::new();\n    let mut opening_brackets_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len = String::new();\n    let mut opening_brackets_len_len_len_len\
    \ = String::new();\n    let mut closing_brackets_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len = String::new();\n    let mut\
    \ closing_brackets_len_len_len_len_len = String::new();\n    let mut opening_brackets_len_len_len_len_len_len\
    \ = String::new();\n    let mut closing_brackets_len_len_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut opening_brackets_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut closing_brackets_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut opening_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxiwldo4t.rs:39:30\n   |\n\
    39 |     let mut opening_brackets_\n   |                              ^ help:\
    \ add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxiwldo4t.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9095hjsx.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ vec![];\n    let mut close_brackets = vec![];\n    let mut open_brackets_count\
    \ = vec![];\n    let mut close_brackets_count = vec![];\n    let mut open_brackets_count_max\
    \ = vec![];\n    let mut close_brackets_count_max = vec![];\n    let mut open_brackets_count_min\
    \ = vec![];\n    let mut close_brackets_count_min = vec![];\n    let mut open_brackets_count_sum\
    \ = vec![];\n    let mut close_brackets_count_sum = vec![];\n    let mut open_brackets_count_avg\
    \ = vec![];\n    let mut close_brackets_count_avg = vec![];\n    let mut open_brackets_count_min\
    \ = vec![];\n    let mut close_brackets_count_min = vec![];\n    let mut open_brackets_count_max\
    \ = vec![];\n    let mut close_brackets_count_max = vec![];\n    let mut open_brackets_count_sum\
    \ = vec![];\n    let mut close_brackets_count_sum = vec![];\n    let mut open_brackets_count_avg\
    \ = vec![];\n    let mut close_brackets_count_avg = vec![];\n    let mut open_brackets_count_min\
    \ = vec![];\n    let mut close_brackets_count_min = vec![];\n    let mut open_brackets_count_max\
    \ = vec![];\n    let mut close_brackets_count_max = vec![];\n    let mut open_brackets_count_sum\
    \ = vec![];\n    let mut close_brackets_count_sum = vec![];\n    let mut open_brackets_count_avg\
    \ = vec![];\n    let mut close_brackets_count_avg = vec![];\n    let mut open_brackets_count_min\
    \ = vec![];\n    let mut close_brackets_count_min = vec![];\n    let mut open_brackets_count_max\
    \ = vec![];\n    let mut close_brackets_count_max = vec![];\n    let mut open_brackets_count_sum\
    \ = vec![];\n    let mut close_brackets_count_sum = vec![];\n    let mut open_brackets_count_avg\
    \ = vec![];\n    let mut close_brackets_count_avg = vec\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgw4xicxp.rs:48:43\n   |\n\
    48 |     let mut close_brackets_count_avg = vec\n   |                        \
    \                   ^ help: add `;` here\n49 | }\n   | - unexpected token\n\n\
    error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpgw4xicxp.rs:48:40\n\
    \   |\n48 |     let mut close_brackets_count_avg = vec\n   |                 \
    \                       ^^^ not a value\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgw4xicxp.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0423.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n    let mut opening_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut opening_brackets_stack = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_stack = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_stack.peekable();\n    let mut\
    \ closing_brackets_iter = closing_brackets_stack.peekable();\n    let mut opening_brackets_stack\
    \ = opening_brackets_iter.peekable();\n    let mut closing_brackets_stack = closing_brackets_iter.peekable();\n\
    \    let mut opening_brackets_iter = opening_brackets_stack.peekable();\n    let\
    \ mut closing_brackets_iter = closing_brackets_stack.peekable();\n    let mut\
    \ opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.peekable();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.peekable();\n    let mut closing_brackets_iter\
    \ = closing_brackets_iter.peekable();\n    let mut opening_brackets_iter = opening_brackets_iter.peekable();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7m4ux1ur.rs:37:11\n   |\n\
    37 |     let mu\n   |           ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7m4ux1ur.rs:16:84\n\
    \   |\n16 |     let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7m4ux1ur.rs:17:84\n   |\n17\
    \ |     let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ `Vec<(usize, char)>` is not an iterator\n   --> /tmp/tmp7m4ux1ur.rs:18:60\n\
    \    |\n18  |       let mut opening_brackets_stack = opening_brackets_iter.peekable();\n\
    \    |                                                              ^^^^^^^^ `Vec<(usize,\
    \ char)>` is not an iterator\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<(usize, char)>: Iterator`\n            which\
    \ is required by `&mut Vec<(usize, char)>: Iterator`\n            `[(usize, char)]:\
    \ Iterator`\n            which is required by `&mut [(usize, char)]: Iterator`\n\
    \nerror[E0599]: `Vec<(usize, char)>` is not an iterator\n   --> /tmp/tmp7m4ux1ur.rs:19:60\n\
    \    |\n19  |       let mut closing_brackets_stack = closing_brackets_iter.peekable();\n\
    \    |                                                              ^^^^^^^^ `Vec<(usize,\
    \ char)>` is not an iterator\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<(usize, char)>: Iterat"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            stack.pop();\n        } else {\n            stack.push(brackets.len());\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpq4zj4780.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_len\
    \ = 0;\n    let mut close_brackets_len = 0;\n    let mut i = 0;\n    while i <\
    \ brackets.len() {\n        let mut j = i;\n        while j < brackets.len() &&\
    \ brackets[j] == brackets[j].chars().next().unwrap() {\n            j += 1\n \
    \       }\n        let open_bracket = brackets[i..j];\n        if open_bracket.len()\
    \ == 1 {\n            open_brackets.push(open_bracket);\n            open_brackets_len\
    \ += 1;\n        } else {\n            stack.unshift(open_bracket);\n        \
    \    open_brackets_len += 1;\n        }\n        i = j;\n    }\n    while stack.len()\
    \ > 0 {\n        let mut open_bracket = stack.pop().unwrap();\n        let mut\
    \ close_bracket = open_bracket;\n        while close_bracket.len() > 1 {\n   \
    \         let mut j = close_bracket.len() - 1;\n            while j >= 0 && close_bracket[j]\
    \ == close_bracket[j].chars().next().unwrap() {\n                j -= 1\n    \
    \        }\n            let mut close_bracket = close_bracket[j..];\n        \
    \    if close_bracket.len() == 1 {\n                close_brackets.push(close_bracket);\n\
    \                close_brackets_len += 1;\n            } else {\n            \
    \    stack.unshift(close_bracket);\n                close_brackets_len += 1;\n\
    \            }\n        }\n        if open_brackets_len == close_brackets_len\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxedlcjr8.rs:20:37\n\
    \   |\n20 |         while j < brackets.len() && brackets[j] == brackets[j].chars().next().unwrap()\
    \ {\n   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxedlcjr8.rs:20:52\n   |\n20 |         while j < brackets.len()\
    \ && brackets[j] == brackets[j].chars().next().unwrap() {\n   |              \
    \                                      ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpxedlcjr8.rs:23:13\n   |\n23 |         let\
    \ open_bracket = brackets[i..j];\n   |             ^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n23 |         let open_bracket = &brackets[i..j];\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp594xj4_u.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp594xj4_u.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp594xj4_u.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch as usize);\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for ch in\
    \ brackets.chars() {\n        if ch == '<' {\n            stack.push(0);\n   \
    \     } else if ch == '>' {\n            if stack.len() == 0 {\n             \
    \   return false;\n            }\n            stack.pop();\n        } else {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n            stack.push(ch as usize);\n       \
    \ }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7d8w1zqa.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate();\n\
    \    let mut close_brackets_iter = brackets.chars().enumerate();\n    let mut\
    \ open_brackets_next = open_brackets_iter.next();\n    let mut close_brackets_next\
    \ = close_brackets_iter.next();\n    while let Some((index, char)) = open_brackets_next\
    \ {\n        if char == \">\" {\n            open_brackets.push_str(&open_brackets_iter.next());\n\
    \            close_brackets.push_str(&close_brackets_iter.next());\n         \
    \   open_brackets_next = open_brackets_iter.next();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            open_brackets.push_str(&open_brackets_iter.next());\n\
    \        }\n    }\n    while let Some((index, char)) = close_brackets_next {\n\
    \        if char == \"<\" {\n            open_brackets.push_str(&open_brackets_iter.next());\n\
    \            close_brackets.push_str(&close_brackets_iter.next());\n         \
    \   open_brackets_next = open_brackets_iter.next();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            close_brackets.push_str(&close_brackets_iter.next());\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxc_n1l0.rs:19:20\n   |\n\
    19 |         if char == \">\" {\n   |                    ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n19 |         if char == '>' {\n   |                    ~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplxc_n1l0.rs:20:36\n   |\n20 |  \
    \           open_brackets.push_str(&open_brackets_iter.next());\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplxc_n1l0.rs:21:37\n   |\n21 |             close_brackets.push_str(&close_brackets_iter.next());\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n   \
    \           found reference `&Option<(usize, char)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplxc_n1l0.rs:25:36\n   |\n25 |             open_brackets.push_str(&open_brackets_iter.next());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplxc_n1l0.rs:29:20\n   |\n29 |         if char == \"<\" {\n   |\
    \                    ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant\
    \ to write a `char` literal, use single quotes\n   |\n29 |         if char ==\
    \ '<' {\n   |                    ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplxc_n1l0.rs:30:36\n   |\n30 |             open_brackets.push_str(&open_brackets_iter.next());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplxc_n1l0.rs:31:37\n   |\n31 |             close_brackets.push_str(&clos"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_char = String::new();\n    let mut closing_char = String::new();\n \
    \   let mut opening_chars = String::new();\n    let mut closing_chars = String::new();\n\
    \    let mut opening_char_count = String::new();\n    let mut closing_char_count\
    \ = String::new();\n    let mut opening_char_count_str = String::new();\n    let\
    \ mut closing_char_count_str = String::new();\n    let mut opening_char_count_str\
    \ = String::new();\n    let mut closing_char_count_str = String::new();\n    let\
    \ mut opening_char_count_str = String::new();\n    let mut closing_char_count_str\
    \ = String::new();\n    let mut opening_char_count_str = String::new();\n    let\
    \ mut closing_char_count_str = String::new();\n    let mut opening_char_count_str\
    \ = String::new();\n    let mut closing_char_count_str = String::new();\n    let\
    \ mut opening_char_count_str = String::new();\n    let mut closing_char_count_str\
    \ = String::new();\n    let mut opening_char_count_str = String::new();\n    let\
    \ mut closing_char_count_str = String::new();\n    let mut opening_char_count_str\
    \ = String::new();\n    let mut closing_char_count_str = String::new();\n    let\
    \ mut opening_char_count_str = String::new();\n    let mut closing_char_count_str\
    \ = String::new();\n    let mut opening_char_count_str = String::new();\n    let\
    \ mut closing_char_count_str = String::new();\n    let mut opening_char_count_str\
    \ = String::new();\n    let mut closing_char_count_str = String::new();\n    let\
    \ mut opening_char_count_str = String::new();\n    let mut closing_char_count_str\
    \ = String::new();\n    let mut opening_char_count_str = String::new();\n    let\
    \ mut closing_char_count_str = String::new();\n    let mut opening_char_count_str\
    \ = String::new();\n    let mut closing_char_count_str = String::new();\n    let\
    \ mut opening_char_count_str = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpquurlniy.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        c != '<' && c !=\
    \ '>'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc_09ekep.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut closed_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut i = 0;\n    while i < brackets.len() {\n   \
    \     if open_brackets_size == closed_brackets_size {\n            open_brackets\
    \ += &brackets[i..];\n            i += open_brackets_size;\n            open_brackets_size\
    \ = 0;\n            closed_brackets_size = 0;\n        } else if open_brackets_size\
    \ > closed_brackets_size {\n            open_brackets += &brackets[i..];\n   \
    \         i += open_brackets_size;\n            open_brackets_size = 0;\n    \
    \    } else {\n            closed_brackets += &brackets[i..];\n            i +=\
    \ closed_brackets_size;\n            closed_brackets_size = 0;\n        }\n  \
    \  }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpri73knty.rs:14:64\n\
    \   |\n14 |     let mut open_brackets_size = brackets.chars().filter(|c| c ==\
    \ '<').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpri73knty.rs:15:66\n   |\n15 |     let mut closed_brackets_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n   |                     \
    \                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '<' {\n            stack.push(c);\n        } else if c == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdsdu3ikx.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut opening_brackets = Vec::new();\n    while let Some(opening_bracket)\
    \ = stack.pop() {\n        if opening_bracket == '<' {\n            opening_brackets.push('>');\n\
    \        } else {\n            opening_brackets.push('<');\n        }\n    }\n\
    \    opening_brackets.len() == brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbwgm71fe.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = String::new();\n    let mut close_brackets_count_stack_size\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut\
    \ close_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeb36kxm2.rs:39:18\n   |\n\
    39 |     let mut close\n   |                  ^ help: add `;` here\n40 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeb36kxm2.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n\n \
    \   for bracket in brackets.chars() {\n        if bracket == '<' {\n         \
    \   stack.push(0);\n            open_brackets.push(0);\n            close_brackets.push(0);\n\
    \        } else if bracket == '>' {\n            stack.push(stack.len() - 1);\n\
    \            open_brackets.push(stack.len() - 1);\n            close_brackets.push(0);\n\
    \        } else {\n            stack.push(stack.len() - 1);\n            open_brackets.push(stack.len()\
    \ - 1);\n            close_brackets.push(stack.len() - 1);\n        }\n    }\n\
    \n    let mut open_brackets_iter = open_brackets.iter();\n    let mut close_brackets_iter\
    \ = close_brackets.iter();\n\n    while let Some(open_bracket) = open_brackets_iter.next()\
    \ {\n        if open_bracket != close_brackets_iter.next() {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&usize` with `Option<&usize>`\n  --> /tmp/tmp1bh46w1u.rs:36:25\n\
    \   |\n36 |         if open_bracket != close_brackets_iter.next() {\n   |    \
    \                     ^^ no implementation for `&usize == Option<&usize>`\n  \
    \ |\n   = help: the trait `PartialEq<Option<&usize>>` is not implemented for `&usize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx: usize\
    \ = 0;\n    let mut open_brackets_idx2: usize = 0;\n    let mut close_brackets_idx2:\
    \ usize = 0;\n    let mut open_brackets_idx3: usize = 0;\n    let mut close_brackets_idx3:\
    \ usize = 0;\n    let mut open_brackets_idx4: usize = 0;\n    let mut close_brackets_idx4:\
    \ usize = 0;\n    let mut open_brackets_idx5: usize = 0;\n    let mut close_brackets_idx5:\
    \ usize = 0;\n    let mut open_brackets_idx6: usize = 0;\n    let mut close_brackets_idx6:\
    \ usize = 0;\n    let mut open_brackets_idx7: usize = 0;\n    let mut close_brackets_idx7:\
    \ usize = 0;\n    let mut open_brackets_idx8: usize = 0;\n    let mut close_brackets_idx8:\
    \ usize = 0;\n    let mut open_brackets_idx9: usize = 0;\n    let mut close_brackets_idx9:\
    \ usize = 0;\n    let mut open_brackets_idx10: usize = 0;\n    let mut close_brackets_idx10:\
    \ usize = 0;\n    let mut open_brackets_idx11: usize = 0;\n    let mut close_brackets_idx11:\
    \ usize = 0;\n    let mut open_brackets_idx12: usize = 0;\n    let mut close_brackets_idx12:\
    \ usize = 0;\n    let mut open_brackets_idx13: usize = 0;\n    let mut close_brackets_idx13:\
    \ usize = 0;\n    let mut open_brackets_idx14: usize = 0;\n    let mut close_brackets_idx14:\
    \ usize = 0;\n    let mut open_brackets_idx15: usize = 0;\n    let mut close_brackets_idx15:\
    \ usize = 0;\n    let mut open_brackets_idx16: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxb3b1h6.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxb3b1h6.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut i = 0;\n    while i < brackets.len() {\n        let c = brackets[i];\n\
    \        if c == '<' {\n            stack.push(i);\n            open_brackets.push(i);\n\
    \        }\n        if c == '>' {\n            if stack.len() == 0 {\n       \
    \         return false;\n            }\n            let open = open_brackets.pop();\n\
    \            let close = stack.pop();\n            if open != close {\n      \
    \          return false;\n            }\n        }\n        i += 1;\n    }\n \
    \   stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo4kk4hl1.rs:17:17\n\
    \   |\n17 |         let c = brackets[i];\n   |                 ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    open_brackets.push(brackets.chars().collect::<Vec<_>>());\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop().unwrap();\n        let mut next = current.clone();\n\
    \        while !next.is_empty() {\n            if *next == '<' {\n           \
    \     open_brackets.push(next.clone());\n                next.pop();\n       \
    \     } else {\n                close_brackets.push(next.clone());\n         \
    \       next.pop();\n            }\n        }\n    }\n    open_brackets.iter().all(|b|\
    \ close_brackets.iter().any(|c| b == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `[char]` with `char`\n  --> /tmp/tmp8ksso2u1.rs:21:22\n\
    \   |\n21 |             if *next == '<' {\n   |                      ^^ no implementation\
    \ for `[char] == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `[char]`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U,\
    \ A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as\
    \ PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n          \
    \   <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n\
    \             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        c >= '<' && c <=\
    \ '>'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgocw9fw1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.len();\n    let\
    \ mut close_brackets_size = brackets.len();\n    let mut i = 0;\n    while i <\
    \ open_brackets_size {\n        if open_brackets.is_empty() {\n            open_brackets\
    \ += &brackets[i as usize];\n            i += 1;\n        } else {\n         \
    \   if open_brackets[open_brackets.len() - 1] != &brackets[i as usize] {\n   \
    \             open_brackets += &brackets[i as usize];\n                i += 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \ }\n    open_brackets_size = open_brackets.len();\n    while i < close_brackets_size\
    \ {\n        if close_brackets.is_empty() {\n            close_brackets += &brackets[i\
    \ as usize];\n            i += 1;\n        } else {\n            if close_brackets[close_brackets.len()\
    \ - 1] != &brackets[i as usize] {\n                close_brackets += &brackets[i\
    \ as usize];\n                i += 1;\n            } else {\n                i\
    \ += 1;\n            }\n        }\n    }\n    close_brackets_size = close_brackets.len();\n\
    \    if open_brackets_size == close_brackets_size {\n        return true;\n  \
    \  }\n    return false;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_ti5j6em.rs:19:31\n\
    \   |\n19 |             open_brackets += &brackets[i as usize];\n   |        \
    \                       ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_ti5j6em.rs:22:16\n   |\n22 |             if open_brackets[open_brackets.len()\
    \ - 1] != &brackets[i as usize] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_ti5j6em.rs:22:59\n   |\n22 |             if open_brackets[open_brackets.len()\
    \ - 1] != &brackets[i as usize] {\n   |                                      \
    \                     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<R"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for ch in brackets {\n        if ch == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else {\n            open_brackets.push('<');\n            close_brackets.push('>');\n\
    \        }\n    }\n    open_brackets.chars().all(|ch| close_brackets.chars().any(|ch|\
    \ ch == ch))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsjqrkq7o.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let top = stack.pop().unwrap();\n        if top == '<' {\n     \
    \       stack.push(brackets.chars().next().unwrap());\n        } else if top ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            let next = stack.pop().unwrap();\n            if next\
    \ != '>' {\n                return false;\n            }\n        } else {\n \
    \           return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpm3ajrckl.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            let top = stack.pop();\n            if top != 0 {\n\
    \                return false;\n            }\n        } else {\n            stack.push(stack.len());\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvadof6y9.rs:21:23\n   |\n\
    21 |             if top != 0 {\n   |                       ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    21 |             if top != Some(0) {\n   |                       +++++ +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjiot6pby.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpte3unr3o.rs:30:52\n   |\n\
    30 |     let mut open_brackets_stack_ptr_end_ptr_end_ptr\n   |               \
    \                                     ^ help: add `;` here\n31 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpte3unr3o.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpyjw7tfaj.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push('>');\n            closed_brackets.push('<');\n\
    \        } else if bracket == '>' {\n            open_brackets.push('<');\n  \
    \          closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdm9mt96o.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if let Some(next) = stack.last() {\n            if next ==\
    \ '>' {\n                stack.pop();\n            } else {\n                stack.push(next);\n\
    \            }\n        } else {\n            break;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl3z12_i6.rs:16:21\n\
    \   |\n16 |             if next == '>' {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpl3z12_i6.rs:19:28\n   |\n19 |  \
    \               stack.push(next);\n   |                            ^^^^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |                 stack.push(*next);\n   |                            +\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push('>');\n            close_brackets.push('<');\n\
    \        } else if bracket == '>' {\n            open_brackets.push('<');\n  \
    \          close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp89hsr3uf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `:`, `=`, or `>`, found `}`\n  --> /tmp/tmpbtlfw97y.rs:31:1\n\
    \   |\n30 |     let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_\n\
    \   |                                                                        \
    \              - expected one of `,`, `:`, `=`, or `>`\n31 | }\n   | ^ unexpected\
    \ token\n   |\nhelp: you might have meant to end the type parameters here\n  \
    \ |\n30 |     let mut opening_brackets_iter = opening_brackets_iter.into_iter().collect::<Vec<_>\n\
    \   |                                                                        \
    \              +\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbtlfw97y.rs:14:84\n\
    \   |\n14 |     let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpbtlfw97y.rs:15:84\n   |\n15\
    \ |     let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for bracket in brackets.chars().filter(|c| c != '<')\
    \ {\n        if open_brackets.is_empty() {\n            open_brackets.push(bracket);\n\
    \        } else {\n            close_brackets.push(bracket);\n        }\n    }\n\
    \n    if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n\n    let mut open_brackets_iter = open_brackets.chars().enumerate();\n\
    \    let mut close_brackets_iter = close_brackets.chars().enumerate();\n\n   \
    \ while open_brackets_iter.any() || close_brackets_iter.any() {\n        let (open_bracket,\
    \ close_bracket) = if open_brackets_iter.any() {\n            (*open_brackets_iter.next(),\
    \ *close_brackets_iter.next())\n        } else {\n            (*close_brackets_iter.next(),\
    \ *open_brackets_iter.next())\n        };\n\n        if open_bracket != close_bracket\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfi_0xjl2.rs:15:50\n\
    \   |\n15 |     for bracket in brackets.chars().filter(|c| c != '<') {\n   | \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpfi_0xjl2.rs:30:30\n\
    \     |\n30   |     while open_brackets_iter.any() || close_brackets_iter.any()\
    \ {\n     |                              ^^^- supplied 0 arguments\n     |   \
    \                           |\n     |                              expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpfi_0xjl2.rs:30:59\n\
    \     |\n30   |     while open_brackets_iter.any() || close_brackets_iter.any()\
    \ {\n     |                                                           ^^^- supplied\
    \ 0 arguments\n     |                                                        \
    \   |\n     |                                                           expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpfi_0xjl2.rs:31:67\n\
    \     |\n31   |         let (open_bracket, close_bracket) = if open_brackets_iter.any()\
    \ {\n     |                                                                  \
    \ ^^^- supplied 0 arguments\n     |                                          \
    \                         |\n     |                                          \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0614]: type `Option<(usize, char)>` cannot be dereferenced\n\
    \  --> /tmp/tmpfi_0xjl2.rs:32:14\n   |\n32 |             (*open_brackets_iter.next(),\
    \ *close_brackets_iter.next())\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<(usize, char)>` cannot be dereferenc"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmphvsti8s9.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp005de6kl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if !stack.is_empty()\
    \ {\n                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for c in\
    \ brackets {\n        if c == '<' {\n            stack.push(0);\n        } else\
    \ if c == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&i| i == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9s3zszix.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => Some('>'),\n        '>' => Some('<'),\n        _ =>\
    \ None,\n    });\n    let mut close_brackets_iter = brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => Some('>'),\n        '>' => Some('<'),\n        _ =>\
    \ None,\n    });\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next\
    \ != None && close_brackets_next != None {\n        if open_brackets_next.unwrap()\
    \ == close_brackets_next.unwrap() {\n            open_brackets_next = open_brackets_iter.next();\n\
    \            close_brackets_next = close_brackets_iter.next();\n        } else\
    \ {\n            open_brackets += open_brackets_next.unwrap();\n            close_brackets\
    \ += close_brackets_next.unwrap();\n            open_brackets_next = open_brackets_iter.next();\n\
    \            close_brackets_next = close_brackets_iter.next();\n        }\n  \
    \  }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2u2bxp6f.rs:31:30\n   |\n\
    31 |             open_brackets += open_brackets_next.unwrap();\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2u2bxp6f.rs:32:31\n   |\n32 |\
    \             close_brackets += close_brackets_next.unwrap();\n   |          \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            opening_brackets.push(bracket);\n\
    \            opening_brackets_stack.push(bracket);\n        } else if bracket\
    \ == '>' {\n            closing_brackets.push(bracket);\n            closing_brackets_stack.push(bracket);\n\
    \        } else {\n            if opening_brackets_stack.len() > 0 {\n       \
    \         if opening_brackets_stack.last().unwrap() != bracket {\n           \
    \         return false;\n                }\n                opening_brackets_stack.pop();\n\
    \            }\n            if closing_brackets_stack.len() > 0 {\n          \
    \      if closing_brackets_stack.last().unwrap() != bracket {\n              \
    \      return false;\n                }\n                closing_brackets_stack.pop();\n\
    \            }\n        }\n    }\n    opening_brackets.len() == 0 && closing_brackets.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpq4elidby.rs:26:59\n\
    \   |\n26 |                 if opening_brackets_stack.last().unwrap() != bracket\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpq4elidby.rs:32:59\n\
    \   |\n32 |                 if closing_brackets_stack.last().unwrap() != bracket\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx: usize\
    \ = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx: usize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzb7oxgky.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for ch in brackets {\n        if ch == '<' {\n     \
    \       open_brackets.push('>');\n            close_brackets.push('<');\n    \
    \    } else if ch == '>' {\n            open_brackets.push('<');\n           \
    \ close_brackets.push('>');\n        } else {\n            open_brackets.push(ch);\n\
    \            close_brackets.push(ch);\n        }\n    }\n\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsph0p154.rs:15:15\n\
    \   |\n15 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = Vec::new();\n    let mut close_brackets_count_stack_size\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr = Vec::new();\n   \
    \ let mut close_brackets_count_stack_ptr = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr = Vec::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ close_brackets_count_stack_ptr_ptr_ptr = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n   \
    \ let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n  \
    \  let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5mi8xbwi.rs:39:51\n   |\n\
    39 |     let mut close_brackets_count_stack_ptr_ptr_ptr\n   |                \
    \                                   ^ help: add `;` here\n40 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5mi8xbwi.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmptodhbe42.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    let mut open_brackets =\
    \ String::new();\n    let mut close_brackets = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_stack = String::new();\n    let mut close_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack_count = String::new();\n\
    \    let mut close_brackets_count_stack_count = String::new();\n    let mut open_brackets_count_stack_count2\
    \ = String::new();\n    let mut close_brackets_count_stack_count2 = String::new();\n\
    \    let mut open_brackets_count_stack_count3 = String::new();\n    let mut close_brackets_count_stack_count3\
    \ = String::new();\n    let mut open_brackets_count_stack_count4 = String::new();\n\
    \    let mut close_brackets_count_stack_count4 = String::new();\n    let mut open_brackets_count_stack_count5\
    \ = String::new();\n    let mut close_brackets_count_stack_count5 = String::new();\n\
    \    let mut open_brackets_count_stack_count6 = String::new();\n    let mut close_brackets_count_stack_count6\
    \ = String::new();\n    let mut open_brackets_count_stack_count7 = String::new();\n\
    \    let mut close_brackets_count_stack_count7 = String::new();\n    let mut open_brackets_count_stack_count8\
    \ = String::new();\n    let mut close_brackets_count_stack_count8 = String::new();\n\
    \    let mut open_brackets_count_stack_count9 = String::new();\n    let mut close_brackets_count_stack_count9\
    \ = String::new();\n    let mut open_brackets_count_stack_count10 = String::new();\n\
    \    let mut close_brackets_count_stack_count10 = String::new();\n    let mut\
    \ open_brackets_count_stack_count11 = String::new();\n    let mut close_brackets_count_stack_count11\
    \ = String::new();\n    let mut open_brackets_count_stack_count12 = String::new();\n\
    \    let mut close_brackets_count_stack_count12 = String::new();\n    let mut\
    \ open_brackets_count_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzmapzruc.rs:43:33\n   |\n\
    43 |     let mut open_brackets_count_\n   |                                 ^\
    \ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzmapzruc.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop();\n       \
    \ let mut next = current.clone();\n        while let Some(next) = next.pop() {\n\
    \            if next == '<' {\n                let mut next = current.clone();\n\
    \                while let Some(next) = next.pop() {\n                    if next\
    \ == '>' {\n                        let mut next = current.clone();\n        \
    \                while let Some(next) = next.pop() {\n                       \
    \     if next == '<' {\n                                let mut next = current.clone();\n\
    \                                while let Some(next) = next.pop() {\n       \
    \                             if next == '>' {\n                             \
    \           let mut next = current.clone();\n                                \
    \        while let Some(next) = next.pop() {\n                               \
    \             if next == '<' {\n                                             \
    \   let mut next = current.clone();\n                                        \
    \        while let Some(next) = next.pop() {\n                               \
    \                     if next == '>' {\n                                     \
    \                   let mut next = current.clone();\n                        \
    \                                while let Some(next) = next.pop() {\n       \
    \                                                     if next == '<' {\n     \
    \                                                           let mut next = current.clone();\n\
    \                                                                while let Some(next)\
    \ = next.pop() {\n                                                           \
    \         if next == '>' {\n                                                 \
    \                       let mut next = current.clone();\n                    \
    \                                                    while let Some(next) = next.pop()\
    \ {\n                                                                        \
    \    if next == '<' {\n                                                      \
    \                          let mut next = current.clone();\n                 \
    \                                                               while let Some(next)\
    \ = next.pop() {\n                                                           \
    \                         if next == '>' {\n                                 \
    \                                                       let mut next = current.clone();\n\
    \                                                                            \
    \            while let Some(next) = next.pop() {\n                           \
    \                                                                 if next == '<'\
    \ {\n                                                                        \
    \                        let mut next = current.clone();\n                   \
    \                                                                            \
    \ while let Some(next) = next.pop() {\n                                      \
    \                                                              if next == '>'\
    \ {\n                                                                        \
    \                                let mut next = current.clone();\n           \
    \                                                                            \
    \                 while let Some(next) = next.pop() {\n                      \
    \                                                                            \
    \          if next == '<' {\n                                                \
    \                                                                let mut next\
    \ = current.clone();\n                                                       \
    \                                                         while let Some(next)\
    \ = next.pop() {\n                                                           \
    \                                                         if next == '>' {\n \
    \                                                                            \
    \                                           let mut next = current.clone();\n\
    \                                                                            \
    \                                            while let Some(next) = next.pop()\
    \ {\n                                                                        \
    \                                                    if next == '<' {\n      \
    \                                                                            \
    \                                              let mut next = current.clone();\n\
    \                                                                            \
    \                                                    while let Some(next) = next.pop()\
    \ {\n                                                                        \
    \                                                            if next == '>' {\n\
    \                                                                            \
    \                                                            let mut next = current.clone();\n\
    \                                                                            \
    \                                                            while let Some(next)\
    \ = next.pop() {\n\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpajrt447z.rs:83:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ stack.len() > 0 {\n   |                           - unclosed delimiter\n...\n\
    17 |         while let Some(next) = next.pop() {\n   |                       \
    \                    - unclosed delimiter\n18 |             if next == '<' {\n\
    \   |                            - unclosed delimiter\n19 |                 let\
    \ mut next = current.clone();\n20 |                 while let Some(next) = next.pop()\
    \ {\n   |                                                   - unclosed delimiter\n\
    21 |                     if next == '>' {\n   |                              \
    \      - unclosed delimiter\n22 |                         let mut next = current.clone();\n\
    23 |                         while let Some(next) = next.pop() {\n   |       \
    \                                                    - unclosed delimiter\n24\
    \ |                             if next == '<' {\n   |                       \
    \                     - unclosed delimiter\n25 |                             \
    \    let mut next = current.clone();\n26 |                                 while\
    \ let Some(next) = next.pop() {\n   |                                        \
    \                           - unclosed delimiter\n27 |                       \
    \              if next == '>' {\n   |                                        \
    \            - unclosed delimiter\n28 |                                      \
    \   let mut next = current.clone();\n29 |                                    \
    \     while let Some(next) = next.pop() {\n   |                              \
    \                                             - unclosed delimiter\n30 |     \
    \                                        if next == '<' {\n   |              \
    \                                              - unclosed delimiter\n31 |    \
    \                                             let mut next = current.clone();\n\
    32 |                                                 whil"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        let next = stack.last().unwrap();\n        if next == '>'\
    \ {\n            stack.pop();\n        } else {\n            stack.push(next);\n\
    \        }\n        if stack.len() == 0 {\n            return false;\n       \
    \ }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpds340off.rs:16:17\n\
    \   |\n16 |         if next == '>' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpds340off.rs:19:24\n   |\n19 |  \
    \           stack.push(next);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |   \
    \          stack.push(*next);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_map\
    \ = String::new();\n    let mut close_brackets_count_map = String::new();\n  \
    \  let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppz1_tss3.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpa77r68r3.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpseye147p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let next = stack.last().unwrap();\n        if next == '<' {\n  \
    \          stack.push(brackets.chars().next().unwrap());\n        } else if next\
    \ == '>' {\n            if stack.len() == 1 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg1s50ooz.rs:19:17\n\
    \   |\n19 |         if next == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg1s50ooz.rs:21:24\n\
    \   |\n21 |         } else if next == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpohphuoeq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c|\
    \ c == '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().filter(|c|\
    \ c == '>').collect::<Vec<_>>());\n    while stack.len() > 0 {\n        let mut\
    \ open = stack.pop();\n        let mut close = stack.pop();\n        if open.len()\
    \ != close.len() {\n            return false;\n        }\n        for (i, c) in\
    \ open.iter().zip(close.iter()).filter(|&(a, b)| a == b) {\n            stack.remove(i);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyjjkqthw.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpyjjkqthw.rs:14:46\n   |\n14\
    \ |     stack.push(brackets.chars().filter(|c| c == '>').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpyjjkqthw.rs:18:17\n\
    \   |\n18 |         if open.len() != close.len() {\n   |                 ^^^ method\
    \ not found in `Option<Vec<char>>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpyjjkqthw.rs:18:32\n  \
    \ |\n18 |         if open.len() != close.len() {\n   |                       \
    \         ^^^ method not found in `Option<Vec<char>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyjjkqthw.rs:22:26\n   |\n22 |             stack.remove(i);\n\
    \   |                          ^ expected `usize`, found `&Vec<char>`\n   |\n\
    \   = note:   expected type `usize`\n           found reference `&Vec<char>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut closed_brackets = Vec::new();\n\
    \    while let Some(item) = stack.last() {\n        if item == '<' {\n       \
    \     open_brackets.push(item);\n        }\n        if item == '>' {\n       \
    \     closed_brackets.push(item);\n        }\n        stack.pop();\n    }\n  \
    \  open_brackets.len() == closed_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpahcrngin.rs:17:17\n\
    \   |\n17 |         if item == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpahcrngin.rs:20:17\n\
    \   |\n20 |         if item == '>' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c|\
    \ c == '<').collect::<Vec<_>>());\n    loop {\n        if stack.len() == 0 {\n\
    \            return false;\n        }\n        let mut opening = stack.pop().unwrap();\n\
    \        if opening.chars().any(|c| c == '>') {\n            stack.push(brackets.chars().filter(|c|\
    \ c == '>').collect::<Vec<_>>());\n        } else {\n            return true;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpy1hwpfey.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpy1hwpfey.rs:19:20\n   |\n19 |         if opening.chars().any(|c|\
    \ c == '>') {\n   |                    ^^^^^ method not found in `Vec<char>`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpy1hwpfey.rs:20:54\n\
    \   |\n20 |             stack.push(brackets.chars().filter(|c| c == '>').collect::<Vec<_>>());\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize\
    \ = 0;\n    let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx:\
    \ usize = 0;\n    let mut open_brackets_idx2: usize = 0;\n    let mut close_brackets_idx2:\
    \ usize = 0;\n    let mut open_brackets_idx3: usize = 0;\n    let mut close_brackets_idx3:\
    \ usize = 0;\n    let mut open_brackets_idx4: usize = 0;\n    let mut close_brackets_idx4:\
    \ usize = 0;\n    let mut open_brackets_idx5: usize = 0;\n    let mut close_brackets_idx5:\
    \ usize = 0;\n    let mut open_brackets_idx6: usize = 0;\n    let mut close_brackets_idx6:\
    \ usize = 0;\n    let mut open_brackets_idx7: usize = 0;\n    let mut close_brackets_idx7:\
    \ usize = 0;\n    let mut open_brackets_idx8: usize = 0;\n    let mut close_brackets_idx8:\
    \ usize = 0;\n    let mut open_brackets_idx9: usize = 0;\n    let mut close_brackets_idx9:\
    \ usize = 0;\n    let mut open_brackets_idx10: usize = 0;\n    let mut close_brackets_idx10:\
    \ usize = 0;\n    let mut open_brackets_idx11: usize = 0;\n    let mut close_brackets_idx11:\
    \ usize = 0;\n    let mut open_brackets_idx12: usize = 0;\n    let mut close_brackets_idx12:\
    \ usize = 0;\n    let mut open_brackets_idx13: usize = 0;\n    let mut close_brackets_idx13:\
    \ usize = 0;\n    let mut open_brackets_idx14: usize = 0;\n    let mut close_brackets_idx14:\
    \ usize = 0;\n    let mut open_brackets_idx15: usize = 0;\n    let mut close_brackets_idx15\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8wjdhfw7.rs:46:33\n   |\n\
    46 |     let mut close_brackets_idx15\n   |                                 ^\
    \ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wjdhfw7.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let next = stack.pop().unwrap();\n        if next == '<' {\n   \
    \         stack.push(brackets.chars().next().unwrap());\n        } else if next\
    \ == '>' {\n            if let Some(next) = stack.pop() {\n                if\
    \ next == '<' {\n                    stack.push(brackets.chars().next().unwrap());\n\
    \                } else {\n                    return false;\n               \
    \ }\n            } else {\n                return false;\n            }\n    \
    \    } else {\n            return false;\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        open_brackets.push(open);\n    }\n    while let Some(close)\
    \ = stack.pop() {\n        close_brackets.push(close);\n    }\n    open_brackets.iter().all(|c|\
    \ close_brackets.iter().any(|c| *c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95lhuox_.rs:27:70\n   |\n\
    27 |     open_brackets.iter().all(|c| close_brackets.iter().any(|c| *c == c))\n\
    \   |                                                                      ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |     open_brackets.iter().all(|c| close_brackets.iter().any(|c| *c == *c))\n\
    \   |                                                                      +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            stack.pop();\n        } else {\n            stack.push((stack.last().unwrap()\
    \ + 1) % 2);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpftudi7hy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(b) = stack.last() {\n        if b == '<' {\n            stack.push(brackets.chars().next().unwrap());\n\
    \        } else if b == '>' {\n            stack.pop();\n        } else {\n  \
    \          return false;\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmporq1r74v.rs:15:14\n\
    \   |\n15 |         if b == '<' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmporq1r74v.rs:17:21\n\
    \   |\n17 |         } else if b == '>' {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars().filter(|c| !c.is_whitespace())\
    \ {\n        if bracket == '<' {\n            open_brackets.push('>');\n     \
    \       close_brackets.push('<');\n        } else if bracket == '>' {\n      \
    \      open_brackets.push('<');\n            close_brackets.push('>');\n     \
    \   } else {\n            open_brackets.push(bracket);\n        }\n    }\n   \
    \ open_brackets.chars().all(|c| close_brackets.chars().any(|c| c == c))\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp62pvytde.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '<' {\n            stack.push(c);\n        } else if c == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5oc2rn32.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6eus8br9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(next) = stack.last() {\n        if next == '<' {\n       \
    \     stack.push(brackets.chars().next().unwrap());\n        } else if next ==\
    \ '>' {\n            if stack.pop().unwrap() == '<' {\n                stack.push(brackets.chars().next().unwrap());\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    stack.pop().unwrap()\
    \ == '>'\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0v1547dq.rs:15:17\n\
    \   |\n15 |         if next == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0v1547dq.rs:17:24\n\
    \   |\n17 |         } else if next == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_wtmzbb8.rs:45:21\n   |\n\
    45 |     let mut open_bra\n   |                     ^ help: add `;` here\n46 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_wtmzbb8.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            let mut last = stack.pop();\n            if last !=\
    \ '<' {\n                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf22d9z5g.rs:21:24\n   |\n\
    21 |             if last != '<' {\n   |                        ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n21 |             if last != Some('<') {\n   |                        +++++\
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4cq5k4qj.rs:46:27\n   |\n\
    46 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4cq5k4qj.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ closed_brackets_stack = Vec::new();\n    let mut open_brackets_stack_size =\
    \ open_brackets_stack.len();\n    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n\
    \    let mut i = 0;\n    while i < brackets.len() {\n        let mut j = i;\n\
    \        while j < brackets.len() && brackets[j] == brackets[j].chars().next().unwrap()\
    \ {\n            j += 1\n        }\n        let open_bracket = brackets[i..j];\n\
    \        let mut closed_bracket = brackets[j..];\n        if open_bracket.len()\
    \ > closed_bracket.len() {\n            closed_brackets_stack.push(closed_bracket);\n\
    \            closed_brackets_stack_size += 1;\n        } else {\n            open_brackets_stack.push(open_bracket);\n\
    \            open_brackets_stack_size += 1;\n        }\n        i = j;\n    }\n\
    \    if open_brackets_stack_size == closed_brackets_stack_size {\n        return\
    \ true;\n    }\n    if open_brackets_stack_size > closed_brackets_stack_size {\n\
    \        return false;\n    }\n    let mut i = 0;\n    while i < open_brackets_stack_size\
    \ && i < closed_brackets_stack_size {\n        if open_brackets_stack[i] != closed_brackets_stack[i]\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    if open_brackets_stack_size\
    \ == closed_brackets_stack_size {\n        return true;\n    }\n    if open_brackets_stack_size\
    \ > closed_brackets_stack_size {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    while i < open_brackets_stack_size && i < closed_brackets_stack_size\
    \ {\n        if open_brackets_stack[i] != closed_brackets_stack[i] {\n       \
    \     return false;\n        }\n        i += 1;\n    }\n    if open_brackets_stack_size\
    \ == closed_brackets_stack_size {\n        return true;\n    }\n    if open_brackets_stack_size\
    \ > closed_brackets_stack_size {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    while i < open_brackets_stack_size && i < closed_brackets_stack_size\
    \ {\n        if open_brackets_stack[i] != closed_brackets_stack[i] {\n       \
    \     return false;\n        }\n        i += 1;\n    }\n    if open_brackets_stack_size\
    \ == \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp4_r4nwzj.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp4_r4nwzj.rs:21:37\n   |\n21 |         while\
    \ j < brackets.len() && brackets[j] == brackets[j].chars().next().unwrap() {\n\
    \   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4_r4nwzj.rs:21:52\n   |\n21 |         while j < brackets.len()\
    \ && brackets[j] == brackets[j].chars().next().unwrap() {\n   |              \
    \                                      ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmp4_r4nwzj.rs:24:13\n   |\n24 |         let\
    \ open_bracket = brackets[i..j];\n   |             ^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpddkvy92n.rs:27:48\n   |\n\
    27 |     let mut close_brackets_iter = close_bracket\n   |                   \
    \                             ^ help: add `;` here\n28 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_bracket` in this scope\n  -->\
    \ /tmp/tmpddkvy92n.rs:27:35\n   |\n27 |     let mut close_brackets_iter = close_bracket\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `close_brackets`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpddkvy92n.rs:14:81\n   |\n14 |     let mut open_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpddkvy92n.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpddkvy92n.rs:16:83\n   |\n16 |     let mut open_brackets_iter =\
    \ open_brackets_iter.into_iter().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpddkvy92n.rs:17:85\n   |\n17 |     let mut close_brackets_iter =\
    \ close_brackets_iter.into_iter().filter"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for bracket in brackets.chars().filter(|c| !c.is_whitespace())\
    \ {\n        if open_brackets.is_empty() {\n            open_brackets.push(bracket);\n\
    \        } else {\n            if open_brackets.chars().any(|c| c == bracket)\
    \ {\n                close_brackets.push(bracket);\n            } else {\n   \
    \             open_brackets.push(bracket);\n            }\n        }\n    }\n\n\
    \    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcvct17j9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.len() == 0 {\n            return\
    \ false;\n        }\n        let mut open = stack.last().unwrap();\n        let\
    \ mut close = c;\n        if open == close {\n            stack.pop();\n     \
    \   } else {\n            stack.push(c);\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv2bma9kp.rs:20:17\n\
    \   |\n20 |         if open == close {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_len = String::new();\n    let mut\
    \ close_brackets_len = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_len\
    \ = String::new();\n    let mut close_brackets_count_len = String::new();\n  \
    \  let mut open_brackets_count_count = String::new();\n    let mut close_brackets_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_len = String::new();\n\
    \    let mut close_brackets_count_count_len = String::new();\n    let mut open_brackets_count_count_count\
    \ = String::new();\n    let mut close_brackets_count_count_count = String::new();\n\
    \    let mut open_brackets_count_count_count_len = String::new();\n    let mut\
    \ close_brackets_count_count_count_len = String::new();\n    let mut open_brackets_count_count_count_count\
    \ = String::new();\n    let mut close_brackets_count_count_count_count = String::new();\n\
    \    let mut open_brackets_count_count_count_count_len = String::new();\n    let\
    \ mut close_brackets_count_count_count_count_len = String::new();\n    let mut\
    \ open_brackets_count_count_count_count_count = String::new();\n    let mut close_brackets_count_count_count_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_count_count_count_len\
    \ = String::new();\n    let mut close_brackets_count_count_count_count_count_len\
    \ = String::new();\n    let mut open_brackets_count_count_count_count_count_count\
    \ = String::new();\n    let mut close_brackets_count_count_count_count_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_count_count_count_count_len\
    \ = String::new();\n    let mut close_brackets_count_count_count_count_count_count_len\
    \ = String::new();\n    let mut open_brackets_count_count_count_count_count_count_count\
    \ = String::new();\n    let mut close_brackets_count_count_count_count_count_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mxd0mfk.rs:42:39\n   |\n\
    42 |     let mut open_brackets_count_count_\n   |                            \
    \           ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_mxd0mfk.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for bracket in brackets.chars().filter_map(|c| match\
    \ c {\n        '<' => Some('>'),\n        '>' => Some('<'),\n        _ => None,\n\
    \    }) {\n        open_brackets.push(bracket);\n    }\n\n    for bracket in brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => Some('<'),\n        '>' => Some('>'),\n        _ =>\
    \ None,\n    }) {\n        close_brackets.push(bracket);\n    }\n\n    open_brackets.chars().all(|c|\
    \ close_brackets.contains(&c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmptnywl7zp.rs:31:59\n\
    \     |\n31   |     open_brackets.chars().all(|c| close_brackets.contains(&c))\n\
    \     |                                                  -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                     |\n     |                                              \
    \    required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n31   |     open_brackets.chars().all(|c| close_brackets.contains(*&c))\n\
    \     |                                                           +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_stack = Vec::new();\n\
    \    let mut closing_brackets_stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            opening_brackets.push(bracket);\n\
    \            opening_brackets_stack.push(bracket);\n        } else if bracket\
    \ == '>' {\n            closing_brackets.push(bracket);\n            closing_brackets_stack.push(bracket);\n\
    \        } else {\n            if opening_brackets.len() == 0 {\n            \
    \    return false;\n            }\n            if closing_brackets.len() == 0\
    \ {\n                return false;\n            }\n            if opening_brackets.len()\
    \ != closing_brackets.len() {\n                return false;\n            }\n\
    \            if opening_brackets_stack.len() != closing_brackets_stack.len() {\n\
    \                return false;\n            }\n            if opening_brackets_stack.pop()\
    \ != closing_brackets_stack.pop() {\n                return false;\n         \
    \   }\n        }\n    }\n    opening_brackets.len() == 0 && closing_brackets.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpabz3i88d.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    stack.push(0);\n\
    \    stack.push(0);\n    stack.push(0);\n    let mut i = 0;\n    while i < brackets.len()\
    \ {\n        let mut j = i;\n        while j < brackets.len() && brackets[j] ==\
    \ brackets[i] {\n            j = j + 1;\n        }\n        if j == i {\n    \
    \        i += 1;\n            continue;\n        }\n        if brackets[i] ==\
    \ '<' {\n            stack.push(j);\n            i += 1;\n        } else {\n \
    \           j = stack.pop();\n            if j == 0 {\n                i += 1;\n\
    \                continue;\n            }\n            if brackets[i] == '>' {\n\
    \                stack.push(j);\n                i += 1;\n            } else {\n\
    \                return false;\n            }\n        }\n    }\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n    stack.pop();\n\
    \    stack.pop();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqyykty8l.rs:19:37\n\
    \   |\n19 |         while j < brackets.len() && brackets[j] == brackets[i] {\n\
    \   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqyykty8l.rs:19:52\n   |\n19 |         while j < brackets.len()\
    \ && brackets[j] == brackets[i] {\n   |                                      \
    \              ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqyykty8l.rs:26:12\n   |\n26 |         if brackets[i] == '<' {\n\
    \   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<Ra"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n\n    for bracket in\
    \ brackets.chars() {\n        if bracket == '<' {\n            stack.push(bracket);\n\
    \            open_brackets.push(bracket);\n        } else if bracket == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            close_brackets.push(stack.pop());\n        } else if bracket\
    \ == '{' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(bracket);\n        } else if bracket ==\
    \ '}' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            close_brackets.push(stack.pop());\n        }\n    }\n\
    \    if stack.len() != 0 {\n        return false;\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    for open_bracket\
    \ in open_brackets {\n        if close_brackets.iter().any(|c| open_bracket ==\
    \ c) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp88ds6xq5.rs:44:58\n   |\n\
    44 |         if close_brackets.iter().any(|c| open_bracket == c) {\n   |     \
    \                                                     ^ expected `char`, found\
    \ `&Option<char>`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&Option<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let next = stack.last().unwrap();\n        if next == '<' {\n  \
    \          stack.push(brackets.chars().next().unwrap());\n        } else if next\
    \ == '>' {\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpupcl_hdc.rs:19:17\n\
    \   |\n19 |         if next == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpupcl_hdc.rs:21:24\n\
    \   |\n21 |         } else if next == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '<' {\n            stack.push(c);\n        } else if c == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return false;\n            }\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmwf076ur.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c != '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0njh2c3j.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    while let Some(open) = stack.pop() {\n        if open != '<' {\n        \
    \    open_brackets.push(open);\n        }\n        if let Some(close) = stack.pop()\
    \ {\n            if close != '>' {\n                close_brackets.push(close);\n\
    \            }\n        } else {\n            return false;\n        }\n    }\n\
    \    if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n    for open in open_brackets {\n        if !close_brackets.contains(&open)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1qh29k4l.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    let mut open_brackets:\
    \ Vec<String> = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n \
    \   let mut open_bracket: Option<String> = None;\n    let mut close_bracket: Option<String>\
    \ = None;\n    let mut open_brackets: Vec<String> = vec![];\n    let mut close_brackets:\
    \ Vec<String> = vec![];\n    let mut open_bracket: Option<String> = None;\n  \
    \  let mut close_bracket: Option<String> = None;\n    let mut open_brackets: Vec<String>\
    \ = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n    let mut open_bracket:\
    \ Option<String> = None;\n    let mut close_bracket: Option<String> = None;\n\
    \    let mut open_brackets: Vec<String> = vec![];\n    let mut close_brackets:\
    \ Vec<String> = vec![];\n    let mut open_bracket: Option<String> = None;\n  \
    \  let mut close_bracket: Option<String> = None;\n    let mut open_brackets: Vec<String>\
    \ = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n    let mut open_bracket:\
    \ Option<String> = None;\n    let mut close_bracket: Option<String> = None;\n\
    \    let mut open_brackets: Vec<String> = vec![];\n    let mut close_brackets:\
    \ Vec<String> = vec![];\n    let mut open_bracket: Option<String> = None;\n  \
    \  let mut close_bracket: Option<String> = None;\n    let mut open_brackets: Vec<String>\
    \ = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n    let mut open_bracket:\
    \ Option<String> = None;\n    let mut close_bracket: Option<String> = None;\n\
    \    let mut open_brackets: Vec<String> = vec![];\n    let mut close_brackets:\
    \ Vec<String> = vec![];\n    let mut open_bracket: Option<String> = None;\n  \
    \  let \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfgsdmarb.rs:45:1\n  \
    \ |\n45 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6l344fg9.rs:46:47\n   |\n\
    46 |     let mut open_brackets_count_max = Vec::new\n   |                    \
    \                           ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6l344fg9.rs:11:44\n   |\n11 |\
    \ fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuaw41k6l.rs:27:48\n   |\n\
    27 |     let mut close_brackets_iter = close_bracket\n   |                   \
    \                             ^ help: add `;` here\n28 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_bracket` in this scope\n  -->\
    \ /tmp/tmpuaw41k6l.rs:27:35\n   |\n27 |     let mut close_brackets_iter = close_bracket\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `close_brackets`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpuaw41k6l.rs:14:81\n   |\n14 |     let mut open_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpuaw41k6l.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpuaw41k6l.rs:16:83\n   |\n16 |     let mut open_brackets_iter =\
    \ open_brackets_iter.into_iter().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpuaw41k6l.rs:17:85\n   |\n17 |     let mut close_brackets_iter =\
    \ close_brackets_iter.into_iter().filter"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    let mut opening_brackets_count\
    \ = Vec::new();\n    let mut closing_brackets_count = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec::new();\n    let mut closing_brackets_length =\
    \ Vec::new();\n    let mut opening_brackets_length = Vec::new();\n    let mut\
    \ closing_brackets_length = Vec::new();\n    let mut opening_brackets_length =\
    \ Vec::new();\n    let mut closing_brackets_length = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec::new();\n    let mut closing_brackets_length =\
    \ Vec::new();\n    let mut opening_brackets_length = Vec::new();\n    let mut\
    \ closing_brackets_length = Vec::new();\n    let mut opening_brackets_length =\
    \ Vec::new();\n    let mut closing_brackets_length = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec::new();\n    let mut closing_brackets_length =\
    \ Vec::new();\n    let mut opening_brackets_length = Vec::new();\n    let mut\
    \ closing_brackets_length = Vec::new();\n    let mut opening_brackets_length =\
    \ Vec::new();\n    let mut closing_brackets_length = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec::new();\n    let mut closing_brackets_length =\
    \ Vec::new();\n    let mut opening_brackets_length = Vec::new();\n    let mut\
    \ closing_brackets_length = Vec::new();\n    let mut opening_brackets_length =\
    \ Vec::new();\n    let mut closing_brackets_length = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec::new();\n    let mut closing_brackets_length =\
    \ Vec::new();\n    let mut opening_brackets_length = Vec::new();\n    let mut\
    \ closing_brackets_length = Vec::new();\n    let mut opening_brackets_length =\
    \ Vec::new();\n    let mut closing_brackets_length = Vec::new();\n    let mut\
    \ opening_brackets_length = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg6wj3gtz.rs:47:42\n   |\n\
    47 |     let mut opening_brackets_length = Vec\n   |                         \
    \                 ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found struct `Vec`\n   --> /tmp/tmpg6wj3gtz.rs:47:39\n    |\n\
    47  |       let mut opening_brackets_length = Vec\n    |                     \
    \                    ^^^ help: use struct literal syntax instead: `Vec { buf:\
    \ val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6wj3gtz.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        if c == stack.pop().unwrap() {\n            continue;\n\
    \        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpluse65pj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch as usize);\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpukamq6j2.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_size = String::new();\n    let mut\
    \ close_brackets_size = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_size\
    \ = String::new();\n    let mut close_brackets_count_size = String::new();\n \
    \   let mut open_brackets_count_size = String::new();\n    let mut close_brackets_count_size\
    \ = String::new();\n    let mut open_brackets_count_size = String::new();\n  \
    \  let mut close_brackets_count_size = String::new();\n    let mut open_brackets_count_size\
    \ = String::new();\n    let mut close_brackets_count_size = String::new();\n \
    \   let mut open_brackets_count_size = String::new();\n    let mut close_brackets_count_size\
    \ = String::new();\n    let mut open_brackets_count_size = String::new();\n  \
    \  let mut close_brackets_count_size = String::new();\n    let mut open_brackets_count_size\
    \ = String::new();\n    let mut close_brackets_count_size = String::new();\n \
    \   let mut open_brackets_count_size = String::new();\n    let mut close_brackets_count_size\
    \ = String::new();\n    let mut open_brackets_count_size = String::new();\n  \
    \  let mut close_brackets_count_size = String::new();\n    let mut open_brackets_count_size\
    \ = String::new();\n    let mut close_brackets_count_size = String::new();\n \
    \   let mut open_brackets_count_size = String::new();\n    let mut close_brackets_count_size\
    \ = String::new();\n    let mut open_brackets_count_size = String::new();\n  \
    \  let mut close_brackets_count_size = String::new();\n    let mut open_brackets_count_size\
    \ = String::new();\n    let mut close_brackets_count_size = String::new();\n \
    \   let mut open_brackets_count_size = String::new();\n    let mut close_brackets_count_size\
    \ = String::new();\n    let mut open_brackets_count_size = \n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp78_bxyzj.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n\n    for bracket in brackets.chars() {\n\
    \        if bracket == '<' {\n            opening_brackets.push('>');\n      \
    \      closing_brackets.push('<');\n        } else if bracket == '>' {\n     \
    \       opening_brackets.push('<');\n            closing_brackets.push('>');\n\
    \        } else {\n            opening_brackets.push(bracket);\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n\n    opening_brackets.chars().all(|c| closing_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8gl_tgbk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if let Some(next) = stack.last() {\n            if next ==\
    \ '<' {\n                stack.pop();\n                stack.push(brackets.chars().next().unwrap());\n\
    \            } else if next == '>' {\n                stack.pop();\n         \
    \       stack.push(brackets.chars().next().unwrap());\n            } else {\n\
    \                return false;\n            }\n        } else {\n            return\
    \ true;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_ubjlrxh.rs:16:21\n\
    \   |\n16 |             if next == '<' {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_ubjlrxh.rs:19:28\n\
    \   |\n19 |             } else if next == '>' {\n   |                        \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut closing_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut opening_brackets_index = -1;\n    let mut closing_brackets_index\
    \ = -1;\n    let mut opening_brackets_index_size = opening_brackets.len();\n \
    \   let mut closing_brackets_index_size = closing_brackets.len();\n    let mut\
    \ opening_brackets_index_pos = 0;\n    let mut closing_brackets_index_pos = 0;\n\
    \    let mut opening_brackets_index_pos_size = opening_brackets_size.len();\n\
    \    let mut closing_brackets_index_pos_size = closing_brackets_size.len();\n\
    \    let mut opening_brackets_index_neg = 0;\n    let mut closing_brackets_index_neg\
    \ = 0;\n    let mut opening_brackets_index_neg_size = opening_brackets_size.len();\n\
    \    let mut closing_brackets_index_neg_size = closing_brackets_size.len();\n\
    \    let mut opening_brackets_index_neg_size = 0;\n    let mut closing_brackets_index_neg_size\
    \ = 0;\n    let mut opening_brackets_index_neg_pos = 0;\n    let mut closing_brackets_index_neg_pos\
    \ = 0;\n    let mut opening_brackets_index_neg_pos_size = 0;\n    let mut closing_brackets_index_neg_pos_size\
    \ = 0;\n    let mut opening_brackets_index_neg_neg = 0;\n    let mut closing_brackets_index_neg_neg\
    \ = 0;\n    let mut opening_brackets_index_neg_neg_size = 0;\n    let mut closing_brackets_index_neg_neg_size\
    \ = 0;\n    let mut opening_brackets_index_neg_neg_pos = 0;\n    let mut closing_brackets_index_neg_neg_pos\
    \ = 0;\n    let mut opening_brackets_index_neg_neg_pos_size = 0;\n    let mut\
    \ closing_brackets_index_neg_neg_pos_size = 0;\n    let mut opening_brackets_index_neg_neg_neg\
    \ = 0;\n    let mut closing_brackets_index_neg_neg_neg = 0;\n    let mut opening_brackets_index_neg_neg_neg_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9q_q9fkk.rs:44:48\n   |\n\
    44 |     let mut opening_brackets_index_neg_neg_neg_\n   |                   \
    \                             ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9q_q9fkk.rs:14:67\n\
    \   |\n14 |     let mut opening_brackets_size = brackets.chars().filter(|c| c\
    \ == '<').count();\n   |                                                     \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp9q_q9fkk.rs:15:67\n   |\n15 |     let mut closing_brackets_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n   |                     \
    \                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmp9q_q9fkk.rs:22:69\n\
    \   |\n22 |     let mut opening_brackets_index_pos_size = opening_brackets_size.len();\n\
    \   |                                                                     ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp9q_q9fkk.rs:23:69\n   |\n23\
    \ |     let mut closing_brackets_index_pos_size = closing_brackets_size.len();\n\
    \   |                                                                     ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp9q_q9fkk.rs:26:69\n   |\n26\
    \ |     let mut opening_brackets_index_neg_size = opening_brackets_size.len();\n\
    \   |                                                                     ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets {\n\
    \        if ch == '<' {\n            stack.push('<');\n        } else if ch ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpjbf4n6a0.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_size\
    \ = brackets.chars().filter(|c| c == '<').count();\n    let mut close_brackets_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n    let mut i = 0;\n    while\
    \ i < brackets.len() {\n        if brackets[i] == '<' {\n            stack.push(i);\n\
    \            i += open_brackets_size;\n            open_brackets.push(i);\n  \
    \          i += close_brackets_size;\n            close_brackets.push(i);\n  \
    \      } else if brackets[i] == '>' {\n            i += close_brackets_size;\n\
    \            close_brackets.push(i);\n        } else {\n            i += 1;\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len() && open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqcwnimql.rs:15:64\n\
    \   |\n15 |     let mut open_brackets_size = brackets.chars().filter(|c| c ==\
    \ '<').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpqcwnimql.rs:16:65\n   |\n16 |     let mut close_brackets_size =\
    \ brackets.chars().filter(|c| c == '>').count();\n   |                       \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqcwnimql.rs:19:12\n\
    \   |\n19 |         if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqcwnimql.rs:25:19\n   |\n25 |         } else if brackets[i] ==\
    \ '>' {\n   |                   ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usiz"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0 && true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(next) = stack.last() {\n        if next == '<' {\n       \
    \     stack.push(brackets.chars().next().unwrap());\n        } else if next ==\
    \ '>' {\n            if stack.len() == 1 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 1 && stack.pop() == '>'\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2zm__et2.rs:15:17\n\
    \   |\n15 |         if next == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2zm__et2.rs:17:24\n\
    \   |\n17 |         } else if next == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2zm__et2.rs:26:40\n\
    \   |\n26 |     stack.len() == 1 && stack.pop() == '>'\n   |                 \
    \                       ^^^ expected enum `Option`, found `char`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found type `char`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n26 |     stack.len() == 1 && stack.pop() ==\
    \ Some('>')\n   |                                        +++++   +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for ch in\
    \ brackets.chars() {\n        if ch == '<' {\n            stack.push(0);\n   \
    \     } else if ch == '>' {\n            if stack.len() == 0 {\n             \
    \   return false;\n            }\n            stack.pop();\n        } else {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.push(stack.len() - 1);\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets\
    \ {\n        if c == '<' {\n            stack.push(brackets.len());\n        }\
    \ else if c == '>' {\n            if stack.len() == 0 {\n                return\
    \ false;\n            }\n            stack.pop();\n        } else {\n        \
    \    if stack.len() == 0 {\n                return false;\n            }\n   \
    \         stack.pop();\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp78scdlef.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp368c0mst.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len() - 1;\n            if stack[top]\
    \ != 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len() - 1;\n            stack[top]\
    \ = ch as usize;\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(0);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets {\n  \
    \      if c == '<' {\n            stack.push(c);\n        } else if c == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() !=\
    \ 0 {\n                return false;\n            }\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpl29997bx.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_len = brackets.len();\n    let mut\
    \ close_brackets_len = brackets.len();\n    let mut i = 0;\n    while i < open_brackets_len\
    \ {\n        if open_brackets[i] != brackets[i] {\n            open_brackets.push_str(&open_brackets[i..i\
    \ + 1]);\n            close_brackets.push_str(&close_brackets[i..i + 1]);\n  \
    \          i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppi0el0aw.rs:18:12\n\
    \   |\n18 |         if open_brackets[i] != brackets[i] {\n   |            ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppi0el0aw.rs:18:32\n   |\n18 |         if open_brackets[i] != brackets[i]\
    \ {\n   |                                ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsnqig5kd.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        c != '<' && c !=\
    \ '>'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp85_m7xt_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_count = String::new();\n    let\
    \ mut close_brackets_count = String::new();\n    let mut open_brackets_count_map\
    \ = HashMap::new();\n    let mut close_brackets_count_map = HashMap::new();\n\
    \    let mut open_brackets_count_map_reverse = HashMap::new();\n    let mut close_brackets_count_map_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_val = HashMap::new();\n\
    \    let mut close_brackets_count_map_reverse_val = HashMap::new();\n    let mut\
    \ open_brackets_count_map_reverse_key_val = HashMap::new();\n    let mut close_brackets_count_map_reverse_key_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val =\
    \ HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n    let mut open_brackets_count_map_reverse_key_val_val_val_val_val_val_val_val_val\
    \ = HashMap::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5csjt2ux.rs:16:39\n   |\n16 |     let mut open_brackets_count_map =\
    \ HashMap::new();\n   |                                       ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp5csjt2ux.rs:17:40\n   |\n17 |     let mut close_brackets_count_map\
    \ = HashMap::new();\n   |                                        ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp5csjt2ux.rs:18:47\n   |\n18 |     let mut open_brackets_count_map_reverse\
    \ = HashMap::new();\n   |                                               ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp5csjt2ux.rs:19:48\n   |\n19\
    \ |     let mut close_brackets_count_map_reverse = HashMap::new();\n   |     \
    \                                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp5csjt2ux.rs:20:51\n   |\n20 |     let mut open_brackets_count_map_reverse_val\
    \ = HashMap::new();\n   |                                                   ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp5csjt2ux.rs:21:52\n   |\n21\
    \ |     let mut close_brackets_count_map_reverse_val = HashMap::new();\n   | \
    \                                                   ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror["
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnljl366p.rs:44:44\n   |\n\
    44 |     let mut open_brackets_count_stack = Vec\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmpnljl366p.rs:44:41\n\
    \    |\n44  |       let mut open_brackets_count_stack = Vec\n    |           \
    \                                ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnljl366p.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut opening_brackets = Vec::new();\n    while let Some(opening_bracket)\
    \ = stack.pop() {\n        if opening_bracket == '<' {\n            opening_brackets.push('>');\n\
    \            stack.push(brackets.chars().next().unwrap());\n        } else {\n\
    \            opening_brackets.push('<');\n            stack.push(brackets.chars().next().unwrap());\n\
    \        }\n    }\n    opening_brackets.len() == brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6hrd7riw.rs:27:48\n   |\n\
    27 |     let mut close_brackets_iter = close_bracket\n   |                   \
    \                             ^ help: add `;` here\n28 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_bracket` in this scope\n  -->\
    \ /tmp/tmp6hrd7riw.rs:27:35\n   |\n27 |     let mut close_brackets_iter = close_bracket\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `close_brackets`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp6hrd7riw.rs:14:81\n   |\n14 |     let mut open_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp6hrd7riw.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp6hrd7riw.rs:16:83\n   |\n16 |     let mut open_brackets_iter =\
    \ open_brackets_iter.into_iter().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp6hrd7riw.rs:17:85\n   |\n17 |     let mut close_brackets_iter =\
    \ close_brackets_iter.into_iter().filter"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            let opening = stack.pop();\n            if opening !=\
    \ c {\n                return false;\n            }\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp426cwew_.rs:15:24\n   |\n\
    15 |             stack.push(c);\n   |                        ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp426cwew_.rs:21:27\n   |\n21 |             if\
    \ opening != c {\n   |                           ^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<String>`\n              found\
    \ type `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_len = brackets.len();\n    let mut\
    \ close_brackets_len = brackets.len();\n    let mut i = 0;\n    while i < open_brackets_len\
    \ {\n        if open_brackets.is_empty() {\n            open_brackets.push(brackets[i]);\n\
    \        } else {\n            if open_brackets[open_brackets.len() - 1] != brackets[i]\
    \ {\n                open_brackets.push(brackets[i]);\n            }\n       \
    \ }\n        i += 1;\n    }\n    open_brackets_len -= 1;\n    close_brackets_len\
    \ -= 1;\n    open_brackets.reverse();\n    close_brackets.reverse();\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6n_q_hfc.rs:19:32\n\
    \   |\n19 |             open_brackets.push(brackets[i]);\n   |               \
    \                 ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6n_q_hfc.rs:21:16\n\
    \   |\n21 |             if open_brackets[open_brackets.len() - 1] != brackets[i]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6n_q_hfc.rs:21:58\n   |\n21 |             if open_brackets[open_brackets.len()\
    \ - 1] != brackets[i] {\n   |                                                \
    \          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String a"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5z2nzsvs.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx: usize\
    \ = 0;\n    let mut open_brackets_idx2: usize = 0;\n    let mut close_brackets_idx2:\
    \ usize = 0;\n    let mut open_brackets_idx3: usize = 0;\n    let mut close_brackets_idx3:\
    \ usize = 0;\n    let mut open_brackets_idx4: usize = 0;\n    let mut close_brackets_idx4:\
    \ usize = 0;\n    let mut open_brackets_idx5: usize = 0;\n    let mut close_brackets_idx5:\
    \ usize = 0;\n    let mut open_brackets_idx6: usize = 0;\n    let mut close_brackets_idx6:\
    \ usize = 0;\n    let mut open_brackets_idx7: usize = 0;\n    let mut close_brackets_idx7:\
    \ usize = 0;\n    let mut open_brackets_idx8: usize = 0;\n    let mut close_brackets_idx8:\
    \ usize = 0;\n    let mut open_brackets_idx9: usize = 0;\n    let mut close_brackets_idx9:\
    \ usize = 0;\n    let mut open_brackets_idx10: usize = 0;\n    let mut close_brackets_idx10:\
    \ usize = 0;\n    let mut open_brackets_idx11: usize = 0;\n    let mut close_brackets_idx11:\
    \ usize = 0;\n    let mut open_brackets_idx12: usize = 0;\n    let mut close_brackets_idx12:\
    \ usize = 0;\n    let mut open_brackets_idx13: usize = 0;\n    let mut close_brackets_idx13:\
    \ usize = 0;\n    let mut open_brackets_idx14: usize = 0;\n    let mut close_brackets_idx14:\
    \ usize = 0;\n    let mut open_brackets_idx15: usize = 0;\n    let mut close_brackets_idx15:\
    \ usize = 0;\n    let mut open_brackets_idx16: usize = 0;\n    let mut close_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdw6k8yum.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdw6k8yum.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        let mut last = stack.pop().unwrap();\n        if\
    \ last != c {\n            return false;\n        }\n        stack.push(c);\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61ezswm8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkpugh6iv.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpktvgxsiz.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut opening = Vec::new();\n    let mut closing = Vec::new();\n    while\
    \ let Some(item) = stack.last() {\n        if item == '<' {\n            opening.push(item);\n\
    \        } else if item == '>' {\n            closing.push(item);\n        } else\
    \ {\n            stack.push(item);\n        }\n    }\n    closing.reverse();\n\
    \    opening.reverse();\n    closing.iter().all(|c| opening.contains(c))\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3v4dvb7m.rs:17:17\n\
    \   |\n17 |         if item == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3v4dvb7m.rs:19:24\n\
    \   |\n19 |         } else if item == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3v4dvb7m.rs:22:24\n\
    \   |\n22 |             stack.push(item);\n   |                        ^^^^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |             stack.push(*item);\n   |                        +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpinqaq7ah.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp_y00tk8c.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n   \
    \ let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n  \
    \  let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_bracket: usize = 0;\n    let mut close_bracket: usize = 0;\n\
    \    let mut open_b\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzqps7w60.rs:53:19\n   |\n\
    53 |     let mut open_b\n   |                   ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzqps7w60.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for c in brackets {\n        if c == '<' {\n         \
    \   open_brackets.push(c);\n        } else if c == '>' {\n            close_brackets.push(c);\n\
    \        } else {\n            return false;\n        }\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    for open_bracket\
    \ in open_brackets.chars() {\n        if !close_brackets.contains(&open_bracket)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp4mhdy1lf.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp4mhdy1lf.rs:27:37\n \
    \    |\n27   |         if !close_brackets.contains(&open_bracket) {\n     |  \
    \                          -------- ^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                            |\n     |                  \
    \          required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n     = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n27   |         if !close_brackets.contains(*&open_bracket)\
    \ {\n     |                                     +\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut open_brackets:\
    \ Vec<usize> = vec![];\n    let mut close_brackets: Vec<usize> = vec![];\n\n \
    \   for bracket in brackets.chars() {\n        if bracket == '<' {\n         \
    \   stack.push(0);\n            open_brackets.push(0);\n            close_brackets.push(0);\n\
    \        } else if bracket == '>' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            stack.pop();\n         \
    \   open_brackets.pop();\n            close_brackets.pop();\n        } else {\n\
    \            if stack.len() == 0 {\n                stack.push(0);\n         \
    \   }\n            stack.push(stack.len() - 1);\n            open_brackets.push(stack.len()\
    \ - 1);\n            close_brackets.push(stack.len() - 1);\n        }\n    }\n\
    \n    for open_bracket in open_brackets {\n        if close_brackets[open_bracket]\
    \ != open_bracket {\n            return false;\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpclizskv2.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_ptr = Vec::new();\n    let mut close_brackets_count_stack_ptr\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr = Vec::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr = Vec::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut close_brackets_count_stack_ptr_ptr_ptr_ptr = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut close_brackets_count_stack_ptr_ptr\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_4yd9de_.rs:38:47\n   |\n\
    38 |     let mut close_brackets_count_stack_ptr_ptr\n   |                    \
    \                           ^ help: add `;` here\n39 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_4yd9de_.rs:11:44\n   |\n11 |\
    \ fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        let mut found = false;\n        for c in stack.iter().rev()\
    \ {\n            if c == brackets.chars().next().unwrap() {\n                found\
    \ = true;\n                break;\n            }\n            if c == '<' {\n\
    \                stack.push(brackets.chars().next().unwrap());\n            }\n\
    \            if c == '>' {\n                let mut last = stack.last().unwrap();\n\
    \                if last == brackets.chars().next().unwrap() {\n             \
    \       stack.pop();\n                } else {\n                    return false;\n\
    \                }\n            }\n        }\n        if !found {\n          \
    \  return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5g7r_t7.rs:17:18\n\
    \   |\n17 |             if c == brackets.chars().next().unwrap() {\n   |     \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpw5g7r_t7.rs:21:18\n   |\n21 |             if c == '<' {\n   | \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpw5g7r_t7.rs:24:18\n   |\n24 |             if c ==\
    \ '>' {\n   |                  ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpw5g7r_t7.rs:26:25\n   |\n26 |           \
    \      if last == brackets.chars().next().unwrap() {\n   |                   \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpzc3jbsrr.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push(0);\n        } else if ch\
    \ == '>' {\n            stack.pop();\n        } else {\n            stack.push((stack.len()\
    \ as usize) - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpearb1i64.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut closing_brackets = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n            opening_brackets.push(c);\n\
    \        } else if c == '>' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            closing_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.last().unwrap().push(c);\n\
    \        }\n    }\n    if stack.len() != 0 {\n        return false;\n    }\n \
    \   if opening_brackets.len() != closing_brackets.len() {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmp3lfb7ys6.rs:29:35\n   |\n29 |             stack.last().unwrap().push(c);\n\
    \   |                                   ^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let next = stack.last().unwrap();\n        if next == '<' {\n  \
    \          stack.push(brackets.chars().next().unwrap());\n        } else if next\
    \ == '>' {\n            if stack.len() == 1 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8m02bypa.rs:19:17\n\
    \   |\n19 |         if next == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8m02bypa.rs:21:24\n\
    \   |\n21 |         } else if next == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_index = 0;\n    let mut close_brackets_index\
    \ = 0;\n    let mut open_brackets_chars = String::new();\n    let mut close_brackets_chars\
    \ = String::new();\n    let mut open_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_chars_index = 0;\n    let mut\
    \ close_brackets_chars_index = 0;\n    let mut open_brackets_chars_chars = String::new();\n\
    \    let mut close_brackets_chars_chars = String::new();\n    let mut open_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == '<').count();\n    let mut close_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n    let mut open_brackets_chars_chars_index\
    \ = 0;\n    let mut close_brackets_chars_chars_index = 0;\n    let mut open_brackets_chars_chars_chars\
    \ = String::new();\n    let mut close_brackets_chars_chars_chars = String::new();\n\
    \    let mut open_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_chars_chars_chars_index = 0;\n\
    \    let mut close_brackets_chars_chars_chars_index = 0;\n    let mut open_brackets_chars_chars_chars_chars\
    \ = String::new();\n    let mut close_brackets_chars_chars_chars_chars = String::new();\n\
    \    let mut open_brackets_chars_chars_chars_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu63iym0e.rs:38:45\n   |\n\
    38 |     let mut open_brackets_chars_chars_chars_\n   |                      \
    \                       ^ help: add `;` here\n39 | }\n   | - unexpected token\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu63iym0e.rs:14:64\n\
    \   |\n14 |     let mut open_brackets_size = brackets.chars().filter(|c| c ==\
    \ '<').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpu63iym0e.rs:15:65\n   |\n15 |     let mut close_brackets_size =\
    \ brackets.chars().filter(|c| c == '>').count();\n   |                       \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpu63iym0e.rs:20:70\n   |\n20 |   \
    \  let mut open_brackets_chars_size = brackets.chars().filter(|c| c == '<').count();\n\
    \   |                                                                      ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu63iym0e.rs:21:71\n\
    \   |\n21 |     let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n   |                                                   \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpu63iym0e.rs:26:76\n   |\n26 |     let mut open_brackets_chars_chars_size\
    \ = brackets."
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            stack.push('<');\n        } else if ch\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(ch);\n        }\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let top = stack.last().unwrap();\n        if top == '<' {\n    \
    \        stack.push(brackets.chars().next().unwrap());\n        } else if top\
    \ == '>' {\n            if stack.len() == 1 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj7zwdvcr.rs:19:16\n\
    \   |\n19 |         if top == '<' {\n   |                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj7zwdvcr.rs:21:23\n\
    \   |\n21 |         } else if top == '>' {\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push('>');\n            close_brackets.push('<');\n\
    \        } else if bracket == '>' {\n            open_brackets.push('<');\n  \
    \          close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphy6qrc5n.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    let mut open_brackets:\
    \ Vec<String> = vec![];\n    let mut close_brackets: Vec<String> = vec![];\n \
    \   let mut open_brackets_idx: usize = 0;\n    let mut close_brackets_idx: usize\
    \ = 0;\n    let mut open_brackets_len: usize = 0;\n    let mut close_brackets_len:\
    \ usize = 0;\n    let mut open_brackets_idx2: usize = 0;\n    let mut close_brackets_idx2:\
    \ usize = 0;\n    let mut open_brackets_len2: usize = 0;\n    let mut close_brackets_len2:\
    \ usize = 0;\n    let mut open_brackets_idx3: usize = 0;\n    let mut close_brackets_idx3:\
    \ usize = 0;\n    let mut open_brackets_len3: usize = 0;\n    let mut close_brackets_len3:\
    \ usize = 0;\n    let mut open_brackets_idx4: usize = 0;\n    let mut close_brackets_idx4:\
    \ usize = 0;\n    let mut open_brackets_len4: usize = 0;\n    let mut close_brackets_len4:\
    \ usize = 0;\n    let mut open_brackets_idx5: usize = 0;\n    let mut close_brackets_idx5:\
    \ usize = 0;\n    let mut open_brackets_len5: usize = 0;\n    let mut close_brackets_len5:\
    \ usize = 0;\n    let mut open_brackets_idx6: usize = 0;\n    let mut close_brackets_idx6:\
    \ usize = 0;\n    let mut open_brackets_len6: usize = 0;\n    let mut close_brackets_len6:\
    \ usize = 0;\n    let mut open_brackets_idx7: usize = 0;\n    let mut close_brackets_idx7:\
    \ usize = 0;\n    let mut open_brackets_len7: usize = 0;\n    let mut close_brackets_len7:\
    \ usize = 0;\n    let mut open_brackets_idx8: usize = 0;\n    let mut close_brackets_idx8:\
    \ usize = 0;\n    let mut open_brackets_len8: usize = 0;\n    let mut close_brackets_len8:\
    \ usize = 0;\n    let mut open\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyy8n3uz1.rs:47:17\n   |\n\
    47 |     let mut open\n   |                 ^ help: add `;` here\n48 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyy8n3uz1.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars() {\n \
    \       if bracket == '<' {\n            opening_brackets.push('>');\n       \
    \     closing_brackets.push('<');\n        } else if bracket == '>' {\n      \
    \      opening_brackets.push('<');\n            closing_brackets.push('>');\n\
    \        } else {\n            opening_brackets.push(bracket);\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.chars().all(|c| closing_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmd1_lk06.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    loop {\n        if stack.is_empty()\
    \ {\n            return open_brackets.len() == 0;\n        }\n        let mut\
    \ current = stack.pop().unwrap();\n        if current == '<' {\n            open_brackets.push(current);\n\
    \        }\n        if current == '>' {\n            if open_brackets.len() ==\
    \ 0 {\n                return false;\n            }\n            let mut last\
    \ = open_brackets.last().unwrap();\n            if last != '<' {\n           \
    \     return false;\n            }\n            open_brackets.pop();\n       \
    \ }\n        stack.push(current);\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgmu2z52z.rs:28:21\n\
    \   |\n28 |             if last != '<' {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
