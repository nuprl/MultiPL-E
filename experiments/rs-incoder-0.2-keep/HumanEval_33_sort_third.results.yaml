name: HumanEval_33_sort_third
language: rust
results:
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsr1mffls.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpo_qjgnl9.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1b29e0bz.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbkd6nzet.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmps01pl_y_.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n         \
    \   0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp84cioiy2.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            *v = (*v + 1) as isize;\n      \
    \  }\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 4, 6, 6, 8, 10]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpzx1rt4bx.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpuf288wmw.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n \
    \   let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8,\
    \ 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3,\
    \ 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdt1plkfq.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *v = *i;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_bwh0c0.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpf_bwh0c0.rs:14:18\n\
    \   |\n14 |             *v = *i;\n   |                  ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppqzqt75g.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6c9a4kxi.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6c9a4kxi.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwsf40n41.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8rsatd1q.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp59ue3a1q.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *v = l3[i];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpovz_4j5j.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ j)| {\n        if i % 3 == 0 {\n            l3[i] = l[j];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&mut isize`\n  -->\
    \ /tmp/tmp02lmmwg3.rs:14:21\n   |\n14 |             l3[i] = l[j];\n   |      \
    \               ^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&mut\
    \ isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&mut isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = *i;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbmhkjfoq.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpbmhkjfoq.rs:14:13\n\
    \   |\n14 |             *i = *i;\n   |             ^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpbmhkjfoq.rs:14:18\n   |\n14 |        \
    \     *i = *i;\n   |                  ^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    l2.dedup();\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpz7mj7af5.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpncvz38hv.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpuz4zsf3g.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n        l3[i] = l3[i / 3];\n    });\n    l3\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpfyqu0mkw.rs:12:33\n\
    \   |\n12 |     l3.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfyqu0mkw.rs:12:53\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp6c7cch5f.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpd0789f3m.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpttety2t8.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2[i] = l2[i];\n        } else {\n            l2[i] = l2[i\
    \ + 1];\n            i += 1;\n        }\n    }\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmppkkl2tvi.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = l3[i / 3];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv9qx92fl.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpop9b6qmt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcf6m6vh0.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            *v = (*v + 1) as isize;\n      \
    \  }\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 4, 6, 6, 8, 10]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfijeend2.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4fzmili5.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp6n1symp3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgfbj9z5j.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  x.to_owned()\n        } else {\n            x.to_owned() + 3\n        }\n \
    \   });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpxwzuxvtm.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7f8nus_z.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfeyblmsz.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphm4er1oq.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphm4er1oq.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwfznbjt6.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp98diirun.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp28bac46u.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmph6taws_a.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = i;\n        }\n    });\n   \
    \ l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwex219j6.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnbree0iv.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcqw1pgk6.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n         \
    \   0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsepb7zik.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmphp9l8ini.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1iqaresl.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp06bopki4.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp06bopki4.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq0ns6xsj.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9yeae61u.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpp91u2kjt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i /= 3;\n        }\n    });\n    l3\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0keataw.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpg0patxcj.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmprp3mbcwn.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuu5kqqu7.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |             -----   ^ expected `isize`, found\
    \ `&mut isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n14 | \
    \            l3[i] = *v;\n   |                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp80_c1yio.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *v = l3[i];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp75lnhtv4.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2u2r81u9.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2[i] = l2[i];\n        }\n        i += 1;\n    }\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 3, 4, 8, 9, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpjsef9o5j.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    let mut l3 = l2.clone();\n    l3.sort_unstable();\n\
    \    let mut l4 = l3.clone();\n    l4.sort_unstable();\n    let mut l5 = l4.clone();\n\
    \    l5.sort_unstable();\n    let mut l6 = l5.clone();\n    l6.sort_unstable();\n\
    \    let mut l7 = l6.clone();\n    l7.sort_unstable();\n    let mut l8 = l7.clone();\n\
    \    l8.sort_unstable();\n    let mut l9 = l8.clone();\n    l9.sort_unstable();\n\
    \    let mut l10 = l9.clone();\n    l10.sort_unstable();\n    let mut l11 = l10.clone();\n\
    \    l11.sort_unstable();\n    let mut l12 = l11.clone();\n    l12.sort_unstable();\n\
    \    let mut l13 = l12.clone();\n    l13.sort_unstable();\n    let mut l14 = l13.clone();\n\
    \    l14.sort_unstable();\n    let mut l15 = l14.clone();\n    l15.sort_unstable();\n\
    \    let mut l16 = l15.clone();\n    l16.sort_unstable();\n    let mut l17 = l16.clone();\n\
    \    l17.sort_unstable();\n    let mut l18 = l17.clone();\n    l18.sort_unstable();\n\
    \    let mut l19 = l18.clone();\n    l19.sort_unstable();\n    let mut l20 = l19.clone();\n\
    \    l20.sort_unstable();\n    let mut l21 = l20.clone();\n    l21.sort_unstable();\n\
    \    let mut l22 = l21.clone();\n    l22.sort_unstable();\n    let mut l23 = l22.clone();\n\
    \    l23.sort_unstable();\n    let mut l24 = l23.clone();\n    l24.sort_unstable();\n\
    \    let mut l25 = l24.clone();\n    l25.sort_unstable();\n    let mut l26 = l25.clone();\n\
    \    l26.sort_unstable();\n    let mut l27 = l26.clone();\n    l27.sort_unstable();\n\
    \    let mut l28 = l27.clone();\n    l28.sort_unstable();\n    let mut l29 = l28.clone();\n\
    \    l29.sort_unstable();\n    let mut l30 = l29.clone();\n    l30.sort_unstable();\n\
    \    let mut l31 = l30.clone();\n    l31.sort_unstable();\n    let mut l32 = l31.clone();\n\
    \    l32.sort_unstable\n}\n\nfn main() {\n    let candidate = sort_third;\n  \
    \  assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `sort_unstable` on type\
    \ `Vec<isize>`\n  --> /tmp/tmp6u4xrpsi.rs:70:9\n   |\n70 |     l32.sort_unstable\n\
    \   |         ^^^^^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to\
    \ call the method\n   |\n70 |     l32.sort_unstable()\n   |                  \
    \    ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqu0y9zg.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |             -----   ^ expected `isize`, found\
    \ `&mut isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n14 | \
    \            l3[i] = *v;\n   |                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| x % 3);\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp89dlnz41.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46k4a_qt.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |             -----   ^ expected `isize`, found\
    \ `&mut isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n14 | \
    \            l3[i] = *v;\n   |                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6r5495rt.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8x76nggy.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdg5wy3sk.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdg5wy3sk.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2z_fw3qp.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpovite9es.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfbikxqh4.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpt8vkjjzo.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps693_40z.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw7hefexr.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2.dedup();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfcqmhoud.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l2.clone();\n    l3.sort();\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l2[i] = l3[i];\n        }\n    }\n \
    \   l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 6, 3, 5, 8, 9, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9iepkny4.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = v;\n        }\n    });\n \
    \   l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmynneb8m.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpmynneb8m.rs:14:13\n\
    \   |\n14 |             *i = v;\n   |             ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = i;\n        }\n    });\n   \
    \ l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnd1dqfqf.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoko4zu39.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpoko4zu39.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    l2.dedup();\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp_fc388ea.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_8pupvw8.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpvumaqvfx.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpyy711m39.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpobcgydpq.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphjdz_06n.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpb80wut08.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4myh1s4e.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeh8dt8vk.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpf_cim61u.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpq91xve19.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3lw1vty6.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg48a3ydc.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdvkl_2l_.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7q13pf9o.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6qks6v7w.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |             -----   ^ expected `isize`, found\
    \ `&mut isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n14 | \
    \            l3[i] = *v;\n   |                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  x.to_owned()\n        } else {\n            x.to_owned() + 3\n        }\n \
    \   });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpi6u5kp6m.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbf_vvubx.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi31yxa3a.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp__lhh85t.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp82x9bxdr.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpy_27fxb3.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpvr6hhga1.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpu48wzeeg.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -----------^^^^^^^^-----\n   |            \
    \ |  |       |\n   |             |  |       immutable borrow occurs here\n   |\
    \             |  mutable borrow later used by call\n   |             mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpu48wzeeg.rs:13:24\n   |\n13 |             l2.swap(i, l2.len() - 1);\n\
    \   |                        ^^^^^^^^\nhelp: ...and then using that local as the\
    \ argument to this call\n  --> /tmp/tmpu48wzeeg.rs:13:13\n   |\n13 |         \
    \    l2.swap(i, l2.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    let mut l3 = l2.clone();\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l3[i] = l2[i];\n        }\n    }\n \
    \   l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpu52u2o5u.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcg094d0n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpm_j30a88.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| *i %= 3);\n    l3.sort();\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpevlib6ev.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| *i %= 3);\n   |        \
    \                                     ^^- expected due to this\n   |         \
    \                                    |\n   |                                 \
    \            types differ in mutability\n   |                                \
    \             help: you can probably remove the explicit borrow: `v`\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpevlib6ev.rs:12:50\n\
    \   |\n12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| *i %= 3);\n   | \
    \                                                 ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgvg6x7o0.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    l2\n}\n\nfn main() {\n    let candidate =\
    \ sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6,\
    \ 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp09_tv1kl.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i /= 3;\n        }\n    });\n    l3\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplvw9o5rh.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpg9sul7wu.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp45rltlmi.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp45rltlmi.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpdd2xskm8.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  x.to_owned()\n        } else {\n            x.to_owned() + 3\n        }\n \
    \   });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7qyoei8v.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_unstable();\n    l2\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmptwrddfxo.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort();\n    let mut l3 = l2.clone();\n    for i in 0..l2.len()\
    \ {\n        if i % 3 == 0 {\n            l3[i] = l2[i];\n        }\n    }\n \
    \   l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp55v_sdq6.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = i;\n        }\n    });\n   \
    \ l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_u07q65.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcgotpc15.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7dzrevmm.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = i;\n        }\n    });\n   \
    \ l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6aabh_e6.rs:12:29\n   |\n\
    12 |     l3.iter_mut().for_each(|&i| {\n   |                             ^--\n\
    \   |                             ||\n   |                             |expected\
    \ due to this\n   |                             types differ in mutability\n \
    \  |                             help: did you mean `i`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgs_nmb33.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = v;\n        }\n    });\n \
    \   l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6f8qrqgs.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp6f8qrqgs.rs:14:13\n\
    \   |\n14 |             *i = v;\n   |             ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp2eu4t1uh.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort_by_key(|&x|\
    \ x % 3);\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9, 4, 2, 5, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3lw7ia4u.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpxw0iodhz.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1y3bi6t3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    let mut l3 = l2.clone();\n    l3.iter_mut().skip(1).for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            *i /= 3;\n        }\n    });\n    l3\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3wkuzsj.rs:12:37\n   |\n\
    12 |     l3.iter_mut().skip(1).for_each(|&i| {\n   |                         \
    \            ^--\n   |                                     ||\n   |          \
    \                           |expected due to this\n   |                      \
    \               types differ in mutability\n   |                             \
    \        help: did you mean `i`: `&&mut isize`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    l2.dedup();\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpy_yboe44.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpa89fdgm4.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi8npu6r9.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6_1vno4s.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort_by_key(|&x|\
    \ x % 3);\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9, 4, 2, 5, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpelcxqpkf.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4xb4qcui.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp85v86_wq.rs:14:21\n   |\n\
    14 |             l3[i] = v;\n   |             -----   ^ expected `isize`, found\
    \ `&mut isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n14 | \
    \            l3[i] = *v;\n   |                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    l2.dedup();\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp1q6drapy.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4ifs_wq3.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsmqy7ye8.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmperrbpiwj.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2nlv2khi.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2.dedup();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpnaf6gxai.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl9haf6om.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7gth4u2e.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7gth4u2e.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw62jfaq1.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| l3[i] = l[i]);\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]),\
    \ vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9,\
    \ 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4,\
    \ 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmp1xk03e4x.rs:12:33\n\
    \   |\n12 |     l3.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| l3[i] = l[i]);\n\
    \   |                               - ^ - {integer}\n   |                    \
    \           |\n   |                               &mut isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `i`\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| l3[i] = l[i]);\n   |                            \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xk03e4x.rs:12:53\n   |\n\
    12 |     l3.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| l3[i] = l[i]);\n\
    \   |                                                     ^--\n   |          \
    \                                           ||\n   |                         \
    \                            |expected due to this\n   |                     \
    \                                types differ in mutability\n   |            \
    \                                         help: did you mean `i`: `&&mut isize`\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpn_rk20tt.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpk44i5_5b.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfbrtm97h.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpfhyg2p54.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -----------^^^^^^^^-----\n   |            \
    \ |  |       |\n   |             |  |       immutable borrow occurs here\n   |\
    \             |  mutable borrow later used by call\n   |             mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpfhyg2p54.rs:13:24\n   |\n13 |             l2.swap(i, l2.len() - 1);\n\
    \   |                        ^^^^^^^^\nhelp: ...and then using that local as the\
    \ argument to this call\n  --> /tmp/tmpfhyg2p54.rs:13:13\n   |\n13 |         \
    \    l2.swap(i, l2.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx0y133l7.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpraa23paj.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpraa23paj.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            *v = (*v + 1) % 3;\n        }\n\
    \    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 4, 0, 6, 8, 1]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpj1f0uarc.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7gpsv65b.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbybfzvw9.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsxc271eg.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2tlv6no6.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2tlv6no6.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpu5p39a9c.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n        l3[i] = l3[i / 3];\n    });\n    l3\n}\n\
    \nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpyt7zl6df.rs:12:33\n\
    \   |\n12 |     l3.iter_mut().filter(|&i| i % 3 == 0).for_each(|&i| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `i`\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ *i % 3 == 0).for_each(|&i| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyt7zl6df.rs:12:53\n   |\n12 |     l3.iter_mut().filter(|&i|\
    \ i % 3 == 0).for_each(|&i| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `i`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2.dedup();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpqoe18d6w.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp6f2x9il5.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn88py5sp.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            l3[i] = v;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_xsm81j.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| {\n        if x % 3 == 0 {\n         \
    \   x.to_owned()\n        } else {\n            x.to_owned() + 3\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 6, 4, 5, 9, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4wvfasn2.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2.swap(i, l2.len() - 1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `l2` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpmh6kat4k.rs:13:24\n   |\n13 |             l2.swap(i,\
    \ l2.len() - 1);\n   |             -----------^^^^^^^^-----\n   |            \
    \ |  |       |\n   |             |  |       immutable borrow occurs here\n   |\
    \             |  mutable borrow later used by call\n   |             mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpmh6kat4k.rs:13:24\n   |\n13 |             l2.swap(i, l2.len() - 1);\n\
    \   |                        ^^^^^^^^\nhelp: ...and then using that local as the\
    \ argument to this call\n  --> /tmp/tmpmh6kat4k.rs:13:13\n   |\n13 |         \
    \    l2.swap(i, l2.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpotwql_2f.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpf9o789jv.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7376pqru.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp9262wu10.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpjuia00oy.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2.dedup();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpcxhzuxa3.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp7qbyxjzr.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpw3vt4hle.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpxtx4xayy.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort();\n\
    \    let mut l4 = l3.clone();\n    l4.sort();\n    let mut l5 = l4.clone();\n\
    \    l5.sort();\n    let mut l6 = l5.clone();\n    l6.sort();\n    let mut l7\
    \ = l6.clone();\n    l7.sort();\n    let mut l8 = l7.clone();\n    l8.sort();\n\
    \    let mut l9 = l8.clone();\n    l9.sort();\n    let mut l10 = l9.clone();\n\
    \    l10.sort();\n    let mut l11 = l10.clone();\n    l11.sort();\n    let mut\
    \ l12 = l11.clone();\n    l12.sort();\n    let mut l13 = l12.clone();\n    l13.sort();\n\
    \    let mut l14 = l13.clone();\n    l14.sort();\n    let mut l15 = l14.clone();\n\
    \    l15.sort();\n    let mut l16 = l15.clone();\n    l16.sort();\n    let mut\
    \ l17 = l16.clone();\n    l17.sort();\n    let mut l18 = l17.clone();\n    l18.sort();\n\
    \    let mut l19 = l18.clone();\n    l19.sort();\n    let mut l20 = l19.clone();\n\
    \    l20.sort();\n    let mut l21 = l20.clone();\n    l21.sort();\n    let mut\
    \ l22 = l21.clone();\n    l22.sort();\n    let mut l23 = l22.clone();\n    l23.sort();\n\
    \    let mut l24 = l23.clone();\n    l24.sort();\n    let mut l25 = l24.clone();\n\
    \    l25.sort();\n    let mut l26 = l25.clone();\n    l26.sort();\n    let mut\
    \ l27 = l26.clone();\n    l27.sort();\n    let mut l28 = l27.clone();\n    l28.sort();\n\
    \    let mut l29 = l28.clone();\n    l29.sort();\n    let mut l30 = l29.clone();\n\
    \    l30.sort();\n    let mut l31 = l30.clone();\n    l31.sort();\n    let mut\
    \ l32 = l31.clone();\n    l32.sort();\n    let mut l33 = l32.clone();\n    l33.sort();\n\
    \    let mut l34 = l33.clone();\n    l34.sort();\n    let mut l35 = l34.clone();\n\
    \    l35.sort();\n    let mut l36 = l35.clone();\n    l36.sort();\n\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5jtqkdst.rs:8:33\n  |\n8 |\
    \ fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------            \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbh546q1g.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpbh546q1g.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *v = l3[i];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8htf3zbk.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpa8ecb286.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| *i =\n        v.checked_mul(3).ok_or(Error::InvalidInput)?);\n    l3\n\
    }\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmplaez2a20.rs:13:32\n   |\n13 |         v.checked_mul(3).ok_or(Error::InvalidInput)?);\n\
    \   |                                ^^^^^ use of undeclared type `Error`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplaez2a20.rs:12:45\n   |\n12 |  \
    \   l3.iter_mut().enumerate().for_each(|(i, &v)| *i =\n   |                  \
    \                           ^^- expected due to this\n   |                   \
    \                          |\n   |                                           \
    \  types differ in mutability\n   |                                          \
    \   help: you can probably remove the explicit borrow: `v`\n   |\n   = note: expected\
    \ mutable reference `&mut isize`\n                      found reference `&_`\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmplaez2a20.rs:12:50\n\
    \   |\n12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| *i =\n   |      \
    \                                            ^^\n\nerror[E0277]: the `?` operator\
    \ can only be used in a closure that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmplaez2a20.rs:13:52\n   |\n\
    12 |       l3.iter_mut().enumerate().for_each(|(i, &v)| *i =\n   |  ________________________________________-\n\
    13 | |         v.checked_mul(3).ok_or(Error::InvalidInput)?);\n   | |        \
    \                                            ^\n   | |                       \
    \                             |\n   | |____________________________________________________cannot\
    \ use the `?` operator in a closure that returns `()`\n   |                  \
    \                                    this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented\
    \ for `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0433, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpfn2_rbsr.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.to_vec();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpi46tv5zk.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpnso6fa0i.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpv2jq1q_n.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpd446e5iu.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort_by_key(|x| {\n       \
    \ if x % 3 == 0 {\n            0\n        } else {\n            1\n        }\n\
    \    });\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpks27cx_t.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n    while i <\
    \ l2.len() {\n        if i % 3 == 0 {\n            l2[i] = l2[i];\n        } else\
    \ {\n            l2[i] = l2[i].wrapping_add(1);\n        }\n        i += 1;\n\
    \    }\n    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 7, 4, 4, 9, 10, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpsbx6ei4g.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|&x| x % 3);\n    l2\n}\n\nfn main() {\n  \
    \  let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbj7imw6_.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| x % 3);\n    l2\n}\n\nfn main() {\n   \
    \ let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9,\
    \ 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4,\
    \ 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6,\
    \ 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 4, 5, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpgzxo0kx6.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = *i / 3;\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwyir531d.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpwyir531d.rs:14:13\n\
    \   |\n14 |             *i = *i / 3;\n   |             ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpwyir531d.rs:14:18\n   |\n14 |\
    \             *i = *i / 3;\n   |                  ^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut i = 0;\n    while i < l2.len() {\n        if i % 3\
    \ == 0 {\n            l2.swap(i, i + 1);\n        }\n        i += 1;\n    }\n\
    \    l2\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpfd5obgme.rs:13:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmphxclhurh.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp3or_2a86.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp_91cfmvq.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().skip(1).for_each(|&i|\
    \ {\n        if i % 3 == 0 {\n            l3[i] = l3[i / 3];\n        }\n    });\n\
    \    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhc51v0m.rs:12:37\n   |\n\
    12 |     l3.iter_mut().skip(1).for_each(|&i| {\n   |                         \
    \            ^--\n   |                                     ||\n   |          \
    \                           |expected due to this\n   |                      \
    \               types differ in mutability\n   |                             \
    \        help: did you mean `i`: `&&mut isize`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i % 3 == 0 {\n            *v = (*v + 1) as isize;\n      \
    \  }\n    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9,\
    \ 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 4, 6, 6, 8, 10]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp4ozyezqt.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    let mut l3 = l2.clone();\n    l3.iter_mut().enumerate().for_each(|(i,\
    \ &v)| {\n        if i % 3 == 0 {\n            *i = v;\n        }\n    });\n \
    \   l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfslsutq5.rs:12:45\n   |\n\
    12 |     l3.iter_mut().enumerate().for_each(|(i, &v)| {\n   |                \
    \                             ^^- expected due to this\n   |                 \
    \                            |\n   |                                         \
    \    types differ in mutability\n   |                                        \
    \     help: you can probably remove the explicit borrow: `v`\n   |\n   = note:\
    \ expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpfslsutq5.rs:14:13\n\
    \   |\n14 |             *i = v;\n   |             ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_by_key(|x| {\n        if x % 3 == 0 {\n          \
    \  0\n        } else {\n            1\n        }\n    });\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 3, 9, 5, 4, 8, 2]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp999jpoly.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.sort_by_key(|x|\
    \ x % 3);\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 6, 9, 4, 2, 5, 8]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpwrnjfenj.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu1aqc7w7.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu1aqc7w7.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort_unstable();\n    l2\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmpbf8lnhpo.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mut l3 = l2.clone();\n    l3.iter_mut().filter(|&x|\
    \ x % 3 == 0).for_each(|&x| {\n        l3[x] = l3[x].checked_add(1).unwrap();\n\
    \    });\n    l3\n}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpfkp8vcw0.rs:12:33\n\
    \   |\n12 |     l3.iter_mut().filter(|&x| x % 3 == 0).for_each(|&x| {\n   |  \
    \                             - ^ - {integer}\n   |                          \
    \     |\n   |                               &mut isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n12 |     l3.iter_mut().filter(|&x|\
    \ *x % 3 == 0).for_each(|&x| {\n   |                               +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfkp8vcw0.rs:12:53\n   |\n12 |     l3.iter_mut().filter(|&x|\
    \ x % 3 == 0).for_each(|&x| {\n   |                                          \
    \           ^--\n   |                                                     ||\n\
    \   |                                                     |expected due to this\n\
    \   |                                                     types differ in mutability\n\
    \   |                                                     help: did you mean `x`:\
    \ `&&mut isize`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                    found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.clone();\n    let mut l3 = l.clone();\n    let mut l4 = l.clone();\n   \
    \ let mut l5 = l.clone();\n    let mut l6 = l.clone();\n    let mut l7 = l.clone();\n\
    \    let mut l8 = l.clone();\n    let mut l9 = l.clone();\n    let mut l10 = l.clone();\n\
    \    let mut l11 = l.clone();\n    let mut l12 = l.clone();\n    let mut l13 =\
    \ l.clone();\n    let mut l14 = l.clone();\n    let mut l15 = l.clone();\n   \
    \ let mut l16 = l.clone();\n    let mut l17 = l.clone();\n    let mut l18 = l.clone();\n\
    \    let mut l19 = l.clone();\n    let mut l20 = l.clone();\n    let mut l21 =\
    \ l.clone();\n    let mut l22 = l.clone();\n    let mut l23 = l.clone();\n   \
    \ let mut l24 = l.clone();\n    let mut l25 = l.clone();\n    let mut l26 = l.clone();\n\
    \    let mut l27 = l.clone();\n    let mut l28 = l.clone();\n    let mut l29 =\
    \ l.clone();\n    let mut l30 = l.clone();\n    let mut l31 = l.clone();\n   \
    \ let mut l32 = l.clone();\n    let mut l33 = l.clone();\n    let mut l34 = l.clone();\n\
    \    let mut l35 = l.clone();\n    let mut l36 = l.clone();\n    let mut l37 =\
    \ l.clone();\n    let mut l38 = l.clone();\n    let mut l39 = l.clone();\n   \
    \ let mut l40 = l.clone();\n    let mut l41 = l.clone();\n    let mut l42 = l.clone();\n\
    \    let mut l43 = l.clone();\n    let mut l44 = l.clone();\n    let mut l45 =\
    \ l.clone();\n    let mut l46 = l.clone();\n    let mut l47 = l.clone();\n   \
    \ let mut l48 = l.clone();\n    let mut l49 = l.clone();\n    let mut l50 = l.clone();\n\
    \    let mut l51 = l.clone();\n    let mut l52 = l.clone();\n    let mut l53 =\
    \ l.clone();\n    let mut l54 = l.clone();\n    let mut l55 = l.clone();\n   \
    \ let mut l56 = l.clone();\n    let mut l57 = l.clone();\n    let mut l58 = l.clone();\n\
    \    let mut l59 = l.clone();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2,\
    \ 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2,\
    \ 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2,\
    \ 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]),\
    \ vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzkdqmq9j.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzkdqmq9j.rs:8:33\n  |\n\
    8 | fn sort_third(l: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the indicies that are not divisible by three, while\
    \ its values at the indicies that are divisible by three are equal\n/// to the\
    \ values of the corresponding indicies of l, but sorted.\n/// >>> sort_third([1,\
    \ 2, 3])\n/// [1, 2, 3]\n/// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n/// [2, 6,\
    \ 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l2\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l2.sort();\n    l2\n}\n\nfn main()\
    \ {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4,\
    \ 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8,\
    \ 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5, 6, 8, 9]`,\n right: `[2, 6, 3, 4, 8, 9, 5]`', /tmp/tmp8yn0vkwn.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
