name: HumanEval_44_change_base
language: rust
results:
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0i32; base];\n\
    \    let mut carry = 0;\n    for digit in x.to_digits().iter() {\n        if digit\
    \ > base {\n            digits.insert(0, 0);\n            carry = 1;\n       \
    \ } else {\n            digits.insert(0, digit);\n            carry = 0;\n   \
    \     }\n    }\n    while carry != 0 {\n        digits.insert(0, 0);\n       \
    \ carry = digits.iter().filter(|&x| x != 0).count();\n    }\n    for digit in\
    \ digits.iter() {\n        s += char::from_u32(digit as u32).unwrap();\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfyrmrlo2.rs:12:33\n   |\n\
    12 |     let mut digits = vec![0i32; base];\n   |                            \
    \     ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0i32; base.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpfyrmrlo2.rs:14:20\n\
    \   |\n14 |     for digit in x.to_digits().iter() {\n   |                    ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0277]: can't compare `i32` with `isize`\n\
    \  --> /tmp/tmpfyrmrlo2.rs:15:18\n   |\n15 |         if digit > base {\n   | \
    \                 ^ no implementation for `i32 < isize` and `i32 > isize`\n  \
    \ |\n   = help: the trait `PartialOrd<isize>` is not implemented for `i32`\n \
    \  = help: the following other types implement trait `PartialOrd<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&i32` with `{integer}`\n  --> /tmp/tmpfyrmrlo2.rs:25:45\n\
    \   |\n25 |         carry = digits.iter().filter(|&x| x != 0).count();\n   | \
    \                                            ^^ no implementation for `&i32 ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&i32`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfyrmrlo2.rs:28:14\n\
    \   |\n28 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0606]: casting `&i32` as `u32` is invalid\n  --> /tmp/tmpfyrmrlo2.rs:28:29\n\
    \   |\n28 |         s += char::from_u32(digit as "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x / base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    s += digits.into_owned();\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04quhxh8.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp04quhxh8.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmp04quhxh8.rs:20:17\n\
    \   |\n20 |     s += digits.into_owned();\n   |                 ^^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder = x % base;\n        x /= base;\n        s.push((remainder\
    \ + '0') as char);\n    }\n    s.push((x as char + '0') as char);\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `char` to `isize`\n  --> /tmp/tmpnlrn5jmn.rs:16:27\n\
    \   |\n16 |         s.push((remainder + '0') as char);\n   |                 \
    \          ^ no implementation for `isize + char`\n   |\n   = help: the trait\
    \ `Add<char>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n          \
    \   <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n            \
    \ <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a\
    \ i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize\
    \ as Add<isize>>\n           and 48 others\n\nerror[E0369]: cannot add `char`\
    \ to `char`\n  --> /tmp/tmpnlrn5jmn.rs:18:23\n   |\n18 |     s.push((x as char\
    \ + '0') as char);\n   |             --------- ^ --- char\n   |             |\n\
    \   |             char\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n\
    \  --> /tmp/tmpnlrn5jmn.rs:18:13\n   |\n18 |     s.push((x as char + '0') as char);\n\
    \   |             ^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpnlrn5jmn.rs:18:13\n   |\n18 |     s.push((x as\
    \ char + '0') as char);\n   |             ^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0369, E0604.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x as i32;\n    let mut base\
    \ = base as i32;\n    while x >= base {\n        s +=\n            format!(\"\
    {:0{}b}\", x % base, base).to_string()\n                .replace_all(\" \", \"\
    0\");\n        x /= base;\n    }\n    s += format!(\"{:0{}b}\", x, base).to_string()\n\
    \        .replace_all(\" \", \"0\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmppmhjcevv.rs:16:25\n\
    \   |\n16 |             format!(\"{:0{}b}\", x % base, base).to_string()\n   |\
    \                      -  ^ expected `}` in format string\n   |              \
    \        |\n   |                      because of this opening brace\n   |\n  \
    \ = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmppmhjcevv.rs:20:22\n\
    \   |\n20 |     s += format!(\"{:0{}b}\", x, base).to_string()\n   |         \
    \          -  ^ expected `}` in format string\n   |                   |\n   |\
    \                   because of this opening brace\n   |\n   = note: if you intended\
    \ to print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i];\n \
    \       if base == 10 {\n            digit = digit.to_string().chars().collect::<Vec<_>>()[0];\n\
    \        }\n        if digit < '0' || digit > '9' {\n            break;\n    \
    \    }\n        let mut new_digit = digit.to_string().chars().collect::<Vec<_>>()[0];\n\
    \        let mut j = i;\n        while j > 0 && digits[j - 1] < '0' {\n      \
    \      new_digit += '0';\n            j -= 1;\n        }\n        new_digit +=\
    \ &base[i - j];\n        result.push(new_digit);\n        i += 1;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpxuwbru27.rs:17:17\n\
    \   |\n17 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpxuwbru27.rs:26:13\n\
    \   |\n26 |             new_digit += '0';\n   |             ---------^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpxuwbru27.rs:29:9\n\
    \   |\n29 |         new_digit += &base[i - j];\n   |         ---------^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let mut digit = quotient % base;\n \
    \       remainder = quotient / base;\n        if digit < 10 {\n            s.push_str(&format!(\"\
    {}\", digit));\n        } else {\n            s.push_str(&format!(\"{}\", digit\
    \ - 10));\n        }\n        quotient = remainder;\n    }\n    s + &format!(\"\
    {}\", remainder)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"220\"`,\n right: `\"22\"`', /tmp/tmpxrd77wrb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        remainder *= base;\n        remainder\
    \ %= base;\n        quotient /= base;\n        s.push((remainder % base) as char);\n\
    \    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpk1nxte2_.rs:18:16\n\
    \   |\n18 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpk1nxte2_.rs:18:16\n   |\n18 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 0;\n    while i < digits.len() {\n        let mut\
    \ digit = digits[i];\n        if digit == '0' {\n            digit = &mut base[base[digit].len()..digit.len()];\n\
    \            digits.remove(&i);\n            i += 1;\n        }\n        let mut\
    \ digit = digit.to_digit(base);\n        if digit == 0 {\n            digit =\
    \ &mut carry;\n            digits.remove(&i);\n            i += 1;\n        }\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n        digit = digit.into();\n        digit =\
    \ digit.into();\n        digit = digit.into();\n        digit = digit.into();\n\
    \        digit = digit.into();\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppnwsq9b6.rs:91:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n16 |     while\
    \ i < digits.len() {\n   |                            - this delimiter might not\
    \ be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n91 | }\n   |   ^\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmppnwsq9b6.rs:19:31\n   |\n19 |   \
    \          digit = &mut base[base[digit].len()..digit.len()];\n   |          \
    \                     ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmppnwsq9b6.rs:19:56\n   |\n19 |          \
    \   digit = &mut base[base[digit].len()..digit.len()];\n   |                 \
    \                                       ^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppnwsq9b6.rs:19:21\n   |\n17 |         let mut\
    \ digit = digits[i];\n   |                         --------- expected due to this\
    \ value\n18 |         if digit == '0' {\n19 |             digit = &mut base[base[digit].len()..digit.len()];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&mut [char]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnwsq9b6.rs:20:27\n\
    \   |\n20 |             digits.remove(&i);\n   |                           ^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n20 -             digits.remove(&i);\n20 +             digits.remove(i);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnwsq9b6.rs:23:40\n  \
    \ |\n23 |         let mut digit = digit.to_digit(base);\n   |                \
    \                        ^^^^ expected `u32`, found struct `Vec`\n   |\n   = note:\
    \ expected type `u3"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        let mut digit = remainder % base;\n\
    \        remainder = remainder / base;\n        s = format!(\"{}{}\", s, digit);\n\
    \    }\n    if base > 10 {\n        s = format!(\"{}\", s);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmph30nqivt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut base_len = base.len();\n    while digits_len > base_len {\n     \
    \   digits = digits.chars().nth(digits_len).unwrap().to_string();\n        base\
    \ = base.chars().nth(base_len).unwrap().to_string();\n        digits_len -= 1;\n\
    \        base_len -= 1;\n    }\n    while base_len > digits_len {\n        base\
    \ = base.chars().nth(base_len).unwrap().to_string();\n        base_len -= 1;\n\
    \    }\n    while digits_len > 0 {\n        if digits_len < base_len {\n     \
    \       s.push_str(&base[digits_len..]);\n            digits_len -= 1;\n     \
    \   } else {\n            s.push_str(&digits[digits_len..]);\n            digits_len\
    \ -= 1;\n            base = base.chars().nth(base_len).unwrap().to_string();\n\
    \            base_len -= 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgk1t1rzo.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut basedigits = digits.chars().map(|c| match c {\n        '0' => 0,\n \
    \       '1' => 1,\n        '2' => 2,\n        '3' => 3,\n        '4' => 4,\n \
    \       '5' => 5,\n        '6' => 6,\n        '7' => 7,\n        '8' => 8,\n \
    \       '9' => 9,\n        _ => panic!(\"Invalid base!\"),\n    }).collect::<Vec<_>>();\n\
    \    basedigits[base] = 1;\n    while basedigits.len() > 0 {\n        let mut\
    \ i = 0;\n        for &d in basedigits {\n            i += d;\n        }\n   \
    \     s = format!(\"{}{}\", s, i);\n        basedigits = basedigits.iter().filter(|&d|\
    \ d != 0).collect::<Vec<_>>();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp83ldy77a.rs:26:5\n   |\n26 |     basedigits[base] = 1;\n   |     ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83ldy77a.rs:29:13\n   |\n29 |         for &d\
    \ in basedigits {\n   |             ^^    ---------- this expression has type\
    \ `Option<{integer}>`\n   |             |\n   |             expected integer,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `d`\n   |\n   = note:   expected type `{integer}`\n           found\
    \ reference `&_`\n\nerror[E0277]: can't compare `&{integer}` with `{integer}`\n\
    \  --> /tmp/tmp83ldy77a.rs:33:54\n   |\n33 |         basedigits = basedigits.iter().filter(|&d|\
    \ d != 0).collect::<Vec<_>>();\n   |                                         \
    \             ^^ no implementation for `&{integer} == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&{integer}`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp83ldy77a.rs:33:22\n   |\n13 |\
    \       let mut basedigits = digits.chars().map(|c| match c {\n   |  __________________________-\n\
    14 | |         '0' => 0,\n15 | |         '1' => 1,\n16 | |         '2' => 2,\n\
    ...  |\n24 | |         _ => panic!(\"Invalid base!\"),\n25 | |     }).collect::<Vec<_>>();\n\
    \   | |__________________________- expected due to this value\n...\n33 |     \
    \      basedigits = basedigits.iter().filter(|&d| d != 0).collect::<Vec<_>>();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = 0;\n    while\
    \ x >= base {\n        remainder = x % base;\n        result += '0' + remainder;\n\
    \        x /= base;\n    }\n    result += '0' + x;\n    result\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `char`\n  --> /tmp/tmpl0k9d082.rs:15:23\n\
    \   |\n15 |         result += '0' + remainder;\n   |                   --- ^ ---------\
    \ isize\n   |                   |\n   |                   char\n\nerror[E0369]:\
    \ cannot add `isize` to `char`\n  --> /tmp/tmpl0k9d082.rs:18:19\n   |\n18 |  \
    \   result += '0' + x;\n   |               --- ^ - isize\n   |               |\n\
    \   |               char\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digits, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpce1tfpro.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push_str(&format!(\"{}\", remainder));\n        x = x / base;\n\
    \    }\n    digits.push_str(&format!(\"{}\", x));\n    s += &digits;\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpx3q8ajqu.rs:13:13\n\
    \   |\n13 |     let mut remainder = 0;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `x`\n\
    \  --> /tmp/tmpx3q8ajqu.rs:17:9\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n17 |         x = x / base;\n   |         ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 0;\n    while i < digits.len() {\n        let mut\
    \ digit = digits[i];\n        if digit == '0' {\n            digit = base.len()\
    \ - i;\n        }\n        let mut new_digit = digit;\n        if carry > 0 {\n\
    \            new_digit += 1;\n        }\n        carry = new_digit as isize;\n\
    \        s[i] = new_digit as char;\n        i += 1;\n    }\n    if carry > 0 {\n\
    \        s.push('1');\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpocbpfckt.rs:19:21\n   |\n\
    17 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n18 |         if digit == '0' {\n19 |           \
    \  digit = base.len() - i;\n   |                     ^^^^^^^^^^^^^^ expected `char`,\
    \ found `usize`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpocbpfckt.rs:23:13\n   |\n23 |             new_digit\
    \ += 1;\n   |             ---------^^^^^\n   |             |\n   |           \
    \  cannot use `+=` on type `char`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpocbpfckt.rs:26:9\n   |\n26 |         s[i]\
    \ = new_digit as char;\n   |         ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] > base {\n      \
    \      s.push_str(&digits[i .. (i + 1)]);\n            i += 1;\n        } else\
    \ {\n            s.push_str(&base[digits[i] - base]);\n            i += 1;\n \
    \       }\n    }\n    s.push_str(&digits[digits.len() - i ..]);\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz1iqjrw5.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz1iqjrw5.rs:17:24\n\
    \   |\n17 |             s.push_str(&digits[i .. (i + 1)]);\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found slice `[char]`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&[char]`\n\
    \nerror[E0369]: cannot subtract `Vec<char>` from `char`\n  --> /tmp/tmpz1iqjrw5.rs:20:40\n\
    \   |\n20 |             s.push_str(&base[digits[i] - base]);\n   |           \
    \                   --------- ^ ---- Vec<char>\n   |                         \
    \     |\n   |                              char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz1iqjrw5.rs:24:16\n   |\n24 |     s.push_str(&digits[digits.len()\
    \ - i ..]);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found slice `[char]`\n   |\n   = note: expected reference `&str`\n         \
    \     found reference `&[char]`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    let mut digits\
    \ = vec![0isize; base];\n    let mut digit = 0;\n    while x >= base {\n     \
    \   remainder = x % base;\n        digits[digit] = remainder;\n        x /= base;\n\
    \        digit += 1;\n    }\n    digits[digit] = x;\n    for digit in digits.iter_mut()\
    \ {\n        *digit = *digit + 1;\n    }\n    for digit in digits.iter() {\n \
    \       *digit = *digit + 1;\n    }\n    for digit in digits.iter_mut() {\n  \
    \      *digit = *digit + 1;\n    }\n    for digit in digits.iter() {\n       \
    \ *digit = *digit + 1;\n    }\n    for digit in digits.iter_mut() {\n        *digit\
    \ = *digit + 1;\n    }\n    for digit in digits.iter() {\n        *digit = *digit\
    \ + 1;\n    }\n    for digit in digits.iter_mut() {\n        *digit = *digit +\
    \ 1;\n    }\n    for digit in digits.iter() {\n        *digit = *digit + 1;\n\
    \    }\n    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n \
    \   }\n    for digit in digits.iter() {\n        *digit = *digit + 1;\n    }\n\
    \    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n    }\n \
    \   for digit in digits.iter() {\n        *digit = *digit + 1;\n    }\n    for\
    \ digit in digits.iter_mut() {\n        *digit = *digit + 1;\n    }\n    for digit\
    \ in digits.iter() {\n        *digit = *digit + 1;\n    }\n    for digit in digits.iter_mut()\
    \ {\n        *digit = *digit + 1;\n    }\n    for digit in digits.iter() {\n \
    \       *digit = *digit + 1;\n    }\n    for digit in digits.iter_mut() {\n  \
    \      *digit = *digit + 1;\n    }\n    for digit in digits.iter() {\n       \
    \ *digit = *digit + 1;\n    }\n    for digit in digits.iter_mut() {\n        *digit\
    \ = *digit + 1;\n    }\n    for digit in digits.iter() {\n        *digit = *digit\
    \ + 1;\n    }\n    for digit in digits.iter_mut() {\n        *digit = *digit +\
    \ 1;\n    }\n    for digit in digits.iter() {\n        *digit = *digit + 1;\n\
    \    }\n    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n \
    \   }\n    for digit in digits.iter() {\n        *digit = *digit + 1;\n    }\n\
    \    for digit \n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpyhiswkb7.rs:94:14\n  \
    \ |\n94 |       for digit \n   |  ______________^\n95 | | }\n   | |_ help: try\
    \ adding `in` here\n\nerror: expected expression, found `}`\n  --> /tmp/tmpyhiswkb7.rs:95:1\n\
    \   |\n95 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyhiswkb7.rs:13:35\n   |\n13 |     let mut digits = vec![0isize;\
    \ base];\n   |                                   ^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |     let mut digits = vec![0isize; base.try_into().unwrap()];\n\
    \   |                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        let mut digit = remainder % base;\n\
    \        remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    while digits.len() > 0 {\n        let mut digit = digits.remove(0).unwrap();\n\
    \        let mut new_digit = base.iter().position(|&b| digit == b).unwrap();\n\
    \        if new_digit == base.len() {\n            new_digit = 0;\n          \
    \  carry = 0;\n        }\n        digit += carry;\n        carry = digit / base.len();\n\
    \        digit %= base.len();\n        base.insert(new_digit, digit);\n    }\n\
    \    if carry > 0 {\n        base.insert(0, carry);\n    }\n    base.into_iter().map(|&b|\
    \ b.to_string()).collect()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprdowghmc.rs:16:42\n   |\n16 |         let mut digit = digits.remove(0).unwrap();\n\
    \   |                                          ^^^^^^ method not found in `char`\n\
    \nerror[E0277]: cannot add-assign `{integer}` to `char`\n  --> /tmp/tmprdowghmc.rs:22:15\n\
    \   |\n22 |         digit += carry;\n   |               ^^ no implementation for\
    \ `char += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not\
    \ implemented for `char`\n\nerror[E0277]: cannot divide `char` by `usize`\n  -->\
    \ /tmp/tmprdowghmc.rs:23:23\n   |\n23 |         carry = digit / base.len();\n\
    \   |                       ^ no implementation for `char / usize`\n   |\n   =\
    \ help: the trait `Div<usize>` is not implemented for `char`\n\nerror[E0277]:\
    \ cannot mod-assign `char` by `usize``\n  --> /tmp/tmprdowghmc.rs:24:15\n   |\n\
    24 |         digit %= base.len();\n   |               ^^ no implementation for\
    \ `char %= usize`\n   |\n   = help: the trait `RemAssign<usize>` is not implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprdowghmc.rs:28:24\n\
    \   |\n28 |         base.insert(0, carry);\n   |                        ^^^^^\
    \ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprdowghmc.rs:30:27\n\
    \   |\n30 |     base.into_iter().map(|&b| b.to_string()).collect()\n   |     \
    \                      ^--\n   |                           ||\n   |          \
    \                 |expected due to this\n   |                           expected\
    \ `char`, found reference\n   |                           help: did you mean `b`:\
    \ `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder += x / base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x % base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    s += &digits[..digits.len() - 1];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfnndo2z.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsfnndo2z.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base] = x % base;\n\
    \        x /= base;\n        carry = (digits[base] + carry) as u8;\n    }\n  \
    \  if carry > 0 {\n        digits[base] = carry;\n    }\n    for &d in &digits[..]\
    \ {\n        s += char::from_u32(d as u32).unwrap();\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnnu8zqgq.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpnnu8zqgq.rs:15:9\n   |\n15 |         digits[base]\
    \ = x % base;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpnnu8zqgq.rs:17:18\n   |\n17 |         carry = (digits[base] + carry)\
    \ as u8;\n   |                  ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpnnu8zqgq.rs:20:9\n   |\n20 |         digits[base] = carry;\n  \
    \ |         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnnu8zqgq.rs:23:14\n   |\n23 |\
    \         s += char::from_u32(d as u32).unwrap();\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1).unwrap();\n        let digit =\
    \ match digit {\n            '0' => 0,\n            '1' => 1,\n            '2'\
    \ => 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n\
    \            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n       \
    \     '9' => 9,\n            _ => panic!(\"Invalid base\"),\n        };\n    \
    \    let digit = digit * base;\n        s = format!(\"{}{}\", s, digit);\n   \
    \     digits = digits.chars().nth(digits.len() - 1).unwrap();\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `{integer}` by `String`\n  --> /tmp/tmp3y3w7nv_.rs:29:27\n\
    \   |\n29 |         let digit = digit * base;\n   |                          \
    \ ^ no implementation for `{integer} * String`\n   |\n   = help: the trait `Mul<String>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3y3w7nv_.rs:31:18\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n31 |         digits = digits.chars().nth(digits.len()\
    \ - 1).unwrap();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut i = 0;\n    while i < digits.size()\
    \ {\n        if base == 10 {\n            s.push_str(&digits[..i]);\n        \
    \    break;\n        }\n        let mut digit = digits[..i].parse::<usize>().unwrap();\n\
    \        if digit < base {\n            s.push_str(&digits[..i]);\n          \
    \  break;\n        }\n        digit /= base;\n        i += digit;\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfjuon48y.rs:15:22\n   |\n15 |     while i < digits.size()\
    \ {\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmpfjuon48y.rs:16:17\n \
    \  |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjuon48y.rs:21:20\n\
    \   |\n21 |         if digit < base {\n   |                    ^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0277]: cannot divide-assign `usize` by `String`\n\
    \  --> /tmp/tmpfjuon48y.rs:25:15\n   |\n25 |         digit /= base;\n   |    \
    \           ^^ no implementation for `usize /= String`\n   |\n   = help: the trait\
    \ `DivAssign<String>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n    \
    \         <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n      \
    \       <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n         \
    \    <i16 as DivAssign>\n           and 20 others\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits[base] = remainder;\n        x /= base;\n    }\n    digits[base]\
    \ = x;\n    for digit in digits {\n        s += char::from_u32(digit).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwx0tsr9.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpwwx0tsr9.rs:16:9\n   |\n16 |         digits[base]\
    \ = remainder;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwwx0tsr9.rs:19:5\n   |\n19 |     digits[base] = x;\n   |     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwwx0tsr9.rs:21:29\n   |\n21 |         s += char::from_u32(digit).unwrap();\n\
    \   |                             ^^^^^ expected `u32`, found `u8`\n   |\nhelp:\
    \ you can convert a `u8` to a `u32`\n   |\n21 |         s += char::from_u32(digit.into()).unwrap();\n\
    \   |                                  +++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwwx0tsr9.rs:21:14\n   |\n21 |         s += char::from_u32(digit).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] >= base[0] {\n  \
    \          s.push_str(&base[digits[i] - base[0]]);\n            i += 1;\n    \
    \    } else {\n            s.push_str(&digits[i]);\n            i += 1;\n    \
    \    }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpbykikqp_.rs:17:40\n\
    \   |\n17 |             s.push_str(&base[digits[i] - base[0]]);\n   |        \
    \                      --------- ^ ------- char\n   |                        \
    \      |\n   |                              char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbykikqp_.rs:20:24\n   |\n20 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += x;\n\
    \        carry = digits[base - 1];\n        digits[base - 1] -= x;\n        x\
    \ /= base;\n    }\n    if carry > 0 {\n        digits[base - 1] += carry;\n  \
    \  }\n    for &d in &digits[..] {\n        s += char::from_u32(d as u32).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfwh4dxea.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfwh4dxea.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += x;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfwh4dxea.rs:16:17\n   |\n16 |         carry = digits[base - 1];\n\
    \   |                 ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfwh4dxea.rs:17:9\n   |\n17 |         digits[base - 1] -= x;\n \
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpfwh4dxea.rs:21:9\n\
    \   |\n21 |         digits[base - 1] += carry;\n   |         ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not i"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = base;\n    while remainder > 0 {\n        remainder %= base;\n        digits\
    \ = base - digits;\n    }\n    while digits > 0 {\n        s.push((digits % base)\
    \ as char);\n        digits /= base;\n    }\n    s + &x[..]\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmprttqs2av.rs:22:10\n\
    \   |\n22 |     s + &x[..]\n   |          ^^^^^\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmprttqs2av.rs:19:16\n   |\n19 |\
    \         s.push((digits % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmprttqs2av.rs:19:16\n   |\n19 |         s.push((digits % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0604, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    while digits.len() > 0 {\n        let\
    \ mut digit = digits.chars().nth(digits.len() - 1);\n        if base == 10 {\n\
    \            digit = digit.chars().nth(digit.len() - 1);\n        }\n        if\
    \ digit == '0' {\n            digit = digit.chars().nth(digit.len() - 1);\n  \
    \      }\n        if digit == '1' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '2' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '3' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '4' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '5' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '6' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '7' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '8' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == '9' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'A' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'B' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'C' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'D' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'E' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'F' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'G' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'H' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n        }\n        if digit == 'I' {\n            digit = digit.\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl9c58aqo.rs:91:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ digits.len() > 0 {\n   |                            - unclosed delimiter\n...\n\
    73 |         if digit == 'I' {\n   |                         - this delimiter\
    \ might not be properly closed...\n74 |             digit = digit.\n75 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n91 | }\n \
    \  |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpl9c58aqo.rs:75:1\n   |\n\
    75 | }\n   | ^\n\nerror[E0277]: can't compare `String` with `{integer}`\n  -->\
    \ /tmp/tmpl9c58aqo.rs:16:17\n   |\n16 |         if base == 10 {\n   |        \
    \         ^^ no implementation for `String == {integer}`\n   |\n   = help: the\
    \ trait `PartialEq<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `chars` found for enum `Option` in the current scope\n  --> /tmp/tmpl9c58aqo.rs:17:27\n\
    \   |\n17 |             digit = digit.chars().nth(digit.len() - 1);\n   |    \
    \                       ^^^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpl9c58aqo.rs:17:45\n\
    \   |\n17 |             digit = digit.chars().nth(digit.len() - 1);\n   |    \
    \                                         ^^^ method not found in `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl9c58aqo.rs:19:21\n   |\n19 |\
    \         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expecte"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += 1;\n\
    \        x -= base;\n    }\n    while x >= 10 {\n        digits[base - 1] += 1;\n\
    \        x -= 10;\n    }\n    while x > 0 {\n        digits[base - 1] += 1;\n\
    \        x -= 1;\n    }\n    for &d in digits {\n        if carry > 0 {\n    \
    \        s += &format!(\"{}{}\", d, carry);\n        } else {\n            s +=\
    \ &format!(\"{}\", d);\n        }\n        carry = 0;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ry6b4ip.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp5ry6b4ip.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp5ry6b4ip.rs:19:9\n   |\n19 |         digits[base - 1] += 1;\n \
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmp5ry6b4ip.rs:23:9\n\
    \   |\n23 |         digits[base - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<u8>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5ry6b4ip.rs:26:9\n   |\n26 |     for &d in digits {\n   |     \
    \    ^^    ------ this expression has type `Option<u8>`\n   |         |\n   |\
    \         expected `u8`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `d`"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits {\n        s.push(digit);\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjcciqvrx.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpjcciqvrx.rs:19:18\n   |\n19 |     for digit in digits {\n   | \
    \                 ^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut basedigits = base.to_string().chars().collect::<Vec<_>>();\n    let\
    \ mut carry = 0;\n    while basedigits.len() > 0 {\n        let mut nextdigit\
    \ = basedigits.pop().unwrap();\n        if carry > 0 {\n            nextdigit\
    \ += 1;\n        }\n        carry = nextdigit as isize;\n        if nextdigit\
    \ > 9 {\n            nextdigit -= 10;\n        }\n        s += digits[digits.len()\
    \ - 1] + &nextdigit.to_string();\n    }\n    if carry > 0 {\n        s += &carry;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpm35k_cd_.rs:18:13\n   |\n18 |             nextdigit +=\
    \ 1;\n   |             ---------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm35k_cd_.rs:21:24\n\
    \   |\n21 |         if nextdigit > 9 {\n   |                        ^ expected\
    \ `char`, found `u8`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpm35k_cd_.rs:22:13\n   |\n22 |     \
    \        nextdigit -= 10;\n   |             ---------^^^^^^\n   |            \
    \ |\n   |             cannot use `-=` on type `char`\n\nerror[E0369]: cannot add\
    \ `&String` to `char`\n  --> /tmp/tmpm35k_cd_.rs:24:39\n   |\n24 |         s +=\
    \ digits[digits.len() - 1] + &nextdigit.to_string();\n   |              ------------------------\
    \ ^ ---------------------- &String\n   |              |\n   |              char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm35k_cd_.rs:27:14\n   |\n27 |\
    \         s += &carry;\n   |              ^^^^^^ expected `str`, found `isize`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        remainder /= base;\n        quotient\
    \ /= base;\n        s.push((remainder % base) as char);\n    }\n    s.push((quotient\
    \ % base) as char);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpc5hr2yvv.rs:17:16\n\
    \   |\n17 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpc5hr2yvv.rs:17:16\n   |\n17 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmpc5hr2yvv.rs:19:12\n   |\n19 |\
    \     s.push((quotient % base) as char);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpc5hr2yvv.rs:19:12\n   |\n19 |     s.push((quotient % base) as char);\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut i = 0;\n    while i < digits.len()\
    \ {\n        if base == 10 {\n            s.push_str(&digits[i..]);\n        \
    \    break;\n        }\n        let mut digit = digits[i..].chars().nth(base).unwrap();\n\
    \        if digit == '0' {\n            s.push_str(&digits[0..i]);\n         \
    \   i += 1;\n        } else {\n            s.push_str(&digit);\n        }\n  \
    \      i += 1;\n        base /= 10;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmp0nw7qedr.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0nw7qedr.rs:20:49\n\
    \   |\n20 |         let mut digit = digits[i..].chars().nth(base).unwrap();\n\
    \   |                                                 ^^^^ expected `usize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0nw7qedr.rs:25:24\n\
    \   |\n25 |             s.push_str(&digit);\n   |                        ^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `String`\n  --> /tmp/tmp0nw7qedr.rs:28:9\n  \
    \ |\n28 |         base /= 10;\n   |         ----^^^^^^\n   |         |\n   | \
    \        cannot use `/=` on type `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x >=\
    \ base {\n        s += &format!(\"{:0{}b}\", x % base, base);\n        x /= base;\n\
    \    }\n    s += &format!(\"{:0{}b}\", x, base);\n    s\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpcwpve9ek.rs:14:27\n\
    \   |\n14 |         s += &format!(\"{:0{}b}\", x % base, base);\n   |        \
    \                -  ^ expected `}` in format string\n   |                    \
    \    |\n   |                        because of this opening brace\n   |\n   =\
    \ note: if you intended to print `{`, you can escape it using `{{`\n\nerror: invalid\
    \ format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpcwpve9ek.rs:17:23\n\
    \   |\n17 |     s += &format!(\"{:0{}b}\", x, base);\n   |                   \
    \ -  ^ expected `}` in format string\n   |                    |\n   |        \
    \            because of this opening brace\n   |\n   = note: if you intended to\
    \ print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut power = 1;\n    while digits.len() > 0 {\n        if digits.len() >\
    \ base {\n            digits = &digits[..(digits.len() - base)];\n        } else\
    \ {\n            digits = &digits[..digits.len() - 1];\n        }\n        power\
    \ = power + 1;\n    }\n    s += &format!(\"{}\", power);\n    s += &digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgoizadwy.rs:15:27\n   |\n\
    15 |         if digits.len() > base {\n   |                           ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |         if digits.len()\
    \ > base.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgoizadwy.rs:16:48\n   |\n16 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \                                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmpgoizadwy.rs:16:46\n   |\n\
    16 |             digits = &digits[..(digits.len() - base)];\n   |            \
    \                                  ^ no implementation for `usize - isize`\n \
    \  |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgoizadwy.rs:16:22\n   |\n12 |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n16 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n16 |             digits = (&digits[..(digits.len()\
    \ - base)]).to_string();\n   |                      +                        \
    \        +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgoizadwy.rs:18:22\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n18 |             digits = &digits[..digits.le"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut quotient = x;\n    while quotient > 0 {\n        let remainder = quotient\
    \ % base;\n        quotient = quotient / base;\n        result = format!(\"{}{}\"\
    , result, remainder);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpvqw9eo98.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string();\n \
    \   let mut remainder = x;\n    while remainder > base {\n        res.push_str(&digits[..]);\n\
    \        remainder -= base;\n    }\n    res.push_str(&digits[..]);\n    res.push_str(&format!(\"\
    {}\", remainder).to_string());\n    res\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8882\"`,\n right: `\"22\"`', /tmp/tmp2ckv3xex.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += 1;\n\
    \        x -= base;\n    }\n    while x != 0 {\n        digits[base - 1] += 1;\n\
    \        x /= base;\n    }\n    for &d in digits {\n        if carry != 0 {\n\
    \            s += '1';\n            carry = 0;\n        } else {\n           \
    \ s += '0';\n        }\n        if d > 0 {\n            s += '0';\n        }\n\
    \        s += '0';\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2b9wgdm.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpe2b9wgdm.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpe2b9wgdm.rs:19:9\n   |\n19 |         digits[base - 1] += 1;\n \
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe2b9wgdm.rs:22:9\n   |\n22 | \
    \    for &d in digits {\n   |         ^^    ------ this expression has type `Option<u8>`\n\
    \   |         |\n   |         expected `u8`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `d`\n   |\n   = note:   expected\
    \ type `u8`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe2b9wgdm.rs:24:18\n   |\n24 |             s += '1';\n   |     \
    \             ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n24 |             s += \"1\";\n   |\
    \                  ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2b9wgdm.rs:27:18\n\
    \   |\n27 |             s += '0';\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits {\n        s += char::from_u32(digit as u32).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmwd5c8b.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpzmwd5c8b.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzmwd5c8b.rs:20:14\n\
    \   |\n20 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut base_size = base.len();\n    while\
    \ base_size.abs() > 1 {\n        base_size = base_size.saturating_sub(1);\n  \
    \  }\n    let mut base_size = base_size.saturating_sub(1);\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.abs()\
    \ > 1 {\n        base_size = base_size.saturating_sub(1);\n    }\n    while base_size.\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpoj5g_ntg.rs:86:1\n   |\n86\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpoj5g_ntg.rs:86:1\n\
    \   |\n85 |     while base_size.\n   |     ----- --------- this `while` condition\
    \ successfully parsed\n   |     |\n   |     while parsing the body of this `while`\
    \ expression\n86 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `abs`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:15:21\n\
    \   |\n15 |     while base_size.abs() > 1 {\n   |                     ^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `abs` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:19:21\n   |\n19 |     while\
    \ base_size.abs() > 1 {\n   |                     ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `abs` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpoj5g_ntg.rs:22:21\n   |\n22 |     while base_size.abs() > 1 {\n\
    \   |                     ^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:25:21\n\
    \   |\n25 |     while base_size.abs() > 1 {\n   |                     ^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `abs` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:28:21\n   |\n28 |     while\
    \ base_size.abs() > 1 {\n   |                     ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `abs` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpoj5g_ntg.rs:31:21\n   |\n31 |     while base_size.abs() > 1 {\n\
    \   |                     ^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:34:21\n\
    \   |\n34 |     while base_size.abs() > 1 {\n   |                     ^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `abs` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpoj5g_ntg.rs:37:21\n   |\n37 |     while\
    \ base_size.abs() > 1 {\n   |                     ^^^ method not found in `usize`\n\
    \nerror[E0599]:"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    while digits.len() > 0 {\n        let\
    \ mut digit = digits.chars().nth(digits.len() - 1);\n        if digit == '0' {\n\
    \            digit = base.chars().nth(base.len() - 1);\n        }\n        s.push(*digit);\n\
    \        digits = digits.chars().nth(digits.len() - 1);\n        base = base.chars().nth(base.len()\
    \ - 1);\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyym5nln.rs:16:21\n   |\n\
    16 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n16 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0614]:\
    \ type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpbyym5nln.rs:19:16\n\
    \   |\n19 |         s.push(*digit);\n   |                ^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbyym5nln.rs:20:18\n   |\n12 |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n20 |         digits = digits.chars().nth(digits.len() - 1);\n  \
    \ |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyym5nln.rs:21:16\n\
    \   |\n13 |     let mut base = base.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n21 |         base = base.chars().nth(base.len()\
    \ - 1);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut power = 1;\n    let mut digit = digits.iter().nth(base).unwrap();\n\
    \    while digit != 0 {\n        res.push_str(&digit % base);\n        digit /=\
    \ base;\n        power += 1;\n    }\n    res.push_str(&power.to_string());\n \
    \   res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6fs0iskn.rs:14:39\n   |\n\
    14 |     let mut digit = digits.iter().nth(base).unwrap();\n   |             \
    \                          ^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |     let mut digit = digits.iter().nth(base.try_into().unwrap()).unwrap();\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&char` with `{integer}`\n  --> /tmp/tmp6fs0iskn.rs:15:17\n  \
    \ |\n15 |     while digit != 0 {\n   |                 ^^ no implementation for\
    \ `&char == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&char`\n   = help: the trait `PartialEq` is implemented for\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6fs0iskn.rs:15:20\n\
    \   |\n15 |     while digit != 0 {\n   |                    ^ expected `char`,\
    \ found integer\n\nerror[E0369]: cannot mod `&&char` by `isize`\n  --> /tmp/tmp6fs0iskn.rs:16:29\n\
    \   |\n16 |         res.push_str(&digit % base);\n   |                      ------\
    \ ^ ---- isize\n   |                      |\n   |                      &&char\n\
    \nerror[E0368]: binary assignment operation `/=` cannot be applied to type `&char`\n\
    \  --> /tmp/tmp6fs0iskn.rs:17:9\n   |\n17 |         digit /= base;\n   |     \
    \    -----^^^^^^^^\n   |         |\n   |         cannot use `/=` on type `&char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    while base.len() > 0 {\n        if base\
    \ % 10 == 0 {\n            s.push_str(&digits);\n            digits.clear();\n\
    \        }\n        base = base.to_string();\n    }\n    if digits.len() > 0 {\n\
    \        s.push_str(&digits);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `String` by `{integer}`\n  --> /tmp/tmps9toqen8.rs:15:17\n\
    \   |\n15 |         if base % 10 == 0 {\n   |            ---- ^ -- {integer}\n\
    \   |            |\n   |            String\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = String::new();\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits.iter().rev() {\n        s.push(digit);\n    }\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbbj5vt1k.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpbbj5vt1k.rs:19:25\n\
    \   |\n19 |     for digit in digits.iter().rev() {\n   |                     \
    \    ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n19 |     for digit in digits.chars().rev() {\n   |                    \
    \     ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    digits.reverse();\n    for digit in digits {\n        s += digit;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_6lq0uv.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj_6lq0uv.rs:19:12\n\
    \   |\n19 |     digits.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpj_6lq0uv.rs:20:18\n   |\n20 |     for digit in digits\
    \ {\n   |                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 0;\n    while i < digits.size() {\n        let mut\
    \ digit = digits[i];\n        let mut base = base[i];\n        if digit == '0'\
    \ {\n            digit = &mut carry;\n            base = &mut base;\n        \
    \    carry = 0;\n        }\n        let mut new_digit = digit + base;\n      \
    \  if new_digit > '9' {\n            new_digit -= 10;\n            carry = 1;\n\
    \        }\n        i += 1;\n        s += new_digit.to_string();\n    }\n    if\
    \ carry != 0 {\n        s += &mut carry.to_string();\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpc2ogfnh3.rs:16:22\n   |\n16 |     while i < digits.size()\
    \ {\n   |                      ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2ogfnh3.rs:20:21\n\
    \   |\n17 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n...\n20 |             digit = &mut carry;\n   |\
    \                     ^^^^^^^^^^ expected `char`, found `&mut {integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc2ogfnh3.rs:21:20\n   |\n18 |         let mut\
    \ base = base[i];\n   |                        ------- expected due to this value\n\
    ...\n21 |             base = &mut base;\n   |                    ^^^^^^^^^ expected\
    \ `char`, found `&mut char`\n   |\nhelp: consider removing the borrow\n   |\n\
    21 -             base = &mut base;\n21 +             base = base;\n   | \n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpc2ogfnh3.rs:24:35\n   |\n24 |   \
    \      let mut new_digit = digit + base;\n   |                             -----\
    \ ^ ---- char\n   |                             |\n   |                      \
    \       char\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut basedigits = base.to_string().chars().collect::<Vec<_>>();\n    let\
    \ mut carry = 0;\n    while basedigits.len() > 0 {\n        let mut digit = basedigits.pop().unwrap();\n\
    \        if carry > 0 {\n            digit += 1;\n        }\n        digit = digit.to_string().chars().collect::<Vec<_>>().iter().fold(0,\
    \ |acc, x| {\n            acc + (x.to_digit(10).unwrap() as isize) * x;\n    \
    \        acc\n        });\n        digits.push(digit);\n        carry = digit\
    \ as isize;\n    }\n    while digits.len() > 0 {\n        let mut digit = digits.pop().unwrap();\n\
    \        if carry > 0 {\n            digit += 1;\n        }\n        digit = digit.to_string().chars().collect::<Vec<_>>().iter().fold(0,\
    \ |acc, x| {\n            acc + (x.to_digit(10).unwrap() as isize) * x;\n    \
    \        acc\n        });\n        digits.push(digit);\n        carry = digit\
    \ as isize;\n    }\n    s += digits.iter().fold(\"\".to_string(), |mut acc, x|\
    \ {\n        acc + &x.to_string()[..];\n        acc\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmprjcmgsd4.rs:18:13\n   |\n18 |             digit += 1;\n\
    \   |             -----^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjcmgsd4.rs:20:75\n\
    \   |\n20 |         digit = digit.to_string().chars().collect::<Vec<_>>().iter().fold(0,\
    \ |acc, x| {\n   |                                                           \
    \                ^ expected `char`, found `u8`\n\nerror[E0277]: cannot multiply\
    \ `isize` by `&char`\n  --> /tmp/tmprjcmgsd4.rs:21:54\n   |\n21 |            \
    \ acc + (x.to_digit(10).unwrap() as isize) * x;\n   |                        \
    \                              ^ no implementation for `isize * &char`\n   |\n\
    \   = help: the trait `Mul<&char>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0369]: cannot\
    \ add `_` to `char`\n  --> /tmp/tmprjcmgsd4.rs:21:17\n   |\n21 |             acc\
    \ + (x.to_digit(10).unwrap() as isize) * x;\n   |             --- ^ --------------------------------------\
    \ _\n   |             |\n   |             char\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmprjcmgsd4.rs:30:13\n\
    \   |\n30 |             digit += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprjcmgsd4.rs:32:75\n   |\n32 |         digit = digit.to_string().chars().collect::<Vec<_>>().iter().fold(0,\
    \ |acc, x| {\n   |                                                           \
    \                ^ expected `char`, found `u8`\n\nerror[E0277]: cannot multiply\
    \ `isize` by `&char`\n  --> /tmp/tmprjcmgsd4.rs:33:54\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push_str(&format!(\"\
    {}\", digit));\n    }\n    digits.push_str(&format!(\"{}\", remainder));\n   \
    \ s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n \
    \   assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"220\"`,\n right: `\"22\"`', /tmp/tmphz7lejr9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x.to_digits();\n    let mut\
    \ base = base.to_digits();\n    while x.len() > 0 {\n        let mut digit = x.pop().unwrap();\n\
    \        if digit < base {\n            s.push_str(&format!(\"{}\", digit));\n\
    \        } else {\n            s.push_str(&format!(\"{}\", digit - base));\n \
    \           s.push_str(&format!(\"{}\", base));\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp1bxsbaxo.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp1bxsbaxo.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpsnn0phx4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    for &d in &mut digits {\n        let mut new_digit = d.to_digit(base);\n\
    \        if carry > 0 {\n            new_digit += carry;\n        }\n        carry\
    \ = new_digit / 10;\n        s = s.push_str(&new_digit);\n    }\n    if carry\
    \ > 0 {\n        s = s.push_str(&carry);\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cqsml05.rs:15:9\n   |\n\
    15 |     for &d in &mut digits {\n   |         ^^    ----------- this expression\
    \ has type `Option<&mut char>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `d`\n   |\n \
    \  = note: expected mutable reference `&mut char`\n                      found\
    \ reference `&_`\n\nerror[E0277]: cannot add-assign `{integer}` to `str`\n  -->\
    \ /tmp/tmp7cqsml05.rs:18:23\n   |\n18 |             new_digit += carry;\n   |\
    \                       ^^ no implementation for `str += {integer}`\n   |\n  \
    \ = help: the trait `AddAssign<{integer}>` is not implemented for `str`\n   =\
    \ help: the trait `AddAssign<&str>` is implemented for `String`\n\nerror[E0277]:\
    \ cannot divide `str` by `{integer}`\n  --> /tmp/tmp7cqsml05.rs:20:27\n   |\n\
    20 |         carry = new_digit / 10;\n   |                           ^ no implementation\
    \ for `str / {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not implemented\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cqsml05.rs:21:13\n\
    \   |\n11 |     let mut s = String::new();\n   |                 -------------\
    \ expected due to this value\n...\n21 |         s = s.push_str(&new_digit);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmp7cqsml05.rs:21:15\n\
    \   |\n21 |         s = s.push_str(&new_digit);\n   |             - ^^^^^^^^ this\
    \ call modifies `s` in-place\n   |             |\n   |             you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7cqsml05.rs:24:24\n   |\n24 |         s = s.push_str(&carry);\n   |\
    \                        ^^^^^^ expected `str`, found integer\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7cqsml05.rs:24:13\n   |\n11 |     let mut s\
    \ = String::new();\n   |                 -------"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0; base];\n   \
    \ let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n \
    \       digits[digit] += 1;\n        x /= base;\n    }\n    for digit in digits\
    \ {\n        if digit > 0 {\n            s.push_str(&format!(\"{}\", digit));\n\
    \        } else {\n            s.push_str(&format!(\"0\"));\n        }\n    }\n\
    \    if carry > 0 {\n        s.push_str(&format!(\"{}\", carry));\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptyq6jpfi.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmptyq6jpfi.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i];\n \
    \       let mut basedigit = base[i];\n        if basedigit == '0' {\n        \
    \    digits.remove(&i);\n            digits.insert(0, digit);\n            base.remove(&i);\n\
    \            base.insert(0, basedigit);\n            i += 1;\n        } else {\n\
    \            digit *= basedigit;\n        }\n    }\n    res.push_str(&digits.join(\"\
    \"));\n    res.push_str(&base.join(\"\"));\n    res\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpla1iz9sz.rs:19:27\n   |\n\
    19 |             digits.remove(&i);\n   |                           ^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n19\
    \ -             digits.remove(&i);\n19 +             digits.remove(i);\n   | \n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpla1iz9sz.rs:21:25\n   |\n21 |\
    \             base.remove(&i);\n   |                         ^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n21 -       \
    \      base.remove(&i);\n21 +             base.remove(i);\n   | \n\nerror[E0368]:\
    \ binary assignment operation `*=` cannot be applied to type `char`\n  --> /tmp/tmpla1iz9sz.rs:25:13\n\
    \   |\n25 |             digit *= basedigit;\n   |             -----^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `*=` on type `char`\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<char>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpla1iz9sz.rs:28:26\n   |\n28 |     res.push_str(&digits.join(\"\
    \"));\n   |                          ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror[E0599]: the method\
    \ `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpla1iz9sz.rs:29:24\n   |\n29 |     res.push_str(&base.join(\"\"\
    ));\n   |                        ^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut basedigits = digits.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    basedigits.reverse();\n    basedigits.insert(0, base);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0, 0);\n    basedigits.insert(0,\
    \ 0);\n    basedigits.insert(0, \n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmpbxwod29p.rs:107:22\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - closing delimiter possibly meant\
    \ for this\n...\n107 |     basedigits.insert(0, \n    |                      ^\
    \ unclosed delimiter\n108 | }\n    | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbxwod29p.rs:15:26\n   |\n15 |     basedigits.insert(0,\
    \ base);\n   |                          ^^^^ expected `char`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:16:26\n   |\n16 |  \
    \   basedigits.insert(0, 0);\n   |                          ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:17:26\n\
    \   |\n17 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:18:26\n\
    \   |\n18 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:19:26\n\
    \   |\n19 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:20:26\n\
    \   |\n20 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:21:26\n\
    \   |\n21 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:22:26\n\
    \   |\n22 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:23:26\n\
    \   |\n23 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxwod29p.rs:24:26\n\
    \   |\n24 |     basedigits.insert(0, 0);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut x = x;\n    while x >= base {\n        digits[x - base] += 1;\n \
    \       x /= base;\n    }\n    while x != 0 {\n        res.insert(0, digits[x\
    \ % base].to_string());\n        x /= base;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkyphk0wa.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpkyphk0wa.rs:15:9\n   |\n15 |         digits[x\
    \ - base] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkyphk0wa.rs:19:23\n   |\n19 |         res.insert(0, digits[x %\
    \ base].to_string());\n   |                       ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n\
    \        digits[digit] += 1;\n        x /= base;\n        carry = 1;\n    }\n\
    \    while carry != 0 {\n        digits[digits.len() - 1] += 1;\n        carry\
    \ /= 10;\n    }\n    for digit in digits[0..digits.len() - 1] {\n        s +=\
    \ char::from_u32(digit as u32).unwrap();\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6uhan3m6.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp6uhan3m6.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the size for values of type `[u8]` cannot be\
    \ known at compilation time\n  --> /tmp/tmp6uhan3m6.rs:24:18\n   |\n24 |     for\
    \ digit in digits[0..digits.len() - 1] {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[u8]: IntoIterator` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `[u8]`\nhelp: consider borrowing\
    \ here\n   |\n24 |     for digit in &digits[0..digits.len() - 1] {\n   |     \
    \             +\n24 |     for digit in &mut digits[0..digits.len() - 1] {\n  \
    \ |                  ++++\n\nerror[E0277]: `[u8]` is not an iterator\n  --> /tmp/tmp6uhan3m6.rs:24:18\n\
    \   |\n24 |     for digit in digits[0..digits.len() - 1] {\n   |             \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[u8]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[u8]`\nhelp: consider borrowing here\n   |\n24 |     for digit in &digits[0..digits.len()\
    \ - 1] {\n   |                  +\n24 |     for digit in &mut digits[0..digits.len()\
    \ - 1] {\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let digit = quotient % base;\n     \
    \   remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \        quotient = quotient / base;\n    }\n    if remainder > 0 {\n        s\
    \ = format!(\"{}\", s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits {\n        s.push(digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbuvq43c8.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpbuvq43c8.rs:19:18\n   |\n19 |     for digit in digits {\n   | \
    \                 ^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0i32; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits {\n        if digit == 0 {\n            continue;\n\
    \        }\n        let mut digit = digit;\n        let mut carry = 0;\n     \
    \   while digit > 0 {\n            let digit = digit % base;\n            digit\
    \ /= base;\n            carry = carry + digit;\n        }\n        if carry >\
    \ 0 {\n            s.push_str(&format!(\"{}{}\", digit, carry));\n        } else\
    \ {\n            s.push_str(&format!(\"{}\", digit));\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphgk_csdo.rs:12:33\n   |\n\
    12 |     let mut digits = vec![0i32; base];\n   |                            \
    \     ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0i32; base.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[i32]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmphgk_csdo.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphgk_csdo.rs:26:33\n\
    \   |\n26 |             let digit = digit % base;\n   |                      \
    \           ^^^^ expected `i32`, found `isize`\n\nerror[E0277]: cannot mod `i32`\
    \ by `isize`\n  --> /tmp/tmphgk_csdo.rs:26:31\n   |\n26 |             let digit\
    \ = digit % base;\n   |                               ^ no implementation for\
    \ `i32 % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented for\
    \ `i32`\n   = help: the following other types implement trait `Rem<Rhs>`:\n  \
    \           <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n      \
    \       <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n        \
    \     <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n            \
    \ <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphgk_csdo.rs:27:22\n\
    \   |\n27 |             digit /= base;\n   |                      ^^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0277]: cannot divide-assign `i32` by `isize`\n\
    \  --> /tmp/tmphgk_csdo.rs:27:19\n   |\n27 |             digit /= base;\n   |\
    \                   ^^ no implementation for `i32 /= isize`\n   |\n   = help:\
    \ th"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string();\n \
    \   let mut base = base.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut base_len = base.length();\n    while digits_len > base_len {\n  \
    \      res.push_str(&base[base_len..]);\n        base_len -= 1;\n    }\n    while\
    \ digits_len < base_len {\n        res.push_str(&digits[digits_len..]);\n    \
    \    digits_len += 1;\n    }\n    res.push_str(&digits[digits_len..]);\n    res\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpz7r3d4t5.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpz7r3d4t5.rs:15:29\n\
    \   |\n15 |     let mut base_len = base.length();\n   |                      \
    \       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x >=\
    \ base {\n        s += &format!(\"{}\", x / base);\n        x %= base;\n     \
    \   base /= 10;\n    }\n    s += &format!(\"{}\", x);\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpns8juwbl.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x %= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut digits = vec![0u8; base];\n    while remainder > 0 {\n        let digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        digits[digit]\
    \ = 1;\n    }\n    for digit in digits.iter().rev() {\n        if digit == 0 {\n\
    \            continue;\n        }\n        result.push((digit as char).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcmtvzn2g.rs:13:32\n   |\n\
    13 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n13 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpcmtvzn2g.rs:17:9\n   |\n17 |         digits[digit]\
    \ = 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: can't compare `&u8` with `{integer}`\n  --> /tmp/tmpcmtvzn2g.rs:20:18\n\
    \   |\n20 |         if digit == 0 {\n   |                  ^^ no implementation\
    \ for `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&u8`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcmtvzn2g.rs:23:21\n   |\n23 |         result.push((digit as char).to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0606]: casting `&u8` as `char` is invalid\n  --> /tmp/tmpcmtvzn2g.rs:23:21\n\
    \   |\n23 |         result.push((digit as char).to_string());\n   |          \
    \           ^-----^^^^^^^^^\n   |                     ||\n   |               \
    \      |help: dereference the expression: `*digit`\n   |                     cannot\
    \ cast `&u8` as `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0606.\nFor more information about\
    \ an error, try `rustc"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = 1;\n    while remainder > 0 {\n        let digit = remainder % base;\n   \
    \     remainder = remainder / base;\n        s = format!(\"{}{}\", s, digit);\n\
    \        digits += 1;\n    }\n    if digits > 0 {\n        s = format!(\"{}\"\
    , s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpmyhcblre.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] == base[0] {\n  \
    \          s.push_str(&base[1..]);\n            i += 1;\n        } else {\n  \
    \          s.push_str(&digits[i]);\n        }\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1c2gptwg.rs:17:24\n   |\n\
    17 |             s.push_str(&base[1..]);\n   |                        ^^^^^^^^^^\
    \ expected `str`, found slice `[char]`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&[char]`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1c2gptwg.rs:20:24\n   |\n20 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] > base {\n      \
    \      digits[i] -= base;\n        } else {\n            digits[i] += base;\n\
    \        }\n        i += 1;\n    }\n    for d in digits {\n        s += d.to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaaffu2cj.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0368]: binary assignment operation `-=`\
    \ cannot be applied to type `char`\n  --> /tmp/tmpaaffu2cj.rs:17:13\n   |\n17\
    \ |             digits[i] -= base;\n   |             ---------^^^^^^^^\n   | \
    \            |\n   |             cannot use `-=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpaaffu2cj.rs:19:13\n\
    \   |\n19 |             digits[i] += base;\n   |             ---------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaaffu2cj.rs:24:14\n   |\n24 |         s += d.to_string();\n\
    \   |              ^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&d.to_string()`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut x = x;\n    while x >= base {\n        digits.insert(0, x % base);\n\
    \        x /= base;\n    }\n    digits.insert(0, x);\n    for i in &digits {\n\
    \        s += char::from_u32(*i).unwrap().to_string();\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsu1mbe9.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjsu1mbe9.rs:15:26\n   |\n15 |         digits.insert(0, x % base);\n\
    \   |                          ^^^^^^^^ expected `u8`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `u8` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         digits.insert(0, (x % base).try_into().unwrap());\n\
    \   |                          +        +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjsu1mbe9.rs:18:22\n   |\n18 |     digits.insert(0,\
    \ x);\n   |                      ^ expected `u8`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `u8` and panic if the converted value doesn't fit\n\
    \   |\n18 |     digits.insert(0, x.try_into().unwrap());\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjsu1mbe9.rs:20:29\n\
    \   |\n20 |         s += char::from_u32(*i).unwrap().to_string();\n   |      \
    \                       ^^ expected `u32`, found `u8`\n   |\nhelp: you can convert\
    \ a `u8` to a `u32`\n   |\n20 |         s += char::from_u32((*i).into()).unwrap().to_string();\n\
    \   |                             +  ++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjsu1mbe9.rs:20:14\n   |\n20 |         s += char::from_u32(*i).unwrap().to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             \
    \ |\n   |              expected `&str`, found struct `String`\n   |          \
    \    help: consider borrowing here: `&char::from_u32(*i).unwrap().to_string()`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n\
    \        digits[digit] += 1;\n        x /= base;\n        carry += 1;\n    }\n\
    \    if carry > 0 {\n        digits[digit] += 1;\n    }\n    for digit in digits.iter().rev()\
    \ {\n        res.insert(0, digit.to_string());\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpvkc3lkaq.rs:21:16\n\
    \   |\n21 |         digits[digit] += 1;\n   |                ^^^^^ help: a local\
    \ variable with a similar name exists: `digits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvkc3lkaq.rs:12:32\n   |\n12 |     let mut digits = vec![0u8; base];\n\
    \   |                                ^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     let mut digits = vec![0u8; base.try_into().unwrap()];\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpvkc3lkaq.rs:16:9\n\
    \   |\n16 |         digits[digit] += 1;\n   |         ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvkc3lkaq.rs:24:23\n\
    \   |\n24 |         res.insert(0, digit.to_string());\n   |                  \
    \     ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut digits = String::new();\n    while remainder > 0 {\n        let digit =\
    \ remainder % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits.chars() {\n        result.push(digit);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqj56plp_.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remain = x;\n    while remain\
    \ > 0 {\n        let mut digit = remain;\n        remain %= base;\n        digit\
    \ += base;\n        s.push((digit as char).to_string());\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhpnfi1z.rs:17:16\n   |\n\
    17 |         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmplhpnfi1z.rs:17:16\n   |\n17 |        \
    \ s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmplhpnfi1z.rs:17:16\n\
    \   |\n17 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0604.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut x = x as usize;\n    let\
    \ mut base = base as usize;\n    while x >= base {\n        result += '0';\n \
    \       x -= base;\n    }\n    result += '1';\n    result += &x[..];\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps33xb499.rs:15:19\n   |\n\
    15 |         result += '0';\n   |                   ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n15 |         result += \"0\";\n   |                   ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps33xb499.rs:18:15\n   |\n18 |     result +=\
    \ '1';\n   |               ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n18 |     result +=\
    \ \"1\";\n   |               ~~~\n\nerror[E0608]: cannot index into a value of\
    \ type `usize`\n  --> /tmp/tmps33xb499.rs:19:16\n   |\n19 |     result += &x[..];\n\
    \   |                ^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut x = x;\n    while x >= base {\n        digits.insert(0, x % base);\n\
    \        x /= base;\n    }\n    res.push_str(&digits);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp_cavb5.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnp_cavb5.rs:15:26\n   |\n15 |         digits.insert(0, x % base);\n\
    \   |                          ^^^^^^^^ expected `u8`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `u8` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         digits.insert(0, (x % base).try_into().unwrap());\n\
    \   |                          +        +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp_cavb5.rs:18:18\n   |\n18 |     res.push_str(&digits);\n\
    \   |                  ^^^^^^^ expected `str`, found struct `Vec`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&Vec<u8>`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x / base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    s += &digits;\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp54qthhjd.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp54qthhjd.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x /= base;\n    }\n\
    \    digits.push(format!(\"{}\", x));\n    s += digits.into_owned();\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwpo874q_.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwpo874q_.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpwpo874q_.rs:20:17\n\
    \   |\n20 |     s += digits.into_owned();\n   |                 ^^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x / base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    result = digits.join(\"\");\n \
    \   result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp24h_4iq7.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp24h_4iq7.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `join` found for struct `String` in the current scope\n  --> /tmp/tmp24h_4iq7.rs:20:21\n\
    \   |\n20 |     result = digits.join(\"\");\n   |                     ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x >=\
    \ base {\n        s += &format!(\"{}\", x / base);\n        x %= base;\n     \
    \   base /= 10;\n    }\n    s += &format!(\"{}\", x);\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmps3zfyrkg.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x %= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.insert(0, digit.to_string());\n\
    \    }\n    digits.insert(0, remainder.to_string());\n    s.push_str(&digits);\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvrxn280.rs:17:26\n   |\n\
    17 |         digits.insert(0, digit.to_string());\n   |                      \
    \    ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphvrxn280.rs:19:22\n   |\n19 |     digits.insert(0,\
    \ remainder.to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut power = 1;\n    let mut i = 0;\n    while i < digits.len() {\n     \
    \   if digits.len() - i < base {\n            power = 1;\n            i += 1;\n\
    \        } else {\n            power = power * base;\n            i += base;\n\
    \        }\n        if power > 10 {\n            power = 1;\n            i +=\
    \ 1;\n        }\n        s += digits.chars().nth(i).to_string();\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1om_2fe.rs:16:31\n   |\n\
    16 |         if digits.len() - i < base {\n   |                              \
    \ ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n16 |      \
    \   if digits.len() - i < base.try_into().unwrap() {\n   |                   \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk1om_2fe.rs:21:18\n   |\n21 |             i += base;\n   |         \
    \         ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpk1om_2fe.rs:21:15\n   |\n21 |            \
    \ i += base;\n   |               ^^ no implementation for `usize += isize`\n \
    \  |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmpk1om_2fe.rs:27:36\n\
    \    |\n27  |           s += digits.chars().nth(i).to_string();\n    |       \
    \                               ^^^^^^^^^ `Option<char>` cannot be formatted with\
    \ the default formatter\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] >= base[0] {\n  \
    \          s.push_str(&base[digits[i] - base[0]]);\n            i += 1;\n    \
    \    } else {\n            s.push_str(&digits[i]);\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpa_jxtmpt.rs:17:40\n\
    \   |\n17 |             s.push_str(&base[digits[i] - base[0]]);\n   |        \
    \                      --------- ^ ------- char\n   |                        \
    \      |\n   |                              char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa_jxtmpt.rs:20:24\n   |\n20 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut i = 0;\n    while i < digits.len()\
    \ {\n        let mut digit = digits[i..].parse::<usize>().unwrap();\n        digit\
    \ = digit * base.parse::<usize>().unwrap();\n        digit = digit.to_string();\n\
    \        i += digit.len();\n        s = s.push_str(&digit);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvd4v5x8w.rs:18:17\n   |\n\
    16 |         let mut digit = digits[i..].parse::<usize>().unwrap();\n   |    \
    \                     ------------------------------------- expected due to this\
    \ value\n17 |         digit = digit * base.parse::<usize>().unwrap();\n18 |  \
    \       digit = digit.to_string();\n   |                 ^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0599]: no method named `len` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpvd4v5x8w.rs:19:20\n   |\n\
    19 |         i += digit.len();\n   |                    ^^^ method not found in\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvd4v5x8w.rs:20:24\n\
    \   |\n20 |         s = s.push_str(&digit);\n   |                        ^^^^^^\
    \ expected `str`, found `usize`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvd4v5x8w.rs:20:13\n   |\n11 |     let mut s = String::new();\n   | \
    \                ------------- expected due to this value\n...\n20 |         s\
    \ = s.push_str(&digit);\n   |             ^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpvd4v5x8w.rs:20:15\n   |\n20 |         s = s.push_str(&digit);\n\
    \   |             - ^^^^^^^^ this call modifies `s` in-place\n   |           \
    \  |\n   |             you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient /= base;\n        s.push(remainder);\n    }\n    s.push(remainder);\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbk906806.rs:17:16\n   |\n\
    17 |         s.push(remainder);\n   |                ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbk906806.rs:19:12\n\
    \   |\n19 |     s.push(remainder);\n   |            ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = base;\n    while remainder > 0 {\n        remainder %= base;\n        digits\
    \ += 1;\n    }\n    while digits > 0 {\n        s.push((digits).to_string());\n\
    \        digits -= 1;\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplb9eshzr.rs:19:16\n   |\n\
    19 |         s.push((digits).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut x = x;\n    while x >= base {\n        digits[x - base] += 1;\n \
    \       x /= base;\n    }\n    while x > 0 {\n        res.push_str(&format!(\"\
    {}\", digits[x % base]));\n        x /= base;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6a8vqs0.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpo6a8vqs0.rs:15:9\n   |\n15 |         digits[x\
    \ - base] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpo6a8vqs0.rs:19:37\n   |\n19 |         res.push_str(&format!(\"\
    {}\", digits[x % base]));\n   |                                     ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut x = x as usize;\n    let mut\
    \ base = base as usize;\n    while x >= base {\n        res.push_str(&format!(\"\
    {}\", x / base));\n        x %= base;\n    }\n    res.push_str(&format!(\"{}\"\
    , x));\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"30\"`,\n right: `\"100\"`', /tmp/tmp87cvqh_3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    let mut digits\
    \ = x.to_string();\n    while !digits.is_empty() {\n        let digit = digits.chars().nth(base).unwrap();\n\
    \        remainder += digit as isize;\n        s = format!(\"{}{}\", s, digit);\n\
    \        digits = digits.chars().skip_while(|c| c != digit).collect();\n    }\n\
    \    if remainder > 0 {\n        s = format!(\"{}{}\", s, remainder);\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps73i2ayu.rs:15:40\n   |\n\
    15 |         let digit = digits.chars().nth(base).unwrap();\n   |            \
    \                            ^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmps73i2ayu.rs:18:50\n   |\n18\
    \ |         digits = digits.chars().skip_while(|c| c != digit).collect();\n  \
    \ |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let digit = quotient % base;\n     \
    \   remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \        quotient = quotient / base;\n    }\n    if remainder > 0 {\n        s\
    \ = format!(\"{}\", s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    if quotient > 0 {\n        s = format!(\"{}\", quotient);\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmphcketh48.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string();\n\
    \    let mut remainder = x;\n    while remainder > base {\n        remainder -=\
    \ base;\n        result.push((&mut digits[..]).to_ascii_lowercase()[base]);\n\
    \    }\n    result.push((&mut digits[..]).to_ascii_lowercase()[remainder]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpdnl5qrlq.rs:16:21\n\
    \   |\n16 |         result.push((&mut digits[..]).to_ascii_lowercase()[base]);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpdnl5qrlq.rs:18:17\n   |\n18 |     result.push((&mut digits[..]).to_ascii_lowercase()[remainder]);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digits, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp9h_m0rr5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x / base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    s += digits.into_owned();\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd5zjffth.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpd5zjffth.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpd5zjffth.rs:20:17\n\
    \   |\n20 |     s += digits.into_owned();\n   |                 ^^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digits, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpy0jnasot.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        remainder /= base;\n        quotient\
    \ /= base;\n        s.push((remainder % base) as char);\n    }\n    s.push((quotient\
    \ % base) as char);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpp7e6_8_f.rs:17:16\n\
    \   |\n17 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpp7e6_8_f.rs:17:16\n   |\n17 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmpp7e6_8_f.rs:19:12\n   |\n19 |\
    \     s.push((quotient % base) as char);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpp7e6_8_f.rs:19:12\n   |\n19 |     s.push((quotient % base) as char);\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n\
    \        digits[digit] += 1;\n        x /= base;\n        carry = 1;\n    }\n\
    \    while carry != 0 {\n        digits[digits.len() - 1] += 1;\n        carry\
    \ /= 10;\n    }\n    for digit in digits.iter() {\n        s += char::from_u32(digit\
    \ as u32).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxei23qzv.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxei23qzv.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxei23qzv.rs:25:14\n\
    \   |\n25 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0606]: casting `&u8` as `u32` is invalid\n  --> /tmp/tmpxei23qzv.rs:25:29\n\
    \   |\n25 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \                     -----^^^^^^^\n   |                             |\n   | \
    \                            cannot cast `&u8` as `u32`\n   |                \
    \             help: dereference the expression: `*digit`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    let mut power = 1;\n    let mut digits_len = base;\n\
    \    let mut remainder_len = base;\n    let mut digit_len = base;\n    let mut\
    \ remainder_len = base;\n    let mut digit_len = base;\n    let mut remainder_len\
    \ = base;\n    let mut digit_len = base;\n    let mut remainder_len = base;\n\
    \    let mut digit_len = base;\n    let mut remainder_len = base;\n    let mut\
    \ digit_len = base;\n    let mut remainder_len = base;\n    let mut digit_len\
    \ = base;\n    let mut remainder_len = base;\n    let mut digit_len = base;\n\
    \    let mut remainder_len = base;\n    let mut digit_len = base;\n    let mut\
    \ remainder_len = base;\n    let mut digit_len = base;\n    let mut remainder_len\
    \ = base;\n    let mut digit_len = base;\n    let mut remainder_len = base;\n\
    \    let mut digit_len = base;\n    let mut remainder_len = base;\n    let mut\
    \ digit_len = base;\n    let mut remainder_len = base;\n    let mut digit_len\
    \ = base;\n    let mut remainder_len = base;\n    let mut digit_len = base;\n\
    \    let mut remainder_len = base;\n    let mut digit_len = base;\n    let mut\
    \ remainder_len = base;\n    let mut digit_len = base;\n    let mut remainder_len\
    \ = base;\n    let mut digit_len = base;\n    let mut remainder_len = base;\n\
    \    let mut digit_len = base;\n    let mut remainder_len = base;\n    let mut\
    \ digit_len = base;\n    let mut remainder_len = base;\n    let mut digit_len\
    \ = base;\n    let mut remainder_len = base;\n    let mut digit_len = base;\n\
    \    let mut remainder_len = base;\n    let mut digit_len = base;\n    let mut\
    \ remainder_len = base;\n    let mut digit_len = base;\n    let mut remainder_len\
    \ = base;\n    let mut digit_len = base;\n    let mut remainder_len = base;\n\
    \    let mut digit_len = base;\n    let mut remainder_len = base;\n    let mut\
    \ digit_len = base;\n    let mut remainder_len = base;\n    let mut digit_len\
    \ = base;\n    let mut remainder_len = base;\n    let mu\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmput03yq6h.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmput03yq6h.rs:10:42\n \
    \  |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |    -----------\
    \                           ^^^^^^ expected struct `String`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut bases = base.to_string();\n    while bases.len() > 0 {\n        let\
    \ mut digit = digits.chars().nth(bases.len() - 1).unwrap();\n        if digit\
    \ == '0' {\n            digits.remove(bases.len() - 1);\n            bases.remove(bases.len()\
    \ - 1);\n        } else {\n            s.insert(0, digit);\n        }\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x = x / base;\n   \
    \ }\n    digits.push(format!(\"{}\", x));\n    s += &digits;\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmnsisi3t.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmnsisi3t.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] > base {\n      \
    \      digits[i] -= base;\n        } else {\n            digits[i] += base;\n\
    \        }\n        i += 1;\n    }\n    for i in 0..digits.len() {\n        s\
    \ += digits[i].to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlg4pkx0.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0368]: binary assignment operation `-=`\
    \ cannot be applied to type `char`\n  --> /tmp/tmptlg4pkx0.rs:17:13\n   |\n17\
    \ |             digits[i] -= base;\n   |             ---------^^^^^^^^\n   | \
    \            |\n   |             cannot use `-=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmptlg4pkx0.rs:19:13\n\
    \   |\n19 |             digits[i] += base;\n   |             ---------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptlg4pkx0.rs:24:14\n   |\n24 |         s += digits[i].to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^\n   |              |\n   |          \
    \    expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&digits[i].to_string()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    let mut digits\
    \ = x.to_string();\n    while digits.len() > 0 {\n        let digit = digits.chars().nth(base).unwrap();\n\
    \        remainder += digit as isize;\n        digits = digits.chars().nth(base\
    \ - 1).unwrap();\n    }\n    if remainder > 0 {\n        remainder -= 1;\n   \
    \     s.push('0');\n    }\n    s.push(remainder);\n    s\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfwb3wra3.rs:15:40\n   |\n\
    15 |         let digit = digits.chars().nth(base).unwrap();\n   |            \
    \                            ^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfwb3wra3.rs:17:37\n   |\n17 |         digits\
    \ = digits.chars().nth(base - 1).unwrap();\n   |                             \
    \        ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |         digits = digits.chars().nth((base - 1).try_into().unwrap()).unwrap();\n\
    \   |                                     +        +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfwb3wra3.rs:17:18\n   |\n13 |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n17 |         digits = digits.chars().nth(base - 1).unwrap();\n \
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                  |\n   |           \
    \       expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfwb3wra3.rs:23:12\n   |\n23 |     s.push(remainder);\n   |    \
    \        ^^^^^^^^^ expected `char`, found `isize`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut x = x as usize;\n    let\
    \ mut base = base as usize;\n    while x >= base {\n        result += '0';\n \
    \       x /= base;\n    }\n    result += '0';\n    result += x.to_string();\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2srtkki5.rs:15:19\n   |\n\
    15 |         result += '0';\n   |                   ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n15 |         result += \"0\";\n   |                   ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2srtkki5.rs:18:15\n   |\n18 |     result +=\
    \ '0';\n   |               ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n18 |     result +=\
    \ \"0\";\n   |               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2srtkki5.rs:19:15\n\
    \   |\n19 |     result += x.to_string();\n   |               ^^^^^^^^^^^^^\n \
    \  |               |\n   |               expected `&str`, found struct `String`\n\
    \   |               help: consider borrowing here: `&x.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder += x % base;\n        x /= base;\n    }\n    while\
    \ x > 0 {\n        remainder += x;\n        x /= base;\n    }\n    s += format!(\"\
    {}\", remainder);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2wh9mz6.rs:21:10\n   |\n\
    21 |     s += format!(\"{}\", remainder);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut x = x;\n    while x >= base\
    \ {\n        let mut y = x / base;\n        result = format!(\"{}{}\", result,\
    \ y);\n        x = x - y * base;\n    }\n    result = format!(\"{}\", result);\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmp4gjfweda.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder += x % base;\n        x /= base;\n    }\n    if x\
    \ > 0 {\n        remainder += x;\n    }\n    while remainder > 0 {\n        s\
    \ += char::from_u32(remainder as u32).unwrap();\n        remainder -= char::from_u32(base).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy51mv0jd.rs:21:14\n   |\n\
    21 |         s += char::from_u32(remainder as u32).unwrap();\n   |           \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy51mv0jd.rs:22:37\n   |\n22 |  \
    \       remainder -= char::from_u32(base).unwrap();\n   |                    \
    \                 ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n   |\n22\
    \ |         remainder -= char::from_u32(base.try_into().unwrap()).unwrap();\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot subtract-assign `char` from `isize`\n  --> /tmp/tmpy51mv0jd.rs:22:19\n\
    \   |\n22 |         remainder -= char::from_u32(base).unwrap();\n   |        \
    \           ^^ no implementation for `isize -= char`\n   |\n   = help: the trait\
    \ `SubAssign<char>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n    \
    \         <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n      \
    \       <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n         \
    \    <i16 as SubAssign>\n           and 20 others\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0; base];\n   \
    \ let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n \
    \       digits[digit] += 1;\n        x /= base;\n    }\n    for digit in digits\
    \ {\n        if digit > 0 {\n            s.push_str(&format!(\"{}\", digit));\n\
    \        } else {\n            s.push_str(&format!(\"0\"));\n        }\n    }\n\
    \    if carry > 0 {\n        s.push_str(&format!(\"{}\", carry));\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbzi33lw.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkbzi33lw.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = base;\n    while remainder > 0 {\n        remainder %= base;\n        s +=\
    \ digits[remainder];\n        remainder /= base;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpn9ukr27c.rs:16:14\n\
    \   |\n16 |         s += digits[remainder];\n   |              ^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if base == 0 {\n            s.push('0');\n\
    \            i += 1;\n            continue;\n        }\n        let mut digit\
    \ = digits[i];\n        if digit >= '0' && digit <= '9' {\n            digit =\
    \ digit - '0';\n        }\n        if digit >= base {\n            digit = digit\
    \ - base;\n            s.push('0');\n            i += 1;\n        }\n        s.push((digit\
    \ as char).to_string());\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpof5or87r.rs:16:17\n\
    \   |\n16 |         if base == 0 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmpof5or87r.rs:23:27\n   |\n23 |            \
    \ digit = digit - '0';\n   |                     ----- ^ --- char\n   |      \
    \               |\n   |                     char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpof5or87r.rs:25:21\n   |\n25 |         if digit >= base {\n   |\
    \                     ^^^^ expected `char`, found struct `Vec`\n   |\n   = note:\
    \ expected type `char`\n            found struct `Vec<char>`\n\nerror[E0369]:\
    \ cannot subtract `Vec<char>` from `char`\n  --> /tmp/tmpof5or87r.rs:26:27\n \
    \  |\n26 |             digit = digit - base;\n   |                     ----- ^\
    \ ---- Vec<char>\n   |                     |\n   |                     char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpof5or87r.rs:30:16\n   |\n30 |  \
    \       s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder = x % base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \        x = x / base;\n    }\n    s = format!(\"{}\", s);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpqs_ght6w.rs:12:13\n\
    \   |\n12 |     let mut remainder = 0;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `x`\n\
    \  --> /tmp/tmpqs_ght6w.rs:16:9\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n16 |         x = x / base;\n   |         ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = String::new();\n   \
    \ let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.push(format!(\"{}\", remainder));\n        x /= base;\n    }\n\
    \    digits.push(format!(\"{}\", x));\n    s += &digits[..digits.len() - 1];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbfx170m.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmptbfx170m.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1);\n        let mut new_digit = digit;\n\
    \        if base == 2 {\n            if digit == '0' {\n                new_digit\
    \ = '1';\n            }\n            else if digit == '1' {\n                new_digit\
    \ = '0';\n            }\n        }\n        if base == 8 {\n            if digit\
    \ == '0' {\n                new_digit = '7';\n            }\n            else\
    \ if digit == '7' {\n                new_digit = '0';\n            }\n       \
    \ }\n        if base == 10 {\n            if digit == '0' {\n                new_digit\
    \ = '9';\n            }\n            else if digit == '9' {\n                new_digit\
    \ = '0';\n            }\n        }\n        s += new_digit;\n        digits =\
    \ digits.chars().nth(digits.len() - 1);\n        base /= 10;\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpab_9kz1x.rs:17:17\n\
    \   |\n17 |         if base == 2 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab_9kz1x.rs:18:25\n\
    \   |\n18 |             if digit == '0' {\n   |                         ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |             if digit == Some('0') {\n   |                        \
    \ +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab_9kz1x.rs:19:29\n\
    \   |\n16 |         let mut new_digit = digit;\n   |                         \
    \    ----- expected due to this value\n...\n19 |                 new_digit = '1';\n\
    \   |                             ^^^ expected enum `Option`, found `char`\n \
    \  |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |                 new_digit\
    \ = Some('1');\n   |                             +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpab_9kz1x.rs:21:30\n   |\n21 |             else if digit\
    \ == '1' {\n   |                              ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<char>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n21 |            \
    \ else if digit == Some('1') {\n   |                              +++++   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x.to_digits();\n    let mut\
    \ base = base.to_digits();\n    while x.len() > 0 {\n        let mut digit = x.remove(0);\n\
    \        if digit >= base {\n            digit -= base;\n        }\n        s\
    \ += digit.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmppspq7hb7.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmppspq7hb7.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder += x / base;\n        x = x % base;\n    }\n    s\
    \ += x.to_string();\n    if remainder > 0 {\n        s += &format!(\"{}\", remainder).to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6t7ciwhb.rs:17:10\n   |\n\
    17 |     s += x.to_string();\n   |          ^^^^^^^^^^^^^\n   |          |\n \
    \  |          expected `&str`, found struct `String`\n   |          help: consider\
    \ borrowing here: `&x.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += x;\n\
    \        x -= base;\n        carry = 0;\n        for &d in &digits[base..] {\n\
    \            carry += d;\n            if carry > 0 {\n                s += '0';\n\
    \            }\n            s += '1';\n            carry = 0;\n        }\n   \
    \ }\n    if carry > 0 {\n        s += '0';\n    }\n    s += '1';\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplz0rohmi.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmplz0rohmi.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += x;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmplz0rohmi.rs:18:20\n   |\n18 |         for &d in &digits[base..]\
    \ {\n   |                    ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `RangeFrom<isize>`\n   = help: the following other types implement trait\
    \ `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n     \
    \        <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because of\
    \ the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<u8>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplz0rohmi.rs:21:22\n   |\n21 |  \
    \               s += '0';\n   |                      ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n21 |                 s += \"0\";\n   |                      ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplz0rohmi.rs:23:18\n   |\n23 |             s\
    \ += '1';\n   |                  ^^^ expected `&str`, found `char`\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n23 |       \
    \      s += \"1\";\n   |                  ~~~\n\nerror[E030"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] = 1;\n\
    \    }\n    for digit in digits {\n        if digit == 0 {\n            continue;\n\
    \        }\n        s.push('0');\n    }\n    s.push((x as i8).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbrb28hd.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmppbrb28hd.rs:17:9\n   |\n17 |         digits[digit]\
    \ = 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbrb28hd.rs:25:12\n\
    \   |\n25 |     s.push((x as i8).to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut x = x;\n    while x >= base\
    \ {\n        result += '0';\n        x -= base;\n    }\n    result += &format!(\"\
    {}\", x);\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpls9ddddt.rs:14:19\n   |\n\
    14 |         result += '0';\n   |                   ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n14 |         result += \"0\";\n   |                   ~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut digits = base;\n    while remainder > 0 {\n        remainder %= base;\n\
    \        remainder += digits;\n        digits *= base;\n    }\n    result.push_str(&format!(\"\
    {}\", remainder));\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpj9jtygs3.rs:17:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        remainder %= base;\n\
    \        digits[base] = remainder;\n        result += &digits[base].to_string();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_3kch26.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2_3kch26.rs:16:9\n   |\n16 |         digits[base]\
    \ = remainder;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp2_3kch26.rs:17:20\n   |\n17 |         result += &digits[base].to_string();\n\
    \   |                    ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut i = 0;\n    while i < digits.size()\
    \ {\n        if base == 10 {\n            s.push_str(&digits[..i]);\n        \
    \    break;\n        }\n        let mut digit = digits[..i].parse::<usize>().unwrap();\n\
    \        digit *= base.parse::<usize>().unwrap();\n        digit %= base;\n  \
    \      i += 1;\n        s.push_str(&digit.to_string());\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvnj2wzow.rs:15:22\n   |\n15 |     while i < digits.size()\
    \ {\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmpvnj2wzow.rs:16:17\n \
    \  |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: cannot mod-assign `usize` by `String``\n\
    \  --> /tmp/tmpvnj2wzow.rs:22:15\n   |\n22 |         digit %= base;\n   |    \
    \           ^^ no implementation for `usize %= String`\n   |\n   = help: the trait\
    \ `RemAssign<String>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `RemAssign<Rhs>`:\n             <f32 as RemAssign<&f32>>\n\
    \             <f32 as RemAssign>\n             <f64 as RemAssign<&f64>>\n    \
    \         <f64 as RemAssign>\n             <i128 as RemAssign<&i128>>\n      \
    \       <i128 as RemAssign>\n             <i16 as RemAssign<&i16>>\n         \
    \    <i16 as RemAssign>\n           and 20 others\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += x;\n\
    \        carry = digits[base - 1];\n        x -= base;\n    }\n    if carry >\
    \ 0 {\n        digits[base - 1] += carry;\n    }\n    for &d in &digits[..] {\n\
    \        s += char::from_u32(d as u32).unwrap();\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvhul1sae.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpvhul1sae.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += x;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpvhul1sae.rs:16:17\n   |\n16 |         carry = digits[base - 1];\n\
    \   |                 ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpvhul1sae.rs:20:9\n   |\n20 |         digits[base - 1] += carry;\n\
    \   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvhul1sae.rs:23:14\n\
    \   |\n23 |         s += char::from_u32(d as u32).unwrap();\n   |            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detail"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    while\
    \ remainder > 0 {\n        let digit = remainder % base;\n        remainder =\
    \ remainder / base;\n        result = format!(\"{}{}\", digit, result);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digits, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpdrj6z19j.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x as usize;\n    let mut\
    \ base = base as usize;\n    while x >= base {\n        s += &format!(\"{:0{}b}\"\
    , x % base, base);\n        x /= base;\n    }\n    s += &format!(\"{:0{}b}\",\
    \ x, base);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpuri3qrpm.rs:15:27\n\
    \   |\n15 |         s += &format!(\"{:0{}b}\", x % base, base);\n   |        \
    \                -  ^ expected `}` in format string\n   |                    \
    \    |\n   |                        because of this opening brace\n   |\n   =\
    \ note: if you intended to print `{`, you can escape it using `{{`\n\nerror: invalid\
    \ format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpuri3qrpm.rs:18:23\n\
    \   |\n18 |     s += &format!(\"{:0{}b}\", x, base);\n   |                   \
    \ -  ^ expected `}` in format string\n   |                    |\n   |        \
    \            because of this opening brace\n   |\n   = note: if you intended to\
    \ print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] = 1;\n\
    \    }\n    for digit in digits {\n        if digit == 0 {\n            continue;\n\
    \        }\n        result.push((digit as char).to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx72au7ci.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpx72au7ci.rs:17:9\n   |\n17 |         digits[digit]\
    \ = 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx72au7ci.rs:23:21\n\
    \   |\n23 |         result.push((digit as char).to_string());\n   |          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n  --> /tmp/tmpx72au7ci.rs:23:21\n\
    \   |\n23 |         result.push((digit as char).to_string());\n   |          \
    \           ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpx72au7ci.rs:23:21\n   |\n23 |         result.push((digit\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0604.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 0;\n    while i < digits.len() {\n        let mut\
    \ digit = digits[i];\n        let mut base = base[i];\n        if digit == 0 {\n\
    \            digit = carry;\n            base = base - 1;\n        }\n       \
    \ let mut new_digit = digit + base;\n        if new_digit > 9 {\n            new_digit\
    \ -= 10;\n            carry = 1;\n        } else {\n            carry = 0;\n \
    \       }\n        result = result.push_str(&new_digit.to_string());\n       \
    \ i += 1;\n    }\n    if carry != 0 {\n        result = result.push_str(&carry.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbzjy7ah.rs:19:21\n   |\n\
    19 |         if digit == 0 {\n   |                     ^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbzjy7ah.rs:20:21\n  \
    \ |\n17 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n...\n20 |             digit = carry;\n   |     \
    \                ^^^^^ expected `char`, found integer\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `char`\n  --> /tmp/tmpsbzjy7ah.rs:21:25\n   |\n21\
    \ |             base = base - 1;\n   |                    ---- ^ - {integer}\n\
    \   |                    |\n   |                    char\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmpsbzjy7ah.rs:23:35\n   |\n23 |         let\
    \ mut new_digit = digit + base;\n   |                             ----- ^ ----\
    \ char\n   |                             |\n   |                             char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsbzjy7ah.rs:30:18\n   |\n11 |\
    \     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n30 |         result = result.push_str(&new_digit.to_string());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n\
    \  --> /tmp/tmpsbzjy7ah.rs:30:25\n   |\n30 |         result = result.push_str(&new_digit.to_string());\n\
    \   |                  ------ ^^^^^^^^ this call modifies `result` in-place\n\
    \   |                  |\n   |                  you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbzjy7ah.rs:34:18\n\
    \   |\n11 |     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n34 |         result = result.push_str(&carry.to_string());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ -"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder += x % base;\n        x = x / base;\n    }\n    s\
    \ += &format!(\"{}\", remainder);\n    s += &format!(\"{}\", x);\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpdown506n.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x = x / base;\n   |         ^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    for digit in x.to_digits().iter().cloned() {\n   \
    \     if digit > base {\n            digits.insert(0, 0);\n            carry =\
    \ 1;\n        } else {\n            digits.insert(0, digit);\n            carry\
    \ = 0;\n        }\n    }\n    while carry != 0 {\n        digits.insert(0, 0);\n\
    \        carry = digits.iter().cloned().next().unwrap();\n    }\n    for digit\
    \ in digits.iter().cloned() {\n        s += char::from_u32(digit as u32).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6e_xp_5.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpg6e_xp_5.rs:14:20\n\
    \   |\n14 |     for digit in x.to_digits().iter().cloned() {\n   |           \
    \         ^^^^^^^^^ method not found in `isize`\n\nerror[E0277]: can't compare\
    \ `u8` with `isize`\n  --> /tmp/tmpg6e_xp_5.rs:15:18\n   |\n15 |         if digit\
    \ > base {\n   |                  ^ no implementation for `u8 < isize` and `u8\
    \ > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is not implemented\
    \ for `u8`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6e_xp_5.rs:28:14\n\
    \   |\n28 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let digit = quotient % base;\n     \
    \   remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \        quotient = quotient / base;\n    }\n    if remainder > 0 {\n        s\
    \ = format!(\"{}\", remainder) + s;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnr85ykz9.rs:21:40\n   |\n\
    21 |         s = format!(\"{}\", remainder) + s;\n   |                       \
    \                 ^\n   |                                        |\n   |     \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                        help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits {\n        s += char::from_u32(digit as u32).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6g_31r6.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpl6g_31r6.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl6g_31r6.rs:20:14\n\
    \   |\n20 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        if remainder >= base {\n       \
    \     s.push((remainder % base).to_string());\n            remainder /= base;\n\
    \        } else {\n            s.push((remainder % base).to_string());\n     \
    \       break;\n        }\n    }\n    s.push((remainder).to_string());\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxhrnvhn.rs:16:20\n   |\n\
    16 |             s.push((remainder % base).to_string());\n   |               \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprxhrnvhn.rs:19:20\n   |\n19 |  \
    \           s.push((remainder % base).to_string());\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmprxhrnvhn.rs:23:12\n   |\n23 |     s.push((remainder).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base] = x % base;\n\
    \        x /= base;\n        carry += 1;\n    }\n    while carry > 0 {\n     \
    \   digits[base] = carry % base;\n        carry /= base;\n    }\n    for &d in\
    \ digits {\n        s += char::from_u32(d as u32).unwrap();\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_bxp30dh.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp_bxp30dh.rs:15:9\n   |\n15 |         digits[base]\
    \ = x % base;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp_bxp30dh.rs:20:9\n   |\n20 |         digits[base] = carry % base;\n\
    \   |         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_bxp30dh.rs:23:9\n   |\n23 | \
    \    for &d in digits {\n   |         ^^    ------ this expression has type `Option<u8>`\n\
    \   |         |\n   |         expected `u8`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `d`\n   |\n   = note:   expected\
    \ type `u8`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_bxp30dh.rs:24:14\n   |\n24 |         s += char::from_u32(d as\
    \ u32).unwrap();\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut x = x;\n    let mut base =\
    \ base;\n    while x >= base {\n        res.push_str(&x.to_string().rjust(base,\
    \ '0'));\n        x /= base;\n    }\n    res.push_str(&x.to_string().rjust(base,\
    \ '0'));\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rjust` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbyie_y4y.rs:15:37\n   |\n15 |         res.push_str(&x.to_string().rjust(base,\
    \ '0'));\n   |                                     ^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `rjust` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbyie_y4y.rs:18:33\n   |\n18 |     res.push_str(&x.to_string().rjust(base,\
    \ '0'));\n   |                                 ^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > base {\n        remainder -= base;\n\
    \        digits.insert(0, base.to_string());\n    }\n    while remainder > 0 {\n\
    \        remainder -= 1;\n        digits.insert(0, remainder.to_string());\n \
    \   }\n    s += digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyuqagzih.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyuqagzih.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ remainder.to_string());\n   |                          ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpyuqagzih.rs:22:10\n   |\n22 |     s += digits;\n   |          ^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits {\n        s += char::from_u32(digit as u32).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6hp91ff.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpi6hp91ff.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi6hp91ff.rs:20:14\n\
    \   |\n20 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        remainder %= base;\n        s +=\
    \ char::from_u32(base).unwrap();\n        base /= base;\n    }\n    s += char::from_u32(base).unwrap();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2l6vdsix.rs:16:29\n   |\n\
    16 |         s += char::from_u32(base).unwrap();\n   |                       \
    \      ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n16 |        \
    \ s += char::from_u32(base.try_into().unwrap()).unwrap();\n   |              \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2l6vdsix.rs:16:14\n   |\n16 |         s += char::from_u32(base).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2l6vdsix.rs:19:25\n   |\n19 |\
    \     s += char::from_u32(base).unwrap();\n   |                         ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n19 |     s += char::from_u32(base.try_into().unwrap()).unwrap();\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2l6vdsix.rs:19:10\n   |\n19 |     s += char::from_u32(base).unwrap();\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        remainder /= base;\n        quotient\
    \ /= base;\n        s.push((remainder % base) as char);\n    }\n    s.push((quotient\
    \ % base) as char);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpr1hhc3wj.rs:17:16\n\
    \   |\n17 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpr1hhc3wj.rs:17:16\n   |\n17 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmpr1hhc3wj.rs:19:12\n   |\n19 |\
    \     s.push((quotient % base) as char);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpr1hhc3wj.rs:19:12\n   |\n19 |     s.push((quotient % base) as char);\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x > 0\
    \ {\n        let digit = x % base;\n        s += digit.to_string();\n        x\
    \ /= base;\n    }\n    if base == 10 {\n        s += '0';\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vztn_el.rs:15:14\n   |\n\
    15 |         s += digit.to_string();\n   |              ^^^^^^^^^^^^^^^^^\n  \
    \ |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&digit.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3vztn_el.rs:19:14\n   |\n19 |         s += '0';\n\
    \   |              ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n19 |         s += \"0\";\n\
    \   |              ~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut power = 1;\n    let mut digit = digits.get(0);\n    while digit !=\
    \ 0 {\n        if digit % base == 0 {\n            power = power * base;\n   \
    \     }\n        digit = digit / base;\n    }\n    power = power + 1;\n    while\
    \ power > 0 {\n        digit = digits.get(0);\n        if digit != 0 {\n     \
    \       digit = digit / base;\n        }\n        s = s.chars().collect::<Vec<_>>().join(\"\
    \") + &*s.chars().collect::<Vec<_>>().join(\"\");\n        power = power - 1;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7p69ou_s.rs:15:20\n   |\n\
    15 |     while digit != 0 {\n   |                    ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<&char>`\n            \
    \  found type `{integer}`\n\nerror[E0369]: cannot mod `Option<&char>` by `isize`\n\
    \  --> /tmp/tmp7p69ou_s.rs:16:18\n   |\n16 |         if digit % base == 0 {\n\
    \   |            ----- ^ ---- isize\n   |            |\n   |            Option<&char>\n\
    \nerror[E0369]: cannot divide `Option<&char>` by `isize`\n  --> /tmp/tmp7p69ou_s.rs:19:23\n\
    \   |\n19 |         digit = digit / base;\n   |                 ----- ^ ---- isize\n\
    \   |                 |\n   |                 Option<&char>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7p69ou_s.rs:24:21\n   |\n24 |         if digit != 0 {\n\
    \   |                     ^ expected enum `Option`, found integer\n   |\n   =\
    \ note: expected enum `Option<&char>`\n              found type `{integer}`\n\n\
    error[E0369]: cannot divide `Option<&char>` by `isize`\n  --> /tmp/tmp7p69ou_s.rs:25:27\n\
    \   |\n25 |             digit = digit / base;\n   |                     -----\
    \ ^ ---- isize\n   |                     |\n   |                     Option<&char>\n\
    \nerror[E0599]: the method `join` exists for struct `Vec<char>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp7p69ou_s.rs:27:43\n   |\n27 |     \
    \    s = s.chars().collect::<Vec<_>>().join(\"\") + &*s.chars().collect::<Vec<_>>().join(\"\
    \");\n   |                                           ^^^^ method cannot be called\
    \ on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[char]: Join<_>`\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<char>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp7p69ou_s.rs:27:86\n   |\n27 |         s = s.chars().collect::<Vec<_>>().join(\"\
    \") + &*s.chars().collect::<Vec<_>>().join(\"\");\n   |                      \
    \                                                                ^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n \
    \   }\n    for digit in digits.iter() {\n        *digit = *digit as char;\n  \
    \  }\n    s += digits.iter().map(|x| x as char).collect();\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp15xnlfm9.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp15xnlfm9.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15xnlfm9.rs:23:18\n\
    \   |\n23 |         *digit = *digit as char;\n   |         ------   ^^^^^^^^^^^^^^\
    \ expected `u8`, found `char`\n   |         |\n   |         expected due to the\
    \ type of this binding\n\nerror[E0277]: a value of type `&str` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp15xnlfm9.rs:25:43\n\
    \     |\n25   |     s += digits.iter().map(|x| x as char).collect();\n     | \
    \                                          ^^^^^^^ value of type `&str` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `&str`\n     = help: the following\
    \ other types implement trait `FromIterator<A>`:\n               <String as FromIterator<&'a\
    \ char>>\n               <String as FromIterator<&'a str>>\n               <String\
    \ as FromIterator<Box<str>>>\n               <String as FromIterator<Cow<'a, str>>>\n\
    \               <String as FromIterator<String>>\n               <String as FromIterator<char>>\n\
    note: required by a bound in `collect`\n\nerror[E0606]: casting `&u8` as `char`\
    \ is invalid\n  --> /tmp/tmp15xnlfm9.rs:25:32\n   |\n25 |     s += digits.iter().map(|x|\
    \ x as c"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] >= base[0] {\n  \
    \          res.push_str(&base[digits[i] - base[0]]);\n            i += 1;\n  \
    \      } else {\n            res.push_str(&digits[i]);\n            i += 1;\n\
    \        }\n    }\n    res.push_str(&digits[digits.len() - 1]);\n    res\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpxhj83vw7.rs:17:42\n\
    \   |\n17 |             res.push_str(&base[digits[i] - base[0]]);\n   |      \
    \                          --------- ^ ------- char\n   |                    \
    \            |\n   |                                char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxhj83vw7.rs:20:26\n   |\n20 |             res.push_str(&digits[i]);\n\
    \   |                          ^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxhj83vw7.rs:24:18\n   |\n24 |\
    \     res.push_str(&digits[digits.len() - 1]);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] > base {\n      \
    \      result.push_str(&base[digits[i] - base]);\n            i += 1;\n      \
    \  } else {\n            result.push_str(&digits[i]);\n            i += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkdra3axb.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0369]: cannot subtract `Vec<char>` from\
    \ `char`\n  --> /tmp/tmpkdra3axb.rs:17:45\n   |\n17 |             result.push_str(&base[digits[i]\
    \ - base]);\n   |                                   --------- ^ ---- Vec<char>\n\
    \   |                                   |\n   |                              \
    \     char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdra3axb.rs:20:29\n\
    \   |\n20 |             result.push_str(&digits[i]);\n   |                   \
    \          ^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    if quotient > 0 {\n        s = format!(\"{}\", quotient) + s;\n  \
    \  }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_065ule.rs:20:39\n   |\n\
    20 |         s = format!(\"{}\", quotient) + s;\n   |                        \
    \               ^\n   |                                       |\n   |        \
    \                               expected `&str`, found struct `String`\n   | \
    \                                      help: consider borrowing here: `&s`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x as usize;\n    let mut\
    \ base = base as usize;\n    while x >= base {\n        x /= base;\n        s\
    \ += &format!(\"{}\", x);\n    }\n    s += &format!(\"{}\", x);\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"311\"`,\n right: `\"100\"`', /tmp/tmp0dthtzuy.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits {\n        result = format!(\"{}{}\", result,\
    \ digit);\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgndhkoc4.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgndhkoc4.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    if quotient > 0 {\n        s = format!(\"{}\", s);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpo_jz1kjn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpebuuael3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += 1;\n\
    \        x -= base;\n    }\n    while x >= 1 {\n        digits[base - 1] += 1;\n\
    \        x -= 1;\n    }\n    for &d in &digits[..] {\n        s += char::from_u32(d\
    \ as u32).unwrap();\n    }\n    if carry > 0 {\n        s += char::from_u32(base).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbmtyeir.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmppbmtyeir.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmppbmtyeir.rs:19:9\n   |\n19 |         digits[base - 1] += 1;\n \
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppbmtyeir.rs:23:14\n   |\n23 |\
    \         s += char::from_u32(d as u32).unwrap();\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbmtyeir.rs:26:29\n\
    \   |\n26 |         s += char::from_u32(base).unwrap();\n   |                \
    \             ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n   |\n26\
    \ |         s += char::from_u32(base.try_into().unwrap()).unwrap();\n   |    \
    \                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppbmtyeir.rs:26:14\n   |\n26 |         s += char::from_u32(base).unwrap();\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remain = x;\n    let mut base\
    \ = base;\n    while remain > 0 {\n        if remain % base == 0 {\n         \
    \   s += &format!(\"{}\", base);\n            remain /= base;\n        } else\
    \ {\n            s += &format!(\"{}\", remain);\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in 0..digits.len() {\n        if digits[digit] == 0 {\n\
    \            result.push('_');\n        } else {\n            result.push(digits[digit].to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa1_rkdf9.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa1_rkdf9.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1_rkdf9.rs:23:25\n\
    \   |\n23 |             result.push(digits[digit].to_string());\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut base_size = base.len();\n    let\
    \ mut digits_size = digits.len();\n    let mut i = 0;\n    while i < digits_size\
    \ {\n        if digits[i] >= base_size\n            || (digits[i] < 0 && digits[i]\
    \ > base_size)\n        {\n            break;\n        }\n        let mut j =\
    \ i;\n        while j < digits_size && digits[j] == 0 {\n            j += 1; //\
    \ skip leading zeros\n        }\n        let mut digit = digits[j];\n        if\
    \ digit < 0 {\n            digit = digit + base_size;\n        }\n        if digit\
    \ > base_size {\n            digit = digit - base_size;\n        }\n        digit\
    \ = digit as usize;\n        digits[i] = digit;\n        i += 1;\n    }\n    digits.truncate(digits_size);\n\
    \    s = digits.to_string();\n    if base < 2 {\n        s = \"0\" + s;\n    }\n\
    \    if base < 10 {\n        s = &s[..1] + &s[1..];\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp13s9w5v0.rs:18:12\n\
    \   |\n18 |         if digits[i] >= base_size\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp13s9w5v0.rs:19:17\n   |\n19 |             || (digits[i] < 0 &&\
    \ digits[i] > base_size)\n   |                 ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp13s9w5v0.rs:19:34\n   |\n19 |             || (digits[i] < 0 &&\
    \ digits[i] > base_size)\n   |                                  ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::o"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0; base];\n   \
    \ let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n \
    \       digits[digit] += 1;\n        x /= base;\n    }\n    while x != 0 {\n \
    \       let digit = x % base;\n        digits[digit] += 1;\n        x /= base;\n\
    \    }\n    for &digit in &digits {\n        if digit > 0 {\n            s.push_str(&format!(\"\
    {}\", digit));\n        } else {\n            s.push_str(&format!(\"{}\", digit\
    \ as char));\n        }\n    }\n    if carry > 0 {\n        s.push_str(&format!(\"\
    {}\", carry));\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2265fwv4.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp2265fwv4.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp2265fwv4.rs:21:9\n   |\n21 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n\
    \  --> /tmp/tmp2265fwv4.rs:28:39\n   |\n28 |             s.push_str(&format!(\"\
    {}\", digit as char));\n   |                                       ^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp2265fwv4.rs:28:39\n   |\n28 |             s.push_str(&format!(\"{}\"\
    , digit as char));\n   |                                       ^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0604.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > base {\n        remainder -= base;\n\
    \        digits.insert(0, remainder);\n    }\n    while remainder < base {\n \
    \       remainder += base;\n        digits.insert(0, remainder);\n    }\n    s\
    \ += digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf14_vc76.rs:16:26\n   |\n\
    16 |         digits.insert(0, remainder);\n   |                          ^^^^^^^^^\
    \ expected `char`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf14_vc76.rs:20:26\n\
    \   |\n20 |         digits.insert(0, remainder);\n   |                       \
    \   ^^^^^^^^^ expected `char`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf14_vc76.rs:22:10\n   |\n22 |     s += digits;\n   |          ^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i];\n \
    \       if base > 10 {\n            digit *= base;\n            digits.remove(&i);\n\
    \            i += 1;\n        }\n        res.push_str(&digit);\n        i += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi46f6lpe.rs:17:19\n   |\n\
    17 |         if base > 10 {\n   |                   ^^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<char>`\n              \
    \  found type `{integer}`\n\nerror[E0368]: binary assignment operation `*=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpi46f6lpe.rs:18:13\n   |\n18 |     \
    \        digit *= base;\n   |             -----^^^^^^^^\n   |             |\n\
    \   |             cannot use `*=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi46f6lpe.rs:19:27\n   |\n19 |             digits.remove(&i);\n\
    \   |                           ^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n19 -             digits.remove(&i);\n19\
    \ +             digits.remove(i);\n   | \n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpi46f6lpe.rs:22:22\n   |\n22 |         res.push_str(&digit);\n  \
    \ |                      ^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut base_len = base.length();\n    while digits_len > base_len {\n  \
    \      digits.insert(0, base.chars().nth(digits_len - base_len).unwrap());\n \
    \       digits_len -= base_len;\n        base_len += 1;\n    }\n    while digits_len\
    \ < base_len {\n        digits.insert(0, base.chars().nth(digits_len).unwrap());\n\
    \        digits_len += 1;\n    }\n    digits.insert(0, base.chars().nth(digits_len).unwrap());\n\
    \    s.append(&digits);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0ndytq1e.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp0ndytq1e.rs:15:29\n\
    \   |\n15 |     let mut base_len = base.length();\n   |                      \
    \       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0ndytq1e.rs:26:7\n   |\n26 |     s.append(&digits);\n \
    \  |       ^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        let mut digit = remainder % base;\n\
    \        remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = base;\n    while remainder > 0 {\n        if remainder >= base {\n       \
    \     digits = base - digits;\n            remainder -= base;\n        }\n   \
    \     remainder /= base;\n        s.push((digits as char).to_string());\n    }\n\
    \    s.push((digits as char).to_string());\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcq37svxi.rs:20:16\n   |\n\
    20 |         s.push((digits as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpcq37svxi.rs:22:12\n   |\n22 |     s.push((digits as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpcq37svxi.rs:20:16\n\
    \   |\n20 |         s.push((digits as char).to_string());\n   |              \
    \  ^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead (via\
    \ a `u32`)\n  --> /tmp/tmpcq37svxi.rs:20:16\n   |\n20 |         s.push((digits\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpcq37svxi.rs:22:12\n\
    \   |\n22 |     s.push((digits as char).to_string());\n   |            ^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpcq37svxi.rs:22:12\n   |\n22 |     s.push((digits as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let digit = quotient % base;\n     \
    \   remainder = remainder - digit as isize;\n        s = format!(\"{}{}\", s,\
    \ digit);\n        quotient = quotient / base;\n    }\n    if remainder > 0 {\n\
    \        s = format!(\"{}\", remainder);\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"4\"`,\n right: `\"22\"`', /tmp/tmppfnq4dl5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digit);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp340f0hlo.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0isize; base];\n\
    \    let mut carry = 0;\n    for digit in &digits {\n        match x {\n     \
    \       0 => s.push_str(&format!(\"{}\", digit)),\n            n => {\n      \
    \          let mut new_digit = digit + carry + 1;\n                carry = new_digit\
    \ / base;\n                new_digit %= base;\n                s.push_str(&format!(\"\
    {}\", new_digit));\n            }\n        }\n    }\n    if carry > 0 {\n    \
    \    s.push_str(&format!(\"{}\", carry));\n    }\n    s\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpld6eybsn.rs:12:35\n   |\n\
    12 |     let mut digits = vec![0isize; base];\n   |                          \
    \         ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n12\
    \ |     let mut digits = vec![0isize; base.try_into().unwrap()];\n   |       \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = base.len();\n    while i >= 0 {\n        if carry\
    \ > 0 {\n            digits[i] = '0';\n        }\n        digits[i] = digits[i]\
    \ - base + carry;\n        carry = 0;\n        if digits[i] >= 10 {\n        \
    \    digits[i] -= 10;\n            carry++;\n        }\n        i--;\n    }\n\
    \    for i in 0..digits.len() {\n        if digits[i] >= 10 {\n            digits[i]\
    \ += '0';\n            carry++;\n        }\n    }\n    for i in 0..digits.len()\
    \ {\n        if digits[i] < 10 {\n            digits[i] += '0';\n            carry++;\n\
    \        }\n    }\n    for i in 0..digits.len() {\n        if digits[i] == 0 {\n\
    \            digits[i] = '0';\n        }\n    }\n    for i in 0..digits.len()\
    \ {\n        s += digits[i].to_string();\n    }\n    if carry > 0 {\n        s\
    \ += &format!(\"{}\", carry);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpautt6_j8.rs:24:18\n\
    \   |\n24 |             carry++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |             { let tmp =\
    \ carry; carry += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    24 -             carry++;\n24 +             carry += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmpautt6_j8.rs:26:12\n   |\n26 |         i--;\n\
    \   |            ^ expected expression\n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpautt6_j8.rs:31:18\n   |\n31 |             carry++;\n\
    \   |                  ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n31 |             { let tmp = carry; carry += 1; tmp };\n   |\
    \             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n31 -             carry++;\n\
    31 +             carry += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpautt6_j8.rs:37:18\n   |\n37 |             carry++;\n   |      \
    \            ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n37 |             { let tmp = carry; carry += 1; tmp };\n   |          \
    \   +++++++++++      ~~~~~~~~~~~~~~~~~~~\n37 -             carry++;\n37 +    \
    \         carry += 1;\n   | \n\nerror[E0369]: cannot subtract `Vec<char>` from\
    \ `char`\n  --> /tmp/tmpautt6_j8.rs:20:31\n   |\n20 |         digits[i] = digits[i]\
    \ - base + carry;\n   |                     --------- ^ ---- Vec<char>\n   | \
    \                    |\n   |                     char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpautt6_j8.rs:22:25\n   |\n22 |         if digits[i] >= 10\
    \ {\n   |                         ^^ expected `char`, found `u8`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `char`\n  --> /tmp/tmpautt6_j8.rs:23:13\n\
    \   |\n23 |             digits[i] -= 10;\n   |             ---------^^^^^^\n \
    \  |             |\n   |             cannot use `-=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpautt6_j8.rs:29:25\n   |\n29 |         if digits[i]\
    \ >= 10 {\n   |                         ^^ expected"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    while\
    \ remainder > 0 {\n        let digit = remainder % base;\n        remainder =\
    \ remainder / base;\n        result = format!(\"{}{}\", digit, result);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut bases = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 1;\n    while i < digits.len() {\n        let mut\
    \ digit = digits[i];\n        if digit == '0' {\n            digit = bases[i -\
    \ 1];\n            carry = 0;\n        } else {\n            carry = (digit as\
    \ i32 + carry) as u8;\n            digit = digit as u8;\n        }\n        res.push_str(&format!(\"\
    {}{}\", digit, carry));\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_n_gbfd.rs:22:21\n   |\n\
    14 |     let mut carry = 0;\n   |                     - expected due to this value\n\
    ...\n22 |             carry = (digit as i32 + carry) as u8;\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5_n_gbfd.rs:23:21\n   |\n17 |         let mut\
    \ digit = digits[i];\n   |                         --------- expected due to this\
    \ value\n...\n23 |             digit = digit as u8;\n   |                    \
    \ ^^^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0; base];\n   \
    \ let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n \
    \       digits[digit] += 1;\n        x /= base;\n    }\n    for digit in digits\
    \ {\n        if digit > 0 {\n            s.push_str(&format!(\"{}\", digit));\n\
    \        }\n    }\n    if carry > 0 {\n        s.push_str(&format!(\"{}\", carry));\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqthh0_jf.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpqthh0_jf.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp1nk880fb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut basedigits = base.to_string().chars().collect::<Vec<_>>();\n    let\
    \ mut carry = 0;\n    while basedigits.len() > 0 {\n        let mut digit = digits.remove(0);\n\
    \        let mut basedigit = basedigits.remove(0);\n        if digit < basedigit\
    \ {\n            carry = 1;\n            digit += basedigit as isize;\n      \
    \  }\n        s += digit.to_string();\n        if carry != 0 {\n            s\
    \ += '1';\n            carry = 0;\n        }\n    }\n    if carry != 0 {\n   \
    \     s += '1';\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmp1ibvzmrv.rs:20:13\n   |\n20 |             digit += basedigit\
    \ as isize;\n   |             -----^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1ibvzmrv.rs:22:14\n   |\n22 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ibvzmrv.rs:24:18\n\
    \   |\n24 |             s += '1';\n   |                  ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n24 |             s += \"1\";\n   |                  ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1ibvzmrv.rs:29:14\n   |\n29 |         s += '1';\n\
    \   |              ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n29 |         s += \"1\";\n\
    \   |              ~~~\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut digits = String::new();\n    while remainder > 0 {\n        let digit =\
    \ remainder % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits.drain(..) {\n        result.push_str(digit);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpig95x_au.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpig95x_au.rs:20:25\n   |\n20 |         result.push_str(digit);\n\
    \   |                         ^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x >=\
    \ base {\n        s +=\n            format!(\"{:0{}b}\", x % base, base).to_string();\n\
    \        x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpjbyt2v46.rs:15:25\n\
    \   |\n15 |             format!(\"{:0{}b}\", x % base, base).to_string();\n  \
    \ |                      -  ^ expected `}` in format string\n   |            \
    \          |\n   |                      because of this opening brace\n   |\n\
    \   = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpjbyt2v46.rs:19:21\n\
    \   |\n19 |         format!(\"{:0{}b}\", x, base).to_string();\n   |         \
    \         -  ^ expected `}` in format string\n   |                  |\n   |  \
    \                because of this opening brace\n   |\n   = note: if you intended\
    \ to print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] == base[0] {\n  \
    \          s.push_str(&base[1..]);\n            i += 1;\n        } else {\n  \
    \          s.push_str(&digits[i..]);\n            i += 1;\n        }\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdsmtesvm.rs:17:24\n   |\n\
    17 |             s.push_str(&base[1..]);\n   |                        ^^^^^^^^^^\
    \ expected `str`, found slice `[char]`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&[char]`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdsmtesvm.rs:20:24\n   |\n20 |             s.push_str(&digits[i..]);\n\
    \   |                        ^^^^^^^^^^^^ expected `str`, found slice `[char]`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&[char]`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base10 = base.to_string();\n    let mut base10_digits = base10.to_string();\n\
    \    let mut base10_digits_len = base10_digits.length();\n    let mut base10_digits_power\
    \ = base10_digits_len as isize;\n    let mut base10_digits_power = base10_digits_power\
    \ as isize;\n    let mut base10_digits_power = base10_digits_power as isize;\n\
    \    let mut base10_digits_power = base10_digits_power as isize;\n    let mut\
    \ base10_digits_power = base10_digits_power as isize;\n    let mut base10_digits_power\
    \ = base10_digits_power as isize;\n    let mut base10_digits_power = base10_digits_power\
    \ as isize;\n    let mut base10_digits_power = base10_digits_power as isize;\n\
    \    let mut base10_digits_power = base10_digits_power as isize;\n    let mut\
    \ base10_digits_power = base10_digits_power as isize;\n    let mut base10_digits_power\
    \ = base10_digits_power as isize;\n    let mut base10_digits_power = base10_digits_power\
    \ as isize;\n    let mut base10_digits_power = base10_digits_power as isize;\n\
    \    let mut base10_digits_power = base10_digits_power as isize;\n    let mut\
    \ base10_digits_power = base10_digits_power as isize;\n    let mut base10_digits_power\
    \ = base10_digits_power as isize;\n    let mut base10_digits_power = base10_digits_power\
    \ as isize;\n    let mut base10_digits_power = base10_digits_power as isize;\n\
    \    let mut base10_digits_power = base10_digits_power as isize;\n    let mut\
    \ base10_digits_power = base10_digits_power as isize;\n    let mut base10_digits_power\
    \ = base10_digits_power as isize;\n    let mut base10_digits_power = base10_digits_power\
    \ as isize;\n    let mut base10_digits_power = base10_digits_power as isize;\n\
    \    let mut base10_digits_power = base10_digits_power as isize;\n    let mut\
    \ base10_digits_power = base10_digits_power as isize;\n    let mut base10_digits_power\
    \ = \n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpbbipyf5c.rs:42:1\n\
    \   |\n42 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpbbipyf5c.rs:15:47\n\
    \   |\n15 |     let mut base10_digits_len = base10_digits.length();\n   |    \
    \                                           ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        digits[base - 1] += 1;\n\
    \        x -= base;\n    }\n    while x != 0 {\n        digits[base - 1] += 1;\n\
    \        x /= base;\n    }\n    for i in 0..digits.len() {\n        if digits[i]\
    \ > 0 {\n            s.push_str(&format!(\"{}\", digits[i]));\n        } else\
    \ {\n            s.push_str(&format!(\"0\"));\n        }\n    }\n    if carry\
    \ != 0 {\n        s.push_str(&format!(\"{}\", carry));\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7xg3ljt7.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp7xg3ljt7.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp7xg3ljt7.rs:19:9\n   |\n19 |         digits[base - 1] += 1;\n \
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut basedigits = digits.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    basedigits.reverse();\n    let mut i = 0;\n    while i < basedigits.len()\
    \ {\n        if basedigits[i] == base {\n            basedigits[i] = '0';\n  \
    \      } else {\n            basedigits[i] = '1';\n        }\n        i += 1;\n\
    \    }\n    s += &basedigits.join(\"\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jrio1rb.rs:17:29\n   |\n\
    17 |         if basedigits[i] == base {\n   |                             ^^^^\
    \ expected `char`, found `isize`\n\nerror[E0599]: the method `join` exists for\
    \ struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmp7jrio1rb.rs:24:22\n\
    \   |\n24 |     s += &basedigits.join(\"\");\n   |                      ^^^^ method\
    \ cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0u8; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n \
    \   }\n    for i in 0..digits.len() {\n        if digits[i] < 10 {\n         \
    \   result.push_str(&format!(\"{}\", digits[i]));\n        } else {\n        \
    \    result.push_str(&format!(\"{}\", digits[i] - 10));\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyqzdj9b2.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpyqzdj9b2.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut base = base.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut base_len = base.len();\n    while digits_len > base_len {\n     \
    \   digits = digits.chars().nth(digits_len).unwrap().to_string();\n        base\
    \ = base.chars().nth(base_len).unwrap().to_string();\n        digits_len -= 1;\n\
    \        base_len -= 1;\n    }\n    while digits_len < base_len {\n        digits\
    \ = digits.chars().nth(digits_len).unwrap().to_string();\n        base = base.chars().nth(base_len).unwrap().to_string();\n\
    \        digits_len += 1;\n        base_len += 1;\n    }\n    digits = digits.chars().nth(digits_len).unwrap().to_string();\n\
    \    base = base.chars().nth(base_len).unwrap().to_string();\n    s += digits;\n\
    \    s += base;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n \
    \   assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpf6h5q20_.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf6h5q20_.rs:30:10\n   |\n30 |     s += digits;\n   |  \
    \        ^^^^^^\n   |          |\n   |          expected `&str`, found struct\
    \ `String`\n   |          help: consider borrowing here: `&digits`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf6h5q20_.rs:31:10\n   |\n31 |     s += base;\n\
    \   |          ^^^^\n   |          |\n   |          expected `&str`, found struct\
    \ `String`\n   |          help: consider borrowing here: `&base`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    let mut i = 0;\n    while i < digits.len() {\n        let mut\
    \ digit = digits[i];\n        if digit == '0' {\n            digit = base.len()\
    \ - i;\n            carry = 0;\n        } else {\n            digit = digit.to_digit(base.len());\n\
    \            carry = (digit as i32 + carry) as i32;\n        }\n        result\
    \ += digit.to_string();\n        i += 1;\n    }\n    if carry > 0 {\n        result\
    \ += '1';\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpic9eqje9.rs:19:21\n   |\n\
    17 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n18 |         if digit == '0' {\n19 |           \
    \  digit = base.len() - i;\n   |                     ^^^^^^^^^^^^^^ expected `char`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpic9eqje9.rs:22:36\n\
    \   |\n22 |             digit = digit.to_digit(base.len());\n   |            \
    \                        ^^^^^^^^^^ expected `u32`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n22 |             digit = digit.to_digit(base.len().try_into().unwrap());\n\
    \   |                                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpic9eqje9.rs:22:21\n   |\n17 |         let mut\
    \ digit = digits[i];\n   |                         --------- expected due to this\
    \ value\n...\n22 |             digit = digit.to_digit(base.len());\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<u32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpic9eqje9.rs:25:19\n   |\n25 |\
    \         result += digit.to_string();\n   |                   ^^^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&str`, found struct\
    \ `String`\n   |                   help: consider borrowing here: `&digit.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpic9eqje9.rs:29:19\n   |\n29 |\
    \         result += '1';\n   |                   ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    29 |         result += \"1\";\n   |                   ~~~\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = vec![0u8; base];\n \
    \   let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] += 1;\n\
    \    }\n    for digit in digits.iter_mut() {\n        *digit = *digit + 1;\n \
    \   }\n    for digit in digits.iter() {\n        if *digit == 0 {\n          \
    \  *digit = base;\n        }\n    }\n    for digit in digits.iter() {\n      \
    \  if *digit > base {\n            *digit = *digit - base;\n        }\n    }\n\
    \    s += digits.iter().cloned().collect();\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8qbr4rm_.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp8qbr4rm_.rs:17:9\n   |\n17 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qbr4rm_.rs:24:22\n\
    \   |\n24 |             *digit = base;\n   |             ------   ^^^^ expected\
    \ `u8`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qbr4rm_.rs:28:21\n\
    \   |\n28 |         if *digit > base {\n   |                     ^^^^ expected\
    \ `u8`, found `isize`\n   |\nhelp: you can convert `*digit` from `u8` to `isize`,\
    \ matching the type of `base`\n   |\n28 |         if isize::from(*digit) > base\
    \ {\n   |            ++++++++++++      +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp8qbr4rm_.rs:29:31\n   |\n29 |             *digit = *digit - base;\n\
    \   |                               ^^^^ expected `u8`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `u8`\n  --> /tmp/tmp8qbr4rm_.rs:29:29\n   |\n29\
    \ |             *digit = *digit - base;\n   |                             ^ no\
    \ implementation for `u8 - isize`\n   |\n   = help: the trait `Sub<isize>` is\
    \ not implemented for `u8`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n         "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if base == 0 {\n            res.push_str(&digits[i]);\n\
    \            i += 1;\n        } else {\n            let mut carry = 0;\n     \
    \       let mut j = i;\n            while j < digits.len() && digits[j] == base[j]\
    \ {\n                j += 1;\n            }\n            if j == digits.len()\
    \ {\n                res.push_str(&digits[i]);\n                i += 1;\n    \
    \        } else {\n                while j < digits.len() {\n                \
    \    let mut tmp = digits[j];\n                    digits[j] = digits[j] + carry;\n\
    \                    carry = tmp % base;\n                    j += 1;\n      \
    \          }\n                if carry != 0 {\n                    res.push_str(&digits[i]);\n\
    \                    i += 1;\n                }\n            }\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpv3nc_1ze.rs:16:17\n\
    \   |\n16 |         if base == 0 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv3nc_1ze.rs:17:26\n   |\n17 |             res.push_str(&digits[i]);\n\
    \   |                          ^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv3nc_1ze.rs:26:30\n   |\n26 |\
    \                 res.push_str(&digits[i]);\n   |                            \
    \  ^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmpv3nc_1ze.rs:31:43\n   |\n31 |                     digits[j]\
    \ = digits[j] + carry;\n   |                                 --------- ^ -----\
    \ {integer}\n   |                                 |\n   |                    \
    \             char\n\nerror[E0369]: cannot mod `char` by `Vec<char>`\n  --> /tmp/tmpv3nc_1ze.rs:32:33\n\
    \   |\n32 |                     carry = tmp % base;\n   |                    \
    \         --- ^ ---- Vec<char>\n   |                             |\n   |     \
    \                        char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv3nc_1ze.rs:36:34\n\
    \   |\n36 |                     res.push_str(&digits[i]);\n   |              \
    \                    ^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detaile"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        remainder *= base;\n        s += char::from_u32(x as u32).unwrap();\n\
    \    }\n    s + char::from_u32(x as u32).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgbl9vxv.rs:15:14\n   |\n\
    15 |         s += char::from_u32(x as u32).unwrap();\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjgbl9vxv.rs:17:9\n\
    \   |\n17 |     s + char::from_u32(x as u32).unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = 1;\n    while remainder > 0 {\n        if remainder >= base {\n          \
    \  digits = digits * base + remainder - base;\n            remainder = 0;\n  \
    \      } else {\n            remainder = remainder / base;\n        }\n    }\n\
    \    if remainder > 0 {\n        digits = digits * base + remainder;\n    }\n\
    \    for _ in 0..digits {\n        s.push('0');\n    }\n    s.push((x as u32).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9vx_nhbo.rs:28:12\n   |\n\
    28 |     s.push((x as u32).to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if base == 0 {\n            s.push_str(&digits[i\
    \ as usize]);\n            i += 1;\n        } else {\n            let mut j =\
    \ i;\n            while j < digits.len() && base != 0 {\n                let mut\
    \ c = digits[j as usize];\n                let mut k = j;\n                while\
    \ k < digits.len() && digits[k as usize] == c {\n                    k += 1;\n\
    \                }\n                let mut base = base.to_string().chars().collect::<Vec<_>>();\n\
    \                base[k] = c;\n                s.push_str(&base);\n          \
    \      i += 1;\n                j += 1;\n            }\n        }\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpnqw3gwe4.rs:16:17\n\
    \   |\n16 |         if base == 0 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnqw3gwe4.rs:17:24\n   |\n17 |             s.push_str(&digits[i\
    \ as usize]);\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmpnqw3gwe4.rs:21:44\n   |\n21 |             while j < digits.len()\
    \ && base != 0 {\n   |                                            ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: `Vec<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpnqw3gwe4.rs:27:37\n  \
    \  |\n27  |                   let mut base = base.to_string().chars().collect::<Vec<_>>();\n\
    \    |                                       ^^^^^^^^^ `Vec<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: std::fmt::Display`\n            which\
    \ is required by `Vec<char>: ToString"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = 0;\n    while x >=\
    \ base {\n        remainder = x % base;\n        x /= base;\n        s += char::from_u32(x\
    \ as u32 + remainder).unwrap();\n    }\n    s += char::from_u32(x as u32 + remainder).unwrap();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj96gan22.rs:16:40\n   |\n\
    16 |         s += char::from_u32(x as u32 + remainder).unwrap();\n   |       \
    \                                 ^^^^^^^^^ expected `u32`, found `isize`\n\n\
    error[E0277]: cannot add `isize` to `u32`\n  --> /tmp/tmpj96gan22.rs:16:29\n \
    \  |\n16 |         s += char::from_u32(x as u32 + remainder).unwrap();\n   | \
    \             -------------- ^^^^^^^^^^^^^^^^^^^^ no implementation for `u32 +\
    \ isize`\n   |              |\n   |              required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Add<isize>` is not implemented for\
    \ `u32`\n   = help: the following other types implement trait `Add<Rhs>`:\n  \
    \           <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n      \
    \       <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n        \
    \     <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n            \
    \ <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj96gan22.rs:16:14\n\
    \   |\n16 |         s += char::from_u32(x as u32 + remainder).unwrap();\n   |\
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj96gan22.rs:18:36\n\
    \   |\n18 |     s += char::from_u32(x as u32 + remainder).unwrap();\n   |    \
    \                                ^^^^^^^^^ expected `u32`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `u32`\n  --> /tmp/tmpj96gan22.rs:18:25\n   |\n18 |   \
    \  s += char::from_u32(x as u32 + remainder).unwrap();\n   |          --------------\
    \ ^^^^^^^^^^^^^^^^^^^^ no implementation for `u32 + isize`\n   |          |\n\
    \   |          required by a bound introduced by this call\n   |\n   = help: the\
    \ trait `Add<isize>` is not implemented for `u32`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n          \
    \   <&'a i64 a"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ carry = 0;\n    while digits.len() > 0 {\n        let mut digit = digits.remove(0);\n\
    \        if base == 2 {\n            if carry > 0 {\n                digit +=\
    \ &'0' + &'1';\n            }\n            digit += &'0';\n            carry =\
    \ 0;\n        } else {\n            if carry > 0 {\n                digit += &'0'\
    \ + &'1';\n            }\n            digit += &'0';\n            carry = 0;\n\
    \        }\n        s += digit;\n    }\n    if carry > 0 {\n        s += &'1';\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmp9dnyokdo.rs:17:17\n\
    \   |\n17 |         if base == 2 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0369]: cannot add\
    \ `&char` to `&char`\n  --> /tmp/tmp9dnyokdo.rs:19:31\n   |\n19 |            \
    \     digit += &'0' + &'1';\n   |                          ---- ^ ---- &char\n\
    \   |                          |\n   |                          &char\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp9dnyokdo.rs:21:13\n\
    \   |\n21 |             digit += &'0';\n   |             -----^^^^^^^^\n   | \
    \            |\n   |             cannot use `+=` on type `char`\n\nerror[E0369]:\
    \ cannot add `&char` to `&char`\n  --> /tmp/tmp9dnyokdo.rs:25:31\n   |\n25 | \
    \                digit += &'0' + &'1';\n   |                          ---- ^ ----\
    \ &char\n   |                          |\n   |                          &char\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `char`\n\
    \  --> /tmp/tmp9dnyokdo.rs:27:13\n   |\n27 |             digit += &'0';\n   |\
    \             -----^^^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9dnyokdo.rs:30:14\n\
    \   |\n30 |         s += digit;\n   |              ^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9dnyokdo.rs:33:14\n\
    \   |\n33 |         s += &'1';\n   |              ^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed e"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut power = 1;\n    while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.len()\
    \ - 1);\n        if digit == '0' {\n            power = 1;\n        } else {\n\
    \            power = base;\n        }\n        s += digit.to_string();\n     \
    \   digits -= digit;\n    }\n    power.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm86d7xcj.rs:16:21\n   |\n\
    16 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n16 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0599]:\
    \ `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmpm86d7xcj.rs:21:20\n\
    \    |\n21  |           s += digit.to_string();\n    |                      ^^^^^^^^^\
    \ `Option<char>` cannot be formatted with the default formatter\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ std::fmt::Display`\n            which is required by `Option<char>: ToString`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `String`\n\
    \  --> /tmp/tmpm86d7xcj.rs:22:9\n   |\n22 |         digits -= digit;\n   |   \
    \      ------^^^^^^^^^\n   |         |\n   |         cannot use `-=` on type `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0; base];\n \
    \   let mut carry = 0;\n    while x >= base {\n        let digit = x % base;\n\
    \        digits[digit] += 1;\n        x /= base;\n    }\n    for digit in digits\
    \ {\n        if digit > 0 {\n            res.push_str(&format!(\"{}\", digit));\n\
    \        } else {\n            res.push_str(&format!(\"0\"));\n        }\n   \
    \ }\n    if carry > 0 {\n        res.push_str(&format!(\"{}\", carry));\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ghyrcq0.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_ghyrcq0.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    if quotient == 0 {\n        s = format!(\"{}\", remainder);\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8\"`,\n right: `\"22\"`', /tmp/tmp6i2j1rxq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_string();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        result = format!(\"\
    {}{}\", digits, digit);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpl7d7v8f9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        remainder %= base;\n        s +=\
    \ char::from_u32(base).unwrap();\n        base /= base;\n    }\n    s += char::from_u32(base).unwrap();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitb3_t__.rs:16:29\n   |\n\
    16 |         s += char::from_u32(base).unwrap();\n   |                       \
    \      ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n16 |        \
    \ s += char::from_u32(base.try_into().unwrap()).unwrap();\n   |              \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpitb3_t__.rs:16:14\n   |\n16 |         s += char::from_u32(base).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpitb3_t__.rs:19:25\n   |\n19 |\
    \     s += char::from_u32(base).unwrap();\n   |                         ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n19 |     s += char::from_u32(base.try_into().unwrap()).unwrap();\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpitb3_t__.rs:19:10\n   |\n19 |     s += char::from_u32(base).unwrap();\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut base\
    \ = base;\n    while remainder > 0 {\n        let mut digit = remainder % base;\n\
    \        remainder = remainder / base;\n        s = format!(\"{}{}\", digit, s);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digit, s);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut remainder = x;\n    let\
    \ mut digits = vec![0u8; base];\n    while remainder > 0 {\n        let digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        digits[digit]\
    \ = 1;\n    }\n    for digit in digits {\n        if digit == 0 {\n          \
    \  result.push('-');\n        } else {\n            result.push((digit as char).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbuygvbx0.rs:13:32\n   |\n\
    13 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n13 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpbuygvbx0.rs:17:9\n   |\n17 |         digits[digit]\
    \ = 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuygvbx0.rs:23:25\n\
    \   |\n23 |             result.push((digit as char).to_string());\n   |      \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut digits = x.to_string();\n   \
    \ let mut remainder = x;\n    while remainder > 0 {\n        let mut digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    for digit in digits {\n        s.push(digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyl2asnru.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpyl2asnru.rs:19:18\n   |\n19 |     for digit in digits {\n   | \
    \                 ^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = vec![0; base];\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        digits[digit] = 1;\n\
    \    }\n    for digit in digits {\n        if digit == 0 {\n            result.push('-');\n\
    \        } else {\n            result.push((digit as char).to_string());\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwj8pzok2.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwj8pzok2.rs:17:9\n   |\n17 |         digits[digit]\
    \ = 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwj8pzok2.rs:23:25\n\
    \   |\n23 |             result.push((digit as char).to_string());\n   |      \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n\
    \  --> /tmp/tmpwj8pzok2.rs:23:25\n   |\n23 |             result.push((digit as\
    \ char).to_string());\n   |                         ^^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpwj8pzok2.rs:23:25\n\
    \   |\n23 |             result.push((digit as char).to_string());\n   |      \
    \                   ^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut quotient\
    \ = x;\n    while quotient > 0 {\n        let remainder = quotient % base;\n \
    \       quotient = quotient / base;\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpvc4jn895.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n    while x >=\
    \ base {\n        s +=\n            format!(\"{}\", x / base).to_string().chars().collect::<String>().to_string();\n\
    \        x %= base;\n        base /= base;\n    }\n    s +=\n        format!(\"\
    {}\", x).to_string().chars().collect::<String>().to_string();\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxqou089l.rs:15:13\n   |\n\
    15 |             format!(\"{}\", x / base).to_string().chars().collect::<String>().to_string();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             expected `&str`, found struct `String`\n\
    \   |             help: consider borrowing here: `&format!(\"{}\", x / base).to_string().chars().collect::<String>().to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxqou089l.rs:20:9\n   |\n20 | \
    \        format!(\"{}\", x).to_string().chars().collect::<String>().to_string();\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         expected `&str`, found struct `String`\n   |   \
    \      help: consider borrowing here: `&format!(\"{}\", x).to_string().chars().collect::<String>().to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut x = x.to_digits();\n    let mut\
    \ base = base.to_digits();\n    while x.len() > 0 {\n        if x.len() > base\
    \ {\n            s.push_str(&x[..base]);\n            x = &x[base..];\n      \
    \  } else {\n            s.push_str(&x[..]);\n            break;\n        }\n\
    \    }\n    s.push_str(&x[..]);\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpofij7kvn.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpofij7kvn.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut digits\
    \ = vec![];\n    while remainder > 0 {\n        let digit = remainder % base;\n\
    \        remainder = remainder / base;\n        digits.push(digit);\n    }\n \
    \   for digit in digits {\n        s.push((digit as char).to_string());\n    }\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpih8l_6b7.rs:20:16\n   |\n\
    20 |         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpih8l_6b7.rs:20:16\n   |\n20 |        \
    \ s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpih8l_6b7.rs:20:16\n\
    \   |\n20 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0604.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
