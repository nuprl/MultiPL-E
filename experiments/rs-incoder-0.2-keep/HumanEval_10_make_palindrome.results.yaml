name: HumanEval_10_make_palindrome
language: rust
results:
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    for c in string.chars()\
    \ {\n        if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n        }\n    }\n    for c in string.chars() {\n        if longest_postfix_length\
    \ == c.len() {\n            reversed_string += &c.to_ascii_lowercase();\n    \
    \    }\n    }\n    reversed_string += &string[longest_postfix_length..].to_ascii_lowercase();\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdrnmibq6.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdrnmibq6.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdrnmibq6.rs:20:40\n   |\n20 |         if longest_postfix_length\
    \ == c.len() {\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpdrnmibq6.rs:21:13\n   |\n21 |             reversed_string\
    \ += &c.to_ascii_lowercase();\n   |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpdrnmibq6.rs:24:5\n\
    \   |\n24 |     reversed_string += &string[longest_postfix_length..].to_ascii_lowercase();\n\
    \   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdrnmibq6.rs:25:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n25 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnagnvn7a.rs:55:41\n   |\n\
    55 |     let mut longest_postfix_char_length_\n   |                          \
    \               ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnagnvn7a.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix = 0;\n    let mut longest_postfix_length_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_index = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo8yvkls_.rs:40:64\n   |\n\
    40 |     let mut longest_postfix_length_suffix_suffix_suffix_suffix_\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo8yvkls_.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut postfix = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp27lkir3.rs:63:25\n   |\n\
    63 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp27lkir3.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_len_index\
    \ = 0;\n    let mut longest_postfix_len_index_start = 0;\n    let mut longest_postfix_len_index_end\
    \ = 0;\n    let mut longest_postfix_len_index_start2 = 0;\n    let mut longest_postfix_len_index_end2\
    \ = 0;\n    let mut longest_postfix_len_index_start3 = 0;\n    let mut longest_postfix_len_index_end3\
    \ = 0;\n    let mut longest_postfix_len_index_start4 = 0;\n    let mut longest_postfix_len_index_end4\
    \ = 0;\n    let mut longest_postfix_len_index_start5 = 0;\n    let mut longest_postfix_len_index_end5\
    \ = 0;\n    let mut longest_postfix_len_index_start6 = 0;\n    let mut longest_postfix_len_index_end6\
    \ = 0;\n    let mut longest_postfix_len_index_start7 = 0;\n    let mut longest_postfix_len_index_end7\
    \ = 0;\n    let mut longest_postfix_len_index_start8 = 0;\n    let mut longest_postfix_len_index_end8\
    \ = 0;\n    let mut longest_postfix_len_index_start9 = 0;\n    let mut longest_postfix_len_index_end9\
    \ = 0;\n    let mut longest_postfix_len_index_start10 = 0;\n    let mut longest_postfix_len_index_end10\
    \ = 0;\n    let mut longest_postfix_len_index_start11 = 0;\n    let mut longest_postfix_len_index_end11\
    \ = 0;\n    let mut longest_postfix_len_index_start12 = 0;\n    let mut longest_postfix_len_index_end12\
    \ = 0;\n    let mut longest_postfix_len_index_start13 = 0;\n    let mut longest_postfix_len_index_end13\
    \ = 0;\n    let mut longest_postfix_len_index_start14 = 0;\n    let mut longest_postfix_len_index_end14\
    \ = 0;\n    let mut longest_postfix_len_index_start15 = 0;\n    let mut longest_postfix_len_index_end15\
    \ = 0;\n    let mut longest_postfix_len_index_start16 = 0;\n    let mut longest_postfix_len_index_end16\
    \ = 0;\n    let mut longest_postfix_len_index_start17 = 0;\n    let mut longest_postfix_len_index_end17\
    \ = 0;\n    let mut longest_postfix_len_index_start18 = 0;\n    let mut longest_postfix_len_index_end18\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1p7oemjm.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1p7oemjm.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length = 0;\n    while longest_postfix_length\
    \ < string.len() {\n        let mut postfix_index = longest_postfix_index;\n \
    \       let mut postfix_length = longest_postfix_length;\n        while postfix_length\
    \ < string.len() {\n            let mut postfix_char = string[postfix_index];\n\
    \            while postfix_char == string[postfix_index] {\n                postfix_index\
    \ += 1;\n                postfix_length += 1;\n            }\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_index = postfix_index;\n    \
    \    }\n        reversed_string += &string[longest_postfix_index..];\n    }\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp92f9_qki.rs:20:36\n   |\n20 |             let mut postfix_char = string[postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp92f9_qki.rs:21:35\n   |\n21 |             while postfix_char ==\
    \ string[postfix_index] {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_prefix;\n    let mut longest_palindrome_suffix;\n\
    \    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix;\n    let mut longest_palindrome_prefix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix;\n    let mut longest_palindrome_prefix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix;\n    let mut\
    \ longest_palindrome_prefix_suffix_suffix_suffix_length = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_length = 0;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix;\n \
    \   let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvriwogs7.rs:37:100\n   |\n\
    37 |     let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffi\n\
    \   |                                                                        \
    \                            ^ help: add `;` here\n38 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvriwogs7.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmph9u68xvd.rs:60:1\n  \
    \ |\n60 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_index = string.len()\
    \ - suffix_length;\n        while suffix_index >= 0 {\n            let mut suffix_char\
    \ = string[suffix_index];\n            suffix_index -= 1;\n            if suffix_char\
    \ == reversed_string[suffix_index] {\n                suffix_length += 1;\n  \
    \          } else {\n                break;\n            }\n        }\n      \
    \  let mut prefix_index = suffix_length - 1;\n        while prefix_index >= 0\
    \ {\n            let mut prefix_char = string[prefix_index];\n            prefix_index\
    \ -= 1;\n            if prefix_char == reversed_string[prefix_index] {\n     \
    \           prefix_length += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if prefix_length >= suffix_length {\n     \
    \       break;\n        }\n        reversed_string.push_str(&string[prefix_length..suffix_length]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm_go2lmq.rs:18:35\n\
    \   |\n18 |             let mut suffix_char = string[suffix_index];\n   |    \
    \                               ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm_go2lmq.rs:20:31\n   |\n20 |             if suffix_char == reversed_string[suffix_index]\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm_go2lmq.rs:28:35\n   |\n28 |             let mut prefix_char =\
    \ string[prefix_index];\n   |                                   ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<R"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        let mut suffix_end = suffix_length;\n        while suffix_end < string.len()\
    \ {\n            if string[suffix_end] != string[suffix_end - 1] {\n         \
    \       break;\n            }\n            suffix_end += 1;\n        }\n     \
    \   let mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_end < string.len() {\n            if string[prefix_end]\
    \ != string[prefix_end - 1] {\n                break;\n            }\n       \
    \     prefix_end += 1;\n        }\n        if suffix_start < prefix_end {\n  \
    \          suffix_length = suffix_end;\n            prefix_length = prefix_end;\n\
    \        } else {\n            suffix_length = suffix_start;\n            prefix_length\
    \ = prefix_start;\n        }\n        reversed_string.push_str(&string[prefix_length..suffix_length]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23coseb0.rs:19:16\n\
    \   |\n19 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23coseb0.rs:19:38\n   |\n19 |             if string[suffix_end]\
    \ != string[suffix_end - 1] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23coseb0.rs:27:16\n   |\n27 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string[0];\n\
    \        reversed_string = reversed_string.chars().skip_while(|c| c != current_char).collect();\n\
    \        prefix_length += 1;\n        if reversed_string.len() > 0 {\n       \
    \     suffix_length += 1;\n        }\n    }\n    let mut reversed_string_reversed\
    \ = reversed_string;\n    while !reversed_string_reversed.is_empty() {\n     \
    \   let mut current_char = reversed_string_reversed[0];\n        reversed_string_reversed\
    \ = reversed_string_reversed.chars().skip_while(|c| c != current_char).collect();\n\
    \    }\n    let mut palindrome = string;\n    palindrome.push_str(&reversed_string);\n\
    \    palindrome.push_str(&reversed_string_reversed);\n    palindrome\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp17z8zmy8.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp17z8zmy8.rs:25:32\n   |\n25 |         let mut current_char = reversed_string_reversed[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    for c in string.chars()\
    \ {\n        if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n        }\n    }\n    let mut longest_postfix_index = 0;\n    for\
    \ c in string.chars() {\n        if longest_postfix_index == longest_postfix_length\
    \ {\n            break;\n        }\n        if longest_postfix_index == 0 {\n\
    \            reversed_string += &c.to_string();\n        } else {\n          \
    \  reversed_string += &c.to_string().chars().last().to_string();\n        }\n\
    \        longest_postfix_index += 1;\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpm76_nifo.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpm76_nifo.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmpm76_nifo.rs:27:62\n    |\n27  |               reversed_string\
    \ += &c.to_string().chars().last().to_string();\n    |                       \
    \                                         ^^^^^^^^^ `Option<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut prefix = string;\n    let mut suffix = string;\n    let\
    \ mut palindrome = string;\n    let mut i = 0;\n    while i < prefix.len() {\n\
    \        let mut j = i;\n        while j + 1 < prefix.len() && prefix[j + 1] ==\
    \ prefix[j] {\n            j += 1\n        }\n        if j + 1 < prefix.len()\
    \ {\n            reverse.extend(&prefix[j..i + 1]);\n            prefix.truncate(i);\n\
    \            i += j - i;\n        } else {\n            i += 1;\n        }\n \
    \   }\n    while i < suffix.len() {\n        let mut j = i;\n        while j +\
    \ 1 < suffix.len() && suffix[j + 1] == suffix[j] {\n            j += 1\n     \
    \   }\n        if j + 1 < suffix.len() {\n            reverse.extend(&suffix[j..i\
    \ + 1]);\n            suffix.truncate(i);\n            i += j - i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    palindrome.extend(&reverse);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz1qj4fcu.rs:19:39\n\
    \   |\n19 |         while j + 1 < prefix.len() && prefix[j + 1] == prefix[j] {\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz1qj4fcu.rs:19:56\n   |\n19 |         while j + 1 < prefix.len()\
    \ && prefix[j + 1] == prefix[j] {\n   |                                      \
    \                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ `&str` is not an iterator\n   --> /tmp/tmpz1qj4fcu.rs:23:28\n    |\n23  |  \
    \           reverse.extend(&prefix[j..i + 1]);\n    |                     ------\
    \ ^^^^^^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |                     |\n    |                     required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&str`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\nnote: required by a bound in `extend`\n\nerror[E0277]"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd9njd8gz.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd9njd8gz.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reverse_string = \"\";\n    let mut reverse_string_index\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5r29rjof.rs:59:25\n   |\n\
    59 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5r29rjof.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reversed_string = \"\";\n    let mut longest_palindrome\
    \ = String::new();\n    let mut longest_palindrome_length = 0;\n\n    for c in\
    \ string.chars() {\n        if longest_palindrome_length < c.len() {\n       \
    \     longest_palindrome_length = c.len();\n            longest_palindrome = c.to_string();\n\
    \        }\n    }\n\n    for c in string.chars() {\n        if longest_palindrome_length\
    \ == c.len() {\n            reversed_string += c.to_string();\n        }\n   \
    \ }\n\n    longest_palindrome += reversed_string;\n    longest_palindrome\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpro2kkxut.rs:18:42\n   |\n18 |         if longest_palindrome_length\
    \ < c.len() {\n   |                                          ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpro2kkxut.rs:19:43\n   |\n19 |             longest_palindrome_length\
    \ = c.len();\n   |                                           ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpro2kkxut.rs:25:43\n   |\n25 |         if longest_palindrome_length\
    \ == c.len() {\n   |                                           ^^^ method not\
    \ found in `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `&str`\n  --> /tmp/tmpro2kkxut.rs:26:13\n   |\n26 |        \
    \     reversed_string += c.to_string();\n   |             ---------------^--^^^^^^^^^^^^^^\n\
    \   |             |               |\n   |             |               `+` cannot\
    \ be used to concatenate a `&str` with a `String`\n   |             cannot use\
    \ `+=` on type `&str`\n   |\n   = note: string concatenation requires an owned\
    \ `String` on the left\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp25j152l5.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25j152l5.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    while prefix_length < string.len()\
    \ {\n        let mut suffix_length = string.len() - prefix_length;\n        let\
    \ mut suffix_char = string[suffix_length];\n        while suffix_length >= 0 {\n\
    \            if suffix_char != string[suffix_length] {\n                break;\n\
    \            }\n            suffix_length -= 1;\n        }\n        if suffix_length\
    \ >= 0 {\n            reversed_string.insert(0, &suffix_char);\n            prefix_length\
    \ += 1;\n        }\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkjmx6gb_.rs:16:31\n\
    \   |\n16 |         let mut suffix_char = string[suffix_length];\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkjmx6gb_.rs:18:31\n   |\n18 |             if suffix_char != string[suffix_length]\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkjmx6gb_.rs:24:39\n\
    \   |\n24 |             reversed_string.insert(0, &suffix_char);\n   |       \
    \                                ^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n24 -             reversed_string.insert(0,\
    \ &suffix_char);\n24 +             reversed_string.insert(0, suffix_char);\n \
    \  | \n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --e"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char:\
    \ char;\n    let mut longest_postfix_char_length = 0;\n    let mut longest_prefix_length\
    \ = 0;\n    let mut longest_prefix_index = 0;\n    let mut longest_prefix_char:\
    \ char;\n    let mut longest_prefix_char_length = 0;\n    let mut longest_suffix_length\
    \ = 0;\n    let mut longest_suffix_index = 0;\n    let mut longest_suffix_char:\
    \ char;\n    let mut longest_suffix_char_length = 0;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_index = 0;\n    let mut longest_palindrome_char:\
    \ char;\n    let mut longest_palindrome_char_length = 0;\n    let mut longest_palindrome_suffix\
    \ = 0;\n    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut longest_palindrome_suffix_char: char;\n    let mut longest_palindrome_suffix_char_length\
    \ = 0;\n    let mut longest_palindrome_prefix = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_index = 0;\n    let mut longest_palindrome_prefix_char:\
    \ char;\n    let mut longest_palindrome_prefix_char_length = 0;\n    let mut longest_palindrome_prefix_suffix\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_length = 0;\n    let mut\
    \ longest_palindrome_prefix_suffix_index = 0;\n    let mut longest_palindrome_prefix_suffix_char:\
    \ char;\n    let mut longest_palindrome_prefix_suffix_char_length = 0;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_index = 0;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix_char: char;\n    let mut longest_palindrome_prefix_suffix_suffix_char_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq8t6ec6r.rs:51:21\n   |\n\
    51 |     let mut longest_\n   |                     ^ help: add `;` here\n52 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8t6ec6r.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != 0 {\n        reversed_string.insert(0, reversed_string[prefix_length]);\n\
    \        suffix_length -= 1;\n        prefix_length += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpfw3e45hz.rs:16:35\n   |\n16 |         reversed_string.insert(0, reversed_string[prefix_length]);\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut suffix_length = 0;\n\
    \    let mut prefix_length = 0;\n\n    while palindrome.len() > 0 {\n        let\
    \ mut suffix_start = palindrome.len() - 1;\n        let mut suffix_end = suffix_start;\n\
    \        while suffix_start >= 0 && palindrome[suffix_start] == palindrome[suffix_end]\
    \ {\n            suffix_start -= 1;\n            suffix_end -= 1;\n        }\n\
    \        if suffix_start >= 0 {\n            suffix_length += 1;\n           \
    \ palindrome = &palindrome[..suffix_start];\n        } else {\n            suffix_length\
    \ += 1;\n            palindrome = &palindrome[..];\n        }\n    }\n\n    while\
    \ reversed_string.len() > 0 {\n        let mut prefix_start = reversed_string.len()\
    \ - 1;\n        let mut prefix_end = prefix_start;\n        while prefix_start\
    \ >= 0 && reversed_string[prefix_start] == reversed_string[prefix_end] {\n   \
    \         prefix_start -= 1;\n            prefix_end -= 1;\n        }\n      \
    \  if prefix_start >= 0 {\n            prefix_length += 1;\n            reversed_string\
    \ = &reversed_string[..prefix_start];\n        } else {\n            prefix_length\
    \ += 1;\n            reversed_string = &reversed_string[..];\n        }\n    }\n\
    \n    String::from_utf8(\n        &[\n            suffix_length,\n           \
    \ palindrome,\n            reversed_string,\n            prefix_length,\n    \
    \    ],\n    )\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp84m9_a9u.rs:20:36\n\
    \   |\n20 |         while suffix_start >= 0 && palindrome[suffix_start] == palindrome[suffix_end]\
    \ {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp84m9_a9u.rs:20:64\n   |\n20 |         while suffix_start >= 0 &&\
    \ palindrome[suffix_start] == palindrome[suffix_end] {\n   |                 \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp84m9_a9u.rs:26:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n26 |             palindrome = &palindrome[..suffix_start];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n26 |        \
    \     palindrome = (&palindrome[..suffix_start]).to_string();\n   |          \
    \                +    "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start2\
    \ = 0;\n    let mut longest_postfix_end2 = 0;\n    let mut longest_postfix_start3\
    \ = 0;\n    let mut longest_postfix_end3 = 0;\n    let mut longest_postfix_start4\
    \ = 0;\n    let mut longest_postfix_end4 = 0;\n    let mut longest_postfix_start5\
    \ = 0;\n    let mut longest_postfix_end5 = 0;\n    let mut longest_postfix_start6\
    \ = 0;\n    let mut longest_postfix_end6 = 0;\n    let mut longest_postfix_start7\
    \ = 0;\n    let mut longest_postfix_end7 = 0;\n    let mut longest_postfix_start8\
    \ = 0;\n    let mut longest_postfix_end8 = 0;\n    let mut longest_postfix_start9\
    \ = 0;\n    let mut longest_postfix_end9 = 0;\n    let mut longest_postfix_start10\
    \ = 0;\n    let mut longest_postfix_end10 = 0;\n    let mut longest_postfix_start11\
    \ = 0;\n    let mut longest_postfix_end11 = 0;\n    let mut longest_postfix_start12\
    \ = 0;\n    let mut longest_postfix_end12 = 0;\n    let mut longest_postfix_start13\
    \ = 0;\n    let mut longest_postfix_end13 = 0;\n    let mut longest_postfix_start14\
    \ = 0;\n    let mut longest_postfix_end14 = 0;\n    let mut longest_postfix_start15\
    \ = 0;\n    let mut longest_postfix_end15 = 0;\n    let mut longest_postfix_start16\
    \ = 0;\n    let mut longest_postfix_end16 = 0;\n    let mut longest_postfix_start17\
    \ = 0;\n    let mut longest_postfix_end17 = 0;\n    let mut longest_postfix_start18\
    \ = 0;\n    let mut longest_postfix_end18 = 0;\n    let mut longest_postfix_start19\
    \ = 0;\n    let mut longest_postfix_end19 = 0;\n    let mut longest_postfix_start20\
    \ = 0;\n    let mut longest_postfix_end20 = 0;\n    let mut longest_postfix_start21\
    \ = 0;\n    let mut longest_postfix_end21 = 0;\n    let mut longest_postfix_start22\
    \ = 0;\n    let mut longest_postfix_end22 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkyfcsccw.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut suffix_length = 0;\n        while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == string[prefix_length] {\n            suffix_length\
    \ += 1;\n        }\n        reversed_string = &reversed_string[suffix_length..];\n\
    \        prefix_length += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7_6stkq1.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == string[prefix_length] {\n   |         \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7_6stkq1.rs:16:80\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == string[prefix_length] {\n   |         \
    \                                                                       ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_6stkq1.rs:19:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n19 |         reversed_string\
    \ = &reversed_string[suffix_length..];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_palindromic_postfix\
    \ = \"\";\n    let mut longest_palindromic_postfix_length = 0;\n    let mut longest_palindromic_postfix_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index = 0;\n    let mut\
    \ longest_palindromic_postfix_length_index_index = 0;\n    let mut longest_palindromic_postfix_length_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiniswt25.rs:35:131\n   |\n\
    35 |     let mut longest_palindromic_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\n\
    \   |                                                                        \
    \                                                           ^ help: add `;` here\n\
    36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiniswt25.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut last_char_index\
    \ = 0;\n    let mut last_char_index_reversed = 0;\n    let mut last_char_index_reversed_reversed\
    \ = 0;\n    while last_char_index < palindrome.len() {\n        let mut current_char_index\
    \ = 0;\n        while current_char_index < palindrome.len() {\n            let\
    \ mut current_char = palindrome[current_char_index];\n            let mut current_char_reversed\
    \ = palindrome[current_char_index_reversed];\n            while current_char_index\
    \ < palindrome.len() {\n                let mut current_char = palindrome[current_char_index];\n\
    \                let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                while current_char_index < palindrome.len() {\n             \
    \       let mut current_char = palindrome[current_char_index];\n             \
    \       let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                    while current_char_index < palindrome.len() {\n         \
    \               let mut current_char = palindrome[current_char_index];\n     \
    \                   let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                        while current_char_index < palindrome.len() {\n     \
    \                       let mut current_char = palindrome[current_char_index];\n\
    \                            let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                            while current_char_index < palindrome.len() {\n \
    \                               let mut current_char = palindrome[current_char_index];\n\
    \                                let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                                while current_char_index < palindrome.len() {\n\
    \                                    let mut current_char = palindrome[current_char_index];\n\
    \                                    let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                                    while current_char_index < palindrome.len()\
    \ {\n                                        let mut current_char = palindrome[current_char_index];\n\
    \                                        let mut current_char_reversed = palindrome[current_char_index_reversed];\n\
    \                                        while current_char_index < palindrome.len()\
    \ {\n                                            let mut current_char = palindrome[current_char_index];\n\
    \                                            let mut current_char_reversed = palindrome[current_char\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc3rs62f3.rs:55:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while last_char_index\
    \ < palindrome.len() {\n   |                                              - unclosed\
    \ delimiter\n18 |         let mut current_char_index = 0;\n19 |         while\
    \ current_char_index < palindrome.len() {\n   |                              \
    \                       - unclosed delimiter\n...\n22 |             while current_char_index\
    \ < palindrome.len() {\n   |                                                 \
    \        - unclosed delimiter\n...\n25 |                 while current_char_index\
    \ < palindrome.len() {\n   |                                                 \
    \            - unclosed delimiter\n...\n28 |                     while current_char_index\
    \ < palindrome.len() {\n   |                                                 \
    \                - unclosed delimiter\n...\n31 |                         while\
    \ current_char_index < palindrome.len() {\n   |                              \
    \                                       - unclosed delimiter\n...\n34 |      \
    \                       while current_char_index < palindrome.len() {\n   |  \
    \                                                                       - unclosed\
    \ delimiter\n...\n37 |                                 while current_char_index\
    \ < palindrome.len() {\n   |                                                 \
    \                            - unclosed delimiter\n...\n40 |                 \
    \                    while current_char_index < palindrome.len() {\n   |     \
    \                                                                            -\
    \ unclosed delimiter\n...\n43 |                                         while\
    \ current_char_index < palindrome.len() {\n   |                              \
    \                                                       - this delimiter might\
    \ not be properly closed...\n...\n46 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n55 | }\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != 0 || prefix_length != 0 {\n        if suffix_length\
    \ != 0 {\n            reversed_string.push(reversed_string[suffix_length - 1]);\n\
    \            suffix_length -= 1;\n        }\n        if prefix_length != 0 {\n\
    \            reversed_string.insert(0, reversed_string[prefix_length]);\n    \
    \        prefix_length -= 1;\n        }\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpu217g3rz.rs:17:34\n   |\n17 |             reversed_string.push(reversed_string[suffix_length\
    \ - 1]);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpu217g3rz.rs:21:39\n   |\n21 |             reversed_string.insert(0,\
    \ reversed_string[prefix_length]);\n   |                                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n        prefix_length += 1;\n    }\n    let mut suffix_length = 0;\n    while\
    \ !reversed_string.ends_with(string[suffix_length..]) {\n        suffix_length\
    \ += 1;\n    }\n    let mut palindrome = &string[prefix_length..suffix_length];\n\
    \    while !palindrome.starts_with(&reversed_string[..]) {\n        palindrome\
    \ = &palindrome[..].reverse();\n    }\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpbxx3uwlt.rs:14:40\n     |\n14   |     while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                            ----------- ^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n     |                            |\n   \
    \  |                            required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `str`\n    --> /tmp/tmpbxx3uwlt.rs:14:40\n\
    \     |\n14   |     while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                            ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ an implementor of trait `Pattern<'_>`\n     |                            |\n\
    \     |                            required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `str: Pattern<'_>` is not satisfied\n  \
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n14   |     while !reversed_string.starts_with(&string[prefix_length..])\
    \ {\n     |                                        +\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n    --> /tmp/tmpbxx3uwlt.rs:18:38\n\
    \     |\n18   |     while !reversed_string.ends_with(string[suffix_length..])\
    \ {\n     |                            --------- ^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n     |                            |\n   \
    \  |                            required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `core::str::<impl str>::ends_with`\n\nerror[E0277]: expected a\
    \ `FnMut<(char,)>` closure, found `str`\n  --> /tmp/tmpbxx3uwlt.rs:18:38\n   |\n\
    18 |     while !reversed_string.ends_with(s"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphls8_qbp.rs:59:29\n   |\n\
    59 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphls8_qbp.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index2\
    \ = 0;\n    let mut longest_postfix_end_index2 = 0;\n    let mut longest_postfix_start_index3\
    \ = 0;\n    let mut longest_postfix_end_index3 = 0;\n    let mut longest_postfix_start_index4\
    \ = 0;\n    let mut longest_postfix_end_index4 = 0;\n    let mut longest_postfix_start_index5\
    \ = 0;\n    let mut longest_postfix_end_index5 = 0;\n    let mut longest_postfix_start_index6\
    \ = 0;\n    let mut longest_postfix_end_index6 = 0;\n    let mut longest_postfix_start_index7\
    \ = 0;\n    let mut longest_postfix_end_index7 = 0;\n    let mut longest_postfix_start_index8\
    \ = 0;\n    let mut longest_postfix_end_index8 = 0;\n    let mut longest_postfix_start_index9\
    \ = 0;\n    let mut longest_postfix_end_index9 = 0;\n    let mut longest_postfix_start_index10\
    \ = 0;\n    let mut longest_postfix_end_index10 = 0;\n    let mut longest_postfix_start_index11\
    \ = 0;\n    let mut longest_postfix_end_index11 = 0;\n    let mut longest_postfix_start_index12\
    \ = 0;\n    let mut longest_postfix_end_index12 = 0;\n    let mut longest_postfix_start_index13\
    \ = 0;\n    let mut longest_postfix_end_index13 = 0;\n    let mut longest_postfix_start_index14\
    \ = 0;\n    let mut longest_postfix_end_index14 = 0;\n    let mut longest_postfix_start_index15\
    \ = 0;\n    let mut longest_postfix_end_index15 = 0;\n    let mut longest_postfix_start_index16\
    \ = 0;\n    let mut longest_postfix_end_index16 = 0;\n    let mut longest_postfix_start_index17\
    \ = 0;\n    let mut longest_postfix_end_index17 = 0;\n    let mut longest_postfix_start_index18\
    \ = 0;\n    let mut longest_postfix_end_index18 = 0;\n    let mut longest_postfix_start_index19\
    \ = 0;\n    let mut longest_postfix_end_index19 = 0;\n    let mut longest_postfix_start_index20\
    \ = 0;\n    let mut longest_postfix_end_index20 = 0;\n    let mut lon\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyvdjps1q.rs:56:16\n   |\n\
    56 |     let mut lon\n   |                ^ help: add `;` here\n57 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvdjps1q.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_start_index2 = 0;\n    let mut longest_postfix_end_index2\
    \ = 0;\n    let mut longest_postfix_start_index3 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_start_index4 = 0;\n    let mut longest_postfix_end_index4\
    \ = 0;\n    let mut longest_postfix_start_index5 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_start_index6 = 0;\n    let mut longest_postfix_end_index6\
    \ = 0;\n    let mut longest_postfix_start_index7 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_start_index8 = 0;\n    let mut longest_postfix_end_index8\
    \ = 0;\n    let mut longest_postfix_start_index9 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_start_index10 = 0;\n    let mut longest_postfix_end_index10\
    \ = 0;\n    let mut longest_postfix_start_index11 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_start_index12 = 0;\n    let mut longest_postfix_end_index12\
    \ = 0;\n    let mut longest_postfix_start_index13 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_start_index14 = 0;\n    let mut longest_postfix_end_index14\
    \ = 0;\n    let mut longest_postfix_start_index15 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_start_index16 = 0;\n    let mut longest_postfix_end_index16\
    \ = 0;\n    let mut longest_postfix_start_index17 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_start_index18 = 0;\n    let mut longest_postfix_end_index18\
    \ = 0;\n    let mut longest_postfix_start_index19 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_start_index20 = 0;\n    let mut lon\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp0kg43t8.rs:56:16\n   |\n\
    56 |     let mut lon\n   |                ^ help: add `;` here\n57 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0kg43t8.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9wuzao5b.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wuzao5b.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_index = 0;\n    let mut longest_palindrome\
    \ = string;\n    let mut longest_palindrome_index = 0;\n    while reversed_string_index\
    \ < string.len() {\n        let mut reversed_string_slice = &mut reversed_string[reversed_string_index..];\n\
    \        let mut longest_palindrome_slice = &mut longest_palindrome[longest_palindrome_index..];\n\
    \        let mut longest_palindrome_slice_start = longest_palindrome_index;\n\
    \        let mut longest_palindrome_slice_end = longest_palindrome_index;\n  \
    \      while longest_palindrome_slice_end < longest_palindrome_slice.len() {\n\
    \            let mut longest_palindrome_slice_slice = &mut longest_palindrome_slice[longest_palindrome_slice_start..];\n\
    \            let mut reversed_string_slice_slice = &mut reversed_string_slice[reversed_string_index..];\n\
    \            if longest_palindrome_slice_slice.len() < reversed_string_slice_slice.len()\
    \ {\n                longest_palindrome_slice_end = longest_palindrome_slice_slice.len();\n\
    \            } else {\n                longest_palindrome_slice_start = longest_palindrome_slice_slice.len();\n\
    \            }\n            longest_palindrome_slice_slice = longest_palindrome_slice_slice.reverse();\n\
    \            reversed_string_slice_slice = reversed_string_slice_slice.reverse();\n\
    \        }\n        if longest_palindrome_slice_end == longest_palindrome_slice.len()\
    \ {\n            longest_palindrome = longest_palindrome_slice.reverse();\n  \
    \          longest_palindrome_index += longest_palindrome_slice.len();\n     \
    \   } else {\n            longest_palindrome = longest_palindrome_slice;\n   \
    \         longest_palindrome_index = longest_palindrome_slice_end;\n        }\n\
    \        reversed_string_index += reversed_string_slice.len();\n    }\n    longest_palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpdgteg5gp.rs:29:77\n   |\n29 |     \
    \        longest_palindrome_slice_slice = longest_palindrome_slice_slice.reverse();\n\
    \   |                                                                        \
    \     ^^^^^^^ method not found in `&mut str`\n\nerror[E0599]: no method named\
    \ `reverse` found for mutable reference `&mut str` in the current scope\n  -->\
    \ /tmp/tmpdgteg5gp.rs:30:71\n   |\n30 |             reversed_string_slice_slice\
    \ = reversed_string_slice_slice.reverse();\n   |                             \
    \                                          ^^^^^^^ method not found in `&mut str`\n\
    \nerror[E0599]: no method named `reverse` found for mutable reference `&mut str`\
    \ in the current scope\n  --> /tmp/tmpdgteg5gp.rs:33:59\n   |\n33 |          \
    \   longest_palindrome = longest_palindrome_slice.reverse();\n   |           \
    \                                                ^^^^^^^ method not found in `&mut\
    \ str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdgteg5gp.rs:36:34\n  \
    \ |\n14 |     let mut longest_palindrome = string;\n   |                     \
    \             ------ expected due to this value\n...\n36 |             longest_palindrome\
    \ = longest_palindrome_slice;\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                |\n   |                                  expected struct `String`,\
    \ found `&mut str`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_len\
    \ = 0;\n\n    for c in string.chars() {\n        if longest_postfix_len > c.len()\
    \ {\n            longest_postfix_len = c.len();\n            longest_postfix =\
    \ &c;\n        }\n        if longest_postfix_len == c.len() {\n            reversed_string\
    \ += &c[longest_postfix_len..];\n        }\n    }\n\n    longest_postfix += &reversed_string[longest_postfix_len..];\n\
    \n    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn6a6ru_8.rs:17:36\n   |\n17 |         if longest_postfix_len\
    \ > c.len() {\n   |                                    ^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn6a6ru_8.rs:18:37\n   |\n18 |             longest_postfix_len\
    \ = c.len();\n   |                                     ^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6a6ru_8.rs:19:31\n\
    \   |\n13 |     let mut longest_postfix = \"\";\n   |                        \
    \       -- expected due to this value\n...\n19 |             longest_postfix =\
    \ &c;\n   |                               ^^ expected `str`, found `char`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpn6a6ru_8.rs:21:37\n   |\n21 |         if longest_postfix_len ==\
    \ c.len() {\n   |                                     ^^^ method not found in\
    \ `char`\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpn6a6ru_8.rs:22:33\n\
    \   |\n22 |             reversed_string += &c[longest_postfix_len..];\n   |  \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpn6a6ru_8.rs:26:5\n\
    \   |\n26 |     longest_postfix += &reversed_string[longest_postfix_len..];\n\
    \   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \  |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn6a6ru_8.rs:28:5\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n28 |     longest_postfix\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explan"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_start_index2 = 0;\n    let mut longest_postfix_end_index2\
    \ = 0;\n    let mut longest_postfix_start_index3 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_start_index4 = 0;\n    let mut longest_postfix_end_index4\
    \ = 0;\n    let mut longest_postfix_start_index5 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_start_index6 = 0;\n    let mut longest_postfix_end_index6\
    \ = 0;\n    let mut longest_postfix_start_index7 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_start_index8 = 0;\n    let mut longest_postfix_end_index8\
    \ = 0;\n    let mut longest_postfix_start_index9 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_start_index10 = 0;\n    let mut longest_postfix_end_index10\
    \ = 0;\n    let mut longest_postfix_start_index11 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_start_index12 = 0;\n    let mut longest_postfix_end_index12\
    \ = 0;\n    let mut longest_postfix_start_index13 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_start_index14 = 0;\n    let mut longest_postfix_end_index14\
    \ = 0;\n    let mut longest_postfix_start_index15 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_start_index16 = 0;\n    let mut longest_postfix_end_index16\
    \ = 0;\n    let mut longest_postfix_start_index17 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_start_index18 = 0;\n    let mut longest_postfix_end_index18\
    \ = 0;\n    let mut longest_postfix_start_index19 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_start_index20 = 0;\n    let mut lon\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpncijhij8.rs:56:16\n   |\n\
    56 |     let mut lon\n   |                ^ help: add `;` here\n57 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpncijhij8.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_chars = String::new();\n    let mut longest_postfix_char_index\
    \ = -1;\n    let mut longest_postfix_char_length = -1;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut longest_postfix_char_length_start = 0;\n    let mut longest_postfix_char_length_end\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoch3tr4l.rs:55:16\n   |\n\
    55 |     let mut lon\n   |                ^ help: add `;` here\n56 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoch3tr4l.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length2 = 0;\n    let mut longest_postfix_index_length3\
    \ = 0;\n    let mut longest_postfix_index_length4 = 0;\n    let mut longest_postfix_index_length5\
    \ = 0;\n    let mut longest_postfix_index_length6 = 0;\n    let mut longest_postfix_index_length7\
    \ = 0;\n    let mut longest_postfix_index_length8 = 0;\n    let mut longest_postfix_index_length9\
    \ = 0;\n    let mut longest_postfix_index_length10 = 0;\n    let mut longest_postfix_index_length11\
    \ = 0;\n    let mut longest_postfix_index_length12 = 0;\n    let mut longest_postfix_index_length13\
    \ = 0;\n    let mut longest_postfix_index_length14 = 0;\n    let mut longest_postfix_index_length15\
    \ = 0;\n    let mut longest_postfix_index_length16 = 0;\n    let mut longest_postfix_index_length17\
    \ = 0;\n    let mut longest_postfix_index_length18 = 0;\n    let mut longest_postfix_index_length19\
    \ = 0;\n    let mut longest_postfix_index_length20 = 0;\n    let mut longest_postfix_index_length21\
    \ = 0;\n    let mut longest_postfix_index_length22 = 0;\n    let mut longest_postfix_index_length23\
    \ = 0;\n    let mut longest_postfix_index_length24 = 0;\n    let mut longest_postfix_index_length25\
    \ = 0;\n    let mut longest_postfix_index_length26 = 0;\n    let mut longest_postfix_index_length27\
    \ = 0;\n    let mut longest_postfix_index_length28 = 0;\n    let mut longest_postfix_index_length29\
    \ = 0;\n    let mut longest_postfix_index_length30 = 0;\n    let mut longest_postfix_index_length31\
    \ = 0;\n    let mut longest_postfix_index_length32 = 0;\n    let mut longest_postfix_index_length33\
    \ = 0;\n    let mut longest_postfix_index_length34 = 0;\n    let mut longest_postfix_index_length35\
    \ = 0;\n    let mut longest_postfix_index_length36 = 0;\n    let mut longest_postfix_index_length37\
    \ = 0;\n    let mut longest_postfix_index_length38 = 0;\n    let mut longest_postfix_index_length39\
    \ = 0;\n    let mut longest_postfix_index_length40 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnaziuvh.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reverse = string;\n    let mut palindrome = string;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n  \
    \      while j + 1 < string.len() {\n            if string[j] != string[j + 1]\
    \ {\n                break;\n            }\n            j += 1;\n        }\n \
    \       if j - i > 1 {\n            palindrome = &string[i..j];\n            i\
    \ += j - i;\n        }\n    }\n    reverse = &reverse[..palindrome.len()];\n \
    \   string = &string[..palindrome.len()];\n    string += &reverse;\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6cg4o2z_.rs:19:16\n\
    \   |\n19 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6cg4o2z_.rs:19:29\n   |\n19 |             if string[j] != string[j\
    \ + 1] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6cg4o2z_.rs:25:26\n\
    \   |\n14 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n25 |             palindrome = &string[i..j];\n\
    \   |                          ^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n25 |             palindrome\
    \ = (&string[i..j]).to_string();\n   |                          +            \
    \ +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6cg4o2z_.rs:29:15\n\
    \   |\n13 |     let mut reverse = string;\n   |                       ------ expected\
    \ due to this value\n...\n29 |     reverse "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut suffix_length = 0;\n\
    \    let mut prefix_length = 0;\n    while palindrome.len() > 0 {\n        let\
    \ mut suffix_start = palindrome.len() - 1;\n        while suffix_start >= 0 &&\
    \ palindrome[suffix_start] == palindrome[suffix_start - 1] {\n            suffix_start\
    \ -= 1;\n        }\n        if suffix_start < 0 {\n            break;\n      \
    \  }\n        let mut suffix_end = suffix_start + 1;\n        while suffix_end\
    \ < palindrome.len() && palindrome[suffix_end] != palindrome[suffix_end - 1] {\n\
    \            suffix_end += 1;\n        }\n        if suffix_end == palindrome.len()\
    \ {\n            break;\n        }\n        let mut prefix_start = suffix_end\
    \ + 1;\n        while prefix_start < palindrome.len() && palindrome[prefix_start]\
    \ != palindrome[prefix_start - 1] {\n            prefix_start += 1;\n        }\n\
    \        if prefix_start == palindrome.len() {\n            break;\n        }\n\
    \        let mut prefix_end = prefix_start + 1;\n        while prefix_end < palindrome.len()\
    \ && palindrome[prefix_end] != palindrome[prefix_end - 1] {\n            prefix_end\
    \ += 1;\n        }\n        if prefix_end == palindrome.len() {\n            break;\n\
    \        }\n        let mut suffix = &palindrome[..suffix_end];\n        let mut\
    \ prefix = &palindrome[prefix_start..prefix_end];\n        reversed_string +=\
    \ suffix;\n        palindrome = &palindrome[suffix_end..];\n        suffix_length\
    \ = suffix_end - suffix_start + 1;\n        prefix_length = prefix_end - prefix_start\
    \ + 1;\n    }\n    reversed_string += &palindrome[..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp400y7u8k.rs:18:36\n\
    \   |\n18 |         while suffix_start >= 0 && palindrome[suffix_start] == palindrome[suffix_start\
    \ - 1] {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp400y7u8k.rs:18:64\n   |\n18 |         while suffix_start >= 0 &&\
    \ palindrome[suffix_start] == palindrome[suffix_start - 1] {\n   |           \
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp400y7u8k.rs:25:48\n   |\n25 |         while suffix_end < palindrome.len()\
    \ && palindrome[suffix_end] != palindrome[suffix_end - 1] {\n   |            \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \        "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_postfix_length = 0;\n    let mut longest_palindrome_postfix\
    \ = string;\n    let mut longest_palindrome_postfix_length = 0;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix = string;\n    let mut longest_palindrome_postfix_length\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpscu2cxgi.rs:49:16\n   |\n\
    49 |     let mut lon\n   |                ^ help: add `;` here\n50 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpscu2cxgi.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_index = 0;\n    let mut longest_postfix_length_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_index = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqcmvk6un.rs:40:76\n   |\n\
    40 |     let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffi\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqcmvk6un.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjh655g67.rs:63:29\n   |\n\
    63 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjh655g67.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_end_index2 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_end_index4 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_end_index6 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_end_index8 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_end_index10 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_end_index12 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_end_index14 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_end_index16 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_end_index18 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_end_index20 = 0;\n    let mut longest_postfix_end_index21\
    \ = 0;\n    let mut longest_postfix_end_index22 = 0;\n    let mut longest_postfix_end_index23\
    \ = 0;\n    let mut longest_postfix_end_index24 = 0;\n    let mut longest_postfix_end_index25\
    \ = 0;\n    let mut longest_postfix_end_index26 = 0;\n    let mut longest_postfix_end_index27\
    \ = 0;\n    let mut longest_postfix_end_index28 = 0;\n    let mut longest_postfix_end_index29\
    \ = 0;\n    let mut longest_postfix_end_index30 = 0;\n    let mut longest_postfix_end_index31\
    \ = 0;\n    let mut longest_postfix_end_index32 = 0;\n    let mut longest_postfix_end_index33\
    \ = 0;\n    let mut longest_postfix_end_index34 = 0;\n    let mut longest_postfix_end_index35\
    \ = 0;\n    let mut longest_postfix_end_index36 = 0;\n    let mut longest_postfix_end_index37\
    \ = 0;\n    let mut longest_postfix_end_index38 = 0;\n    let mut longest_postfix_end_index39\
    \ = 0;\n    let mut longest_postfix_end_index40 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4e3iulk.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = string;\n    let mut palindrome = string;\n\
    \    let mut i = 1;\n    while i < string.len() {\n        if string[i] != string[string.len()\
    \ - i] {\n            break;\n        }\n        i += 1;\n    }\n    i += 1;\n\
    \    while i < string.len() {\n        reversed_string = reversed_string\n   \
    \         .chars()\n            .map(|c| match c {\n                c if c ==\
    \ string[i] => c,\n                _ => c,\n            })\n            .collect();\n\
    \        palindrome = palindrome\n            .chars()\n            .map(|c| match\
    \ c {\n                c if c == string[string.len() - i] => c,\n            \
    \    _ => c,\n            })\n            .collect();\n        i += 1;\n    }\n\
    \    palindrome = reversed_string.join(\"\");\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4vwseb9t.rs:17:12\n\
    \   |\n17 |         if string[i] != string[string.len() - i] {\n   |         \
    \   ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4vwseb9t.rs:17:25\n   |\n17 |         if string[i] != string[string.len()\
    \ - i] {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4vwseb9t.rs:27:27\n   |\n27 |                 c if c == string[i]\
    \ => c,\n   |                           ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String a"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp82q4oe39.rs:35:53\n   |\n\
    35 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82q4oe39.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpebfgh055.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpebfgh055.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = 0;\n    let mut longest_index = 0;\n    for\
    \ pos in string.char_indices() {\n        let mut index = pos;\n        while\
    \ index > 0 {\n            let c = string[index - 1];\n            if c != string[index]\
    \ {\n                break;\n            }\n            index -= 1;\n        }\n\
    \        let mut length = index - pos;\n        if length > longest {\n      \
    \      longest = length;\n            longest_index = pos;\n        }\n    }\n\
    \    reverse.push_str(&string[longest_index..]);\n    reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6q996mwz.rs:17:23\n   |\n\
    17 |         while index > 0 {\n   |                       ^ expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `{integer}`\n\nerror[E0369]: cannot subtract `{integer}` from `(usize,\
    \ char)`\n  --> /tmp/tmp6q996mwz.rs:18:34\n   |\n18 |             let c = string[index\
    \ - 1];\n   |                            ----- ^ - {integer}\n   |           \
    \                 |\n   |                            (usize, char)\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `(usize, char)`\n  --> /tmp/tmp6q996mwz.rs:19:21\n\
    \   |\n19 |             if c != string[index] {\n   |                     ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `(usize, char)`\n   |\n   = help: the trait `Index<(usize,\
    \ char)>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `(usize, char)`\n  --> /tmp/tmp6q996mwz.rs:22:13\n   |\n22 |       \
    \      index -= 1;\n   |             -----^^^^^\n   |             |\n   |    \
    \         cannot use `-=` on type `(usize, char)`\n\nerror[E0369]: cannot subtract\
    \ `(usize, char)` from `(usize, char)`\n  --> /tmp/tmp6q996mwz.rs:24:32\n   |\n\
    24 |         let mut length = index - pos;\n   |                          -----\
    \ ^ --- (usize, char)\n   |                          |\n   |                 \
    \         (usize, char)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6q996mwz.rs:27:29\n\
    \   |\n14 |     let mut longest_index = 0;\n   |                             -\
    \ expected due to this value\n...\n27 |             longest_index = pos;\n   |\
    \                             ^^^ expected integer, found tup"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n\n    while longest_palindrome_length < string.len() {\n        let mut\
    \ longest_palindrome_start = longest_palindrome_length;\n        let mut longest_palindrome_end\
    \ = longest_palindrome_length;\n\n        while longest_palindrome_end < string.len()\
    \ {\n            let mut current_char = longest_palindrome_end;\n            let\
    \ mut next_char = longest_palindrome_end;\n\n            while current_char <\
    \ string.len() {\n                let mut current_char = longest_palindrome_end;\n\
    \                let mut next_char = longest_palindrome_end;\n\n             \
    \   while current_char < string.len() {\n                    let mut current_char\
    \ = longest_palindrome_end;\n                    let mut next_char = longest_palindrome_end;\n\
    \n                    while current_char < string.len() {\n                  \
    \      let mut current_char = longest_palindrome_end;\n                      \
    \  let mut next_char = longest_palindrome_end;\n\n                        while\
    \ current_char < string.len() {\n                            let mut current_char\
    \ = longest_palindrome_end;\n                            let mut next_char = longest_palindrome_end;\n\
    \n                            while current_char < string.len() {\n          \
    \                      let mut current_char = longest_palindrome_end;\n      \
    \                          let mut next_char = longest_palindrome_end;\n\n   \
    \                             while current_char < string.len() {\n          \
    \                          let mut current_char = longest_palindrome_end;\n  \
    \                                  let mut next_char = longest_palindrome_end;\n\
    \n                                    while current_char < string.len() {\n  \
    \                                      let mut current_char = longest_palindrome_end;\n\
    \                                        let mut next_char = longest_palindrome_end;\n\
    \n                                        while current_char < string.len() {\n\
    \                                            let mut current_char = longest_palindrome_end;\n\
    \                                            let mut next_char = longest_palindrome_end;\n\
    \n                                            if current_char == next_char {\n\
    \                                                break;\n                    \
    \                        }\n\n                                            current_char\
    \ += 1;\n                                            next_char -= 1;\n       \
    \                                 }\n                                    }\n \
    \                               }\n                            }\n           \
    \             }\n                    }\n                }\n            }\n\n \
    \           if longest_palindrome_start < longest_palindrome_end {\n         \
    \       longest_palindrome_start = longest_palindrome_end;\n            }\n  \
    \      }\n\n        let mut longest_palindrome_length = longest_palin\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptidbc0q7.rs:86:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while longest_palindrome_length\
    \ < string.len() {\n   |                                                    -\
    \ this delimiter might not be properly closed...\n...\n77 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n86 | }\n   |   ^\n\nerror:\
    \ expected `;`, found `}`\n  --> /tmp/tmptidbc0q7.rs:76:58\n   |\n76 |       \
    \  let mut longest_palindrome_length = longest_palin\n   |                   \
    \                                       ^ help: add `;` here\n77 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `longest_palin` in this scope\n  -->\
    \ /tmp/tmptidbc0q7.rs:76:45\n   |\n76 |         let mut longest_palindrome_length\
    \ = longest_palin\n   |                                             ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptidbc0q7.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != string.length {\n        suffix_length = string.rfind('a',\
    \ suffix_length);\n        if suffix_length == -1 {\n            break;\n    \
    \    }\n        let mut prefix_length = suffix_length;\n        while prefix_length\
    \ != string.length {\n            prefix_length = string.rfind('a', prefix_length);\n\
    \            if prefix_length == -1 {\n                break;\n            }\n\
    \            let mut reversed_string = string[prefix_length..].to_owned();\n \
    \           reversed_string.push(reversed_string[..prefix_length].to_owned());\n\
    \            reversed_string = reversed_string.reverse();\n            if reversed_string\
    \ == string {\n                return reversed_string;\n            }\n      \
    \  }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpcz9gdkc6.rs:15:35\n\
    \   |\n15 |     while suffix_length != string.length {\n   |                 \
    \                  ^^^^^^ unknown field\n\nerror[E0061]: this function takes 1\
    \ argument but 2 arguments were supplied\n    --> /tmp/tmpcz9gdkc6.rs:16:32\n\
    \     |\n16   |         suffix_length = string.rfind('a', suffix_length);\n  \
    \   |                                ^^^^^ ---  ------------- supplied 2 arguments\n\
    \     |                                |\n     |                             \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcz9gdkc6.rs:16:25\n   |\n13 |     let mut suffix_length\
    \ = 0;\n   |                             - expected due to this value\n...\n16\
    \ |         suffix_length = string.rfind('a', suffix_length);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<usize>`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpcz9gdkc6.rs:21:39\n\
    \   |\n21 |         while prefix_length != string.length {\n   |             \
    \                          ^^^^^^ unknown field\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpcz9gdkc6.rs:22:36\n\
    \     |\n22   |             prefix_length = string.rfind('a', prefix_length);\n\
    \     |                                    ^^^^^ ---  ------------- supplied 2\
    \ arguments\n     |                                    |\n     |             \
    \                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcz9gdkc6.rs:22:29\n\
    \   |\n20 |         let mut prefix_length = suffix_length;\n   |             \
    \                    ------------- expected due to this value\n21 |         while\
    \ prefix_length != string.length {\n22 |             prefix_length = string.rfind('a',\
    \ prefix_length);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integ"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = string;\n    let mut i = 0;\n    while\
    \ i < string.len() {\n        let mut j = string.len() - 1;\n        while j >=\
    \ i {\n            if string[j] != string[i] {\n                break;\n     \
    \       }\n            j -= 1;\n        }\n        if j == i {\n            break;\n\
    \        }\n        reversed_string = reversed_string[..j] + string[i] + reversed_string[j..];\n\
    \        i += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcoi134fe.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcoi134fe.rs:18:29\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcoi134fe.rs:26:50\n   |\n26 |         reversed_string = reversed_string[..j]\
    \ + string[i] + reversed_string[j..];\n   |                                  \
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclus"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse = 0;\n    let mut longest_postfix_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length = 0;\n    let mut longest_postfix_length_reverse_index2\
    \ = 0;\n    let mut longest_postfix_length_reverse_length2 = 0;\n    let mut longest_postfix_length_reverse_length3\
    \ = 0;\n    let mut longest_postfix_length_reverse_length4 = 0;\n    let mut longest_postfix_length_reverse_length5\
    \ = 0;\n    let mut longest_postfix_length_reverse_length6 = 0;\n    let mut longest_postfix_length_reverse_length7\
    \ = 0;\n    let mut longest_postfix_length_reverse_length8 = 0;\n    let mut longest_postfix_length_reverse_length9\
    \ = 0;\n    let mut longest_postfix_length_reverse_length10 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length11 = 0;\n    let mut longest_postfix_length_reverse_length12\
    \ = 0;\n    let mut longest_postfix_length_reverse_length13 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length14 = 0;\n    let mut longest_postfix_length_reverse_length15\
    \ = 0;\n    let mut longest_postfix_length_reverse_length16 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length17 = 0;\n    let mut longest_postfix_length_reverse_length18\
    \ = 0;\n    let mut longest_postfix_length_reverse_length19 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length20 = 0;\n    let mut longest_postfix_length_reverse_length21\
    \ = 0;\n    let mut longest_postfix_length_reverse_length22 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length23 = 0;\n    let mut longest_postfix_length_reverse_length24\
    \ = 0;\n    let mut longest_postfix_length_reverse_length25 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length26 = 0;\n    let mut longest_postfix_length_reverse_length27\
    \ = 0;\n    let mut longest_postfix_length_reverse_length28 = 0;\n    let mut\
    \ longest_postfix_length_reverse_length29 = 0;\n    let mut longest_postfix_length_reverse_length30\
    \ = 0;\n    let mut longest_postfix_length_reverse_\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx3_aq257.rs:50:44\n   |\n\
    50 |     let mut longest_postfix_length_reverse_\n   |                       \
    \                     ^ help: add `;` here\n51 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx3_aq257.rs:11:39\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |    ---------------       \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_len\
    \ = 0;\n\n    for c in string.chars() {\n        if longest_postfix_len < c.len()\
    \ {\n            longest_postfix_len = c.len();\n            longest_postfix =\
    \ c;\n        }\n    }\n\n    for c in string.chars() {\n        if longest_postfix_len\
    \ == c.len() {\n            reversed_string += &c.to_string();\n        }\n  \
    \  }\n\n    reversed_string += &longest_postfix;\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpd2pfvn88.rs:17:36\n   |\n17 |         if longest_postfix_len\
    \ < c.len() {\n   |                                    ^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpd2pfvn88.rs:18:37\n   |\n18 |             longest_postfix_len\
    \ = c.len();\n   |                                     ^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd2pfvn88.rs:19:31\n\
    \   |\n13 |     let mut longest_postfix = \"\";\n   |                        \
    \       -- expected due to this value\n...\n19 |             longest_postfix =\
    \ c;\n   |                               ^ expected `&str`, found `char`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpd2pfvn88.rs:24:37\n\
    \   |\n24 |         if longest_postfix_len == c.len() {\n   |                \
    \                     ^^^ method not found in `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpd2pfvn88.rs:25:13\n\
    \   |\n25 |             reversed_string += &c.to_string();\n   |             ---------------^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpd2pfvn88.rs:29:5\n\
    \   |\n29 |     reversed_string += &longest_postfix;\n   |     ---------------^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd2pfvn88.rs:30:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n30 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about a"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_suffix\
    \ = string;\n    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_prefix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_length = 0;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix = string;\n    let mut longest_palindrome_prefix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix = string;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_length = 0;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix_suffix_suffix = string;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_length = 0;\n    let\
    \ mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix = string;\n\
    \    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = string;\n    let mut longest_palindrome_prefix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix_suffix_suffi\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb3y0e1ob.rs:38:58\n   |\n\
    38 |     let mut longest_palindrome_prefix_suffix_suffix_suffi\n   |         \
    \                                                 ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb3y0e1ob.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut prefix_length = 0;\n\
    \    let mut suffix_length = 0;\n    while palindrome.len() > 0 {\n        let\
    \ mut suffix_length = 0;\n        while suffix_length < palindrome.len() && palindrome[suffix_length]\
    \ == reversed_string[suffix_length] {\n            suffix_length += 1;\n     \
    \   }\n        if suffix_length == palindrome.len() {\n            palindrome\
    \ = &palindrome[..suffix_length];\n            reversed_string = &reversed_string[..suffix_length];\n\
    \            prefix_length += 1;\n        }\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjliwc09v.rs:18:51\n\
    \   |\n18 |         while suffix_length < palindrome.len() && palindrome[suffix_length]\
    \ == reversed_string[suffix_length] {\n   |                                  \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjliwc09v.rs:18:80\n   |\n18 |         while suffix_length < palindrome.len()\
    \ && palindrome[suffix_length] == reversed_string[suffix_length] {\n   |     \
    \                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjliwc09v.rs:22:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n22 |             palindrome = &palindrome[..suffix_length];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n22 |        \
    \     p"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    for ch in reversed_string.chars()\
    \ {\n        if ch.is_uppercase() {\n            longest_postfix_length = longest_postfix_length.saturating_add(1);\n\
    \        } else {\n            longest_postfix_length = longest_postfix_length.saturating_add(2);\n\
    \        }\n    }\n    let mut postfix_length_to_prepend = longest_postfix_length;\n\
    \    let mut postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    let mut postfix_length_to_prepend\
    \ = longest_postfix_length;\n    let mut postfix_length_to_append = longest_postfix_length;\n\
    \    let mut postfix_length_to_prepend = longest_postfix_length;\n    let mut\
    \ postfix_length\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp77gwbftw.rs:50:27\n   |\n\
    50 |     let mut postfix_length\n   |                           ^ help: add `;`\
    \ here\n51 | }\n   | - unexpected token\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmp77gwbftw.rs:16:61\n   |\n\
    16 |             longest_postfix_length = longest_postfix_length.saturating_add(1);\n\
    \   |                                                             ^^^^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n13 |\
    \     let mut longest_postfix_length: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `saturating_add` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp77gwbftw.rs:18:61\n   |\n18 |             longest_postfix_length\
    \ = longest_postfix_length.saturating_add(2);\n   |                          \
    \                                   ^^^^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n13 |     let mut longest_postfix_length:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp77gwbftw.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp138iz3gm.rs:59:34\n   |\n\
    59 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp138iz3gm.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        while suffix_start < string.len() && string[suffix_start] != string[suffix_start\
    \ + 1] {\n            suffix_start += 1;\n        }\n        if suffix_start ==\
    \ suffix_length {\n            break;\n        }\n        let mut suffix_end =\
    \ suffix_start;\n        while suffix_end < string.len() && string[suffix_end]\
    \ != string[suffix_end - 1] {\n            suffix_end += 1;\n        }\n     \
    \   if suffix_end == suffix_length {\n            break;\n        }\n        let\
    \ mut suffix_length = suffix_end - suffix_start + 1;\n        let mut prefix_start\
    \ = prefix_length;\n        while prefix_start < suffix_start && string[prefix_start]\
    \ != string[prefix_start + 1] {\n            prefix_start += 1;\n        }\n \
    \       if prefix_start == prefix_length {\n            break;\n        }\n  \
    \      let mut prefix_end = prefix_start;\n        while prefix_end < suffix_end\
    \ && string[prefix_end] != string[prefix_end - 1] {\n            prefix_end +=\
    \ 1;\n        }\n        if prefix_end == prefix_length {\n            break;\n\
    \        }\n        let mut prefix_length = prefix_end - prefix_start + 1;\n \
    \       reversed_string = &string[prefix_start..prefix_end];\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpusgdfiyu.rs:17:46\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \      ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpusgdfiyu.rs:17:70\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpusgdfiyu.rs:24:44\n   |\n24 |         while suffix_end < string.len()\
    \ && string[suffix_end] != string[suffix_end - 1] {\n   |                    \
    \                        ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <St"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_char: char;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length = 0;\n    let\
    \ mut longest_postfix_char_length_reversed_length_index = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_index\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length_reverse\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp65id1jhe.rs:35:128\n   |\n\
    35 |     let mut longest_postfix_char_length_reversed_length_reversed_length_reversed_length_reversed_length_reversed_length_reverse\n\
    \   |                                                                        \
    \                                                        ^ help: add `;` here\n\
    36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp65id1jhe.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnsm0ttvn.rs:59:16\n   |\n\
    59 |     let mut lon\n   |                ^ help: add `;` here\n60 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsm0ttvn.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut suffix_length = 0;\n\
    \    let mut prefix_length = 0;\n    while !reversed_string.is_empty() {\n   \
    \     let mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip_while(|c|\
    \ c != current_char).collect();\n        if current_char == current_char.rev()\
    \ {\n            palindrome = palindrome[..prefix_length] + current_char + palindrome[prefix_length..];\n\
    \            suffix_length += 1;\n            prefix_length += 1;\n        } else\
    \ {\n            palindrome = palindrome[..prefix_length] + current_char + palindrome[prefix_length..];\n\
    \            suffix_length += 1;\n            prefix_length += 1;\n          \
    \  prefix_length += 1;\n        }\n    }\n    palindrome\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpxczzhwaf.rs:17:32\n   |\n17 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpxczzhwaf.rs:20:69\n   |\n20 |           \
    \  palindrome = palindrome[..prefix_length] + current_char + palindrome[prefix_length..];\n\
    \   |                                                                     ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpxczzhwaf.rs:24:69\n   |\n24 |  \
    \           palindrome = palindrome[..prefix_length] + current_char + palindrome[prefix_length..];\n\
    \   |                                                                     ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while let Some(suffix) = reversed_string.split_last_mut() {\n        if suffix.is_empty()\
    \ {\n            break;\n        }\n        let mut suffix_start = suffix.len()\
    \ - 1;\n        let mut suffix_end = suffix.len();\n        while suffix_start\
    \ >= 0 && suffix_end >= 0 && suffix_start >= suffix_end {\n            suffix_start\
    \ -= 1;\n            suffix_end -= 1;\n        }\n        if suffix_start < 0\
    \ {\n            suffix_start = suffix.len();\n        }\n        if suffix_end\
    \ < 0 {\n            suffix_end = suffix.len();\n        }\n        let mut suffix_reversed\
    \ = suffix[..suffix_end].chars().collect::<String>();\n        suffix_reversed.reverse();\n\
    \        reversed_string = suffix.chars().collect::<String>().concat(&suffix_reversed);\n\
    \        prefix_length = suffix_start + 1;\n    }\n    if prefix_length == 0 {\n\
    \        return string;\n    }\n    let mut reversed_string = reversed_string.chars().collect::<String>().concat(&string[..prefix_length]);\n\
    \    reversed_string.reverse();\n    reversed_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpfri5909q.rs:15:46\n   |\n15 |     while\
    \ let Some(suffix) = reversed_string.split_last_mut() {\n   |                \
    \                              ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0599]: no method named `concat` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpfri5909q.rs:39:75\n\
    \   |\n39 |     let mut reversed_string = reversed_string.chars().collect::<String>().concat(&string[..prefix_length]);\n\
    \   |                                                                        \
    \   ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    while longest_postfix_length < string.len() {\n        let mut longest_postfix_length_index\
    \ = 0;\n        while longest_postfix_length_index < longest_postfix_length {\n\
    \            let mut longest_postfix_length = longest_postfix_length;\n      \
    \      let mut longest_postfix_index = longest_postfix_index;\n            while\
    \ longest_postfix_index >= 0 && longest_postfix_index < string.len() {\n     \
    \           let mut current_char = string[longest_postfix_index];\n          \
    \      longest_postfix_index += 1;\n                while longest_postfix_index\
    \ >= 0 && longest_postfix_index < string.len() {\n                    let mut\
    \ next_char = string[longest_postfix_index];\n                    longest_postfix_index\
    \ += 1;\n                    if current_char == next_char {\n                \
    \        longest_postfix_length += 1;\n                    } else {\n        \
    \                break;\n                    }\n                }\n          \
    \  }\n        }\n        let mut longest_postfix_length = longest_postfix_length;\n\
    \        let mut longest_postfix_index = longest_postfix_index;\n        while\
    \ longest_postfix_index >= 0 && longest_postfix_index < string.len() {\n     \
    \       let mut current_char = string[longest_postfix_index];\n            longest_postfix_index\
    \ += 1;\n            while longest_postfix_index >= 0 && longest_postfix_index\
    \ < string.len() {\n                let mut next_char = string[longest_postfix_index];\n\
    \                longest_postfix_index += 1;\n                if current_char\
    \ == next_char {\n                    longest_postfix_length += 1;\n         \
    \       } else {\n                    break;\n                }\n            }\n\
    \        }\n        if longest_postfix_length == 0 {\n            break;\n   \
    \     }\n        let mut current_char = string[longest_postfix_index];\n     \
    \   longest_postfix_index += 1;\n        while longest_postfix_index >= 0 && longest_postfix_index\
    \ < string.len() {\n            let mut next_char = string[longest_postfix_index];\n\
    \            longest_postfix_index += 1;\n            if current_char == next_char\
    \ {\n                longest_postfix_length += 1;\n            } else {\n    \
    \            break;\n            }\n        }\n        let mut current_char =\
    \ string[longest_postfix_index];\n        longest_postfix_index += 1;\n      \
    \  while longest_postfix_index >= 0 && longest_postfix_index < string.len() {\n\
    \            let mut next_char = string[lon\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2096wokf.rs:78:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while longest_postfix_length\
    \ < string.len() {\n   |                                                 - unclosed\
    \ delimiter\n...\n67 |         while longest_postfix_index >= 0 && longest_postfix_index\
    \ < string.len() {\n   |                                                     \
    \                             - this delimiter might not be properly closed...\n\
    68 |             let mut next_char = string[lon\n69 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror: expected\
    \ one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp2096wokf.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmp2096wokf.rs:68:39\n  \
    \ |\n11 | fn make_palindrome(string: String) -> String {\n   |               \
    \                               - closing delimiter possibly meant for this\n\
    ...\n68 |             let mut next_char = string[lon\n   |                   \
    \                    ^ unclosed delimiter\n69 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2096wokf.rs:23:40\n\
    \   |\n23 |                 let mut current_char = string[longest_postfix_index];\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_start\
    \ = 0;\n    let mut longest_postfix_index_end = 0;\n    let mut longest_postfix_index_start_length\
    \ = 0;\n    let mut longest_postfix_index_end_length = 0;\n    let mut longest_postfix_index_start_start\
    \ = 0;\n    let mut longest_postfix_index_start_end = 0;\n    let mut longest_postfix_index_start_start_length\
    \ = 0;\n    let mut longest_postfix_index_start_end_length = 0;\n    let mut longest_postfix_index_start_start_start2\
    \ = 0;\n    let mut longest_postfix_index_start_start_length2 = 0;\n    let mut\
    \ longest_postfix_index_start_start_start3 = 0;\n    let mut longest_postfix_index_start_start_length3\
    \ = 0;\n    let mut longest_postfix_index_start_start_start4 = 0;\n    let mut\
    \ longest_postfix_index_start_start_length4 = 0;\n    let mut longest_postfix_index_start_start_start5\
    \ = 0;\n    let mut longest_postfix_index_start_start_length5 = 0;\n    let mut\
    \ longest_postfix_index_start_start_start6 = 0;\n    let mut longest_postfix_index_start_start_length6\
    \ = 0;\n    let mut longest_postfix_index_start_start_start7 = 0;\n    let mut\
    \ longest_postfix_index_start_start_length7 = 0;\n    let mut longest_postfix_index_start_start_start8\
    \ = 0;\n    let mut longest_postfix_index_start_start_length8 = 0;\n    let mut\
    \ longest_postfix_index_start_start_start9 = 0;\n    let mut longest_postfix_index_start_start_length9\
    \ = 0;\n    let mut longest_postfix_index_start_start_start10 = 0;\n    let mut\
    \ longest_postfix_index_start_start_length10 = 0;\n    let mut longest_postfix_index_start_start_start11\
    \ = 0;\n    let mut longest_postfix_index_start_start_length11 = 0;\n    let mut\
    \ longest_postfix_index_start_start_start12 = 0;\n    let mut longest_postfix_index_start_start_length12\
    \ = 0;\n    let mut longest_postfix_index_start_start_start13 = 0;\n    let mut\
    \ longest_postfix_index_start_start_length13 = 0;\n    let mut longest_postfix_index_start_start_start14\
    \ = 0;\n    let mut longest_postfix_index_start_start_length14 = 0;\n    let mut\
    \ longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9eayslmf.rs:52:21\n   |\n\
    52 |     let mut longest_\n   |                     ^ help: add `;` here\n53 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9eayslmf.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_index = string.len();\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n\n    while longest_postfix_index\
    \ > 0 {\n        let mut longest_postfix_index = 0;\n        let mut longest_postfix_length\
    \ = 0;\n\n        for index in 0..string.len() {\n            if string[index]\
    \ == string[longest_postfix_index] {\n                longest_postfix_index +=\
    \ 1;\n                longest_postfix_length += 1;\n            }\n        }\n\
    \n        if longest_postfix_length > longest_postfix_length {\n            longest_postfix\
    \ = &string[longest_postfix_index..];\n            longest_postfix_length = longest_postfix_length;\n\
    \        }\n    }\n\n    reversed_string += &string[longest_postfix_index..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp83vprbmm.rs:22:16\n\
    \   |\n22 |             if string[index] == string[longest_postfix_index] {\n\
    \   |                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp83vprbmm.rs:22:33\n\
    \   |\n22 |             if string[index] == string[longest_postfix_index] {\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index2\
    \ = 0;\n    let mut longest_postfix_end_index2 = 0;\n    let mut longest_postfix_start_index3\
    \ = 0;\n    let mut longest_postfix_end_index3 = 0;\n    let mut longest_postfix_start_index4\
    \ = 0;\n    let mut longest_postfix_end_index4 = 0;\n    let mut longest_postfix_start_index5\
    \ = 0;\n    let mut longest_postfix_end_index5 = 0;\n    let mut longest_postfix_start_index6\
    \ = 0;\n    let mut longest_postfix_end_index6 = 0;\n    let mut longest_postfix_start_index7\
    \ = 0;\n    let mut longest_postfix_end_index7 = 0;\n    let mut longest_postfix_start_index8\
    \ = 0;\n    let mut longest_postfix_end_index8 = 0;\n    let mut longest_postfix_start_index9\
    \ = 0;\n    let mut longest_postfix_end_index9 = 0;\n    let mut longest_postfix_start_index10\
    \ = 0;\n    let mut longest_postfix_end_index10 = 0;\n    let mut longest_postfix_start_index11\
    \ = 0;\n    let mut longest_postfix_end_index11 = 0;\n    let mut longest_postfix_start_index12\
    \ = 0;\n    let mut longest_postfix_end_index12 = 0;\n    let mut longest_postfix_start_index13\
    \ = 0;\n    let mut longest_postfix_end_index13 = 0;\n    let mut longest_postfix_start_index14\
    \ = 0;\n    let mut longest_postfix_end_index14 = 0;\n    let mut longest_postfix_start_index15\
    \ = 0;\n    let mut longest_postfix_end_index15 = 0;\n    let mut longest_postfix_start_index16\
    \ = 0;\n    let mut longest_postfix_end_index16 = 0;\n    let mut longest_postfix_start_index17\
    \ = 0;\n    let mut longest_postfix_end_index17 = 0;\n    let mut longest_postfix_start_index18\
    \ = 0;\n    let mut longest_postfix_end_index18 = 0;\n    let mut longest_postfix_start_index19\
    \ = 0;\n    let mut longest_postfix_end_index19 = 0;\n    let mut longest_postfix_start_index20\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jxwnw7v.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3dvmve1m.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3dvmve1m.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_palindrome\
    \ = 0;\n    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_suffix\
    \ = 0;\n    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palin\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwseva_ry.rs:52:26\n   |\n\
    52 |     let mut longest_palin\n   |                          ^ help: add `;`\
    \ here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwseva_ry.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_suffix = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_suffix = 0;\n    while longest_palindrome_length\
    \ < longest_palindrome.len() {\n        let mut longest_palindrome_prefix_length\
    \ = 0;\n        let mut longest_palindrome_prefix_suffix = 0;\n        let mut\
    \ longest_palindrome_suffix = 0;\n        let mut longest_palindrome_length =\
    \ 0;\n        let mut longest_palindrome = string;\n        while longest_palindrome_length\
    \ < longest_palindrome.len() {\n            let mut longest_palindrome_prefix_length\
    \ = 0;\n            let mut longest_palindrome_prefix_suffix = 0;\n          \
    \  let mut longest_palindrome_suffix = 0;\n            let mut longest_palindrome_length\
    \ = 0;\n            let mut longest_palindrome = string;\n            while longest_palindrome_length\
    \ < longest_palindrome.len() {\n                let mut longest_palindrome_prefix_length\
    \ = 0;\n                let mut longest_palindrome_prefix_suffix = 0;\n      \
    \          let mut longest_palindrome_suffix = 0;\n                let mut longest_palindrome_length\
    \ = 0;\n                let mut longest_palindrome = string;\n               \
    \ while longest_palindrome_length < longest_palindrome.len() {\n             \
    \       let mut longest_palindrome_prefix_length = 0;\n                    let\
    \ mut longest_palindrome_prefix_suffix = 0;\n                    let mut longest_palindrome_suffix\
    \ = 0;\n                    let mut longest_palindrome_length = 0;\n         \
    \           let mut longest_palindrome = string;\n                    while longest_palindrome_length\
    \ < longest_palindrome.len() {\n                        let mut longest_palindrome_prefix_length\
    \ = 0;\n                        let mut longest_palindrome_prefix_suffix = 0;\n\
    \                        let mut longest_palindrome_suffix = 0;\n            \
    \            let mut longest_palindrome_length = 0;\n                        let\
    \ mut longest_palindrome = string;\n                        while longest_palindrome_length\
    \ < lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpziuug2l2.rs:60:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n20 |     while longest_palindrome_length\
    \ < longest_palindrome.len() {\n   |                                         \
    \                       - unclosed delimiter\n...\n26 |         while longest_palindrome_length\
    \ < longest_palindrome.len() {\n   |                                         \
    \                           - unclosed delimiter\n...\n32 |             while\
    \ longest_palindrome_length < longest_palindrome.len() {\n   |               \
    \                                                         - unclosed delimiter\n\
    ...\n38 |                 while longest_palindrome_length < longest_palindrome.len()\
    \ {\n   |                                                                    \
    \        - unclosed delimiter\n...\n44 |                     while longest_palindrome_length\
    \ < longest_palindrome.len() {\n   |                                         \
    \                                       - this delimiter might not be properly\
    \ closed...\n...\n51 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n60 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpziuug2l2.rs:51:1\n\
    \   |\n50 |                         while longest_palindrome_length < lon\n  \
    \ |                         ----- ------------------------------- this `while`\
    \ condition successfully parsed\n   |                         |\n   |        \
    \                 while parsing the body of this `while` expression\n51 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpziuug2l2.rs:20:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n20 | /     while longest_palindrome_length < longest_palindrome.len() {\n\
    21 | |         let mut longest_palindrome_prefix_length = 0;\n22 | |         let\
    \ mut longest_palindrome_prefix_suffix = 0;\n23 | |         let mut longest"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != 0 {\n        reversed_string.insert(0, reversed_string[prefix_length]);\n\
    \        suffix_length -= 1;\n        prefix_length += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpvnfbf1ky.rs:16:35\n   |\n16 |         reversed_string.insert(0, reversed_string[prefix_length]);\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_size = string.len();\n    let mut longest_postfix_index\
    \ = -1;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_reverse = \"\";\n    let mut longest_postfix_postfix_reverse_size\
    \ = string.len();\n    let mut longest_postfix_postfix_reverse_index = 0;\n  \
    \  let mut longest_postfix_postfix_reverse_length = 0;\n    let mut longest_postfix_postfix_reverse_index2\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_length2 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index3 = 0;\n    let mut longest_postfix_postfix_reverse_length3\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index4 = 0;\n    let mut longest_postfix_postfix_reverse_length4\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index5 = 0;\n    let mut longest_postfix_postfix_reverse_length5\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index6 = 0;\n    let mut longest_postfix_postfix_reverse_length6\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index7 = 0;\n    let mut longest_postfix_postfix_reverse_length7\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index8 = 0;\n    let mut longest_postfix_postfix_reverse_length8\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index9 = 0;\n    let mut longest_postfix_postfix_reverse_length9\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index10 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_length10 = 0;\n    let mut longest_postfix_postfix_reverse_index11\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_length11 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index12 = 0;\n    let mut longest_postfix_postfix_reverse_length12\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index13 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_length13 = 0;\n    let mut longest_postfix_postfix_reverse_index14\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_length14 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index15 = 0;\n    let mut longest_postfix_postfix_reverse_length15\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index16 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8ftrmqfe.rs:50:45\n   |\n\
    50 |     let mut longest_postfix_postfix_reverse_\n   |                      \
    \                       ^ help: add `;` here\n51 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8ftrmqfe.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n\n    while !reversed_string.is_empty() {\n        let mut reversed_string\
    \ = reversed_string.chars().collect::<String>();\n        let mut longest_postfix\
    \ = longest_postfix.chars().collect::<String>();\n        let mut longest_postfix_length\
    \ = 0;\n\n        while !reversed_string.is_empty() {\n            let mut reversed_string\
    \ = reversed_string.chars().collect::<String>();\n            let mut longest_postfix\
    \ = longest_postfix.chars().collect::<String>();\n\n            if longest_postfix_length\
    \ == 0 {\n                longest_postfix_length = reversed_string.len();\n  \
    \          }\n\n            if longest_postfix_length < reversed_string.len()\
    \ {\n                longest_postfix_length = reversed_string.len();\n       \
    \     }\n\n            if longest_postfix_length == reversed_string.len() {\n\
    \                longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \                longest_postfix_length = 0;\n            }\n\n            if\
    \ longest_postfix_length < reversed_string.len() {\n                longest_postfix\
    \ = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n    \
    \            longest_postfix_length = 0;\n            }\n\n            if longest_postfix_length\
    \ == reversed_string.len() {\n                longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \                longest_postfix_length = 0;\n            }\n\n            if\
    \ longest_postfix_length < reversed_string.len() {\n                longest_postfix\
    \ = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n    \
    \            longest_postfix_length = 0;\n            }\n\n            if longest_postfix_length\
    \ == reversed_string.len() {\n                longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \                longest_postfix_length = 0;\n            }\n\n            if\
    \ longest_postfix_length < reversed_string.len() {\n                longest_postfix\
    \ = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n    \
    \            longest_postfix_length = 0;\n            }\n\n            if longest_postfix_length\
    \ == reversed_string.len() {\n                longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \                longest_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprcqrz9a6.rs:75:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while !reversed_string.is_empty()\
    \ {\n   |                                       - unclosed delimiter\n...\n21\
    \ |         while !reversed_string.is_empty() {\n   |                        \
    \                   - unclosed delimiter\n...\n63 |             if longest_postfix_length\
    \ == reversed_string.len() {\n   |                                           \
    \                     - this delimiter might not be properly closed...\n...\n\
    66 | }\n   | - ...as it matches this but it has different indentation\n...\n75\
    \ | }\n   |   ^\n\nerror[E0425]: cannot find value `longest_post` in this scope\n\
    \  --> /tmp/tmprcqrz9a6.rs:65:17\n   |\n65 |                 longest_post\n  \
    \ |                 ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `longest_postfix`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprcqrz9a6.rs:34:51\n   |\n34 | \
    \                longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmprcqrz9a6.rs:39:51\n   |\n39 |          \
    \       longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmprcqrz9a6.rs:44:51\n   |\n44 |          \
    \       longest_postfix = longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmprcqrz9a6.rs:49:51\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reverse = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j + 1 < string.len()\
    \ && string[j + 1] == string[j] {\n            j += 1;\n        }\n        reverse.push_str(&string[i..j]);\n\
    \        i = j;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppd3xa6zo.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j + 1] == string[j] {\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppd3xa6zo.rs:17:56\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j + 1] == string[j] {\n   |                                      \
    \                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut i = 0;\n    while i\
    \ < palindrome.len() {\n        let mut j = palindrome.len() - 1;\n        while\
    \ j >= i {\n            if palindrome[j] != palindrome[j + 1] {\n            \
    \    break;\n            }\n            j -= 1;\n        }\n        if j == i\
    \ {\n            palindrome = &palindrome[..i];\n            i += 1;\n       \
    \ } else {\n            palindrome = &palindrome[..j + 1] + &palindrome[j..];\n\
    \        }\n    }\n    reversed_string += &palindrome[..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp75vdfc3a.rs:18:16\n\
    \   |\n18 |             if palindrome[j] != palindrome[j + 1] {\n   |        \
    \        ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp75vdfc3a.rs:18:33\n   |\n18 |             if palindrome[j] != palindrome[j\
    \ + 1] {\n   |                                 ^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp75vdfc3a.rs:24:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n24 |             palindrome = &palindrome[..i];\n\
    \   |                          ^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n24 |             palindrome\
    \ = (&palindrome[..i]).to_string();\n   |                          +         \
    \       +++++++++++++\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmp75vdfc3a.rs:27:47\n\
    \   |\n27 |             palindrome = &palindrome[..j + 1] + &palindrome[j"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string.chars().next().unwrap();\n\
    \        if current_char == &'a' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'z' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'A' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'Z' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'0' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'9' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'.' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            prefix_length += 1;\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzuzenwqk.rs:103:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n15  |     while\
    \ !reversed_string.is_empty() {\n    |                                       -\
    \ unclosed delimiter\n...\n92  |         if current_char == &'_' {\n    |    \
    \                             - this delimiter might not be properly closed...\n\
    93  |             prefix_length += 1;\n94  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n103 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzuzenwqk.rs:17:28\n   |\n17 |         if current_char ==\
    \ &'a' {\n   |                            ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n17 -         if current_char\
    \ == &'a' {\n17 +         if current_char == 'a' {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzuzenwqk.rs:20:28\n   |\n20 |         if current_char ==\
    \ &'z' {\n   |                            ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n20 -         if current_char\
    \ == &'z' {\n20 +         if current_char == 'z' {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzuzenwqk.rs:23:28\n   |\n23 |         if current_char ==\
    \ &'A' {\n   |                            ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n23 -         if current_char\
    \ == &'A' {\n23 +         if current_char == 'A' {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzuzenwqk.rs:26:28\n   |\n26 |         if current_char ==\
    \ &'Z' {\n   |                            ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n26 -         if current_char\
    \ == &'Z' {\n26 +         if current_char == 'Z' {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzuzenwqk.rs:29:28\n   |\n29 |         if current_char ==\
    \ &'0' {\n   |                            ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n29 -         if curren"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    for pos in string.char_indices()\
    \ {\n        let mut postfix = &mut reversed_string[..pos];\n        let mut palindrome\
    \ = &mut reversed_string[..pos];\n        let mut i = 0;\n        while i < palindrome.len()\
    \ {\n            if palindrome[i] != postfix[i] {\n                break;\n  \
    \          }\n            i += 1;\n        }\n        if i == palindrome.len()\
    \ {\n            longest_postfix_length = pos;\n        }\n    }\n    let mut\
    \ reversed_postfix = &reversed_string[..longest_postfix_length];\n    reversed_postfix.reverse();\n\
    \    reversed_string += &reversed_postfix;\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpubu2dnri.rs:15:32\n   |\n15 |         let mut postfix = &mut reversed_string[..pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<(usize,\
    \ char)>`\n  --> /tmp/tmpubu2dnri.rs:16:35\n   |\n16 |         let mut palindrome\
    \ = &mut reversed_string[..pos];\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the\
    \ trait `Index<RangeTo<(usize, char)>>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpubu2dnri.rs:25:38\n\
    \   |\n13 |     let mut longest_postfix_length = 0;\n   |                    \
    \                  - expected due to this value\n...\n25 |             longest_postfix_length\
    \ = pos;\n   |                                      ^^^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0599]: no method named `reverse` found for reference\
    \ `&str` in the current sco"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = \"\";\n    for pos in string.len() {\n        let mut postfix = &string[..pos];\n\
    \        let mut reversed_postfix = &reversed_string[..pos];\n        if postfix.chars().all(|c|\
    \ !c.is_alphanumeric()) {\n            longest_postfix_length = pos;\n       \
    \     longest_postfix = postfix;\n        }\n        if reversed_postfix.chars().all(|c|\
    \ !c.is_alphanumeric()) {\n            reversed_postfix = reversed_postfix.chars().collect::<String>().reverse().collect();\n\
    \            reversed_string += &reversed_postfix;\n        }\n    }\n    longest_postfix.chars().collect::<String>().reverse().collect();\n\
    \    reversed_string += &longest_postfix;\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmpva6puh0b.rs:15:16\n\
    \   |\n15 |     for pos in string.len() {\n   |                ^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpva6puh0b.rs:23:77\n\
    \   |\n23 |             reversed_postfix = reversed_postfix.chars().collect::<String>().reverse().collect();\n\
    \   |                                                                        \
    \     ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpva6puh0b.rs:27:49\n   |\n27 |     longest_postfix.chars().collect::<String>().reverse().collect();\n\
    \   |                                                 ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut reversed_char = reversed_string.chars().next().unwrap();\n\
    \        while !reversed_char.is_ascii_lowercase() {\n            reversed_char\
    \ = reversed_string.chars().next().unwrap();\n        }\n        if reversed_char\
    \ != reversed_string[suffix_length] {\n            break;\n        }\n       \
    \ suffix_length += 1;\n    }\n    while !prefix_length.is_zero() {\n        let\
    \ mut prefix_char = string.chars().next().unwrap();\n        while !prefix_char.is_ascii_lowercase()\
    \ {\n            prefix_char = string.chars().next().unwrap();\n        }\n  \
    \      if prefix_char != string[prefix_length] {\n            break;\n       \
    \ }\n        prefix_length += 1;\n    }\n    string += &reversed_string[..prefix_length];\n\
    \    string += &reversed_string[prefix_length..];\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpid5vf_rn.rs:20:29\n   |\n20 |         if reversed_char != reversed_string[suffix_length]\
    \ {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0689]: can't call method `is_zero` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmpid5vf_rn.rs:25:26\n   |\n25 |     while !prefix_length.is_zero()\
    \ {\n   |                          ^^^^^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n14 |     let mut prefix_length: i32 = 0;\n\
    \   |         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmpid5vf_rn.rs:30:27\n   |\n30 |     \
    \    if prefix_char != string[prefix_length] {\n   |                         \
    \  ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   =\
    \ help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0689.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_start_index2 = 0;\n    let mut longest_postfix_end_index2\
    \ = 0;\n    let mut longest_postfix_start_index3 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_start_index4 = 0;\n    let mut longest_postfix_end_index4\
    \ = 0;\n    let mut longest_postfix_start_index5 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_start_index6 = 0;\n    let mut longest_postfix_end_index6\
    \ = 0;\n    let mut longest_postfix_start_index7 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_start_index8 = 0;\n    let mut longest_postfix_end_index8\
    \ = 0;\n    let mut longest_postfix_start_index9 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_start_index10 = 0;\n    let mut longest_postfix_end_index10\
    \ = 0;\n    let mut longest_postfix_start_index11 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_start_index12 = 0;\n    let mut longest_postfix_end_index12\
    \ = 0;\n    let mut longest_postfix_start_index13 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_start_index14 = 0;\n    let mut longest_postfix_end_index14\
    \ = 0;\n    let mut longest_postfix_start_index15 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_start_index16 = 0;\n    let mut longest_postfix_end_index16\
    \ = 0;\n    let mut longest_postfix_start_index17 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_start_index18 = 0;\n    let mut longest_postfix_end_index18\
    \ = 0;\n    let mut longest_postfix_start_index19 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_start_index20 = 0;\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1xvs3_z8.rs:56:25\n   |\n\
    56 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xvs3_z8.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut palindrome_length =\
    \ 0;\n    let mut palindrome_start = 0;\n    let mut palindrome_end = 0;\n   \
    \ let mut palindrome_suffix = 0;\n    let mut palindrome_prefix_length = 0;\n\n\
    \    while palindrome_end < palindrome.len() {\n        palindrome_end = palindrome_end\
    \ + 1;\n        palindrome_prefix_length = palindrome_end - palindrome_start;\n\
    \        palindrome_suffix = palindrome[palindrome_prefix_length..].chars().collect::<String>();\n\
    \        palindrome_start = palindrome_end - palindrome_prefix_length;\n     \
    \   palindrome = palindrome[..palindrome_end].to_string();\n\n        if palindrome.chars().collect::<String>()\
    \ == palindrome_suffix {\n            palindrome_length = palindrome_end - palindrome_start;\n\
    \            palindrome = palindrome[..palindrome_end].to_string();\n        \
    \    palindrome_start = palindrome_end - palindrome_prefix_length;\n         \
    \   palindrome = palindrome[..palindrome_end].to_string();\n        }\n    }\n\
    \n    palindrome = palindrome[..palindrome_end].to_string();\n    palindrome =\
    \ palindrome.reverse();\n\n    while palindrome_end < palindrome.len() {\n   \
    \     palindrome_end = palindrome_end + 1;\n        palindrome_prefix_length =\
    \ palindrome_end - palindrome_start;\n        palindrome_suffix = palindrome[palindrome_prefix_length..].chars().collect::<String>();\n\
    \        palindrome_start = palindrome_end - palindrome_prefix_length;\n     \
    \   palindrome = palindrome[..palindrome_end].to_string();\n\n        if palindrome.chars().collect::<String>()\
    \ == palindrome_suffix {\n            palindrome_length = palindrome_end - palindrome_start;\n\
    \            palindrome = palindrome[..palindrome_end].to_string();\n        \
    \    palindrome_start = palindrome_end - palindrome_prefix_length;\n         \
    \   palindrome = palindrome[..palindrome_end].to_string();\n        }\n    }\n\
    \n    palindrome = palindrome[..palindro\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpsadkj4b_.rs:53:28\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n53 |     palindrome = palindrome[..palindro\n   |                       \
    \     ^ unclosed delimiter\n54 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]:\
    \ cannot find value `palindro` in this scope\n  --> /tmp/tmpsadkj4b_.rs:53:31\n\
    \   |\n53 |     palindrome = palindrome[..palindro\n   |                     \
    \          ^^^^^^^^ help: a local variable with a similar name exists: `palindrome`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsadkj4b_.rs:23:29\n   |\n17 |\
    \     let mut palindrome_suffix = 0;\n   |                                 - expected\
    \ due to this value\n...\n23 |         palindrome_suffix = palindrome[palindrome_prefix_length..].chars().collect::<String>();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found struct `String`\n\nerror[E0277]: can't compare `String`\
    \ with `{integer}`\n  --> /tmp/tmpsadkj4b_.rs:27:51\n   |\n27 |         if palindrome.chars().collect::<String>()\
    \ == palindrome_suffix {\n   |                                               \
    \    ^^ no implementation for `String == {integer}`\n   |\n   = help: the trait\
    \ `PartialEq<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpsadkj4b_.rs:36:29\n   |\n36 | \
    \    palindrome = palindrome.reverse();\n   |                             ^^^^^^^\
    \ h"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reverse = string;\n    let mut i = 0;\n    while i <\
    \ string.len() {\n        let mut j = i;\n        while j + 1 < string.len() &&\
    \ string[j + 1] == string[j] {\n            j += 1\n        }\n        reverse\
    \ = reverse.insert(j, string[i]);\n        i += 1;\n    }\n    reverse\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu2trgghd.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j + 1] == string[j] {\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu2trgghd.rs:17:56\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j + 1] == string[j] {\n   |                                      \
    \                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu2trgghd.rs:20:37\n\
    \   |\n20 |         reverse = reverse.insert(j, string[i]);\n   |            \
    \                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut suffix = 0;\n    while palindrome.len() > 0 {\n     \
    \   let mut prefix = palindrome.clone();\n        while prefix.len() > 0 {\n \
    \           if prefix[prefix.len() - 1] != palindrome[suffix] {\n            \
    \    break;\n            }\n            prefix += &palindrome[suffix];\n     \
    \       suffix += 1;\n        }\n        palindrome = &palindrome[..suffix];\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptaae1f4e.rs:17:16\n\
    \   |\n17 |             if prefix[prefix.len() - 1] != palindrome[suffix] {\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmptaae1f4e.rs:17:44\n   |\n17 |             if prefix[prefix.len()\
    \ - 1] != palindrome[suffix] {\n   |                                         \
    \   ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmptaae1f4e.rs:20:24\n\
    \   |\n20 |             prefix += &palindrome[suffix];\n   |                 \
    \       ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n \
    \  = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeT"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = string.len();\n    while reverse_length\
    \ > 0 {\n        reversed_string = reversed_string[..reverse_length - 1];\n  \
    \      reverse_length -= 1;\n    }\n    reversed_string\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4xweni4.rs:15:27\n   |\n\
    12 |     let mut reversed_string = string;\n   |                             \
    \  ------ expected due to this value\n...\n15 |         reversed_string = reversed_string[..reverse_length\
    \ - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_len = string.len();\n    let mut longest_postfix\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mut longest_postfix_end_pos = 0;\n    let mut longest_postfix_start_pos\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuedg3cv1.rs:58:11\n   |\n\
    58 |     let mu\n   |           ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuedg3cv1.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    for pos in string.len()\
    \ {\n        let mut postfix_length = pos;\n        while postfix_length >= 0\
    \ {\n            let mut postfix_char = string[postfix_length];\n            while\
    \ postfix_char != string[postfix_length - 1] {\n                postfix_length\
    \ -= 1;\n                postfix_char = string[postfix_length];\n            }\n\
    \            postfix_length -= 1;\n            longest_postfix_length = if postfix_length\
    \ > longest_postfix_length { postfix_length } else { longest_postfix_length };\n\
    \        }\n    }\n    let mut postfix_length = longest_postfix_length;\n    let\
    \ mut postfix_char = string[longest_postfix_length];\n    while postfix_length\
    \ >= 0 {\n        let mut postfix_char = string[postfix_length];\n        while\
    \ postfix_char != string[postfix_length - 1] {\n            postfix_length -=\
    \ 1;\n            postfix_char = string[postfix_length];\n        }\n        postfix_length\
    \ -= 1;\n    }\n    reversed_string += &string[longest_postfix_length..];\n  \
    \  reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmppk01jumx.rs:14:16\n\
    \   |\n14 |     for pos in string.len() {\n   |                ^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmppk01jumx.rs:17:36\n   |\n17 |             let\
    \ mut postfix_char = string[postfix_length];\n   |                           \
    \         ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppk01jumx.rs:20:32\n   |\n20 |                 postfix_char = string[postfix_length];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut prefix_length =\
    \ 0;\n    let mut suffix_length = 0;\n    while !palindrome.is_empty() {\n   \
    \     let mut current_char = &palindrome[prefix_length];\n        let mut current_char_length\
    \ = palindrome.len() - prefix_length;\n        while current_char_length > 0 {\n\
    \            let mut current_char_char = &palindrome[current_char_length];\n \
    \           if current_char_char == current_char {\n                current_char_length\
    \ -= 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        reversed_string += &palindrome[prefix_length..current_char_length];\n\
    \        prefix_length = current_char_length;\n        current_char = &palindrome[suffix_length];\n\
    \        let mut current_char_length = palindrome.len() - suffix_length;\n   \
    \     while current_char_length > 0 {\n            let mut current_char_char =\
    \ &palindrome[current_char_length];\n            if current_char_char == current_char\
    \ {\n                current_char_length -= 1;\n            } else {\n       \
    \         break;\n            }\n        }\n        reversed_string += &palindrome[suffix_length..current_char_length];\n\
    \        suffix_length = current_char_length;\n        palindrome = &palindrome[..];\n\
    \    }\n    reversed_string += &palindrome[suffix_length..];\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpr9ifk1dn.rs:17:33\n   |\n17 |         let mut current_char = &palindrome[prefix_length];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr9ifk1dn.rs:20:42\n   |\n20 |             let mut current_char_char\
    \ = &palindrome[current_char_length];\n   |                                  \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpr9ifk1dn.rs:27:9\n   |\n27 |         reversed_string\
    \ += &palindrome[prefix_length..current_char_length];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpr9ifk1dn.rs:29:25\n\
    \   |\n29 |         current_char = &palindrome[suffix_length];\n   |         \
    \                ^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_index = string.len()\
    \ - suffix_length;\n        let mut prefix_index = suffix_index;\n        while\
    \ prefix_index < suffix_index {\n            let mut prefix_char = string[prefix_index];\n\
    \            let mut suffix_char = string[suffix_index];\n            while prefix_char\
    \ != suffix_char {\n                suffix_index -= 1;\n                prefix_index\
    \ += 1;\n                suffix_char = string[suffix_index];\n            }\n\
    \            prefix_index += 1;\n            suffix_char = string[suffix_index];\n\
    \        }\n        suffix_length += 1;\n        prefix_length += 1;\n       \
    \ reversed_string += string[prefix_index..suffix_index];\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv4jgq9i2.rs:19:35\n\
    \   |\n19 |             let mut prefix_char = string[prefix_index];\n   |    \
    \                               ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv4jgq9i2.rs:20:35\n   |\n20 |             let mut suffix_char =\
    \ string[suffix_index];\n   |                                   ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv4jgq9i2.rs:24:31\n   |\n24 |                 suffix_char = string[suffix_index];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = string;\n    let mut i = 0;\n    while i <\
    \ reverse.len() {\n        if reverse == &longest[..i] {\n            longest\
    \ = &longest[i..];\n            i += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    reverse.push_str(&longest);\n    reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpulhedtft.rs:17:23\n   |\n\
    13 |     let mut longest = string;\n   |                       ------ expected\
    \ due to this value\n...\n17 |             longest = &longest[i..];\n   |    \
    \                   ^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n17 |             longest = (&longest[i..]).to_string();\n\
    \   |                       +             +++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_count\
    \ = 0;\n    let mut longest_postfix_length_reverse_count2 = 0;\n    let mut longest_postfix_length_reverse_count3\
    \ = 0;\n    let mut longest_postfix_length_reverse_count4 = 0;\n    let mut longest_postfix_length_reverse_count5\
    \ = 0;\n    let mut longest_postfix_length_reverse_count6 = 0;\n    let mut longest_postfix_length_reverse_count7\
    \ = 0;\n    let mut longest_postfix_length_reverse_count8 = 0;\n    let mut longest_postfix_length_reverse_count9\
    \ = 0;\n    let mut longest_postfix_length_reverse_count10 = 0;\n    let mut longest_postfix_length_reverse_count11\
    \ = 0;\n    let mut longest_postfix_length_reverse_count12 = 0;\n    let mut longest_postfix_length_reverse_count13\
    \ = 0;\n    let mut longest_postfix_length_reverse_count14 = 0;\n    let mut longest_postfix_length_reverse_count15\
    \ = 0;\n    let mut longest_postfix_length_reverse_count16 = 0;\n    let mut longest_postfix_length_reverse_count17\
    \ = 0;\n    let mut longest_postfix_length_reverse_count18 = 0;\n    let mut longest_postfix_length_reverse_count19\
    \ = 0;\n    let mut longest_postfix_length_reverse_count20 = 0;\n    let mut longest_postfix_length_reverse_count21\
    \ = 0;\n    let mut longest_postfix_length_reverse_count22 = 0;\n    let mut longest_postfix_length_reverse_count23\
    \ = 0;\n    let mut longest_postfix_length_reverse_count24 = 0;\n    let mut longest_postfix_length_reverse_count25\
    \ = 0;\n    let mut longest_postfix_length_reverse_count26 = 0;\n    let mut longest_postfix_length_reverse_count27\
    \ = 0;\n    let mut longest_postfix_length_reverse_count28 = 0;\n    let mut longest_postfix_length_reverse_count29\
    \ = 0;\n    let mut longest_postfix_length_reverse_count30 = 0;\n    let mut longest_postfix_length_reverse_count31\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpze1nccm7.rs:51:16\n   |\n\
    51 |     let mut lon\n   |                ^ help: add `;` here\n52 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpze1nccm7.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        while suffix_start < string.len() && string[suffix_start] != string[suffix_start\
    \ + 1] {\n            suffix_start += 1;\n        }\n        let mut suffix_end\
    \ = suffix_start + 1;\n        while suffix_end < string.len() && string[suffix_end]\
    \ != string[suffix_end - 1] {\n            suffix_end += 1;\n        }\n     \
    \   if suffix_start < suffix_end {\n            suffix_length = suffix_end - suffix_start;\n\
    \            reversed_string.push_str(&string[prefix_length..suffix_start]);\n\
    \            prefix_length = suffix_start + 1;\n        } else {\n           \
    \ suffix_length = 0;\n        }\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4g_22umc.rs:17:46\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \      ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4g_22umc.rs:17:70\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4g_22umc.rs:21:44\n   |\n21 |         while suffix_end < string.len()\
    \ && string[suffix_end] != string[suffix_end - 1] {\n   |                    \
    \                        ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <St"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_end = 0;\n    let mut longest_postfix_char_length_start\
    \ = 0;\n    let mut longest_postfix_char_length_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbfg3ge04.rs:55:41\n   |\n\
    55 |     let mut longest_postfix_char_length_\n   |                          \
    \               ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbfg3ge04.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpipgwnuuc.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpipgwnuuc.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        let mut suffix_end = suffix_length;\n        while suffix_end < string.len()\
    \ {\n            if string[suffix_end] != string[suffix_end - 1] {\n         \
    \       break;\n            }\n            suffix_end += 1;\n        }\n     \
    \   if suffix_start == suffix_end {\n            break;\n        }\n        let\
    \ mut suffix_length = suffix_end - suffix_start + 1;\n        let mut prefix_start\
    \ = prefix_length;\n        let mut prefix_end = prefix_length;\n        while\
    \ prefix_end < string.len() {\n            if string[prefix_end] != string[prefix_end\
    \ - 1] {\n                break;\n            }\n            prefix_end += 1;\n\
    \        }\n        if prefix_start == prefix_end {\n            break;\n    \
    \    }\n        let mut prefix_length = prefix_end - prefix_start + 1;\n     \
    \   reversed_string.insert(0, string[suffix_start..suffix_end]);\n    }\n    reversed_string.insert(0,\
    \ string[prefix_length..]);\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn_45lnsd.rs:19:16\n\
    \   |\n19 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn_45lnsd.rs:19:38\n   |\n19 |             if string[suffix_end]\
    \ != string[suffix_end - 1] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn_45lnsd.rs:31:16\n   |\n31 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_start_index2 = 0;\n    let mut longest_postfix_end_index2\
    \ = 0;\n    let mut longest_postfix_start_index3 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_start_index4 = 0;\n    let mut longest_postfix_end_index4\
    \ = 0;\n    let mut longest_postfix_start_index5 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_start_index6 = 0;\n    let mut longest_postfix_end_index6\
    \ = 0;\n    let mut longest_postfix_start_index7 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_start_index8 = 0;\n    let mut longest_postfix_end_index8\
    \ = 0;\n    let mut longest_postfix_start_index9 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_start_index10 = 0;\n    let mut longest_postfix_end_index10\
    \ = 0;\n    let mut longest_postfix_start_index11 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_start_index12 = 0;\n    let mut longest_postfix_end_index12\
    \ = 0;\n    let mut longest_postfix_start_index13 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_start_index14 = 0;\n    let mut longest_postfix_end_index14\
    \ = 0;\n    let mut longest_postfix_start_index15 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_start_index16 = 0;\n    let mut longest_postfix_end_index16\
    \ = 0;\n    let mut longest_postfix_start_index17 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_start_index18 = 0;\n    let mut longest_postfix_end_index18\
    \ = 0;\n    let mut longest_postfix_start_index19 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_start_index20 = 0;\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj3ah0own.rs:56:25\n   |\n\
    56 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3ah0own.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    for c in string.chars()\
    \ {\n        if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n        }\n    }\n    for c in string.chars() {\n        if longest_postfix_length\
    \ == c.len() {\n            reversed_string += &c.to_string();\n        }\n  \
    \  }\n    reversed_string += &string[longest_postfix_length..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpi1dqzv37.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpi1dqzv37.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpi1dqzv37.rs:20:40\n   |\n20 |         if longest_postfix_length\
    \ == c.len() {\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpi1dqzv37.rs:21:13\n   |\n21 |             reversed_string\
    \ += &c.to_string();\n   |             ---------------^^^^^^^^^^^^^^^^^^\n   |\
    \             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpi1dqzv37.rs:24:5\n\
    \   |\n24 |     reversed_string += &string[longest_postfix_length..];\n   |  \
    \   ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n   |   \
    \  cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1dqzv37.rs:25:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    25 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut postfix = string;\n    let mut i = 0;\n    while i <\
    \ string.len() {\n        if string[i] == string[string.len() - i - 1] {\n   \
    \         i += 1;\n        } else {\n            postfix = &string[i..].to_owned();\n\
    \            reverse = &string[..i].to_owned();\n            break;\n        }\n\
    \    }\n    reverse += postfix;\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsqljm_nw.rs:16:12\n\
    \   |\n16 |         if string[i] == string[string.len() - i - 1] {\n   |     \
    \       ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsqljm_nw.rs:16:25\n   |\n16 |         if string[i] == string[string.len()\
    \ - i - 1] {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqljm_nw.rs:19:23\n\
    \   |\n13 |     let mut postfix = string;\n   |                       ------ expected\
    \ due to this value\n...\n19 |             postfix = &string[i..].to_owned();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n19 -      \
    \       postfix = &string[i..].to_owned();\n19 +             postfix = string[i..].to_owned();\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqljm_nw.rs:20:23\n  \
    \ |\n12 |     let mut reverse = string;\n   |                       ------ expected\
    \ due to t"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string[prefix_length];\n\
    \        let mut next_char = reversed_string[suffix_length];\n        if current_char\
    \ == next_char {\n            suffix_length += 1;\n        } else {\n        \
    \    prefix_length += 1;\n            suffix_length += 1;\n        }\n       \
    \ reversed_string = reversed_string.chars().skip_while(|&c| c != current_char).collect();\n\
    \    }\n    prefix_length\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp8m1xqk52.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[prefix_length];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp8m1xqk52.rs:17:29\n   |\n17 |         let mut next_char = reversed_string[suffix_length];\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8m1xqk52.rs:26:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    26 |     prefix_length\n   |     ^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found integer\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string[0];\n\
    \        reversed_string = reversed_string.split_last_mut()?;\n        if current_char\
    \ == current_char.to_chars().last().unwrap() {\n            suffix_length += 1;\n\
    \        } else {\n            prefix_length += 1;\n        }\n    }\n    let\
    \ mut palindrome = String::new();\n    palindrome.push_str(&string[prefix_length..suffix_length]);\n\
    \    palindrome.push_str(&string[suffix_length..]);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmprl_47glf.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_last_mut` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprl_47glf.rs:17:43\n   |\n17 | \
    \        reversed_string = reversed_string.split_last_mut()?;\n   |          \
    \                                 ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0277]: the `?` operator can\
    \ only be used in a function that returns `Result` or `Option` (or another type\
    \ that implements `FromResidual`)\n  --> /tmp/tmprl_47glf.rs:17:59\n   |\n11 |\
    \ / fn make_palindrome(string: String) -> String {\n12 | |     let mut reversed_string\
    \ = string;\n13 | |     let mut prefix_length = 0;\n14 | |     let mut suffix_length\
    \ = 0;\n...  |\n17 | |         reversed_string = reversed_string.split_last_mut()?;\n\
    \   | |                                                           ^ cannot use\
    \ the `?` operator in a function that returns `String`\n...  |\n27 | |     palindrome\n\
    28 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented for `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index23\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1kaewr74.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1kaewr74.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n\n    while longest_postfix_length < string.len() {\n        let mut postfix\
    \ = string;\n        let mut postfix_length = 0;\n\n        while postfix_length\
    \ < longest_postfix_length {\n            postfix.push_str(&string[postfix_length..]);\n\
    \            postfix_length += 1;\n        }\n\n        if postfix_length == longest_postfix_length\
    \ {\n            postfix.push_str(&string[postfix_length..]);\n        }\n\n \
    \       if postfix.to_string() == reversed_string {\n            longest_postfix\
    \ = postfix;\n            longest_postfix_length = postfix_length;\n        }\n\
    \    }\n\n    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpaz7pwvnk.rs:12:9\n\
    \   |\n12 |     let mut reversed_string = string;\n   |         ----^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `string`\n  --> /tmp/tmpaz7pwvnk.rs:13:31\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut reversed_string = string;\n   |\
    \                               ------ value moved here\n13 |     let mut longest_postfix\
    \ = string;\n   |                               ^^^^^^ value used here after move\n\
    \nerror[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpaz7pwvnk.rs:16:36\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut reversed_string = string;\n13 |\
    \     let mut longest_postfix = string;\n   |                               ------\
    \ value moved here\n...\n16 |     while longest_postfix_length < string.len()\
    \ {\n   |                                    ^^^^^^^^^^^^ value borrowed here\
    \ after move\n\nerror[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpaz7pwvnk.rs:21:31\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n17 |         let mut postfix = string;\n  \
    \ |                           ------ value moved here\n...\n21 |             postfix.push_str(&string[postfix_length..]);\n\
    \   |                               ^^^^^^ value borrowed here after move\n\n\
    error: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index23\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6k9p_exb.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6k9p_exb.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string[0];\n\
    \        let mut current_char_length = 1;\n        let mut current_char_suffix\
    \ = \"\";\n        let mut current_char_suffix_length = 0;\n\n        while current_char_length\
    \ < current_char_length {\n            current_char_suffix += current_char;\n\
    \            current_char_suffix_length += 1;\n            current_char_length\
    \ += 1;\n            current_char = reversed_string[current_char_length - 1];\n\
    \        }\n\n        if current_char_length == current_char_suffix_length {\n\
    \            reversed_string = reversed_string.clone();\n            suffix_length\
    \ += 1;\n            reversed_string.insert(0, current_char_suffix);\n       \
    \ } else {\n            prefix_length += 1;\n            reversed_string.insert(0,\
    \ current_char_suffix);\n        }\n    }\n\n    String::from_utf8_lossy(&reversed_string).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpcqmb0ne4.rs:17:32\n   |\n17 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpcqmb0ne4.rs:23:13\n   |\n23 |             current_char_suffix\
    \ += current_char;\n   |             -------------------^^^^^^^^^^^^^^^^\n   |\
    \             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcqmb0ne4.rs:26:28\n\
    \   |\n26 |             current_char = reversed_string[current_char_length - 1];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcqmb0ne4.rs:32:39\n\
    \   |\n32 |             reversed_string.insert(0, current_char_suffix);\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp12t4yv9v.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_start = 0;\n    let mut longest_postfix_string_end\
    \ = 0;\n    let mut longest_postfix_string_start2 = 0;\n    let mut longest_postfix_string_end2\
    \ = 0;\n    let mut longest_postfix_string_start3 = 0;\n    let mut longest_postfix_string_end3\
    \ = 0;\n    let mut longest_postfix_string_start4 = 0;\n    let mut longest_postfix_string_end4\
    \ = 0;\n    let mut longest_postfix_string_start5 = 0;\n    let mut longest_postfix_string_end5\
    \ = 0;\n    let mut longest_postfix_string_start6 = 0;\n    let mut longest_postfix_string_end6\
    \ = 0;\n    let mut longest_postfix_string_start7 = 0;\n    let mut longest_postfix_string_end7\
    \ = 0;\n    let mut longest_postfix_string_start8 = 0;\n    let mut longest_postfix_string_end8\
    \ = 0;\n    let mut longest_postfix_string_start9 = 0;\n    let mut longest_postfix_string_end9\
    \ = 0;\n    let mut longest_postfix_string_start10 = 0;\n    let mut longest_postfix_string_end10\
    \ = 0;\n    let mut longest_postfix_string_start11 = 0;\n    let mut longest_postfix_string_end11\
    \ = 0;\n    let mut longest_postfix_string_start12 = 0;\n    let mut longest_postfix_string_end12\
    \ = 0;\n    let mut longest_postfix_string_start13 = 0;\n    let mut longest_postfix_string_end13\
    \ = 0;\n    let mut longest_postfix_string_start14 = 0;\n    let mut longest_postfix_string_end14\
    \ = 0;\n    let mut longest_postfix_string_start15 = 0;\n    let mut longest_postfix_string_end15\
    \ = 0;\n    let mut longest_postfix_string_start16 = 0;\n    let mut longest_postfix_string_end16\
    \ = 0;\n    let mut longest_postfix_string_start17 = 0;\n    let mut longest_postfix_string_end17\
    \ = 0;\n    let mut longest_postfix_string_start18 = 0;\n    let mut longest_postfix_string_end18\
    \ = 0;\n    let mut longest_postfix_string_start19 = 0;\n    let mut longest_postfix_string_end19\
    \ = 0;\n    let mut longest_postfix_string_start20 = 0;\n    let mut longest_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv1a4_idz.rs:56:21\n   |\n\
    56 |     let mut longest_\n   |                     ^ help: add `;` here\n57 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv1a4_idz.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp07c44bf9.rs:60:1\n  \
    \ |\n60 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = 0;\n    while !reverse.starts_with(string)\
    \ {\n        reverse = reverse.chars().collect::<String>().reverse().collect();\n\
    \        longest = longest + 1;\n    }\n    reverse = reverse.chars().collect::<String>().reverse().collect();\n\
    \    reverse = reverse + &string[longest..];\n    reverse\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp1uo4grfb.rs:14:32\n     |\n14   |     while !reverse.starts_with(string)\
    \ {\n     |                    ----------- ^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                    |\n     |                    required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::starts_with`\nhelp: consider borrowing here\n     |\n14   |     while\
    \ !reverse.starts_with(&string) {\n     |                                +\n\n\
    error[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1uo4grfb.rs:15:55\n   |\n15 |         reverse = reverse.chars().collect::<String>().reverse().collect();\n\
    \   |                                                       ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1uo4grfb.rs:18:51\n   |\n18 |     reverse = reverse.chars().collect::<String>().reverse().collect();\n\
    \   |                                                   ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_start_index = 0;\n    let mut longest_postfix_end_index\
    \ = 0;\n    let mut longest_postfix_start_index2 = 0;\n    let mut longest_postfix_end_index2\
    \ = 0;\n    let mut longest_postfix_start_index3 = 0;\n    let mut longest_postfix_end_index3\
    \ = 0;\n    let mut longest_postfix_start_index4 = 0;\n    let mut longest_postfix_end_index4\
    \ = 0;\n    let mut longest_postfix_start_index5 = 0;\n    let mut longest_postfix_end_index5\
    \ = 0;\n    let mut longest_postfix_start_index6 = 0;\n    let mut longest_postfix_end_index6\
    \ = 0;\n    let mut longest_postfix_start_index7 = 0;\n    let mut longest_postfix_end_index7\
    \ = 0;\n    let mut longest_postfix_start_index8 = 0;\n    let mut longest_postfix_end_index8\
    \ = 0;\n    let mut longest_postfix_start_index9 = 0;\n    let mut longest_postfix_end_index9\
    \ = 0;\n    let mut longest_postfix_start_index10 = 0;\n    let mut longest_postfix_end_index10\
    \ = 0;\n    let mut longest_postfix_start_index11 = 0;\n    let mut longest_postfix_end_index11\
    \ = 0;\n    let mut longest_postfix_start_index12 = 0;\n    let mut longest_postfix_end_index12\
    \ = 0;\n    let mut longest_postfix_start_index13 = 0;\n    let mut longest_postfix_end_index13\
    \ = 0;\n    let mut longest_postfix_start_index14 = 0;\n    let mut longest_postfix_end_index14\
    \ = 0;\n    let mut longest_postfix_start_index15 = 0;\n    let mut longest_postfix_end_index15\
    \ = 0;\n    let mut longest_postfix_start_index16 = 0;\n    let mut longest_postfix_end_index16\
    \ = 0;\n    let mut longest_postfix_start_index17 = 0;\n    let mut longest_postfix_end_index17\
    \ = 0;\n    let mut longest_postfix_start_index18 = 0;\n    let mut longest_postfix_end_index18\
    \ = 0;\n    let mut longest_postfix_start_index19 = 0;\n    let mut longest_postfix_end_index19\
    \ = 0;\n    let mut longest_postfix_start_index20 = 0;\n    let mut longest_postfix_end_index20\
    \ = 0;\n    let mut longest_postfix_start_index21 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy1ao0t8n.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy1ao0t8n.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut suffix_pos\
    \ = 0;\n    let mut prefix_pos = 0;\n    while suffix_pos < palindrome.len() {\n\
    \        let mut suffix_len = palindrome.len() - suffix_pos;\n        while suffix_len\
    \ > 0 {\n            let mut suffix_start = suffix_pos;\n            let mut suffix_end\
    \ = suffix_start + suffix_len;\n            while suffix_end < palindrome.len()\
    \ {\n                if palindrome[suffix_end] != palindrome[suffix_end - 1] {\n\
    \                    break;\n                }\n                suffix_end +=\
    \ 1;\n            }\n            if suffix_end == palindrome.len() {\n       \
    \         break;\n            }\n            let mut suffix_reversed = palindrome[suffix_start..suffix_end].to_string();\n\
    \            suffix_reversed.reverse();\n            palindrome = &palindrome[..suffix_start]\
    \ + &suffix_reversed + &palindrome[suffix_end..];\n            suffix_pos += suffix_len;\n\
    \            suffix_len -= 1;\n        }\n        let mut prefix_len = palindrome.len()\
    \ - prefix_pos;\n        while prefix_len > 0 {\n            let mut prefix_start\
    \ = prefix_pos;\n            let mut prefix_end = prefix_start + prefix_len;\n\
    \            while prefix_end < palindrome.len() {\n                if palindrome[prefix_end]\
    \ != palindrome[prefix_end - 1] {\n                    break;\n              \
    \  }\n                prefix_end += 1;\n            }\n            if prefix_end\
    \ == palindrome.len() {\n                break;\n            }\n            let\
    \ mut prefix_reversed = palindrome[prefix_start..prefix_end].to_string();\n  \
    \          prefix_reversed.reverse();\n            palindrome = &palindrome[..prefix_start]\
    \ + &prefix_reversed + &palindrome[prefix_end..];\n            prefix_pos += prefix_len;\n\
    \            prefix_len -= 1;\n        }\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyqmvvsn2.rs:22:20\n\
    \   |\n22 |                 if palindrome[suffix_end] != palindrome[suffix_end\
    \ - 1] {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyqmvvsn2.rs:22:46\n   |\n22 |                 if palindrome[suffix_end]\
    \ != palindrome[suffix_end - 1] {\n   |                                      \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpyqmvvsn2.rs:31:29\n   |\n31 |          \
    \   suffix_reversed.reverse();\n   |                             ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0369]:\
    \ cannot add `&String` to `&str`\n  --> /tmp/tmpyqmvvsn2.rs:32:54\n   |\n32 |\
    \             palindrome = &palindrome[..suffix_start] + &suffix_reversed + &palindrome[suffix_end..];\n\
    \   |                          --------------------------- ^ ---------------- "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        let mut suffix_end = suffix_length;\n        while suffix_end < string.len()\
    \ {\n            let mut suffix_char = string[suffix_end];\n            if suffix_char\
    \ == reversed_string[suffix_end - 1] {\n                suffix_end++;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ suffix_start < suffix_end {\n            reversed_string.push_str(&string[prefix_length..suffix_start]);\n\
    \            prefix_length = suffix_start + 1;\n            suffix_length = suffix_end\
    \ - 1;\n        } else {\n            break;\n        }\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpny04d8wf.rs:21:27\n\
    \   |\n21 |                 suffix_end++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |       \
    \          { let tmp = suffix_end; suffix_end += 1; tmp };\n   |             \
    \    +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n21 -                 suffix_end++;\n\
    21 +                 suffix_end += 1;\n   | \n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpny04d8wf.rs:19:35\n   |\n19 |  \
    \           let mut suffix_char = string[suffix_end];\n   |                  \
    \                 ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpny04d8wf.rs:20:31\n   |\n20 |             if suffix_char == reversed_string[suffix_end\
    \ - 1] {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut palindrome = string;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut current = palindrome;\n        let mut\
    \ next = &mut reverse[index..];\n        while next != current {\n           \
    \ next = next.clone();\n            current = current.clone();\n        }\n  \
    \      palindrome = next.clone();\n        index += 1;\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `clone` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpes3zjh5y.rs:19:25\n   |\n19 |     \
    \        next = next.clone();\n   |                         ^^^^^ method not found\
    \ in `&mut str`\n\nerror[E0277]: can't compare `&mut str` with `String`\n  -->\
    \ /tmp/tmpes3zjh5y.rs:18:20\n   |\n18 |         while next != current {\n   |\
    \                    ^^ no implementation for `&mut str == String`\n   |\n   =\
    \ help: the trait `PartialEq<String>` is not implemented for `&mut str`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: `PartialEq<String>`\
    \ is implemented for `&str`, but not for `&mut str`\n\nerror[E0599]: no method\
    \ named `clone` found for mutable reference `&mut str` in the current scope\n\
    \  --> /tmp/tmpes3zjh5y.rs:22:27\n   |\n22 |         palindrome = next.clone();\n\
    \   |                           ^^^^^ method not found in `&mut str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_len_index\
    \ = 0;\n    while longest_postfix_len < longest_postfix.len() {\n        let mut\
    \ postfix_len = longest_postfix.len() - longest_postfix_len;\n        let mut\
    \ postfix_index = longest_postfix_index;\n        while postfix_len > 0 {\n  \
    \          let mut postfix_char = longest_postfix[postfix_index];\n          \
    \  while postfix_char == longest_postfix[postfix_index] {\n                postfix_index\
    \ += 1;\n                postfix_len -= 1;\n            }\n            postfix_len\
    \ -= 1;\n            postfix_index += 1;\n        }\n        if longest_postfix_len\
    \ < postfix_len {\n            longest_postfix_len = postfix_len;\n          \
    \  longest_postfix_index = postfix_index;\n        }\n    }\n    let mut postfix_len\
    \ = longest_postfix.len() - longest_postfix_len;\n    let mut postfix_index =\
    \ longest_postfix_index;\n    while postfix_len > 0 {\n        let mut postfix_char\
    \ = longest_postfix[postfix_index];\n        while postfix_char == longest_postfix[postfix_index]\
    \ {\n            postfix_index += 1;\n            postfix_len -= 1;\n        }\n\
    \        postfix_len -= 1;\n        postfix_index += 1;\n    }\n    reversed_string.push_str(&longest_postfix[longest_postfix_index..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpa_801iym.rs:21:36\n   |\n21 |             let mut postfix_char = longest_postfix[postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpa_801iym.rs:22:35\n   |\n22 |             while postfix_char ==\
    \ longest_postfix[postfix_index] {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpa_801iym.rs:37:32\n   |\n37 |         let mut postfix_char = longest_postfix[postfix_index];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length = 0;\n    let mut\
    \ longest_postfix_length_string_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = string.len();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeygldako.rs:52:35\n   |\n\
    52 |     let mut longest_postfix_length\n   |                                \
    \   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeygldako.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reverse = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j < string.len()\
    \ {\n            if string[j] != string[i] {\n                break;\n       \
    \     }\n            i += 1;\n            j += 1\n        }\n        reverse.push_str(&string[i..j]);\n\
    \        i = j;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8w9i7j2x.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8w9i7j2x.rs:18:29\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_start = -1;\n    let mut longest_palindrome_end\
    \ = -1;\n    let mut longest_palindrome_middle = -1;\n    let mut longest_palindrome_middle_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_index = -1;\n    let mut\
    \ longest_palindrome_middle_reversed_length = -1;\n    let mut longest_palindrome_middle_reversed_start\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_end = -1;\n    let mut\
    \ longest_palindrome_middle_reversed_middle = -1;\n    let mut longest_palindrome_middle_reversed_middle_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_length\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_start\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_end =\
    \ -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle =\
    \ -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_length\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_start\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_end\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_middle\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_middle_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_middle_reversed_index\
    \ = -1;\n    let mut longest_palindrome_middle_reversed_middle_reversed_middle_reversed_middle_reversed_length\
    \ = -1;\n    let mut longest_palindro\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9db6vjyz.rs:39:29\n   |\n\
    39 |     let mut longest_palindro\n   |                             ^ help: add\
    \ `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9db6vjyz.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index = 0;\n    let mut longest_postfix_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index = 0;\n   \
    \ let mut longest_postfix_index_length_index_length_index_length = 0;\n    let\
    \ mut longest_postfix_index_length_index_length_index_length_index = 0;\n    let\
    \ mut longest_postfix_index_length_index_length_index_length_index_length = 0;\n\
    \    let mut longest_postfix_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp45x4ka1x.rs:42:61\n   |\n\
    42 |     let mut longest_postfix_index_length_index_length_index_\n   |      \
    \                                                       ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45x4ka1x.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_char: char;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mut longest_postfix_char_length_index36\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpels2881w.rs:52:48\n   |\n\
    52 |     let mut longest_postfix_char_length_index36\n   |                   \
    \                             ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpels2881w.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char\
    \ = 0;\n    let mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index = 0;\n    let mut\
    \ longest_postfix_char_length_index_index_index = 0;\n    let mut longest_postfix_char_length_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxfcu4n1f.rs:40:77\n   |\n\
    40 |     let mut longest_postfix_char_length_index_index_index_index_index_index_\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxfcu4n1f.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_start\
    \ = 0;\n    let mut longest_postfix_length_end = 0;\n    let mut longest_postfix_length_start2\
    \ = 0;\n    let mut longest_postfix_length_end2 = 0;\n    let mut longest_postfix_length_start3\
    \ = 0;\n    let mut longest_postfix_length_end3 = 0;\n    let mut longest_postfix_length_start4\
    \ = 0;\n    let mut longest_postfix_length_end4 = 0;\n    let mut longest_postfix_length_start5\
    \ = 0;\n    let mut longest_postfix_length_end5 = 0;\n    let mut longest_postfix_length_start6\
    \ = 0;\n    let mut longest_postfix_length_end6 = 0;\n    let mut longest_postfix_length_start7\
    \ = 0;\n    let mut longest_postfix_length_end7 = 0;\n    let mut longest_postfix_length_start8\
    \ = 0;\n    let mut longest_postfix_length_end8 = 0;\n    let mut longest_postfix_length_start9\
    \ = 0;\n    let mut longest_postfix_length_end9 = 0;\n    let mut longest_postfix_length_start10\
    \ = 0;\n    let mut longest_postfix_length_end10 = 0;\n    let mut longest_postfix_length_start11\
    \ = 0;\n    let mut longest_postfix_length_end11 = 0;\n    let mut longest_postfix_length_start12\
    \ = 0;\n    let mut longest_postfix_length_end12 = 0;\n    let mut longest_postfix_length_start13\
    \ = 0;\n    let mut longest_postfix_length_end13 = 0;\n    let mut longest_postfix_length_start14\
    \ = 0;\n    let mut longest_postfix_length_end14 = 0;\n    let mut longest_postfix_length_start15\
    \ = 0;\n    let mut longest_postfix_length_end15 = 0;\n    let mut longest_postfix_length_start16\
    \ = 0;\n    let mut longest_postfix_length_end16 = 0;\n    let mut longest_postfix_length_start17\
    \ = 0;\n    let mut longest_postfix_length_end17 = 0;\n    let mut longest_postfix_length_start18\
    \ = 0;\n    let mut longest_postfix_length_end18 = 0;\n    let mut longest_postfix_length_start19\
    \ = 0;\n    let mut longest_postfix_length_end19 = 0;\n    let mut longest_postfix_length_start20\
    \ = 0;\n    let mut longest_postfix_length_end20 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpuvvja_yt.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    while longest_postfix_index\
    \ < longest_postfix.len() {\n        let mut longest_postfix_char = longest_postfix[longest_postfix_index];\n\
    \        let mut longest_postfix_char_length = 0;\n        while longest_postfix_char_length\
    \ < longest_postfix_char.len() {\n            let mut longest_postfix_char_char\
    \ = longest_postfix_char[longest_postfix_char_length];\n            if longest_postfix_char_char\
    \ != longest_postfix_char[longest_postfix_char_length - 1] {\n               \
    \ break;\n            }\n            longest_postfix_char_length += 1;\n     \
    \   }\n        if longest_postfix_char_length < longest_postfix_length {\n   \
    \         longest_postfix_length = longest_postfix_char_length;\n            longest_postfix_index\
    \ = longest_postfix_char.len();\n        }\n        longest_postfix_index += 1;\n\
    \    }\n    let mut longest_postfix_reversed_string = string;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    while longest_postfix_reversed_index < longest_postfix_reversed_string.len()\
    \ {\n        let mut longest_postfix_reversed_char = longest_postfix_reversed_string[longest_postfix_reversed_index];\n\
    \        let mut longest_postfix_reversed_char_length = 0;\n        while longest_postfix_reversed_char_length\
    \ < longest_postfix_reversed_char.len() {\n            let mut longest_postfix_reversed_char_char\
    \ = longest_postfix_reversed_char[longest_postfix_reversed_char_length];\n   \
    \         if longest_postfix_reversed_char_char != longest_postfix_reversed_char[longest_postfix_reversed_char_length\
    \ - 1] {\n                break;\n            }\n            longest_postfix_reversed_char_length\
    \ += 1;\n        }\n        if longest_postfix_reversed_char_length < longest_postfix_reversed_string.len()\
    \ {\n            longest_postfix_reversed_string = longest_postfix_reversed_char.to_string();\n\
    \        }\n        longest_postfix_reversed_index += 1;\n    }\n    longest_postfix_reversed_string\
    \ += &longest_postfix[longest_postfix_index..];\n    longest_postfix_reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvgqyjqx4.rs:17:40\n\
    \   |\n17 |         let mut longest_postfix_char = longest_postfix[longest_postfix_index];\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvgqyjqx4.rs:35:49\n   |\n35 |         let mut longest_postfix_reversed_char\
    \ = longest_postfix_reversed_string[longest_postfix_reversed_index];\n   |   \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_emnwfbe.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31oqn2tu.rs:59:29\n   |\n\
    59 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp31oqn2tu.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_postfix_length = 0;\n    let mut longest_palindrome_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_palindrome_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6cxwmu7r.rs:33:76\n   |\n\
    33 |     let mut longest_palindrome_postfix_postfix_postfix_postfix_postfix_post\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6cxwmu7r.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwozga3iz.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwozga3iz.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut reverse_length = 0;\n\
    \    while !palindrome.is_empty() {\n        let mut index = palindrome.len()\
    \ - 1;\n        while index >= 0 {\n            if palindrome[index] != reversed_string[index]\
    \ {\n                break;\n            }\n            index -= 1;\n        }\n\
    \        if index >= 0 {\n            palindrome = &palindrome[index..];\n   \
    \     } else {\n            palindrome = &palindrome[0..];\n        }\n      \
    \  reverse_length += 1;\n    }\n    palindrome = &palindrome[..];\n    reversed_string\
    \ = &reversed_string[..];\n    format!(\"{}{}\", palindrome, reversed_string)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2aailub9.rs:18:16\n\
    \   |\n18 |             if palindrome[index] != reversed_string[index] {\n   |\
    \                ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2aailub9.rs:18:37\n\
    \   |\n18 |             if palindrome[index] != reversed_string[index] {\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2aailub9.rs:24:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n24 |             palindrome = &palindrome[index..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n24 |        \
    \     palindrome = (&palindrome[index..]).to_string();\n   |                 \
    \         +                    +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2aailub9.rs:26:26\n   |\n13 |     let mut palindrome = "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_index = 0;\n    let mut longest_postfix_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n    let mut longest_postfix_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_index_index_index_length = 0;\n    let mut\
    \ longest_postfix_index_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n    let mut longest_postfix_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_index_index_index_length = 0;\n    let mut\
    \ longest_postfix_index_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n    let mut longest_postfix_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_index_index_index_length = 0;\n    let mut\
    \ longest_postfix_index_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n    let mut longest_postfix_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_index_index_index_length = 0;\n    let mut\
    \ longest_postfix_index_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n    let mut longest_postfix_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_index_index_index_length = 0;\n    let mut\
    \ longest_postfix_index_index_index_index = 0;\n    let mut longest_postfix_index_index_index_length\
    \ = 0;\n    let mut longest_postfix_index_index_index_index = 0;\n    let mut\
    \ longest_postfix_index_index_index_length = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6qt373u4.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut last_index = -1;\n\
    \    while !reversed_string.is_empty() {\n        let mut index = palindrome.len();\n\
    \        while index > 0 {\n            let char = reversed_string[index - 1];\n\
    \            if char != char {\n                break;\n            }\n      \
    \      index -= 1;\n        }\n        last_index = index;\n        palindrome\
    \ = palindrome.chars().collect::<String>().reverse().collect::<String>();\n  \
    \      reversed_string = reversed_string.chars().collect::<String>().reverse().collect::<String>();\n\
    \    }\n    palindrome + &reversed_string[..last_index]\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrfpu2co.rs:18:24\n\
    \   |\n18 |             let char = reversed_string[index - 1];\n   |         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmpsrfpu2co.rs:14:26\n   |\n14 |     let mut last_index = -1;\n   |\
    \                          ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpsrfpu2co.rs:25:61\n   |\n25 | \
    \        palindrome = palindrome.chars().collect::<String>().reverse().collect::<String>();\n\
    \   |                                                             ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpsrfpu2co.rs:26:71\n   |\n26 |         reversed_string = reversed_string.chars().collect::<String>().reverse().collect::<String>();\n\
    \   |                                                                       ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse = 0;\n    let mut longest_postfix_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_re\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5gcq07nj.rs:46:53\n   |\n\
    46 |     let mut longest_postfix_length_reverse_length_re\n   |              \
    \                                       ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5gcq07nj.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoi9hse8p.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoi9hse8p.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut reverse_length = 0;\n        for &c in reversed_string {\n\
    \            if !c.is_alphanumeric() {\n                reverse_length += 1;\n\
    \            }\n        }\n        reversed_string = &reversed_string[..reverse_length];\n\
    \    }\n    let mut reversed_string: String = reversed_string;\n    let mut reverse_length\
    \ = 0;\n    while !reversed_string.is_empty() {\n        let mut reverse_length\
    \ = 0;\n        for &c in reversed_string {\n            if !c.is_alphanumeric()\
    \ {\n                reverse_length += 1;\n            }\n        }\n        reversed_string\
    \ = &reversed_string[..reverse_length];\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxwn7_2jr.rs:16:19\n\
    \   |\n16 |         for &c in reversed_string {\n   |                   ^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxwn7_2jr.rs:21:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n21 |         reversed_string = &reversed_string[..reverse_length];\n   |\
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n21\
    \ |         reversed_string = (&reversed_string[..reverse_length]).to_string();\n\
    \   |                           +                                  +++++++++++++\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpxwn7_2jr.rs:27:19\n\
    \   |\n27 |         for &c in reversed_string {\n   |                   ^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxwn7_2jr.rs:32:27\n   |\n23 |     let mut reversed_string:\
    \ String = reversed_string;\n   |                              ------ expected\
    \ due to this type\n...\n32 |         reversed_string = &reversed_string[..reverse_length];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n32\
    \ |         reversed_string = (&reversed_string[..reverse_length]).to_string();\n\
    \   |                           +                                  +++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_index = 0;\n    let mut longest_postfix_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_index2 = 0;\n    let mut longest_postfix_string_length_index3\
    \ = 0;\n    let mut longest_postfix_string_length_index4 = 0;\n    let mut longest_postfix_string_length_index5\
    \ = 0;\n    let mut longest_postfix_string_length_index6 = 0;\n    let mut longest_postfix_string_length_index7\
    \ = 0;\n    let mut longest_postfix_string_length_index8 = 0;\n    let mut longest_postfix_string_length_index9\
    \ = 0;\n    let mut longest_postfix_string_length_index10 = 0;\n    let mut longest_postfix_string_length_index11\
    \ = 0;\n    let mut longest_postfix_string_length_index12 = 0;\n    let mut longest_postfix_string_length_index13\
    \ = 0;\n    let mut longest_postfix_string_length_index14 = 0;\n    let mut longest_postfix_string_length_index15\
    \ = 0;\n    let mut longest_postfix_string_length_index16 = 0;\n    let mut longest_postfix_string_length_index17\
    \ = 0;\n    let mut longest_postfix_string_length_index18 = 0;\n    let mut longest_postfix_string_length_index19\
    \ = 0;\n    let mut longest_postfix_string_length_index20 = 0;\n    let mut longest_postfix_string_length_index21\
    \ = 0;\n    let mut longest_postfix_string_length_index22 = 0;\n    let mut longest_postfix_string_length_index23\
    \ = 0;\n    let mut longest_postfix_string_length_index24 = 0;\n    let mut longest_postfix_string_length_index25\
    \ = 0;\n    let mut longest_postfix_string_length_index26 = 0;\n    let mut longest_postfix_string_length_index27\
    \ = 0;\n    let mut longest_postfix_string_length_index28 = 0;\n    let mut longest_postfix_string_length_index29\
    \ = 0;\n    let mut longest_postfix_string_length_index30 = 0;\n    let mut longest_postfix_string_length_index31\
    \ = 0;\n    let mut longest_postfix_string_length_index32 = 0;\n    let mut longest_postfix_string_length_index33\
    \ = 0;\n    let mut longest_postfix_string_length_index34 = 0;\n    let mut longest_postfix_string_length_index35\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0xb6vsi1.rs:53:11\n   |\n\
    53 |     let mu\n   |           ^ help: add `;` here\n54 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xb6vsi1.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse = 0;\n    let mut longest_postfix_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_start = 0;\n    let mut longest_postfix_length_reverse_end\
    \ = 0;\n    let mut longest_postfix_length_reverse_start2 = 0;\n    let mut longest_postfix_length_reverse_end2\
    \ = 0;\n    let mut longest_postfix_length_reverse_start3 = 0;\n    let mut longest_postfix_length_reverse_end3\
    \ = 0;\n    let mut longest_postfix_length_reverse_start4 = 0;\n    let mut longest_postfix_length_reverse_end4\
    \ = 0;\n    let mut longest_postfix_length_reverse_start5 = 0;\n    let mut longest_postfix_length_reverse_end5\
    \ = 0;\n    let mut longest_postfix_length_reverse_start6 = 0;\n    let mut longest_postfix_length_reverse_end6\
    \ = 0;\n    let mut longest_postfix_length_reverse_start7 = 0;\n    let mut longest_postfix_length_reverse_end7\
    \ = 0;\n    let mut longest_postfix_length_reverse_start8 = 0;\n    let mut longest_postfix_length_reverse_end8\
    \ = 0;\n    let mut longest_postfix_length_reverse_start9 = 0;\n    let mut longest_postfix_length_reverse_end9\
    \ = 0;\n    let mut longest_postfix_length_reverse_start10 = 0;\n    let mut longest_postfix_length_reverse_end10\
    \ = 0;\n    let mut longest_postfix_length_reverse_start11 = 0;\n    let mut longest_postfix_length_reverse_end11\
    \ = 0;\n    let mut longest_postfix_length_reverse_start12 = 0;\n    let mut longest_postfix_length_reverse_end12\
    \ = 0;\n    let mut longest_postfix_length_reverse_start13 = 0;\n    let mut longest_postfix_length_reverse_end13\
    \ = 0;\n    let mut longest_postfix_length_reverse_start14 = 0;\n    let mut longest_postfix_length_reverse_end14\
    \ = 0;\n    let mut longest_postfix_length_reverse_start15 = 0;\n    let mut longest_postfix_length_reverse_end15\
    \ = 0;\n    let mut longest_postfix_length_reverse_start16 = 0;\n    let mut longest_postfix_length_reverse_end16\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw63mkioe.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string.chars().next().unwrap();\n\
    \        if current_char == current_char.to_ascii_lowercase().rev() {\n      \
    \      suffix_length += 1;\n        } else {\n            prefix_length += 1;\n\
    \        }\n        reversed_string = reversed_string.chars().skip_while(|c| c\
    \ != current_char).collect();\n    }\n    prefix_length += 1;\n    suffix_length\
    \ += 1;\n    reversed_string += &reversed_string[prefix_length..suffix_length];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpyccnh57b.rs:17:62\n\
    \   |\n17 |         if current_char == current_char.to_ascii_lowercase().rev()\
    \ {\n   |                                                              ^^^ `char`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `char: Iterator`\n           which is required by `&mut char: Iterator`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyccnh57b.rs:22:68\n\
    \   |\n22 |         reversed_string = reversed_string.chars().skip_while(|c| c\
    \ != current_char).collect();\n   |                                          \
    \                          ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut suffix_length = 0;\n        while !reversed_string.starts_with(prefix_length)\
    \ {\n            suffix_length += 1;\n        }\n        reversed_string = reversed_string.split_off(prefix_length).reverse().collect();\n\
    \        prefix_length += suffix_length;\n    }\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `{integer}`\n\
    \    --> /tmp/tmpnjx8ogfm.rs:16:44\n     |\n16   |         while !reversed_string.starts_with(prefix_length)\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `{integer}`\n     |                     \
    \           |\n     |                                required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `{integer}`\n     = help: the following other types implement trait `Pattern<'a>`:\n\
    \               &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `{integer}`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpnjx8ogfm.rs:19:68\n   |\n19 |         reversed_string = reversed_string.split_off(prefix_length).reverse().collect();\n\
    \   |                                                                    ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_len = 0;\n    let mut longest_palindrome\
    \ = string;\n    let mut longest_palindrome_len = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut reversed_string_len = 0;\n        let mut longest_palindrome_len\
    \ = 0;\n        for c in reversed_string.chars() {\n            if !c.is_alphanumeric()\
    \ {\n                break;\n            }\n            let mut reversed_string_len\
    \ = reversed_string_len + c.len_utf8();\n            if reversed_string_len >\
    \ longest_palindrome_len {\n                longest_palindrome_len = reversed_string_len;\n\
    \                longest_palindrome = reversed_string;\n            }\n      \
    \  }\n        reversed_string = reversed_string[longest_palindrome_len..].to_string();\n\
    \    }\n    longest_palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `reversed_string_len`\n  --> /tmp/tmpsdpybxmc.rs:13:13\n\
    \   |\n13 |     let mut reversed_string_len = 0;\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_reversed_string_len`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused\
    \ variable: `longest_palindrome_len`\n  --> /tmp/tmpsdpybxmc.rs:15:13\n   |\n\
    15 |     let mut longest_palindrome_len = 0;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_longest_palindrome_len`\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpsdpybxmc.rs:13:9\n\
    \   |\n13 |     let mut reversed_string_len = 0;\n   |         ----^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpsdpybxmc.rs:15:9\n\
    \   |\n15 |     let mut longest_palindrome_len = 0;\n   |         ----^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpsdpybxmc.rs:17:13\n   |\n17 |        \
    \ let mut reversed_string_len = 0;\n   |             ----^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpsdpybxmc.rs:23:17\n   |\n23 |   \
    \          let mut reversed_string_len = reversed_string_len + c.len_utf8();\n\
    \   |                 ----^^^^^^^^^^^^^^^^^^^\n   |                 |\n   |  \
    \               help: remove this `mut`\n\nerror[E0382]: use of moved value: `string`\n\
    \  --> /tmp/tmpsdpybxmc.rs:14:34\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                    ------ move occurs because `string` has\
    \ type `String`, which does not implement the `Copy` trait\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ value moved here\n13 |\
    \     let mut reversed_string_len = 0;\n14 |     let mut longest_palindrome =\
    \ string;\n   |                                  ^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp55jhcen0.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp55jhcen0.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut postfix = string.chars().take_while(|c| !c.is_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    let mut prefix_length = 0;\n    while postfix.len() > 0 {\n        let mut\
    \ suffix_length = 0;\n        for c in postfix.iter_mut() {\n            if !c.is_ascii_lowercase()\
    \ {\n                suffix_length += 1;\n                *c = c.to_ascii_lowercase();\n\
    \            }\n        }\n        if suffix_length == 0 {\n            break;\n\
    \        }\n        let mut suffix_iter = postfix.iter_mut();\n        for _ in\
    \ 0..suffix_length {\n            suffix_iter.next();\n        }\n        let\
    \ mut suffix_slice = suffix_iter.collect::<String>();\n        suffix_slice.reverse();\n\
    \        reversed_string += &suffix_slice;\n        postfix.truncate(suffix_length);\n\
    \        prefix_length += suffix_length;\n    }\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&mut char`\n    --> /tmp/tmp6g696ea9.rs:30:44\n     |\n\
    30   |         let mut suffix_slice = suffix_iter.collect::<String>();\n     |\
    \                                            ^^^^^^^ value of type `String` cannot\
    \ be built from `std::iter::Iterator<Item=&mut char>`\n     |\n     = help: the\
    \ trait `FromIterator<&mut char>` is not implemented for `String`\n     = help:\
    \ the following other types implement trait `FromIterator<A>`:\n             \
    \  <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6g696ea9.rs:31:22\n   |\n31 |         suffix_slice.reverse();\n\
    \   |                      ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length =\
    \ -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprx0mibqk.rs:59:11\n   |\n\
    59 |     let mu\n   |           ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprx0mibqk.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reversed_index = 0;\n    let mut longest_postfix_length_reversed_length\
    \ = 0;\n    let mut longest_postfix_length_reversed_string = \"\";\n\n    while\
    \ string.len() > 0 {\n        let mut postfix_length = 0;\n        let mut postfix_index\
    \ = 0;\n        let mut postfix_length_index = 0;\n        let mut postfix_length_reversed_index\
    \ = 0;\n        let mut postfix_length_reversed_length = 0;\n        let mut postfix_length_reversed_string\
    \ = \"\";\n\n        while string.len() > 0 {\n            let mut postfix_char\
    \ = string[0];\n            let mut postfix_char_length = string.len();\n    \
    \        let mut postfix_char_length_index = 0;\n            let mut postfix_char_length_reversed_index\
    \ = 0;\n            let mut postfix_char_length_reversed_length = 0;\n       \
    \     let mut postfix_char_length_reversed_string = \"\";\n\n            while\
    \ postfix_char_length_index < postfix_char_length {\n                let mut postfix_char_length_reversed_char\
    \ = string[postfix_char_length_reversed_index];\n                let mut postfix_char_length_reversed_char_length\
    \ = string.len();\n                let mut postfix_char_length_reversed_char_length_index\
    \ = 0;\n                let mut postfix_char_length_reversed_char_length_reversed_index\
    \ = 0;\n                let mut postfix_char_length_reversed_char_length_reversed_length\
    \ = 0;\n                let mut postfix_char_length_reversed_char_length_reversed_string\
    \ = \"\";\n\n                while postfix_char_length_reversed_char_length_index\
    \ < postfix_char_length_reversed_char_length {\n                    let mut postfix_char_length_reversed_char_length_reversed_char\
    \ = string[postfix_char_length_reversed_char_length_reversed_index];\n       \
    \             let mut postfix_char_length_reversed_char_length_reversed_char_length\
    \ = string.len();\n                    let mut postfix_char_length_reversed_char_length_reversed_char_length_index\
    \ = 0;\n                    let mut postfix_char_length_reversed_char_length_reversed_char_length_reversed_index\
    \ = 0;\n                    let mut postfix_char_length_reversed_char_length_reversed_char_length_reversed_length\
    \ = 0;\n                    let mut postfix_char_length\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpokw8zt6e.rs:61:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n21 |     while string.len()\
    \ > 0 {\n   |                            - unclosed delimiter\n...\n29 |     \
    \    while string.len() > 0 {\n   |                                - unclosed\
    \ delimiter\n...\n37 |             while postfix_char_length_index < postfix_char_length\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n45 |                 while postfix_char_length_reversed_char_length_index\
    \ < postfix_char_length_reversed_char_length {\n   |                         \
    \                                                                            \
    \            - this delimiter might not be properly closed...\n...\n52 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n61 | }\n \
    \  |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpokw8zt6e.rs:51:48\n\
    \   |\n51 |                     let mut postfix_char_length\n   |            \
    \                                    ^ help: add `;` here\n52 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpokw8zt6e.rs:30:36\n   |\n30 |             let mut postfix_char\
    \ = string[0];\n   |                                    ^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpokw8zt6e.rs:38:61\n   |\n38 |                 let mut postfix_char_lengt"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_lowercase();\n    let mut reversed_string = \"\";\n    let mut longest_palindrome\
    \ = String::new();\n    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_prefix_string\
    \ = \"\";\n    let mut longest_palindrome_suffix_string = \"\";\n    let mut longest_palindrome_prefix_string_reversed\
    \ = \"\";\n    let mut longest_palindrome_suffix_string_reversed = \"\";\n   \
    \ let mut longest_palindrome_prefix_string_reversed_reversed = \"\";\n    let\
    \ mut longest_palindrome_suffix_string_reversed_reversed = \"\";\n    let mut\
    \ longest_palindrome_prefix_string_reversed_reversed_reversed = \"\";\n    let\
    \ mut longest_palindrome_prefix_string_reversed_reversed_reversed = \"\";\n  \
    \  let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"\";\n    let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6w8z85dx.rs:37:100\n   |\n\
    37 |     let mut longest_palindrome_prefix_string_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    \   |                                                                        \
    \                            ^ help: add `;` here\n38 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6w8z85dx.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5m2nem5s.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5m2nem5s.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n\n    while !string.is_empty()\
    \ {\n        let mut current_char = string.chars().next();\n        let mut next_char\
    \ = string.chars().next();\n\n        while current_char != next_char {\n    \
    \        current_char = string.chars().next();\n            next_char = string.chars().next();\n\
    \        }\n\n        reversed_string += &string[..current_char.unwrap()];\n \
    \       string = &string[current_char.unwrap() + 1..];\n    }\n\n    reversed_string\
    \ += &string[..];\n    reversed_string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \  --> /tmp/tmpcwf3cxwe.rs:24:29\n   |\n24 |         reversed_string += &string[..current_char.unwrap()];\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `RangeTo<char>`\n   |\n   = help: the trait `Index<RangeTo<char>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpcwf3cxwe.rs:24:9\n   |\n24 |         reversed_string\
    \ += &string[..current_char.unwrap()];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmpcwf3cxwe.rs:25:48\n   |\n25\
    \ |         string = &string[current_char.unwrap() + 1..];\n   |             \
    \             --------------------- ^ - {integer}\n   |                      \
    \    |\n   |                          char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcwf3cxwe.rs:25:18\n   |\n12 |     let mut string = string;\n  \
    \ |                      ------ expected due to this value\n...\n25 |        \
    \ string = &string[current_char.unwrap() + 1..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n25 |         string = (&string[current_char.unwrap() + 1..]).to_string();\n\
    \   |                  +                                    +++++++++++++\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpcwf3cxwe.rs:28:5\n   |\n28 |     reversed_string += &string[..];\n\
    \   |     -------------"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = 1;\n    let mut longest_prefix_length = 0;\n    let mut longest_prefix_length_index\
    \ = 0;\n    let mut longest_prefix_length_string = \"\";\n    let mut longest_prefix_length_reversed_string\
    \ = \"\";\n    let mut longest_prefix_length_reversed_string_index = 0;\n    let\
    \ mut longest_prefix_length_reversed_string_reversed = false;\n    let mut longest_prefix_length_reversed_string_length\
    \ = 0;\n    let mut longest_prefix_length_reversed_string_length_index = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed = false;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index2 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index3 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index4 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index5 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index6 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index7 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index8 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index9 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index10 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index11 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index12 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index13 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index14 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index15 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index16 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index17 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index18 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index19 = 0;\n\
    \    let mut longest_prefix_length_reversed_string_length_reversed_index\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiysfj6w_.rs:43:72\n   |\n\
    43 |     let mut longest_prefix_length_reversed_string_length_reversed_index\n\
    \   |                                                                        ^\
    \ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiysfj6w_.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_postfix\
    \ = \"\";\n\n    while longest_postfix_len > 0 {\n        let mut longest_postfix_postfix_len\
    \ = longest_postfix_len;\n        let mut longest_postfix_postfix_pos = longest_postfix_pos;\n\
    \        let mut longest_postfix_postfix_postfix = \"\";\n\n        while longest_postfix_postfix_len\
    \ > 0 {\n            let mut longest_postfix_postfix_postfix_len = longest_postfix_postfix_len;\n\
    \            let mut longest_postfix_postfix_postfix_pos = longest_postfix_postfix_pos;\n\
    \            let mut longest_postfix_postfix_postfix = \"\";\n\n            for\
    \ pos in longest_postfix_pos {\n                let mut postfix = &string[..pos];\n\
    \                let mut postfix_postfix = &string[..pos];\n\n               \
    \ while postfix.len() > 0 {\n                    let mut postfix_postfix_len =\
    \ postfix.len();\n                    let mut postfix_postfix_postfix = \"\";\n\
    \n                    for _ in 0..(longest_postfix_len - postfix.len()) {\n  \
    \                      postfix_postfix.push(' ');\n                    }\n\n \
    \                   postfix_postfix.extend(&postfix);\n                    postfix_postfix.reverse();\n\
    \n                    if postfix_postfix.eq(&string[..pos]) {\n              \
    \          longest_postfix_postfix_len = postfix_postfix.len();\n            \
    \            longest_postfix_postfix_pos = pos;\n                        longest_postfix_postfix_postfix\
    \ = postfix_postfix;\n                    }\n\n                    postfix.pop();\n\
    \                }\n            }\n\n            longest_postfix_postfix_len =\
    \ longest_postfix_postfix_len;\n            longest_postfix_postfix_pos = longest_postfix_postfix_pos;\n\
    \            longest_postfix_postfix_postfix = longest_postfix_postfix_postfix;\n\
    \        }\n\n        if longest_postfix_postfix.len() > longest_postfix_len {\n\
    \            longest_postfix_len = longest_postfix_postfix.len();\n          \
    \  longest_postfix_pos = longest_postfix_postfix.len();\n            longest_postfix_postfix\
    \ = longest_postfix_postfix.clone();\n        }\n\n        reversed_string.push(reverse(&longest_postfix_postfix));\n\
    \    }\n\n    reversed_string\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmphwgcue9k.rs:64:30\n\
    \   |\n64 |         reversed_string.push(reverse(&longest_postfix_postfix));\n\
    \   |                              ^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ `{integer}` is not an iterator\n  --> /tmp/tmphwgcue9k.rs:28:24\n   |\n28 |\
    \             for pos in longest_postfix_pos {\n   |                        ^^^^^^^^^^^^^^^^^^^\
    \ `{integer}` is not an iterator\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `{integer}`\n   = note: if you want to iterate between `start`\
    \ until a value `end`, use the exclusive range syntax `start..end` or the inclusive\
    \ range syntax `start..=end`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `{integer}`\n\nerror[E0599]: no method named\
    \ `push` found for reference `&str` in the current scope\n  --> /tmp/tmphwgcue9k.rs:37:41\n\
    \   |\n37 |                         postfix_postfix.push(' ');\n   |         \
    \                                ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `extend` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmphwgcue9k.rs:40:37\n   |\n40 |                     postfix_postfix.extend(&postfix);\n\
    \   |                                     ^^^^^^ method not found in `&str`\n\n\
    error[E0599]: no method named `reverse` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmphwgcue9k.rs:41:37\n   |\n41 |                     postfix_postfix.reverse();\n\
    \   |                                     ^^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `pop` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmphwgcue9k.rs:49:29\n   |\n49 |                     postfix.pop();\n\
    \   |                             ^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_postfix_length = 0;\n    let mut longest_palindrome_postfix_postfix\
    \ = string;\n    let mut longest_palindrome_postfix_postfix_length = 0;\n    let\
    \ mut longest_palindrome_postfix_postfix_postfix = string;\n    let mut longest_palindrome_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n\
    \    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n  \
    \  let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let\
    \ mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut\
    \ longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix =\
    \ string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n\
    \    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n  \
    \  let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let\
    \ mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut\
    \ longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix =\
    \ string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n\
    \    let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n  \
    \  let mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let\
    \ mut longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut\
    \ longest_palindrome_postfix_postfix_postfix_postfix = string;\n    let mut longest_palindrome_postfix_postfix_postfix_postfix\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmamvzwy9.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix = 0;\n    let mut longest_postfix_length_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_index = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjtt933or.rs:40:76\n   |\n\
    40 |     let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffi\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjtt933or.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_len = 0;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut longest_postfix_start_pos = 0;\n    let mut longest_postfix_end_pos\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppuvoev8j.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_chars = String::new();\n    let mut longest_postfix_char_index\
    \ = 0;\n    let mut longest_postfix_char = String::new();\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_char_length = String::new();\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length = String::new();\n    let mut\
    \ longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_char_length = String::new();\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length = String::new();\n    let mut\
    \ longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_char_length = String::new();\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length = String::new();\n    let mut\
    \ longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_char_length = String::new();\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length = String::new();\n    let mut\
    \ longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_char_length = String::new();\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length = String::new();\n    let mut\
    \ longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length\
    \ = String::new();\n    let mut longest_postfix_char_length_index = 0;\n    let\
    \ mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqej1jrcu.rs:52:29\n   |\n\
    52 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqej1jrcu.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_suffix = 0;\n    let mut longest_postfix_length_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome = 0;\n    let mut\
    \ longest_postfix_length_suffix_palindrome_index = 0;\n    let mut longest_postfix_length_suffix_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome_length_index = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_palindrome_index = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_palindrome_length_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome_length\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp9uy522v9.rs:44:1\n  \
    \ |\n44 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = 0;\n    while let Some(pos) = string.rfind('a',\
    \ reverse + 1) {\n        if pos > longest {\n            longest = pos;\n   \
    \     }\n        reverse = &string[..pos];\n    }\n    reverse.push_str(&string[..longest]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpca1j9ecw.rs:14:55\n   |\n\
    14 |     while let Some(pos) = string.rfind('a', reverse + 1) {\n   |        \
    \                                               ^ expected `&str`, found integer\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpca1j9ecw.rs:14:34\n     |\n14   |     while let Some(pos) = string.rfind('a',\
    \ reverse + 1) {\n     |                                  ^^^^^ ---  -----------\
    \ supplied 2 arguments\n     |                                  |\n     |    \
    \                              expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca1j9ecw.rs:18:19\n\
    \   |\n12 |     let mut reverse = string;\n   |                       ------ expected\
    \ due to this value\n...\n18 |         reverse = &string[..pos];\n   |       \
    \            ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n18 |         reverse = (&string[..pos]).to_string();\n\
    \   |                   +              +++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = string;\n    let mut longest_index = 0;\n \
    \   let mut index = 0;\n    while index < reverse.len() {\n        let mut c =\
    \ reverse[index];\n        while c != longest[index] {\n            longest[index]\
    \ = c;\n            index += 1;\n        }\n        index += 1;\n    }\n    longest.extend(&reverse[longest_index..]);\n\
    \    longest\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplgbt4v21.rs:17:21\n\
    \   |\n17 |         let mut c = reverse[index];\n   |                     ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplgbt4v21.rs:18:20\n   |\n18 |         while c != longest[index]\
    \ {\n   |                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplgbt4v21.rs:19:13\n   |\n19 |             longest[index] = c;\n\
    \   |             ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut postfix = string;\n    let mut start = false;\n    while\
    \ !postfix.is_empty() {\n        if postfix.chars().all(|c| !c.is_alphanumeric())\
    \ {\n            postfix.pop();\n        } else {\n            postfix.push(reverse);\n\
    \            reverse = postfix;\n            postfix = string;\n            start\
    \ = !start;\n        }\n    }\n    if start {\n        reverse.push(reverse);\n\
    \    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe406636v.rs:19:26\n   |\n\
    19 |             postfix.push(reverse);\n   |                          ^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpe406636v.rs:26:22\n   |\n26 |         reverse.push(reverse);\n \
    \  |                      ^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = string;\n    let mut longest_index = 0;\n \
    \   for index in 0..string.len() {\n        let mut index = index;\n        while\
    \ index > 0 && string[index] != string[index - 1] {\n            index -= 1;\n\
    \        }\n        if index == 0 {\n            break;\n        }\n        let\
    \ mut index = index;\n        while index > 0 && string[index] != string[index\
    \ + 1] {\n            index += 1;\n        }\n        if index == 0 {\n      \
    \      break;\n        }\n        let mut index = index;\n        while index\
    \ > 0 && string[index] != string[index - 1] {\n            index -= 1;\n     \
    \   }\n        if index == 0 {\n            break;\n        }\n        let mut\
    \ index = index;\n        while index > 0 && string[index] != string[index + 1]\
    \ {\n            index += 1;\n        }\n        if index == 0 {\n           \
    \ break;\n        }\n        let mut index = index;\n        while index > 0 &&\
    \ string[index] != string[index - 1] {\n            index -= 1;\n        }\n \
    \       if index == 0 {\n            break;\n        }\n        let mut index\
    \ = index;\n        while index > 0 && string[index] != string[index + 1] {\n\
    \            index += 1;\n        }\n        if index == 0 {\n            break;\n\
    \        }\n        let mut index = index;\n        while index > 0 && string[index]\
    \ != string[index - 1] {\n            index -= 1;\n        }\n        if index\
    \ == 0 {\n            break;\n        }\n        let mut index = index;\n    \
    \    while index > 0 && string[index] != string[index + 1] {\n            index\
    \ += 1;\n        }\n        if index == 0 {\n            break;\n        }\n \
    \       let mut index = index;\n        while index > 0 && string[index] != string[index\
    \ - 1] {\n            index -= 1;\n        }\n        if index == 0 {\n      \
    \      break;\n        }\n        let mut index = index;\n        while index\
    \ > 0 && string[index] != string[index + 1] {\n            index += 1;\n     \
    \   }\n        if index == 0 {\n            break;\n        }\n        let mut\
    \ index = index;\n        while index > 0 && string[index] != string[index - 1]\
    \ {\n            index -= 1;\n        }\n        if index == 0 {\n           \
    \ break;\n        }\n        let mut index = index;\n        while index > 0 &&\
    \ string[index] != string[index + 1] {\n            index += 1;\n        }\n \
    \       if index == 0 {\n            break;\n        }\n        let mut index\
    \ = index;\n        while index > 0 && string[index] != string[index - 1] {\n\
    \            index -= 1;\n        }\n        if index == 0 {\n            break;\n\
    \        }\n        let mut index = index;\n        while index > 0 && string[index]\
    \ != string[index + 1] {\n            index += 1;\n        }\n        if index\
    \ == 0 {\n            break;\n        }\n        let mut index = index;\n    \
    \    while index > 0 && string[index] != string[index - 1] {\n            index\
    \ -= 1;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8vrdznu8.rs:126:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n15  |     for\
    \ index in 0..string.len() {\n    |                                  - unclosed\
    \ delimiter\n...\n115 |         while index > 0 && string[index] != string[index\
    \ - 1] {\n    |                                                              \
    \ - this delimiter might not be properly closed...\n116 |             index -=\
    \ 1;\n117 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n126 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp8vrdznu8.rs:17:28\n   |\n17 |         while index > 0\
    \ && string[index] != string[index - 1] {\n   |                            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8vrdznu8.rs:17:45\n   |\n17 |         while index > 0 && string[index]\
    \ != string[index - 1] {\n   |                                             ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        while suffix_start < string.len() && string[suffix_start] != string[suffix_start\
    \ + 1] {\n            suffix_start += 1;\n        }\n        let mut suffix_end\
    \ = suffix_start + 1;\n        while suffix_end < string.len() && string[suffix_end]\
    \ != string[suffix_end - 1] {\n            suffix_end += 1;\n        }\n     \
    \   if suffix_start == suffix_end {\n            break;\n        }\n        let\
    \ mut suffix_length = suffix_end - suffix_start + 1;\n        while suffix_length\
    \ < string.len() && string[suffix_length] != string[suffix_length + 1] {\n   \
    \         suffix_length += 1;\n        }\n        let mut prefix_length = suffix_start\
    \ - suffix_length;\n        while prefix_length < string.len() && string[prefix_length]\
    \ != string[prefix_length + 1] {\n            prefix_length += 1;\n        }\n\
    \        reversed_string.push_str(&string[suffix_start - suffix_length..suffix_start]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxz1l93x.rs:17:46\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \      ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphxz1l93x.rs:17:70\n\
    \   |\n17 |         while suffix_start < string.len() && string[suffix_start]\
    \ != string[suffix_start + 1] {\n   |                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphxz1l93x.rs:21:44\n   |\n21 |         while suffix_end < string.len()\
    \ && string[suffix_end] != string[suffix_end - 1] {\n   |                    \
    \                        ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <St"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_len = 0;\n    let mut longest_postfix_len = 0;\n\
    \    let mut longest_postfix = \"\";\n\n    while !reversed_string.is_empty()\
    \ {\n        let mut postfix_len = reversed_string.len();\n        let mut postfix\
    \ = reversed_string[..postfix_len];\n\n        while !postfix.is_empty() {\n \
    \           let mut postfix_len = postfix.len();\n            let mut postfix_char\
    \ = postfix.chars().next().unwrap();\n            let mut postfix_char_str = String::from(postfix_char);\n\
    \n            while !postfix_char_str.is_empty() {\n                let mut postfix_char_len\
    \ = postfix_char_str.len();\n                let mut postfix_char_char = postfix_char_str.chars().next().unwrap();\n\
    \                let mut postfix_char_char_str = String::from(postfix_char_char);\n\
    \n                while !postfix_char_char_str.is_empty() {\n                \
    \    let mut postfix_char_char_len = postfix_char_char_str.len();\n          \
    \          let mut postfix_char_char_char = postfix_char_char_str.chars().next().unwrap();\n\
    \                    let mut postfix_char_char_char_str = String::from(postfix_char_char_char);\n\
    \n                    while !postfix_char_char_char_str.is_empty() {\n       \
    \                 let mut postfix_char_char_char_len = postfix_char_char_char_str.len();\n\
    \                        let mut postfix_char_char_char_char = postfix_char_char_char_str.chars().next().unwrap();\n\
    \                        let mut postfix_char_char_char_char_str = String::from(postfix_char_char_char_char);\n\
    \n                        while !postfix_char_char_char_char_str.is_empty() {\n\
    \                            let mut postfix_char_char_char_char_len = postfix_char_char_char_char_str.len();\n\
    \                            let mut postfix_char_char_char_char_char = postfix_char_char_char_char_str.chars().next().unwrap();\n\
    \                            let mut postfix_char_char_char_char_char_str = String::from(postfix_char_char_char_char_char);\n\
    \n                            while !postfix_char_char_char_char_char_str.is_empty()\
    \ {\n                                let mut postfix_char_char_char_char_char_len\
    \ = postfix_char_char_char_char_char_str.len();\n                            \
    \    let mut postfix_char_char_char_char_char_char = postfix_char_char_char_char_char_str.chars().next().unwrap();\n\
    \                                let mut postfix_char_char_char_char_char_char_str\
    \ = String::from(postfix_char_char_char_char_char_char);\n\n                 \
    \               while !postfix_char_char_char_char_char_char_\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk__t89lk.rs:61:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while !reversed_string.is_empty()\
    \ {\n   |                                       - unclosed delimiter\n...\n21\
    \ |         while !postfix.is_empty() {\n   |                                \
    \   - unclosed delimiter\n...\n26 |             while !postfix_char_str.is_empty()\
    \ {\n   |                                                - unclosed delimiter\n\
    ...\n31 |                 while !postfix_char_char_str.is_empty() {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    36 |                     while !postfix_char_char_char_str.is_empty() {\n   |\
    \                                                                  - unclosed\
    \ delimiter\n...\n41 |                         while !postfix_char_char_char_char_str.is_empty()\
    \ {\n   |                                                                    \
    \       - unclosed delimiter\n...\n46 |                             while !postfix_char_char_char_char_char_str.is_empty()\
    \ {\n   |                                                                    \
    \                - this delimiter might not be properly closed...\n...\n52 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n61 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpk__t89lk.rs:52:1\n\
    \   |\n51 |                                 while !postfix_char_char_char_char_char_char_\n\
    \   |                                 ----- ---------------------------------------\
    \ this `while` condition successfully parsed\n   |                           \
    \      |\n   |                                 while parsing the body of this\
    \ `while` expression\n52 | }\n   | ^ expected `{`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmpk__t89lk.rs:19:13\n\
    \   |\n19 |         let mut postfix = reversed_string[..postfix_len];\n   |  \
    \           ^^^^^^^^^^^ doesn't have a size kno"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char:\
    \ char;\n    let mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_index2 = 0;\n    let mut longest_postfix_char_length_index3\
    \ = 0;\n    let mut longest_postfix_char_length_index4 = 0;\n    let mut longest_postfix_char_length_index5\
    \ = 0;\n    let mut longest_postfix_char_length_index6 = 0;\n    let mut longest_postfix_char_length_index7\
    \ = 0;\n    let mut longest_postfix_char_length_index8 = 0;\n    let mut longest_postfix_char_length_index9\
    \ = 0;\n    let mut longest_postfix_char_length_index10 = 0;\n    let mut longest_postfix_char_length_index11\
    \ = 0;\n    let mut longest_postfix_char_length_index12 = 0;\n    let mut longest_postfix_char_length_index13\
    \ = 0;\n    let mut longest_postfix_char_length_index14 = 0;\n    let mut longest_postfix_char_length_index15\
    \ = 0;\n    let mut longest_postfix_char_length_index16 = 0;\n    let mut longest_postfix_char_length_index17\
    \ = 0;\n    let mut longest_postfix_char_length_index18 = 0;\n    let mut longest_postfix_char_length_index19\
    \ = 0;\n    let mut longest_postfix_char_length_index20 = 0;\n    let mut longest_postfix_char_length_index21\
    \ = 0;\n    let mut longest_postfix_char_length_index22 = 0;\n    let mut longest_postfix_char_length_index23\
    \ = 0;\n    let mut longest_postfix_char_length_index24 = 0;\n    let mut longest_postfix_char_length_index25\
    \ = 0;\n    let mut longest_postfix_char_length_index26 = 0;\n    let mut longest_postfix_char_length_index27\
    \ = 0;\n    let mut longest_postfix_char_length_index28 = 0;\n    let mut longest_postfix_char_length_index29\
    \ = 0;\n    let mut longest_postfix_char_length_index30 = 0;\n    let mut longest_postfix_char_length_index31\
    \ = 0;\n    let mut longest_postfix_char_length_index32 = 0;\n    let mut longest_postfix_char_length_index33\
    \ = 0;\n    let mut longest_postfix_char_length_index34 = 0;\n    let mut longest_postfix_char_length_index35\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4zy17jcg.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4zy17jcg.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_chars = String::new();\n\n    for c in string.chars()\
    \ {\n        if longest_postfix_length == 0 {\n            longest_postfix_length\
    \ = c.len_utf8();\n            longest_postfix_chars = c;\n            longest_postfix_index\
    \ = 0;\n        } else {\n            if longest_postfix_length < c.len_utf8()\
    \ {\n                longest_postfix_length = c.len_utf8();\n                longest_postfix_chars\
    \ = c;\n                longest_postfix_index = 0;\n            }\n        }\n\
    \    }\n\n    let mut longest_postfix_length = longest_postfix_length as usize;\n\
    \    let mut longest_postfix_chars = longest_postfix_chars as char;\n    let mut\
    \ longest_postfix_index = longest_postfix_index as usize;\n    let mut reversed_string\
    \ = reversed_string.chars();\n\n    while longest_postfix_length > 0 {\n     \
    \   let mut longest_postfix_length = longest_postfix_length as usize;\n      \
    \  let mut longest_postfix_chars = longest_postfix_chars as char;\n        let\
    \ mut longest_postfix_index = longest_postfix_index as usize;\n\n        while\
    \ longest_postfix_index != longest_postfix_length - 1 {\n            let mut c\
    \ = reversed_string.next().unwrap();\n            longest_postfix_chars = longest_postfix_chars.chars().next().unwrap();\n\
    \            longest_postfix_index = longest_postfix_index as usize;\n\n     \
    \       if longest_postfix_index == 0 {\n                longest_postfix_length\
    \ = longest_postfix_chars.len_utf8();\n                longest_postfix_chars =\
    \ longest_postfix_chars;\n                longest_postfix_index = 0;\n       \
    \     } else {\n                if longest_postfix_length < longest_postfix_chars.len_utf8()\
    \ {\n                    longest_postfix_length = longest_postfix_chars.len_utf8();\n\
    \                    longest_postfix_chars = longest_postfix_chars;\n        \
    \            longest_postfix_index = 0;\n                }\n            }\n  \
    \      }\n\n        reversed_string = reversed_string.chars();\n    }\n\n    reversed_string.next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps_tla_ey.rs:20:37\n   |\n\
    15 |     let mut longest_postfix_chars = String::new();\n   |                \
    \                     ------------- expected due to this value\n...\n20 |    \
    \         longest_postfix_chars = c;\n   |                                   \
    \  ^- help: try using a conversion method: `.to_string()`\n   |              \
    \                       |\n   |                                     expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_tla_ey.rs:25:41\n\
    \   |\n15 |     let mut longest_postfix_chars = String::new();\n   |         \
    \                            ------------- expected due to this value\n...\n25\
    \ |                 longest_postfix_chars = c;\n   |                         \
    \                ^- help: try using a conversion method: `.to_string()`\n   |\
    \                                         |\n   |                            \
    \             expected struct `String`, found `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmps_tla_ey.rs:43:59\n\
    \   |\n43 |             longest_postfix_chars = longest_postfix_chars.chars().next().unwrap();\n\
    \   |                                                           ^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `chars` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmps_tla_ey.rs:59:43\n   |\n59 |         reversed_string\
    \ = reversed_string.chars();\n   |                                           ^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_tla_ey.rs:62:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    62 |     reversed_string.next().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `char`\n\nerror[E0605]: non-primitive cast: `String`\
    \ as `char`\n  --> /tmp/tmps_tla_ey.rs:32:37\n   |\n32 |     let mut lo"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    for pos in string.len() {\n        let mut postfix_start = pos;\n\
    \        let mut postfix_end = pos;\n        while postfix_end < string.len()\
    \ {\n            let mut char = string[postfix_end];\n            if char == char::from_u32(u32(char).rev()).unwrap()\
    \ {\n                postfix_end = postfix_end + 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if postfix_start > longest_postfix_start\
    \ {\n            longest_postfix_start = postfix_start;\n            longest_postfix_length\
    \ = postfix_end - postfix_start;\n        }\n    }\n    if longest_postfix_start\
    \ == -1 {\n        return string;\n    }\n    let mut postfix_start = longest_postfix_start;\n\
    \    let mut postfix_end = longest_postfix_start + longest_postfix_length;\n \
    \   let mut postfix_string = string;\n    while postfix_end < string.len() {\n\
    \        let mut char = string[postfix_end];\n        if char == char::from_u32(u32(char).rev()).unwrap()\
    \ {\n            postfix_end = postfix_end + 1;\n        } else {\n          \
    \  postfix_string = postfix_string.push_str(&string[postfix_start..postfix_end]);\n\
    \            postfix_start = postfix_end;\n            postfix_end = postfix_start\
    \ + longest_postfix_length;\n        }\n    }\n    postfix_string = postfix_string.push_str(&string[postfix_start..postfix_end]);\n\
    \    postfix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected function, found builtin type `u32`\n  --> /tmp/tmpm9_r7e30.rs:20:39\n\
    \   |\n20 |             if char == char::from_u32(u32(char).rev()).unwrap() {\n\
    \   |                                       ^^^ not a function\n\nerror[E0423]:\
    \ expected function, found builtin type `u32`\n  --> /tmp/tmpm9_r7e30.rs:39:35\n\
    \   |\n39 |         if char == char::from_u32(u32(char).rev()).unwrap() {\n  \
    \ |                                   ^^^ not a function\n\nerror[E0277]: `usize`\
    \ is not an iterator\n  --> /tmp/tmpm9_r7e30.rs:15:16\n   |\n15 |     for pos\
    \ in string.len() {\n   |                ^^^^^^^^^^^^ `usize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `usize`\n   = note:\
    \ if you want to iterate between `start` until a value `end`, use the exclusive\
    \ range syntax `start..end` or the inclusive range syntax `start..=end`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmpm9_r7e30.rs:14:37\n   |\n14 |     let mut longest_postfix_start = -1;\n\
    \   |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpm9_r7e30.rs:19:28\n   |\n19 |             let mut\
    \ char = string[postfix_end];\n   |                            ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \         "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length = 0;\n  \
    \  let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix =\
    \ \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1en_s6dl.rs:42:73\n   |\n\
    42 |     let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_post\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1en_s6dl.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    while !reversed_string.is_empty()\
    \ {\n        let mut postfix_start = -1;\n        let mut postfix_end = -1;\n\
    \        for (i, c) in reversed_string.chars().enumerate() {\n            if c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                postfix_start\
    \ = i;\n            }\n            if c == 'b' || c == 'd' || c == 'f' || c ==\
    \ 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n'\
    \ || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c\
    \ == 'w' || c == 'x' || c == 'y' || c == 'z' {\n                postfix_end =\
    \ i;\n            }\n            if postfix_start != -1 && postfix_end != -1 {\n\
    \                break;\n            }\n        }\n        if postfix_start !=\
    \ -1 && postfix_end != -1 {\n            if postfix_end - postfix_start > longest_postfix_length\
    \ {\n                longest_postfix_length = postfix_end - postfix_start;\n \
    \               longest_postfix_start = postfix_start;\n                longest_postfix_end\
    \ = postfix_end;\n            }\n        }\n        reversed_string = &reversed_string[..postfix_end];\n\
    \    }\n    if longest_postfix_length == 0 {\n        return string;\n    }\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    while !reversed_string.is_empty() {\n        let mut postfix_start = -1;\n\
    \        let mut postfix_end = -1;\n        for (i, c) in reversed_string.chars().enumerate()\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                postfix_start = i;\n            }\n            if c == 'b' ||\
    \ c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c ==\
    \ 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's'\
    \ || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z' {\n\
    \                postfix_end = i;\n            }\n            if postfix_\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpanqacef5.rs:66:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n46 |     while !reversed_string.is_empty()\
    \ {\n   |                                       - unclosed delimiter\n...\n49\
    \ |         for (i, c) in reversed_string.chars().enumerate() {\n   |        \
    \                                                   - this delimiter might not\
    \ be properly closed...\n...\n57 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n66 | }\n   |   ^\n\nerror: expected `{`, found `}`\n\
    \  --> /tmp/tmpanqacef5.rs:57:1\n   |\n56 |             if postfix_\n   |    \
    \         -- this `if` expression has a condition, but no block\n57 | }\n   |\
    \ ^ expected `{`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpanqacef5.rs:17:33\n   |\n17 |         let mut postfix_start = -1;\n\
    \   |                                 ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpanqacef5.rs:18:31\n   |\n18 |         let mut postfix_end\
    \ = -1;\n   |                               ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpanqacef5.rs:26:33\n   |\n26 |             if postfix_start\
    \ != -1 && postfix_end != -1 {\n   |                                 ^^\n   |\
    \                                 |\n   |                                 cannot\
    \ apply unary operator `-`\n   |                          "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_len = string.len();\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_reverse = \"\";\n    let mut longest_postfix_postfix_reverse_index\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index2 = 0;\n    let mut longest_postfix_postfix_reverse_index3\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index4 = 0;\n    let mut longest_postfix_postfix_reverse_index5\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index6 = 0;\n    let mut longest_postfix_postfix_reverse_index7\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index8 = 0;\n    let mut longest_postfix_postfix_reverse_index9\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index10 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index11 = 0;\n    let mut longest_postfix_postfix_reverse_index12\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index13 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index14 = 0;\n    let mut longest_postfix_postfix_reverse_index15\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index16 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index17 = 0;\n    let mut longest_postfix_postfix_reverse_index18\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index19 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index20 = 0;\n    let mut longest_postfix_postfix_reverse_index21\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index22 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index23 = 0;\n    let mut longest_postfix_postfix_reverse_index24\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index25 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index26 = 0;\n    let mut longest_postfix_postfix_reverse_index27\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index28 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index29 = 0;\n    let mut longest_postfix_postfix_reverse_index30\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index31 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index32 = 0;\n    let mut longest_\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppuc9g_6c.rs:50:21\n   |\n\
    50 |     let mut longest_\n   |                     ^ help: add `;` here\n51 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppuc9g_6c.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reverse = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j + 1 < string.len()\
    \ {\n            if string[j] != string[j + 1] {\n                break;\n   \
    \         }\n            j += 1;\n        }\n        if j == i {\n           \
    \ break;\n        }\n        reverse = reverse.insert(i, &string[j..]);\n    \
    \    i += j - i;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpejffa2z4.rs:18:16\n\
    \   |\n18 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpejffa2z4.rs:18:29\n   |\n18 |             if string[j] != string[j\
    \ + 1] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpejffa2z4.rs:26:37\n\
    \   |\n26 |         reverse = reverse.insert(i, &string[j..]);\n   |         \
    \                            ^^^^^^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpejffa2z4.rs:26:19\n   |\n13 |     let mut reverse\
    \ = string;\n   |                       ------ expected due to this value\n...\n\
    26 |         reverse = reverse.insert(i, &string[j..]);\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\n\
    note: method `insert` modifies its receiver in-place\n  --> /tmp/tmpejffa2z4.rs:26:27\n\
    \   |\n26 |         reverse = reverse."
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_palindrome\
    \ = String::new();\n    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_start\
    \ = String::new();\n    let mut longest_palindrome_end = String::new();\n    let\
    \ mut longest_palindrome_start = longest_palindrome_start.chars();\n    let mut\
    \ longest_palindrome_end = longest_palindrome_end.chars();\n    let mut longest_palindrome_length\
    \ = longest_palindrome_length.chars();\n    let mut longest_palindrome_start =\
    \ longest_palindrome_start.chars();\n    let mut longest_palindrome_end = longest_palindrome_end.chars();\n\
    \    let mut longest_palindrome_length = longest_palindrome_length.chars();\n\
    \    let mut longest_palindrome_start = longest_palindrome_start.chars();\n  \
    \  let mut longest_palindrome_end = longest_palindrome_end.chars();\n    let mut\
    \ longest_palindrome_length = longest_palindrome_length.chars();\n    let mut\
    \ longest_palindrome_start = longest_palindrome_start.chars();\n    let mut longest_palindrome_end\
    \ = longest_palindrome_end.chars();\n    let mut longest_palindrome_length = longest_palindrome_length.chars();\n\
    \    let mut longest_palindrome_start = longest_palindrome_start.chars();\n  \
    \  let mut longest_palindrome_end = longest_palindrome_end.chars();\n    let mut\
    \ longest_palindrome_length = longest_palindrome_length.chars();\n    let mut\
    \ longest_palindrome_start = longest_palindrome_start.chars();\n    let mut longest_palindrome_end\
    \ = longest_palindrome_end.chars();\n    let mut longest_palindrome_length = longest_palindrome_length.chars();\n\
    \    let mut longest_palindrome_start = longest_palindrome_start.chars();\n  \
    \  let mut longest_palindrome_end = longest_palindrome_end.chars();\n    let mut\
    \ longest_palindrome_length = longest_palindrome_length.chars();\n    let mut\
    \ longest_palindrome_start = longest_palindrome_start.chars();\n    let \n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3l2p7f4m.rs:41:1\n  \
    \ |\n41 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `chars`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmp3l2p7f4m.rs:20:67\n\
    \   |\n20 |     let mut longest_palindrome_length = longest_palindrome_length.chars();\n\
    \   |                                                                   ^^^^^\
    \ method not found in `{integer}`\n\nerror[E0599]: no method named `chars` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmp3l2p7f4m.rs:21:65\n \
    \  |\n21 |     let mut longest_palindrome_start = longest_palindrome_start.chars();\n\
    \   |                                                                 ^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `chars` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmp3l2p7f4m.rs:22:61\n   |\n\
    22 |     let mut longest_palindrome_end = longest_palindrome_end.chars();\n  \
    \ |                                                             ^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut postfix = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_len_index =\
    \ 0;\n    let mut longest_postfix_len_index_index = 0;\n    let mut longest_postfix_len_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index = 0;\n    let\
    \ mut longest_postfix_len_index_index_index_index_index = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_len_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgrcm1j3k.rs:39:21\n   |\n\
    39 |     let mut longest_\n   |                     ^ help: add `;` here\n40 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgrcm1j3k.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index23\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3yw_62jz.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3yw_62jz.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    for pos in string.char_indices()\
    \ {\n        let mut postfix_length = pos;\n        while postfix_length >= longest_postfix_length\
    \ {\n            postfix_length = longest_postfix_length;\n            longest_postfix_length\
    \ = reversed_string.chars().position(|c| c == reversed_string[postfix_length])\n\
    \                .unwrap_or(longest_postfix_length);\n        }\n        reversed_string.insert(postfix_length,\
    \ reversed_string[postfix_length]);\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ugwdx07.rs:16:33\n   |\n\
    16 |         while postfix_length >= longest_postfix_length {\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found integer\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3ugwdx07.rs:17:30\n   |\n15 |\
    \         let mut postfix_length = pos;\n   |                                \
    \  --- expected due to this value\n16 |         while postfix_length >= longest_postfix_length\
    \ {\n17 |             postfix_length = longest_postfix_length;\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found integer\n \
    \  |\n   = note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `(usize, char)`\n  -->\
    \ /tmp/tmp3ugwdx07.rs:18:80\n   |\n18 |             longest_postfix_length = reversed_string.chars().position(|c|\
    \ c == reversed_string[postfix_length])\n   |                                \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `(usize, char)`\n   |\n   = help: the trait `Index<(usize,\
    \ char)>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ugwdx07.rs:21:32\n\
    \   |\n21 |         reversed_string.insert(postfix_length, reversed_string[postfix_length]);\n\
    \   |                                ^^^^^^^^^^^^^^ expected `usize`, found tuple\n\
    \   |\n   = note: expected type `usize`\n             found tuple `(usize, char)`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `(usize, char)`\n  -->\
    \ /tmp/tmp3ug"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char_index = 0;\n    let mu\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8rxrb_fh.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8rxrb_fh.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reversed_string_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length = 0;\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length =\
    \ 0;\n    let mut longest_postfix_length_string_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length_string_length_string = string;\n\
    \    let mut longest_postfix_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length_string\
    \ = string;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_length_string_length\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb_c1its4.rs:40:49\n   |\n\
    40 |     let mut longest_postfix_length_string_length\n   |                  \
    \                               ^ help: add `;` here\n41 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_c1its4.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !reversed_string.is_empty() {\n        let mut current_char = reversed_string[0];\n\
    \        reversed_string = reversed_string.chars().skip_while(|&c| c != current_char).collect();\n\
    \        prefix_length += 1;\n        if suffix_length == 0 {\n            suffix_length\
    \ = prefix_length;\n        }\n    }\n    let mut reversed_suffix_string = reversed_string.chars().skip_while(|&c|\
    \ c != reversed_string[suffix_length]).collect();\n    reversed_suffix_string.push(reversed_string[suffix_length]);\n\
    \    reversed_suffix_string.push(reversed_string[0]);\n    reversed_suffix_string.push(reversed_string[suffix_length]);\n\
    \    reversed_string\n        .chars()\n        .skip_while(|&c| c != reversed_string[prefix_length])\n\
    \        .collect::<String>()\n        + &reversed_suffix_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpxrmkusye.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxrmkusye.rs:23:83\n   |\n23 |     let mut reversed_suffix_string\
    \ = reversed_string.chars().skip_while(|&c| c != reversed_string[suffix_length]).collect();\n\
    \   |                                                                        \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpxrmkusye.rs:24:33\n   |\n24 |     reversed_suffix_string.push(reversed_string[suffix_length]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <Str"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_suffix = 0;\n\n    while longest_palindrome_length\
    \ < longest_palindrome.len() {\n        let mut longest_palindrome_suffix = longest_palindrome.len()\
    \ - longest_palindrome_length;\n        let mut longest_palindrome_prefix_length\
    \ = 0;\n\n        while longest_palindrome_prefix_length < longest_palindrome_suffix\
    \ {\n            let mut longest_palindrome_prefix = longest_palindrome.chars().nth(longest_palindrome_prefix_length).unwrap();\n\
    \            let mut longest_palindrome_prefix_length = longest_palindrome_prefix_length\
    \ + 1;\n\n            while longest_palindrome_prefix_length < longest_palindrome_suffix\
    \ {\n                let mut longest_palindrome_prefix = longest_palindrome.chars().nth(longest_palindrome_prefix_length).unwrap();\n\
    \                longest_palindrome_prefix_length = longest_palindrome_prefix_length\
    \ + 1;\n\n                if longest_palindrome_prefix != longest_palindrome_prefix.rev()\
    \ {\n                    break;\n                }\n            }\n\n        \
    \    longest_palindrome_suffix = longest_palindrome_suffix - 1;\n        }\n\n\
    \        longest_palindrome_length = longest_palindrome_length + 1;\n        longest_palindrome\
    \ = longest_palindrome.chars().nth(longest_palindrome_length).unwrap();\n    }\n\
    \n    reversed_string += &longest_palindrome;\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmp1e8tggjn.rs:29:75\n\
    \   |\n29 |                 if longest_palindrome_prefix != longest_palindrome_prefix.rev()\
    \ {\n   |                                                                    \
    \       ^^^ `char` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `char: Iterator`\n           which is required\
    \ by `&mut char: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1e8tggjn.rs:38:30\n\
    \   |\n13 |     let mut longest_palindrome = string;\n   |                   \
    \               ------ expected due to this value\n...\n38 |         longest_palindrome\
    \ = longest_palindrome.chars().nth(longest_palindrome_length).unwrap();\n   |\
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph6aqpccd.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph6aqpccd.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reverse_string = \"\";\n\n    for pos in string.len()\
    \ {\n        let mut pos = pos;\n        while pos > 0 {\n            let mut\
    \ char = string.chars().nth(pos).unwrap();\n            pos = pos - 1;\n     \
    \       reverse_string = reverse_string[..pos] + char + reverse_string[pos + 1..].to_owned();\n\
    \        }\n        palindrome = palindrome[..pos] + reverse_string[..pos].to_owned();\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmp7tfc04ot.rs:15:16\n\
    \   |\n15 |     for pos in string.len() {\n   |                ^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0369]: cannot add `char` to `str`\n  -->\
    \ /tmp/tmp7tfc04ot.rs:20:52\n   |\n20 |             reverse_string = reverse_string[..pos]\
    \ + char + reverse_string[pos + 1..].to_owned();\n   |                       \
    \       --------------------- ^ ---- char\n   |                              |\n\
    \   |                              str\n\nerror[E0369]: cannot add `String` to\
    \ `str`\n  --> /tmp/tmp7tfc04ot.rs:22:40\n   |\n22 |         palindrome = palindrome[..pos]\
    \ + reverse_string[..pos].to_owned();\n   |                      -----------------\
    \ ^ -------------------------------- String\n   |                      |\n   |\
    \                      str\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut reverse_suffix = 0;\n    let mut reverse_prefix = 0;\n\
    \    while reverse_suffix < string.len() {\n        let mut reverse_suffix_char\
    \ = string[reverse_suffix];\n        let mut reverse_prefix_char = string[reverse_prefix];\n\
    \        while reverse_prefix_char != reverse_suffix_char {\n            reversed_string.push(reverse_prefix_char);\n\
    \            reverse_prefix_char = string[reverse_prefix];\n        }\n      \
    \  reversed_string.push(reverse_suffix_char);\n        reverse_suffix += 1;\n\
    \        reverse_prefix += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn2w8s9cq.rs:16:39\n\
    \   |\n16 |         let mut reverse_suffix_char = string[reverse_suffix];\n  \
    \ |                                       ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpn2w8s9cq.rs:17:39\n   |\n17 |         let mut reverse_prefix_char\
    \ = string[reverse_prefix];\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpn2w8s9cq.rs:20:35\n   |\n20 |             reverse_prefix_char =\
    \ string[reverse_prefix];\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut palindrome_length =\
    \ 0;\n    let mut longest_postfix_length = 0;\n    while palindrome_length < longest_postfix_length\
    \ {\n        let mut postfix_length = longest_postfix_length;\n        while postfix_length\
    \ < palindrome_length {\n            let mut postfix = palindrome[..postfix_length];\n\
    \            let mut reversed_postfix = reversed_string[..postfix_length];\n \
    \           while postfix.len() > 0 {\n                let mut char = postfix.chars().next().unwrap();\n\
    \                reversed_postfix.push(char);\n                postfix.pop();\n\
    \            }\n            if reversed_postfix.eq(&reversed_string) {\n     \
    \           palindrome = palindrome[..postfix_length];\n                palindrome_length\
    \ = postfix_length;\n                longest_postfix_length = postfix_length;\n\
    \            } else {\n                postfix_length += 1;\n            }\n \
    \       }\n    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpp76mt0ye.rs:19:17\n   |\n19 |             let mut postfix\
    \ = palindrome[..postfix_length];\n   |                 ^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n19 |             let mut postfix = &palindrome[..postfix_length];\n\
    \   |                               +\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmpp76mt0ye.rs:20:17\n\
    \   |\n20 |             let mut reversed_postfix = reversed_string[..postfix_length];\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n20 |\
    \             let mut reversed_postfix = &reversed_string[..postfix_length];\n\
    \   |                                        +\n\nerror[E0599]: no method named\
    \ `push` found for type `str` in the current scope\n  --> /tmp/tmpp76mt0ye.rs:23:34\n\
    \   |\n23 |                 reversed_postfix.push(char);\n   |               \
    \                   ^^^^ method not found in `str`\n\nerror[E0599]: no method\
    \ named `pop` found for type `str` in the current scope\n  --> /tmp/tmpp76mt0ye.rs:24:25\n\
    \   |\n24 |                 postfix.pop();\n   |                         ^^^ method\
    \ not found in `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp76mt0ye.rs:27:30\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n27 |                 palindrome = palindrome[..postfix_length];\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                       "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzeq_ho56.rs:45:33\n   |\n\
    45 |     let mut longest_postfix_post\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzeq_ho56.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_reverse = \"\";\n    let mut longest_postfix_postfix_reverse_index\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index_start = 0;\n    let mut longest_postfix_postfix_reverse_index_start2\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end2 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index_start3 = 0;\n    let mut longest_postfix_postfix_reverse_index_end3\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_start4 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_end4 = 0;\n    let mut longest_postfix_postfix_reverse_index_start5\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end5 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index_start6 = 0;\n    let mut longest_postfix_postfix_reverse_index_end6\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_start7 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_end7 = 0;\n    let mut longest_postfix_postfix_reverse_index_start8\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end8 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index_start9 = 0;\n    let mut longest_postfix_postfix_reverse_index_end9\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_start10 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_end10 = 0;\n    let mut longest_postfix_postfix_reverse_index_start11\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end11 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_start12 = 0;\n    let mut longest_postfix_postfix_reverse_index_end12\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_start13 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_end13 = 0;\n    let mut longest_postfix_postfix_reverse_index_start14\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index_end14 = 0;\n    let\
    \ mut longest_postfix_postfix_reverse_index_start15 = 0;\n    let mut longest_postfix_postfix_reverse_index_end\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp60b56x2k.rs:48:54\n   |\n\
    48 |     let mut longest_postfix_postfix_reverse_index_end\n   |             \
    \                                         ^ help: add `;` here\n49 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp60b56x2k.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut palindrome = string;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length = 0;\n\n    while longest_postfix_length\
    \ < reversed_string.len() {\n        let mut longest_postfix_length = longest_postfix_length;\n\
    \        let mut longest_postfix_index = 0;\n\n        for index in 0..=reversed_string.len()\
    \ - 1 {\n            if reversed_string[index] != string[index] {\n          \
    \      break;\n            }\n            longest_postfix_length = index;\n  \
    \          longest_postfix_index = index;\n        }\n\n        if longest_postfix_length\
    \ == reversed_string.len() {\n            break;\n        }\n\n        let mut\
    \ postfix_start = longest_postfix_index + 1;\n        let mut postfix_end = longest_postfix_length;\n\
    \        let mut postfix_reversed_start = postfix_start;\n        let mut postfix_reversed_end\
    \ = postfix_end;\n\n        while postfix_reversed_start < postfix_end {\n   \
    \         let mut postfix_reversed_start = postfix_reversed_start;\n         \
    \   let mut postfix_reversed_end = postfix_reversed_end;\n\n            for index\
    \ in 0..=postfix_end - 1 {\n                postfix_reversed_end = postfix_reversed_end\
    \ - 1;\n                postfix_reversed_start = postfix_reversed_start + 1;\n\
    \                if postfix_reversed_start > postfix_end {\n                 \
    \   break;\n                }\n                if postfix_reversed_end < postfix_start\
    \ {\n                    break;\n                }\n                if postfix_reversed_end\
    \ == postfix_start {\n                    postfix_reversed_end = postfix_end -\
    \ 1;\n                    postfix_reversed_start = postfix_reversed_start + 1;\n\
    \                }\n            }\n\n            if postfix_reversed_start ==\
    \ postfix_end {\n                break;\n            }\n\n            palindrome\
    \ = &string[postfix_reversed_start..postfix_reversed_end];\n            reversed_string\
    \ = &string[postfix_start..postfix_end];\n        }\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmodsu4yf.rs:22:16\n\
    \   |\n22 |             if reversed_string[index] != string[index] {\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmodsu4yf.rs:22:42\n   |\n22 |             if reversed_string[index]\
    \ != string[index] {\n   |                                          ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmodsu4yf.rs:61:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n61 |             palindrome = &string[postfix_reversed_start..postfix_reversed_end];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n61 |             palindrome = (&string[postfix_reversed_start..postfix_reversed_end]).to_string();\n\
    \   |                          +                                         "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_prefix_length\
    \ = 0;\n    let mut longest_prefix = \"\";\n    let mut longest_prefix_index =\
    \ 0;\n    let mut longest_prefix_length_index = 0;\n    while string.len() > 0\
    \ {\n        let mut postfix_length = 0;\n        let mut postfix = \"\";\n  \
    \      let mut postfix_index = 0;\n        let mut prefix_length = 0;\n      \
    \  let mut prefix = \"\";\n        let mut prefix_index = 0;\n        let mut\
    \ prefix_length_index = 0;\n        while string.len() > 0 {\n            postfix_length\
    \ += 1;\n            postfix.push(string[postfix_index]);\n            postfix_index\
    \ += 1;\n            prefix_length += 1;\n            prefix.push(string[prefix_index]);\n\
    \            prefix_index += 1;\n        }\n        if postfix_length == 0 {\n\
    \            break;\n        }\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n            longest_postfix\
    \ = postfix.clone();\n            longest_postfix_index = postfix_index;\n   \
    \     }\n        if postfix_length < longest_postfix_length {\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix = postfix.clone();\n        \
    \    longest_postfix_index = postfix_index;\n        }\n        if postfix_length\
    \ == longest_postfix_length {\n            let mut prefix_length_index = 0;\n\
    \            while longest_postfix_length_index < longest_postfix_length {\n \
    \               prefix_length_index += 1;\n                longest_prefix_length\
    \ += 1;\n                longest_prefix.push(string[prefix_length_index]);\n \
    \               longest_prefix_length_index += 1;\n            }\n           \
    \ if longest_prefix_length == longest_postfix_length {\n                let mut\
    \ postfix_length_index = 0;\n                while longest_prefix_length_index\
    \ < longest_prefix_length {\n                    postfix_length_index += 1;\n\
    \                    longest_postfix_length += 1;\n                    longest_postfix.push(string[postfix_length_index]);\n\
    \                    longest_postfix_length_index += 1;\n                }\n \
    \               if longest_postfix_length == longest_postfix_length {\n      \
    \              let mut longest_prefix_length_index = 0;\n                    while\
    \ longest_prefix_length_index < longest_prefix_length {\n                    \
    \    longest_prefix_length_index += 1;\n                        longest_prefix.push(string[\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqg82vpmy.rs:81:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     while string.len()\
    \ > 0 {\n   |                            - unclosed delimiter\n...\n51 |     \
    \    if postfix_length == longest_postfix_length {\n   |                     \
    \                                - unclosed delimiter\n...\n59 |             if\
    \ longest_prefix_length == longest_postfix_length {\n   |                    \
    \                                            - unclosed delimiter\n...\n67 | \
    \                if longest_postfix_length == longest_postfix_length {\n   | \
    \                                                                    - unclosed\
    \ delimiter\n68 |                     let mut longest_prefix_length_index = 0;\n\
    69 |                     while longest_prefix_length_index < longest_prefix_length\
    \ {\n   |                                                                    \
    \           - this delimiter might not be properly closed...\n...\n72 | }\n  \
    \ | - ...as it matches this but it has different indentation\n...\n81 | }\n  \
    \ |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmpqg82vpmy.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpqg82vpmy.rs:71:51\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n71 |                         longest_prefix.push(string[\n\
    \   |                                                   ^ unclosed delimiter\n\
    72 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `push`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpqg82vpmy.rs:32:21\n\
    \   |\n32 |             postfix.push(string[postfix_index]);\n   |           \
    \          ^^^^ method not found in `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpqg82vpmy.rs:32:26\n   |\n32\
    \ |             postfix.push(string[postfix_i"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index23\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxekrkelz.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxekrkelz.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    for c in string.chars()\
    \ {\n        if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n        }\n    }\n    for c in string.chars() {\n        if longest_postfix_length\
    \ == c.len() {\n            reversed_string += &c[longest_postfix_length..];\n\
    \        }\n    }\n    reversed_string += &string[longest_postfix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6zipgjlz.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6zipgjlz.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6zipgjlz.rs:20:40\n   |\n20 |         if longest_postfix_length\
    \ == c.len() {\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp6zipgjlz.rs:21:33\n\
    \   |\n21 |             reversed_string += &c[longest_postfix_length..];\n   |\
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp6zipgjlz.rs:24:5\n\
    \   |\n24 |     reversed_string += &string[longest_postfix_length..];\n   |  \
    \   ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n   |   \
    \  cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6zipgjlz.rs:25:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    25 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368, E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reversed_string = string;\n    let mut i = 0;\n    while\
    \ i < palindrome.len() {\n        let mut j = palindrome.len() - 1;\n        while\
    \ j >= i {\n            if palindrome[j] != reversed_string[i] {\n           \
    \     break;\n            }\n            j -= 1;\n        }\n        if j >= i\
    \ {\n            palindrome = &palindrome[i..j + 1];\n            reversed_string\
    \ = &reversed_string[i..j + 1];\n        }\n        i += 1;\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq7vrxwxw.rs:18:16\n\
    \   |\n18 |             if palindrome[j] != reversed_string[i] {\n   |       \
    \         ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq7vrxwxw.rs:18:33\n   |\n18 |             if palindrome[j] != reversed_string[i]\
    \ {\n   |                                 ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq7vrxwxw.rs:24:26\n\
    \   |\n12 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n24 |             palindrome = &palindrome[i..j\
    \ + 1];\n   |                          ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n24 |        \
    \     palindrome = (&palindrome[i..j + 1]).to_string();\n   |                \
    \          +                     +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq7vrxwxw.rs:25:31\n   |\n13 |     let mut reversed_string = string;\n\
    \   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < string.len() {\n        let mut suffix_start = suffix_length;\n\
    \        let mut suffix_end = suffix_length;\n        while suffix_end < string.len()\
    \ {\n            if string[suffix_end] != string[suffix_end - 1] {\n         \
    \       break;\n            }\n            suffix_end += 1;\n        }\n     \
    \   if suffix_end == string.len() {\n            break;\n        }\n        let\
    \ mut suffix_length = suffix_end - suffix_start + 1;\n        let mut prefix_start\
    \ = prefix_length;\n        let mut prefix_end = prefix_length;\n        while\
    \ prefix_end < string.len() {\n            if string[prefix_end] != string[prefix_end\
    \ - 1] {\n                break;\n            }\n            prefix_end += 1;\n\
    \        }\n        if prefix_end == string.len() {\n            break;\n    \
    \    }\n        let mut prefix_length = prefix_end - prefix_start + 1;\n     \
    \   let mut reversed_string = string[prefix_start..prefix_end].to_string();\n\
    \        reversed_string.push(reversed_string[prefix_end - 1]);\n        reversed_string.push(reversed_string[prefix_end\
    \ - 2]);\n    }\n    string[prefix_length..suffix_length].to_string()\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp56sapa5a.rs:19:16\n\
    \   |\n19 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp56sapa5a.rs:19:38\n   |\n19 |             if string[suffix_end]\
    \ != string[suffix_end - 1] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp56sapa5a.rs:31:16\n   |\n31 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length\
    \ = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpi0fz0zod.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut longest_palindrome_start = 0;\n    let mut longest_palindrome_end\
    \ = 0;\n\n    while longest_palindrome_length < string.len() {\n        let mut\
    \ longest_palindrome_start = longest_palindrome_end;\n        let mut longest_palindrome_end\
    \ = longest_palindrome_start + 1;\n\n        for pos in longest_palindrome_start..longest_palindrome_end\
    \ {\n            if string[pos] != string[longest_palindrome_end - 1] {\n    \
    \            break;\n            }\n            longest_palindrome_end++;\n  \
    \      }\n\n        let mut longest_palindrome_length = longest_palindrome_end\
    \ - longest_palindrome_start + 1;\n\n        if longest_palindrome_length < string.len()\
    \ {\n            longest_palindrome = &string[longest_palindrome_start..longest_palindrome_end];\n\
    \        }\n    }\n\n    longest_palindrome.reverse();\n    reversed_string.push_str(longest_palindrome);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpolj30dp9.rs:26:35\n\
    \   |\n26 |             longest_palindrome_end++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n26 |             { let tmp = longest_palindrome_end; longest_palindrome_end\
    \ += 1; tmp };\n   |             +++++++++++                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    26 -             longest_palindrome_end++;\n26 +             longest_palindrome_end\
    \ += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpolj30dp9.rs:23:16\n   |\n23 |             if string[pos] != string[longest_palindrome_end\
    \ - 1] {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpolj30dp9.rs:23:31\n   |\n23 |             if string[pos] != string[longest_palindrome_end\
    \ - 1] {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpolj30d"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    let mut suffix_index = 0;\n    let mut suffix_char = string.chars().nth(suffix_index).unwrap();\n\
    \    while suffix_index != string.len() - 1 {\n        if suffix_char == reversed_string[suffix_index]\
    \ {\n            suffix_index += 1;\n            suffix_char = string.chars().nth(suffix_index).unwrap();\n\
    \        } else {\n            suffix_length += 1;\n            suffix_char =\
    \ string.chars().nth(suffix_index).unwrap();\n        }\n    }\n    let mut prefix_char\
    \ = string.chars().nth(prefix_index).unwrap();\n    while prefix_index != 0 {\n\
    \        if prefix_char == reversed_string[prefix_index] {\n            prefix_index\
    \ -= 1;\n            prefix_char = string.chars().nth(prefix_index).unwrap();\n\
    \        } else {\n            prefix_length += 1;\n            prefix_char =\
    \ string.chars().nth(prefix_index).unwrap();\n        }\n    }\n    prefix_length\
    \ += 1;\n    reversed_string += &reversed_string[prefix_length..suffix_index];\n\
    \    reversed_string += &reversed_string[suffix_index..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prefix_index` in this scope\n  --> /tmp/tmpnbfmap_d.rs:26:46\n\
    \   |\n26 |     let mut prefix_char = string.chars().nth(prefix_index).unwrap();\n\
    \   |                                              ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `suffix_index`\n\nerror[E0425]: cannot\
    \ find value `prefix_index` in this scope\n  --> /tmp/tmpnbfmap_d.rs:27:11\n \
    \  |\n27 |     while prefix_index != 0 {\n   |           ^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `suffix_index`\n\nerror[E0425]: cannot\
    \ find value `prefix_index` in this scope\n  --> /tmp/tmpnbfmap_d.rs:28:43\n \
    \  |\n28 |         if prefix_char == reversed_string[prefix_index] {\n   |   \
    \                                        ^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `suffix_index`\n\nerror[E0425]: cannot find value `prefix_index`\
    \ in this scope\n  --> /tmp/tmpnbfmap_d.rs:29:13\n   |\n29 |             prefix_index\
    \ -= 1;\n   |             ^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `suffix_index`\n\nerror[E0425]: cannot find value `prefix_index` in\
    \ this scope\n  --> /tmp/tmpnbfmap_d.rs:30:46\n   |\n30 |             prefix_char\
    \ = string.chars().nth(prefix_index).unwrap();\n   |                         \
    \                     ^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `suffix_index`\n\nerror[E0425]: cannot find value `prefix_index` in\
    \ this scope\n  --> /tmp/tmpnbfmap_d.rs:33:46\n   |\n33 |             prefix_char\
    \ = string.chars().nth(prefix_index).unwrap();\n   |                         \
    \                     ^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `suffix_index`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpnbfmap_d.rs:18:27\n   |\n18 |         if suffix_char\
    \ == reversed_string[suffix_index] {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Id"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt9k6e_co.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt9k6e_co.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_index = 0;\n    let mut longest_postfix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_length = 0;\n    let mut longest_postfix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_length_index = 0;\n    let mut\
    \ longest_postfix_suffix_suffix_suffix_length = 0;\n    let mut longest_postfix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_length_index = 0;\n \
    \   let mut longest_postfix_suffix_suffix_suffix_suffix_length = 0;\n    let mut\
    \ longest_postfix_suffix_suffix_suffix_suffix_index = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_suffi\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmuwhn1um.rs:40:41\n   |\n\
    40 |     let mut longest_postfix_suffix_suffi\n   |                          \
    \               ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmuwhn1um.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    for index in 0..string.len() {\n        let mut postfix_length = string.len();\n\
    \        let mut postfix_char = string[index];\n        while postfix_length >=\
    \ longest_postfix_length {\n            longest_postfix_length += 1;\n       \
    \     postfix_length -= 1;\n            postfix_char = string[longest_postfix_length];\n\
    \        }\n        if longest_postfix_length == 0 {\n            break;\n   \
    \     }\n        if postfix_char != string[longest_postfix_length] {\n       \
    \     break;\n        }\n        longest_postfix_index += 1;\n        longest_postfix_length\
    \ += 1;\n    }\n    let mut postfix_string = string;\n    for index in longest_postfix_index..string.len()\
    \ {\n        postfix_string += string[index];\n    }\n    reversed_string += string[longest_postfix_index..];\n\
    \    reversed_string += string[longest_postfix_index..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb4s1slj7.rs:17:32\n\
    \   |\n17 |         let mut postfix_char = string[index];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb4s1slj7.rs:21:28\n\
    \   |\n21 |             postfix_char = string[longest_postfix_length];\n   | \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb4s1slj7.rs:26:28\n   |\n26 |         if postfix_char != string[longest_postfix_length]\
    \ {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_len_index\
    \ = 0;\n    let mut longest_postfix_len_index_end = 0;\n    let mut longest_postfix_len_index_start\
    \ = 0;\n    let mut longest_postfix_len_index_start_end = 0;\n    let mut longest_postfix_len_index_start_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end = 0;\n    let\
    \ mut longest_postfix_len_index_start_end_end_end_end = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end =\
    \ 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut longest_postfix_len_index_start_end_end_end_end_\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8brz6ng.rs:40:61\n   |\n\
    40 |     let mut longest_postfix_len_index_start_end_end_end_end_\n   |      \
    \                                                       ^ help: add `;` here\n\
    41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8brz6ng.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = \"\";\n    for c in string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = longest_postfix.len() + 1;\n     \
    \       longest_postfix = &c;\n        } else {\n            if longest_postfix.len()\
    \ < longest_postfix_length {\n                longest_postfix_length = longest_postfix.len()\
    \ + 1;\n                longest_postfix = &c;\n            }\n        }\n    }\n\
    \    for c in string.chars() {\n        if longest_postfix.len() < longest_postfix_length\
    \ {\n            reversed_string += &c.to_string();\n        }\n    }\n    reversed_string\
    \ += &longest_postfix.to_string();\n    reversed_string\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2eg58p9z.rs:18:31\n   |\n\
    14 |     let mut longest_postfix = \"\";\n   |                               --\
    \ expected due to this value\n...\n18 |             longest_postfix = &c;\n  \
    \ |                               ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2eg58p9z.rs:22:35\n   |\n14 |     let mut longest_postfix\
    \ = \"\";\n   |                               -- expected due to this value\n\
    ...\n22 |                 longest_postfix = &c;\n   |                        \
    \           ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp2eg58p9z.rs:28:13\n\
    \   |\n28 |             reversed_string += &c.to_string();\n   |             ---------------^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp2eg58p9z.rs:31:5\n\
    \   |\n31 |     reversed_string += &longest_postfix.to_string();\n   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2eg58p9z.rs:32:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n32 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut palindrome = string;\n    let mut start = 0;\n    let\
    \ mut end = string.len();\n    while start < end {\n        let mut i = start;\n\
    \        let mut j = end;\n        while i < j {\n            if string[i] !=\
    \ string[j] {\n                break;\n            }\n            i += 1;\n  \
    \          j -= 1;\n        }\n        if i == j {\n            palindrome = &string[start..(i\
    \ + 1)];\n            start = i + 1;\n            end = j;\n        }\n    }\n\
    \    reverse.push_str(&palindrome);\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_voiehz.rs:20:16\n\
    \   |\n20 |             if string[i] != string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6_voiehz.rs:20:29\n   |\n20 |             if string[i] != string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_voiehz.rs:27:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n27 |             palindrome = &string[start..(i\
    \ + 1)];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n27\
    \ |             palindrome = (&string[start..(i + 1)]).to_string();\n   |    \
    \                      +                       +++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E02"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmptorihlt5.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut prefix_length =\
    \ 0;\n    let mut suffix_length = 0;\n    while palindrome.len() > 0 {\n     \
    \   let mut current_char = palindrome[0];\n        palindrome.remove(0);\n   \
    \     reversed_string += &current_char.to_string();\n        if palindrome.len()\
    \ > 0 {\n            suffix_length += 1;\n        }\n        if suffix_length\
    \ >= reversed_string.len() {\n            prefix_length += 1;\n        }\n   \
    \     if prefix_length >= reversed_string.len() {\n            palindrome = &palindrome[..];\n\
    \            suffix_length = 0;\n            prefix_length = 0;\n        }\n \
    \   }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmptmbhpkfk.rs:17:32\n   |\n17 |         let mut current_char = palindrome[0];\n\
    \   |                                ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptmbhpkfk.rs:27:26\n\
    \   |\n12 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n27 |             palindrome = &palindrome[..];\n\
    \   |                          ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n27 |             palindrome\
    \ = (&palindrome[..]).to_string();\n   |                          +          \
    \     +++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index = 0;\n    let mut longest_postfix_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index = 0;\n   \
    \ let mut longest_postfix_index_length_index_length_index_length = 0;\n    let\
    \ mut longest_postfix_index_length_index_length_index_length_index = 0;\n    let\
    \ mut longest_postfix_index_length_index_length_index_length_index_length = 0;\n\
    \    let mut longest_postfix_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index_length\
    \ = 0;\n    let mut longest_postfix_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index_length_index\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn6car_7d.rs:41:16\n   |\n\
    41 |     let mut lon\n   |                ^ help: add `;` here\n42 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6car_7d.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_length = 0;\n    while longest_postfix_length\
    \ < longest_postfix_length_length {\n        longest_postfix_length_length = longest_postfix_length.len();\n\
    \        let mut longest_postfix_length_length_length = 0;\n        for (i, c)\
    \ in longest_postfix_length.chars().enumerate() {\n            longest_postfix_length_length_length\
    \ += c;\n            if longest_postfix_length_length_length == longest_postfix_length_length\
    \ {\n                longest_postfix_length_length_length = longest_postfix_length_length;\n\
    \                longest_postfix_index = i;\n            }\n        }\n      \
    \  let mut longest_postfix_length_length_length = 0;\n        for (i, c) in reversed_string.chars().enumerate()\
    \ {\n            longest_postfix_length_length_length += c;\n            if longest_postfix_length_length_length\
    \ == longest_postfix_length_length {\n                longest_postfix_length_length_length\
    \ = longest_postfix_length_length;\n                longest_postfix_length_index\
    \ = i;\n            }\n        }\n        if longest_postfix_length == longest_postfix_length\
    \ {\n            longest_postfix_length = &reversed_string[longest_postfix_length_index..];\n\
    \        }\n    }\n    let mut longest_postfix_length_length_length = 0;\n   \
    \ for (i, c) in longest_postfix_length.chars().enumerate() {\n        longest_postfix_length_length_length\
    \ += c;\n        if longest_postfix_length_length_length == longest_postfix_length_length\
    \ {\n            longest_postfix_length_length_length = longest_postfix_length_length;\n\
    \            longest_postfix_length_length_length = longest_postfix_length_length;\n\
    \            longest_postfix_index = i;\n        }\n    }\n    let mut longest_postfix_length_length_length\
    \ = 0;\n    for (i, c) in reversed_string.chars().enumerate() {\n        longest_postfix_length_length_length\
    \ += c;\n        if longest_postfix_length_length_length == longest_postfix_length_length\
    \ {\n            longest_postfix_length_length_length = longest_postfix_length_length;\n\
    \            longest_postfix_length_length_length = longest_postfix_length_length;\n\
    \            longest_postfix_length_index = i;\n        }\n    }\n    let mut\
    \ longest_postfix_length_length_length = 0;\n    for (i, c) in longest_postfix_length.chars().enumerate()\
    \ {\n        longest_postfix_length_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpn36gtwod.rs:70:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n59 |     for (i,\
    \ c) in longest_postfix_length.chars().enumerate() {\n   |                   \
    \                                           - this delimiter might not be properly\
    \ closed...\n60 |         longest_postfix_length_\n61 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n70 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `longest_postfix_length_` in this scope\n  --> /tmp/tmpn36gtwod.rs:60:9\n\
    \   |\n60 |         longest_postfix_length_\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_postfix_length`\n\
    \nerror[E0689]: can't call method `len` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpn36gtwod.rs:19:64\n   |\n19 |         longest_postfix_length_length\
    \ = longest_postfix_length.len();\n   |                                      \
    \                          ^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `i32`\n   |\n14 |     let mut longest_postfix_length: i32 = 0;\n   |  \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `chars`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmpn36gtwod.rs:21:46\n\
    \   |\n21 |         for (i, c) in longest_postfix_length.chars().enumerate() {\n\
    \   |                                              ^^^^^ method not found in `{integer}`\n\
    \nerror[E0277]: cannot add-assign `char` to `{integer}`\n  --> /tmp/tmpn36gtwod.rs:30:50\n\
    \   |\n30 |             longest_postfix_length_length_length += c;\n   |     \
    \                                             ^^ no implementation for `{integer}\
    \ += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string;\n    let mut palindrome = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    while i < palindrome.len() {\n        let\
    \ mut j = palindrome.len() - 1;\n        while j >= i {\n            if palindrome[j]\
    \ != reversed_palindrome[i] {\n                break;\n            }\n       \
    \     j -= 1;\n        }\n        if j == i {\n            palindrome = &palindrome[..i\
    \ + 1];\n            i += 1;\n        } else {\n            palindrome = &palindrome[..j\
    \ + 1];\n            i += j - i;\n        }\n        reversed_palindrome = &reversed_palindrome[..i\
    \ + 1];\n    }\n    result = &result[..palindrome.len()];\n    result\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkmwitjmt.rs:19:16\n\
    \   |\n19 |             if palindrome[j] != reversed_palindrome[i] {\n   |   \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkmwitjmt.rs:19:33\n\
    \   |\n19 |             if palindrome[j] != reversed_palindrome[i] {\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkmwitjmt.rs:25:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n25 |             palindrome = &palindrome[..i\
    \ + 1];\n   |                          ^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n25 |        \
    \     palindrome = (&palindrome[..i + 1]).to_string();\n   |                 \
    \         +                    +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkmwitjmt.rs:28:26\n   |\n13 |     let mut palindrome = string;\n\
    \   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuaq2vru2.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuaq2vru2.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_index = 0;\n    let mut longest_postfix_suffix_length_index\
    \ = 0;\n    let mut longest_postfix_suffix_string = \"\";\n    let mut longest_postfix_suffix_string_index\
    \ = 0;\n    let mut longest_postfix_suffix_string_index2 = 0;\n    let mut longest_postfix_suffix_string_index3\
    \ = 0;\n    let mut longest_postfix_suffix_string_index4 = 0;\n    let mut longest_postfix_suffix_string_index5\
    \ = 0;\n    let mut longest_postfix_suffix_string_index6 = 0;\n    let mut longest_postfix_suffix_string_index7\
    \ = 0;\n    let mut longest_postfix_suffix_string_index8 = 0;\n    let mut longest_postfix_suffix_string_index9\
    \ = 0;\n    let mut longest_postfix_suffix_string_index10 = 0;\n    let mut longest_postfix_suffix_string_index11\
    \ = 0;\n    let mut longest_postfix_suffix_string_index12 = 0;\n    let mut longest_postfix_suffix_string_index13\
    \ = 0;\n    let mut longest_postfix_suffix_string_index14 = 0;\n    let mut longest_postfix_suffix_string_index15\
    \ = 0;\n    let mut longest_postfix_suffix_string_index16 = 0;\n    let mut longest_postfix_suffix_string_index17\
    \ = 0;\n    let mut longest_postfix_suffix_string_index18 = 0;\n    let mut longest_postfix_suffix_string_index19\
    \ = 0;\n    let mut longest_postfix_suffix_string_index20 = 0;\n    let mut longest_postfix_suffix_string_index21\
    \ = 0;\n    let mut longest_postfix_suffix_string_index22 = 0;\n    let mut longest_postfix_suffix_string_index23\
    \ = 0;\n    let mut longest_postfix_suffix_string_index24 = 0;\n    let mut longest_postfix_suffix_string_index25\
    \ = 0;\n    let mut longest_postfix_suffix_string_index26 = 0;\n    let mut longest_postfix_suffix_string_index27\
    \ = 0;\n    let mut longest_postfix_suffix_string_index28 = 0;\n    let mut longest_postfix_suffix_string_index29\
    \ = 0;\n    let mut longest_postfix_suffix_string_index30 = 0;\n    let mut longest_postfix_suffix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdu_y7rdm.rs:50:36\n   |\n\
    50 |     let mut longest_postfix_suffix_\n   |                               \
    \     ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdu_y7rdm.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdakp2t1k.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdakp2t1k.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = string;\n    let mut reverse_string = string;\n\
    \    let mut reverse_palindrome = string;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut j = i;\n        while j < string.len() {\n            if\
    \ string[j] != string[i] {\n                break;\n            }\n          \
    \  i += 1;\n            j = i;\n        }\n        if j == i {\n            palindrome\
    \ += &string[i];\n        }\n        reverse_palindrome += &string[j];\n     \
    \   reverse_string += &string[j];\n        i += 1;\n    }\n    palindrome += &reverse_palindrome;\n\
    \    reverse_string += &reverse_palindrome;\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoue1d6t2.rs:20:16\n\
    \   |\n20 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoue1d6t2.rs:20:29\n   |\n20 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoue1d6t2.rs:27:28\n   |\n27 |             palindrome += &string[i];\n\
    \   |                            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut palindrome = string;\n    let mut prefix_len = 0;\n \
    \   let mut suffix_len = 0;\n    while !reverse.starts_with(palindrome) {\n  \
    \      let mut i = prefix_len;\n        let mut j = suffix_len;\n        while\
    \ i < j {\n            if reverse[j] != palindrome[i] {\n                break;\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ i == j {\n            palindrome += &reverse[prefix_len..];\n            prefix_len\
    \ += 1;\n            suffix_len += 1;\n        } else {\n            palindrome\
    \ += &reverse[prefix_len..i];\n            prefix_len = i;\n        }\n    }\n\
    \    palindrome += &reverse[suffix_len..];\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp2nwq9zx5.rs:16:32\n     |\n16   |     while !reverse.starts_with(palindrome)\
    \ {\n     |                    ----------- ^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                    |\n     |                \
    \    required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n16   |     while !reverse.starts_with(&palindrome) {\n     | \
    \                               +\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp2nwq9zx5.rs:20:16\n   |\n20 |        \
    \     if reverse[j] != palindrome[i] {\n   |                ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp2nwq9zx5.rs:20:30\n   |\n20 |             if reverse[j] != palindrome[i]\
    \ {\n   |                              ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<us"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut prefix_len = 0;\n    let mut suffix_len = 0;\n    let\
    \ mut suffix_start = 0;\n    let mut suffix_end = string.len();\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_start = string.len();\n    while suffix_start\
    \ < suffix_end {\n        let mut suffix_end = suffix_start;\n        while suffix_end\
    \ < suffix_end + suffix_len {\n            let mut suffix_end = suffix_end + 1;\n\
    \            if suffix_end == suffix_end + suffix_len {\n                suffix_end\
    \ = suffix_end + 1;\n            }\n            if suffix_end == suffix_end {\n\
    \                suffix_end = suffix_end + 1;\n            }\n            if suffix_end\
    \ == suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_end == suffix_end {\n                suffix_end = suffix_end\
    \ + 1;\n            }\n            if suffix_end == suffix_end {\n           \
    \     suffix_end = suffix_end + 1;\n            }\n            if suffix_end ==\
    \ suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_end == suffix_end {\n                suffix_end = suffix_end\
    \ + 1;\n            }\n            if suffix_end == suffix_end {\n           \
    \     suffix_end = suffix_end + 1;\n            }\n            if suffix_end ==\
    \ suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_end == suffix_end {\n                suffix_end = suffix_end\
    \ + 1;\n            }\n            if suffix_end == suffix_end {\n           \
    \     suffix_end = suffix_end + 1;\n            }\n            if suffix_end ==\
    \ suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_end == suffix_end {\n                suffix_end = suffix_end\
    \ + 1;\n            }\n            if suffix_end == suffix_end {\n           \
    \     suffix_end = suffix_end + 1;\n            }\n            if suffix_end ==\
    \ suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_end == suffix_end {\n                suffix_end = suffix_end\
    \ + 1;\n            }\n            if suffix_end == suffix_end {\n           \
    \     suffix_end = suffix_end + 1;\n            }\n            if suffix_end ==\
    \ suffix_end {\n                suffix_end = suffix_end + 1;\n            }\n\
    \            if suffix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqg_b7asn.rs:87:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n19 |     while suffix_start\
    \ < suffix_end {\n   |                                     - unclosed delimiter\n\
    20 |         let mut suffix_end = suffix_start;\n21 |         while suffix_end\
    \ < suffix_end + suffix_len {\n   |                                          \
    \          - this delimiter might not be properly closed...\n...\n78 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n87 | }\n   |\
    \   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpqg_b7asn.rs:78:1\n   |\n\
    77 |             if suffix_\n   |             -- this `if` expression has a condition,\
    \ but no block\n78 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqg_b7asn.rs:19:5\n   |\n11 |   fn make_palindrome(string: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n19 | /     while suffix_start < suffix_end {\n\
    20 | |         let mut suffix_end = suffix_start;\n21 | |         while suffix_end\
    \ < suffix_end + suffix_len {\n22 | |             let mut suffix_end = suffix_end\
    \ + 1;\n...  |\n86 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n87 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_index_index = 0;\n    let mut longest_postfix_length_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index = 0;\n    let\
    \ mut longest_postfix_length_index_index_index_index_index = 0;\n    let mut longest_postfix_length_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index = 0;\n\
    \    let mut longest_postfix_length_index_index_index_index_index_index = 0;\n\
    \    let mut longest_postfix_length_index_index_index_index_index_index = 0;\n\
    \    let mut longest_postfix_length_index_index_index_index_index_index = 0;\n\
    \    let mut longest_postfix_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v1v2p06.rs:42:108\n   |\n\
    42 |     let mut longest_postfix_length_index_index_index_index_index_index_index_index_index_index_index_index_\n\
    \   |                                                                        \
    \                                    ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3v1v2p06.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
