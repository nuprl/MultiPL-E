name: HumanEval_136_largest_smallest_integers
language: rust
results:
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5vy7p3fj.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5vy7p3fj.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vy7p3fj.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5vy7p3fj.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vy7p3fj.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5vy7p3fj.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpivm487jd.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpivm487jd.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpivm487jd.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpivm487jd.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpivm487jd.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpivm487jd.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(0);\n    let mut largest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            smallest = Some(x);\n   \
    \     } else {\n            largest = Some(x);\n        }\n    }\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpgddwv8hs.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = std::i32::MAX;\n    let mut min_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpooct4fk9.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpooct4fk9.rs:14:23\n   |\n11 |     let mut min_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpooct4fk9.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpooct4fk9.rs:17:23\n   |\n10 |     let mut max_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpooct4fk9.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpooct4fk9.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi4t6elx1.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi4t6elx1.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi4t6elx1.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi4t6elx1.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi4t6elx1.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi4t6elx1.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        }\n    }\n   \
    \ (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpjd07dxzi.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(0);\n    let mut largest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            smallest = Some(x);\n   \
    \     } else {\n            largest = Some(x);\n        }\n    }\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmph9wceblo.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpjjxd2slh.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0kqw528w.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0kqw528w.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0kqw528w.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0kqw528w.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0kqw528w.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0kqw528w.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(max_negative.max());\n            }\n        } else\
    \ {\n            if min_positive.is_none() {\n                min_positive = Some(x);\n\
    \            } else {\n                min_positive = Some(min_positive.min());\n\
    \            }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpui1q59ve.rs:17:50\n    |\n17  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpui1q59ve.rs:17:37\n   |\n17 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpui1q59ve.rs:23:50\n\
    \    |\n23  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpui1q59ve.rs:23:37\n\
    \   |\n23 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvkh1_7k.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwvkh1_7k.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvkh1_7k.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwvkh1_7k.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvkh1_7k.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwvkh1_7k.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv_t7sm39.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv_t7sm39.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_t7sm39.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv_t7sm39.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_t7sm39.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv_t7sm39.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkcac2mna.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkcac2mna.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkcac2mna.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkcac2mna.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkcac2mna.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkcac2mna.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8t76v14.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm8t76v14.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm8t76v14.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm8t76v14.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm8t76v14.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm8t76v14.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqwygjro.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsqwygjro.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqwygjro.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsqwygjro.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqwygjro.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsqwygjro.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \        } else {\n            min_val = Some(min_val.unwrap());\n        }\n\
    \    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp8vcjk3eb.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpin_d9xio.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpin_d9xio.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin_d9xio.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpin_d9xio.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin_d9xio.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpin_d9xio.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpqkvuk4s9.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcu9jveg0.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcu9jveg0.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcu9jveg0.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcu9jveg0.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcu9jveg0.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcu9jveg0.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = isize::MAX;\n    let mut largest =\
    \ isize::MIN;\n    for x in lst {\n        if x < smallest {\n            smallest\
    \ = x;\n        }\n        if x > largest {\n            largest = x;\n      \
    \  }\n    }\n    (Some(largest), Some(smallest))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(7), Some(1))`,\n right: `(None, Some(1))`', /tmp/tmpgkridvc4.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl61p6j73.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl61p6j73.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl61p6j73.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl61p6j73.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl61p6j73.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl61p6j73.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprw3t1u3n.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprw3t1u3n.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprw3t1u3n.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprw3t1u3n.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprw3t1u3n.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprw3t1u3n.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmhmz1c79.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmhmz1c79.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmhmz1c79.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmhmz1c79.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmhmz1c79.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmhmz1c79.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpo0zas102.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78_y1a66.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp78_y1a66.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78_y1a66.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp78_y1a66.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78_y1a66.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp78_y1a66.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ed3vza6.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3ed3vza6.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ed3vza6.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ed3vza6.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ed3vza6.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3ed3vza6.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \            min_val = Some(min_val.unwrap());\n        } else if v > 0 {\n  \
    \          max_val = Some(max_val.unwrap());\n            min_val = Some(min_val.unwrap());\n\
    \        } else {\n            max_val = Some(max_val.unwrap());\n           \
    \ min_val = Some(min_val.unwrap());\n        }\n    }\n    (max_val, min_val)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpu0ilnqz_.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp9abv_65b.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qlkwqwo.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1qlkwqwo.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1qlkwqwo.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1qlkwqwo.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1qlkwqwo.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1qlkwqwo.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        } else {\n   \
    \         continue;\n        }\n    }\n    (max_val, min_val)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpzh4s8wvy.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps9gmb3ft.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps9gmb3ft.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9gmb3ft.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps9gmb3ft.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9gmb3ft.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps9gmb3ft.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                largest\
    \ = Some(x);\n            }\n        } else {\n            if largest == None\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  if x > largest {\n                    largest = Some(x);\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqlcp1mxu.rs:23:24\n   |\n\
    23 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp554c2j66.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp554c2j66.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp554c2j66.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp554c2j66.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp554c2j66.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp554c2j66.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpi4l7pbx_.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyog0lq4w.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyog0lq4w.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyog0lq4w.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyog0lq4w.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyog0lq4w.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyog0lq4w.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps64a8sft.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps64a8sft.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps64a8sft.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps64a8sft.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps64a8sft.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps64a8sft.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \            min_val = Some(min_val.unwrap());\n        } else if v > 0 {\n  \
    \          max_val = Some(max_val.unwrap());\n            min_val = Some(min_val.unwrap());\n\
    \        } else {\n            max_val = Some(max_val.unwrap());\n           \
    \ min_val = Some(min_val.unwrap());\n        }\n    }\n    (max_val, min_val)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpi6wo7lih.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplt6eeteg.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplt6eeteg.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplt6eeteg.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplt6eeteg.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplt6eeteg.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplt6eeteg.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgk3gwrqj.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgk3gwrqj.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgk3gwrqj.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgk3gwrqj.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgk3gwrqj.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgk3gwrqj.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0c48qzw.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn0c48qzw.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0c48qzw.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn0c48qzw.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0c48qzw.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn0c48qzw.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphe81_b7a.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphe81_b7a.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphe81_b7a.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphe81_b7a.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphe81_b7a.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphe81_b7a.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyh67ljnq.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyh67ljnq.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyh67ljnq.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyh67ljnq.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyh67ljnq.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyh67ljnq.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgce3g4_.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprgce3g4_.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgce3g4_.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprgce3g4_.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgce3g4_.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprgce3g4_.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbn4o0q9w.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbn4o0q9w.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbn4o0q9w.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbn4o0q9w.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbn4o0q9w.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbn4o0q9w.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6r6u4nm.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn6r6u4nm.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6r6u4nm.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn6r6u4nm.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6r6u4nm.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn6r6u4nm.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe7ld_cbi.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe7ld_cbi.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7ld_cbi.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe7ld_cbi.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7ld_cbi.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe7ld_cbi.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphznw3zha.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphznw3zha.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphznw3zha.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphznw3zha.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphznw3zha.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphznw3zha.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpe0ywk05q.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmph1afiosw.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdyaxxt0.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwdyaxxt0.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwdyaxxt0.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwdyaxxt0.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwdyaxxt0.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwdyaxxt0.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8yeo4akb.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8yeo4akb.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8yeo4akb.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8yeo4akb.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8yeo4akb.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8yeo4akb.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else if x > 0 {\n            smallest = Some(x);\n        }\n    }\n  \
    \  (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpxzqmd6bo.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfrckh9m.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplfrckh9m.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfrckh9m.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplfrckh9m.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfrckh9m.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplfrckh9m.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = isize::MAX;\n    let mut largest =\
    \ isize::MIN;\n    for x in lst {\n        if x < smallest {\n            smallest\
    \ = x;\n        }\n        if x > largest {\n            largest = x;\n      \
    \  }\n    }\n    (Some(largest), Some(smallest))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(7), Some(1))`,\n right: `(None, Some(1))`', /tmp/tmp37zc5jo7.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5y0msoys.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5y0msoys.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5y0msoys.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5y0msoys.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5y0msoys.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5y0msoys.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpprswtihc.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpprswtihc.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpprswtihc.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpprswtihc.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpprswtihc.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpprswtihc.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmptjcpcwsf.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else if x > 0 {\n            smallest = Some(x);\n        }\n    }\n  \
    \  (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpq7rly8td.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2c3k9rw.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb2c3k9rw.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2c3k9rw.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb2c3k9rw.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2c3k9rw.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb2c3k9rw.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r49k_7c.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_r49k_7c.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_r49k_7c.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_r49k_7c.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_r49k_7c.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_r49k_7c.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_hn9enl.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph_hn9enl.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph_hn9enl.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph_hn9enl.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph_hn9enl.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph_hn9enl.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = lst.iter().max().unwrap();\n    let\
    \ mut min_val = lst.iter().min().unwrap();\n    (max_val, min_val)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe6wzkd_c.rs:12:6\n   |\n\
    12 |     (max_val, min_val)\n   |      ^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe6wzkd_c.rs:12:15\n\
    \   |\n12 |     (max_val, min_val)\n   |               ^^^^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n         \
    \  found reference `&isize`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcosfqdm4.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcosfqdm4.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcosfqdm4.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcosfqdm4.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcosfqdm4.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcosfqdm4.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else {\n            min_val = Some(x);\n        }\n    }\n    (max_val,\
    \ min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1p6gkcok.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                largest\
    \ = Some(x);\n            }\n        } else {\n            if largest == None\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  if x > largest {\n                    largest = Some(x);\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0iln_3y.rs:23:24\n   |\n\
    23 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq052ebr1.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq052ebr1.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq052ebr1.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq052ebr1.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq052ebr1.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq052ebr1.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2hhzb63.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw2hhzb63.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2hhzb63.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw2hhzb63.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2hhzb63.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw2hhzb63.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x > max_val {\n            max_val = Some(x);\n\
    \        } else if x < min_val {\n            min_val = Some(x);\n        }\n\
    \    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxst3e0qg.rs:13:16\n   |\n\
    13 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxst3e0qg.rs:15:23\n\
    \   |\n15 |         } else if x < min_val {\n   |                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<{integer}>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1boj7j2x.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1boj7j2x.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1boj7j2x.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1boj7j2x.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1boj7j2x.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1boj7j2x.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                smallest\
    \ = Some(std::cmp::min(smallest, x));\n            }\n        } else {\n     \
    \       if largest == None {\n                largest = Some(x);\n           \
    \ } else {\n                largest = Some(std::cmp::max(largest, x));\n     \
    \       }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphqve_jvx.rs:17:47\n   |\n\
    17 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphqve_jvx.rs:23:46\n   |\n23 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_ybex3a.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_ybex3a.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0_ybex3a.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_ybex3a.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0_ybex3a.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0_ybex3a.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = Some(std::i32::MAX);\n    let mut max_val\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < min_val.unwrap()\
    \ {\n            min_val = Some(x);\n        }\n        if x > max_val.unwrap()\
    \ {\n            max_val = Some(x);\n        }\n    }\n    (min_val, max_val)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9gr6az5i.rs:13:16\n   |\n\
    13 |         if x < min_val.unwrap() {\n   |                ^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n13 |         if x < min_val.unwrap().try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9gr6az5i.rs:14:28\n   |\n14 |             min_val\
    \ = Some(x);\n   |                            ^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n14 |             min_val = Some(x.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9gr6az5i.rs:16:16\n   |\n16 |         if x > max_val.unwrap()\
    \ {\n   |                ^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x > max_val.unwrap().try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9gr6az5i.rs:17:28\n   |\n17 |             max_val\
    \ = Some(x);\n   |                            ^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n17 |             max_val = Some(x.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9gr6az5i.rs:20:6\n   |\n20 |     (min_val, max_val)\n \
    \  |      ^^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Option<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9gr6az5i.rs:20:15\n   |\n20 |     (min_val, max_val)\n\
    \   |               ^^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<i32>`\n\nerror: aborting\
    \ due to 6 previous errors"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp11o3h8bb.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp11o3h8bb.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11o3h8bb.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp11o3h8bb.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11o3h8bb.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp11o3h8bb.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp7297h3sq.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                smallest\
    \ = Some(std::cmp::min(smallest, x));\n            }\n        } else {\n     \
    \       if largest == None {\n                largest = Some(x);\n           \
    \ } else {\n                largest = Some(std::cmp::max(largest, x));\n     \
    \       }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwyiglbm.rs:17:47\n   |\n\
    17 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptwyiglbm.rs:23:46\n   |\n23 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \        } else {\n            min_val = Some(min_val.unwrap());\n        }\n\
    \    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp_kevc39a.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo9o7r822.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo9o7r822.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo9o7r822.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo9o7r822.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo9o7r822.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo9o7r822.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp3j5r72nx.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n    let mut largest\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < smallest {\n    \
    \        smallest = Some(x);\n        }\n        if x > largest {\n          \
    \  largest = Some(x);\n        }\n    }\n    (smallest, largest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:13:16\n   |\n\
    13 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:14:29\n\
    \   |\n14 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n14 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:16:16\n   |\n16 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:17:28\n\
    \   |\n17 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:20:6\n   |\n20 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw6ojzfxx.rs:20:16\n   |\n20 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpru994o4z.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpru994o4z.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpru994o4z.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpru994o4z.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpru994o4z.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpru994o4z.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n    let mut largest\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < smallest {\n    \
    \        smallest = Some(x);\n        }\n        if x > largest {\n          \
    \  largest = Some(x);\n        }\n    }\n    (smallest, largest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:13:16\n   |\n\
    13 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:14:29\n\
    \   |\n14 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n14 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:16:16\n   |\n16 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:17:28\n\
    \   |\n17 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:20:6\n   |\n20 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3e_25j29.rs:20:16\n   |\n20 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpqkiw7zh4.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for v in lst {\n        if v < min_val {\n            min_val = v;\n    \
    \    }\n        if v > max_val {\n            max_val = v;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax46cb0_.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpax46cb0_.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpax46cb0_.rs:16:16\n   |\n16 |\
    \         if v > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpax46cb0_.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpax46cb0_.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpax46cb0_.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplwthll6r.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwthll6r.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwthll6r.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplwthll6r.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwthll6r.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplwthll6r.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9tggx7x.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc9tggx7x.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9tggx7x.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc9tggx7x.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9tggx7x.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc9tggx7x.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8dlxdu22.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8dlxdu22.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8dlxdu22.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8dlxdu22.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8dlxdu22.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8dlxdu22.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5zqhd_zz.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5zqhd_zz.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zqhd_zz.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5zqhd_zz.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zqhd_zz.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5zqhd_zz.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsf7n7ten.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsf7n7ten.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsf7n7ten.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsf7n7ten.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsf7n7ten.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsf7n7ten.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp97_q67ga.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(std::cmp::max(v,\
    \ max_val));\n        } else {\n            min_val = Some(std::cmp::min(v, min_val));\n\
    \        }\n    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0u4vq54i.rs:14:45\n   |\n\
    14 |             max_val = Some(std::cmp::max(v, max_val));\n   |            \
    \                                 ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0u4vq54i.rs:16:45\n   |\n16 |\
    \             min_val = Some(std::cmp::min(v, min_val));\n   |               \
    \                              ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00scazps.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp00scazps.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp00scazps.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp00scazps.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp00scazps.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp00scazps.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp702_gegy.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwlefni0k.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwlefni0k.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlefni0k.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwlefni0k.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlefni0k.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwlefni0k.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuziq_jse.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuziq_jse.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuziq_jse.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuziq_jse.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuziq_jse.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuziq_jse.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_ef4bt4.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc_ef4bt4.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_ef4bt4.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc_ef4bt4.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_ef4bt4.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc_ef4bt4.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpk4wceyq9.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \            min_val = Some(min_val.unwrap());\n        } else if v > 0 {\n  \
    \          max_val = Some(max_val.unwrap());\n        } else {\n            min_val\
    \ = Some(min_val.unwrap());\n        }\n    }\n    (max_val, min_val)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpnabmw7yz.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        }\n    }\n   \
    \ (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp2gtnuhgj.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg24o6g9_.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg24o6g9_.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg24o6g9_.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg24o6g9_.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg24o6g9_.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg24o6g9_.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpul6prpg2.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpul6prpg2.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpul6prpg2.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpul6prpg2.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpul6prpg2.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpul6prpg2.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprai5jifx.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprai5jifx.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprai5jifx.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprai5jifx.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprai5jifx.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprai5jifx.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1enn8gzr.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8mcy75wl.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8mcy75wl.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mcy75wl.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8mcy75wl.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mcy75wl.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8mcy75wl.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpauml6sab.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpauml6sab.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauml6sab.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpauml6sab.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauml6sab.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpauml6sab.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpkia1zffk.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpge6wtll3.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpge6wtll3.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpge6wtll3.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpge6wtll3.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpge6wtll3.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpge6wtll3.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2nh9is5.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj2nh9is5.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2nh9is5.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2nh9is5.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2nh9is5.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj2nh9is5.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqob5o2ym.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqob5o2ym.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqob5o2ym.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqob5o2ym.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqob5o2ym.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqob5o2ym.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0sccl__7.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0sccl__7.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccl__7.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0sccl__7.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccl__7.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0sccl__7.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        } else {\n   \
    \         continue;\n        }\n    }\n    (max_val, min_val)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpwtbaq0ma.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \            min_val = Some(min_val.unwrap());\n        } else if v > 0 {\n  \
    \          max_val = Some(max_val.unwrap());\n        } else {\n            min_val\
    \ = Some(min_val.unwrap());\n        }\n    }\n    (max_val, min_val)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpvw8ea86q.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                largest\
    \ = Some(x);\n            }\n        } else {\n            if largest == None\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  if x > largest {\n                    largest = Some(x);\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9vkx5pv6.rs:23:24\n   |\n\
    23 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfjnsbjyn.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjnsbjyn.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjnsbjyn.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfjnsbjyn.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjnsbjyn.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfjnsbjyn.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x > max_val {\n            max_val = Some(x);\n\
    \        } else if x < min_val {\n            min_val = Some(x);\n        }\n\
    \    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnnjolery.rs:13:16\n   |\n\
    13 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnnjolery.rs:15:23\n\
    \   |\n15 |         } else if x < min_val {\n   |                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<{integer}>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = lst.iter().max().unwrap();\n    let\
    \ mut min_val = lst.iter().min().unwrap();\n    if max_val < min_val {\n     \
    \   (None, Some(min_val))\n    } else {\n        (Some(max_val), None)\n    }\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqy7hr_j.rs:13:21\n   |\n\
    13 |         (None, Some(min_val))\n   |                     ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    13 |         (None, Some(*min_val))\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsqy7hr_j.rs:15:15\n   |\n15 |         (Some(max_val),\
    \ None)\n   |               ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |         (Some(*max_val), None)\n\
    \   |               +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else {\n            min_val = Some(x);\n        }\n    }\n    (max_val,\
    \ min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpdokb20lc.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbly7msyf.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbly7msyf.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbly7msyf.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbly7msyf.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbly7msyf.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbly7msyf.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfoz6m33.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptfoz6m33.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptfoz6m33.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptfoz6m33.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptfoz6m33.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptfoz6m33.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw9ysqz_5.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw9ysqz_5.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9ysqz_5.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw9ysqz_5.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9ysqz_5.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9ysqz_5.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n    let mut largest\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < smallest {\n    \
    \        smallest = Some(x);\n        }\n        if x > largest {\n          \
    \  largest = Some(x);\n        }\n    }\n    (smallest, largest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:13:16\n   |\n\
    13 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:14:29\n\
    \   |\n14 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n14 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:16:16\n   |\n16 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:17:28\n\
    \   |\n17 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:20:6\n   |\n20 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwalk0dmr.rs:20:16\n   |\n20 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpc9jp__ej.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3s33ils.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_3s33ils.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3s33ils.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_3s33ils.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3s33ils.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_3s33ils.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n    let mut largest\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < 0 {\n           \
    \ smallest = Some(x);\n        } else if x > 0 {\n            largest = Some(x);\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbnqpnr8n.rs:14:29\n   |\n\
    14 |             smallest = Some(x);\n   |                             ^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n14 |             smallest =\
    \ Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbnqpnr8n.rs:16:28\n   |\n16 |\
    \             largest = Some(x);\n   |                            ^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n16 |             largest = Some(x.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbnqpnr8n.rs:19:6\n   |\n19 |     (smallest, largest)\n\
    \   |      ^^^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Option<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbnqpnr8n.rs:19:16\n   |\n19 |     (smallest, largest)\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<i32>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpps4i8pm_.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpps4i8pm_.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpps4i8pm_.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpps4i8pm_.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpps4i8pm_.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpps4i8pm_.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbhicuq80.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbhicuq80.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhicuq80.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbhicuq80.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhicuq80.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbhicuq80.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0gm_heyn.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0gm_heyn.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gm_heyn.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0gm_heyn.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gm_heyn.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0gm_heyn.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qx_mimw.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1qx_mimw.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qx_mimw.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1qx_mimw.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qx_mimw.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1qx_mimw.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ul9mn5g.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7ul9mn5g.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7ul9mn5g.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7ul9mn5g.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7ul9mn5g.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7ul9mn5g.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8zqwvdt.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo8zqwvdt.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo8zqwvdt.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo8zqwvdt.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo8zqwvdt.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo8zqwvdt.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp2dd2nb6c.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprvsucvhw.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprvsucvhw.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprvsucvhw.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprvsucvhw.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprvsucvhw.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprvsucvhw.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0v9580pi.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0v9580pi.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0v9580pi.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0v9580pi.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0v9580pi.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0v9580pi.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(max_negative.max());\n            }\n        } else\
    \ {\n            if min_positive.is_none() {\n                min_positive = Some(x);\n\
    \            } else {\n                min_positive = Some(min_positive.min());\n\
    \            }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp36ejp_pe.rs:17:50\n    |\n17  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp36ejp_pe.rs:17:37\n   |\n17 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmp36ejp_pe.rs:23:50\n\
    \    |\n23  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36ejp_pe.rs:23:37\n\
    \   |\n23 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzzk358p.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdzzk358p.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzzk358p.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzzk358p.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzzk358p.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdzzk358p.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                smallest\
    \ = Some(std::cmp::min(smallest, x));\n            }\n        } else {\n     \
    \       if largest == None {\n                largest = Some(x);\n           \
    \ } else {\n                largest = Some(std::cmp::max(largest, x));\n     \
    \       }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_ti89jp.rs:17:47\n   |\n\
    17 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd_ti89jp.rs:23:46\n   |\n23 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3jtc8kx.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd3jtc8kx.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3jtc8kx.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd3jtc8kx.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3jtc8kx.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd3jtc8kx.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6dma8v16.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6dma8v16.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6dma8v16.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6dma8v16.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6dma8v16.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6dma8v16.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n        } else {\n            smallest = Some(std::cmp::min(smallest,\
    \ Some(x)));\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n  \
    \  let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmf7kwtap.rs:14:42\n   |\n\
    14 |             largest = Some(std::cmp::max(largest, Some(x)));\n   |      \
    \                                    ^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmf7kwtap.rs:14:51\n   |\n14 |\
    \             largest = Some(std::cmp::max(largest, Some(x)));\n   |         \
    \                                          ^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf7kwtap.rs:16:43\n\
    \   |\n16 |             smallest = Some(std::cmp::min(smallest, Some(x)));\n \
    \  |                                           ^^^^^^^^ expected integer, found\
    \ enum `Option`\n   |\n   = note: expected type `{integer}`\n              found\
    \ enum `Option<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf7kwtap.rs:16:53\n\
    \   |\n16 |             smallest = Some(std::cmp::min(smallest, Some(x)));\n \
    \  |                                                     ^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1vvadry1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n    let mut largest\
    \ = Some(std::i32::MIN);\n    for x in lst {\n        if x < smallest {\n    \
    \        smallest = Some(x);\n        }\n        if x > largest {\n          \
    \  largest = Some(x);\n        }\n    }\n    (smallest, largest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:13:16\n   |\n\
    13 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:14:29\n\
    \   |\n14 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n14 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:16:16\n   |\n16 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:17:28\n\
    \   |\n17 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:20:6\n   |\n20 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp56c2bhdm.rs:20:16\n   |\n20 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp6xvjakqm.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpow6bvb10.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpow6bvb10.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpow6bvb10.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpow6bvb10.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpow6bvb10.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpow6bvb10.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpurxt0ie6.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpurxt0ie6.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpurxt0ie6.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpurxt0ie6.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpurxt0ie6.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpurxt0ie6.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0y8sb6jw.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0y8sb6jw.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y8sb6jw.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0y8sb6jw.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y8sb6jw.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0y8sb6jw.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2tlze2g.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi2tlze2g.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2tlze2g.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi2tlze2g.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2tlze2g.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi2tlze2g.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptrq47uat.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptrq47uat.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrq47uat.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptrq47uat.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrq47uat.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptrq47uat.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7nmxqd7x.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7nmxqd7x.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7nmxqd7x.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7nmxqd7x.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7nmxqd7x.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7nmxqd7x.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmphp97gew9.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnz7s_cko.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnz7s_cko.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnz7s_cko.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnz7s_cko.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnz7s_cko.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnz7s_cko.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtkk8bsu.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvtkk8bsu.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtkk8bsu.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvtkk8bsu.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtkk8bsu.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvtkk8bsu.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3an7nf9r.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3an7nf9r.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3an7nf9r.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3an7nf9r.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3an7nf9r.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3an7nf9r.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4k1nxph.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy4k1nxph.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4k1nxph.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy4k1nxph.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4k1nxph.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy4k1nxph.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                smallest\
    \ = Some(std::cmp::min(smallest, x));\n            }\n        } else {\n     \
    \       if largest == None {\n                largest = Some(x);\n           \
    \ } else {\n                largest = Some(std::cmp::max(largest, x));\n     \
    \       }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv7p4xcvm.rs:17:47\n   |\n\
    17 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv7p4xcvm.rs:23:46\n   |\n23 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0vjlh7sj.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0vjlh7sj.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0vjlh7sj.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0vjlh7sj.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0vjlh7sj.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0vjlh7sj.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(v);\n    \
    \    } else if v > 0 {\n            min_val = Some(v);\n        }\n    }\n   \
    \ (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp_xmrdbl1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for v in lst {\n        if v < 0 {\n            max_val = Some(std::cmp::max(v,\
    \ max_val));\n        } else {\n            min_val = Some(std::cmp::min(v, min_val));\n\
    \        }\n    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8blfl5f.rs:14:45\n   |\n\
    14 |             max_val = Some(std::cmp::max(v, max_val));\n   |            \
    \                                 ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf8blfl5f.rs:16:45\n   |\n16 |\
    \             min_val = Some(std::cmp::min(v, min_val));\n   |               \
    \                              ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpim77dw5h.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_oy9mnk3.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_oy9mnk3.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_oy9mnk3.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_oy9mnk3.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_oy9mnk3.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_oy9mnk3.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                largest\
    \ = Some(x);\n            }\n        } else {\n            if largest == None\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  if x > largest {\n                    largest = Some(x);\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzx58gkdu.rs:23:24\n   |\n\
    23 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        } else {\n   \
    \         continue;\n        }\n    }\n    (max_val, min_val)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpzcfamd27.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd23nikvv.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd23nikvv.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd23nikvv.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd23nikvv.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd23nikvv.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd23nikvv.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else {\n            min_val = Some(x);\n        }\n    }\n    (max_val,\
    \ min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp4m51q59e.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                smallest\
    \ = Some(std::cmp::min(smallest, x));\n            }\n        } else {\n     \
    \       if largest == None {\n                largest = Some(x);\n           \
    \ } else {\n                largest = Some(std::cmp::max(largest, x));\n     \
    \       }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmu_p4d5x.rs:17:47\n   |\n\
    17 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmu_p4d5x.rs:23:46\n   |\n23 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4eb051fk.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4eb051fk.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4eb051fk.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4eb051fk.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4eb051fk.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4eb051fk.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp3pthrh8w.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo84f4eyy.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo84f4eyy.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo84f4eyy.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo84f4eyy.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo84f4eyy.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo84f4eyy.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = std::i32::MAX;\n    let mut min_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpab6qchl2.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpab6qchl2.rs:14:23\n   |\n11 |     let mut min_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab6qchl2.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpab6qchl2.rs:17:23\n   |\n10 |     let mut max_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab6qchl2.rs:20:11\n\
    \   |\n20 |     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpab6qchl2.rs:20:26\n   |\n20 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps3estfjp.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps3estfjp.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps3estfjp.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps3estfjp.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps3estfjp.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps3estfjp.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnr577f2g.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnr577f2g.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnr577f2g.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnr577f2g.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnr577f2g.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnr577f2g.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbm0oigt.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkbm0oigt.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbm0oigt.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkbm0oigt.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbm0oigt.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbm0oigt.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6evf_z34.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6evf_z34.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6evf_z34.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6evf_z34.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6evf_z34.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6evf_z34.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(0);\n    let mut largest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            smallest = Some(std::cmp::min(smallest,\
    \ x));\n        } else {\n            largest = Some(std::cmp::max(largest, x));\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkhhx8wqc.rs:14:43\n   |\n\
    14 |             smallest = Some(std::cmp::min(smallest, x));\n   |          \
    \                                 ^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkhhx8wqc.rs:16:42\n   |\n16 |\
    \             largest = Some(std::cmp::max(largest, x));\n   |               \
    \                           ^^^^^^^ expected integer, found enum `Option`\n  \
    \ |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13m5s_i8.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp13m5s_i8.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13m5s_i8.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp13m5s_i8.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13m5s_i8.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp13m5s_i8.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpzeb84y5j.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9w92r4f0.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9w92r4f0.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9w92r4f0.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9w92r4f0.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9w92r4f0.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9w92r4f0.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjndgkg0m.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjndgkg0m.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjndgkg0m.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjndgkg0m.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjndgkg0m.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjndgkg0m.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut smallest = Some(0);\n    let mut largest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            smallest = Some(std::cmp::min(smallest,\
    \ x));\n        } else {\n            largest = Some(std::cmp::max(largest, x));\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpryj76yv3.rs:14:43\n   |\n\
    14 |             smallest = Some(std::cmp::min(smallest, x));\n   |          \
    \                                 ^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpryj76yv3.rs:16:42\n   |\n16 |\
    \             largest = Some(std::cmp::max(largest, x));\n   |               \
    \                           ^^^^^^^ expected integer, found enum `Option`\n  \
    \ |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp03pz_bai.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1psezm49.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1psezm49.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1psezm49.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1psezm49.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1psezm49.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1psezm49.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for elt in lst {\n        if elt < min_val {\n            min_val = elt;\n\
    \        }\n        if elt > max_val {\n            max_val = elt;\n        }\n\
    \    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbx1iic8m.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbx1iic8m.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = elt;\n   |                       ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbx1iic8m.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbx1iic8m.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = elt;\n   |                       ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbx1iic8m.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbx1iic8m.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previ"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp67dmoh6f.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp67dmoh6f.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp67dmoh6f.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp67dmoh6f.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp67dmoh6f.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp67dmoh6f.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf7xg7nvd.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf7xg7nvd.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf7xg7nvd.rs:16:16\n   |\n16 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf7xg7nvd.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf7xg7nvd.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7xg7nvd.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        }\n    }\n   \
    \ (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpac6te6k2.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf4a9cf7.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzf4a9cf7.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf4a9cf7.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzf4a9cf7.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf4a9cf7.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzf4a9cf7.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp108mnvk5.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp108mnvk5.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp108mnvk5.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp108mnvk5.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp108mnvk5.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp108mnvk5.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxn2g_2zj.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxn2g_2zj.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn2g_2zj.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxn2g_2zj.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn2g_2zj.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxn2g_2zj.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(max_val.unwrap());\n\
    \        } else {\n            min_val = Some(min_val.unwrap());\n        }\n\
    \    }\n    (max_val, min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpiptzrmjt.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpque2yv1d.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpque2yv1d.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpque2yv1d.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpque2yv1d.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpque2yv1d.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpque2yv1d.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\
    \    for i in lst {\n        if i < min_val {\n            min_val = i;\n    \
    \    }\n        if i > max_val {\n            max_val = i;\n        }\n    }\n\
    \    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tb23e3z.rs:13:16\n   |\n\
    13 |         if i < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if i < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tb23e3z.rs:14:23\n   |\n10 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n14 |   \
    \          min_val = i;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7tb23e3z.rs:16:16\n   |\n16 |\
    \         if i > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if i > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tb23e3z.rs:17:23\n   |\n11 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          max_val = i;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7tb23e3z.rs:20:11\n   |\n20 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7tb23e3z.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else if x > 0 {\n            min_val = Some(x);\n        } else {\n   \
    \         continue;\n        }\n    }\n    (max_val, min_val)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpt9ojgnba.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for v in lst {\n        if v < min_val {\n           \
    \ min_val = v;\n        }\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf7fh3rlb.rs:13:16\n   |\n\
    13 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf7fh3rlb.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf7fh3rlb.rs:16:16\n\
    \   |\n16 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf7fh3rlb.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf7fh3rlb.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7fh3rlb.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = Some(0);\n    let mut smallest = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else {\n            smallest = Some(x);\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpny43cnrw.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_negative = None;\n    let mut min_positive\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            } else {\n         \
    \       max_negative = Some(std::cmp::max(max_negative.unwrap(), x));\n      \
    \      }\n        } else {\n            if min_positive.is_none() {\n        \
    \        min_positive = Some(x);\n            } else {\n                min_positive\
    \ = Some(std::cmp::min(min_positive.unwrap(), x));\n            }\n        }\n\
    \    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmppa1ucs7l.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            max_val = Some(x);\n    \
    \    } else {\n            min_val = Some(x);\n        }\n    }\n    (max_val,\
    \ min_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp2dxfd7ca.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw75f806q.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw75f806q.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw75f806q.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw75f806q.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw75f806q.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw75f806q.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            largest = Some(x);\n    \
    \    } else if x > 0 {\n            smallest = Some(x);\n        }\n    }\n  \
    \  (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpxfa6u_hr.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_sfqgx2.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8_sfqgx2.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_sfqgx2.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8_sfqgx2.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_sfqgx2.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8_sfqgx2.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for x in lst {\n        if x < min_val {\n           \
    \ min_val = x;\n        }\n        if x > max_val {\n            max_val = x;\n\
    \        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp71trachq.rs:13:16\n   |\n\
    13 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp71trachq.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp71trachq.rs:16:16\n\
    \   |\n16 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp71trachq.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp71trachq.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp71trachq.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n    for elt in lst {\n        if elt < min_val {\n       \
    \     min_val = elt;\n        }\n        if elt > max_val {\n            max_val\
    \ = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbgj96xo.rs:13:18\n   |\n\
    13 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkbgj96xo.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbgj96xo.rs:16:18\n\
    \   |\n16 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkbgj96xo.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbgj96xo.rs:20:11\n\
    \   |\n20 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbgj96xo.rs:20:26\n   |\n20 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
    \ 1)\n/// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
    \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
    \ Option<isize>) {\n    let mut min_val = Some(0);\n    let mut max_val = Some(0);\n\
    \    for x in lst {\n        if x < 0 {\n            min_val = Some(x);\n    \
    \    } else {\n            max_val = Some(x);\n        }\n    }\n    (min_val,\
    \ max_val)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp79gm2dvh.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
