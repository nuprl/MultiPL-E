name: HumanEval_98_count_upper
language: rust
results:
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpp8l_gri_.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpp8l_gri_.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_r54lw8r.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmp8honsgwt.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8honsgwt.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmp5lwgj10a.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp5lwgj10a.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq2cm01ob.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk_jrjfio.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpakhz4zvi.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut count = 0;\n    for &c in s.chars() {\n        if c.is_uppercase()\
    \ {\n            count += 1;\n            if c.is_even() {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr0c1gwj7.rs:8:9\n  |\n8 |\
    \     for &c in s.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp096qgmug.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp096qgmug.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp096qgmug.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp096qgmug.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl64sicn8.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmponss2zdm.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfk1cznw7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfk1cznw7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpfk1cznw7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpfk1cznw7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve0rdic7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpve0rdic7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpve0rdic7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpve0rdic7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdrncph9v.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc3my9fl_.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcyiu6s7p.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqyqy2t5i.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpvtlx0m9v.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpvtlx0m9v.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg3g5py81.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgu8yhxlj.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyvork2tz.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmp3ddti3o6.rs:7:57\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3ddti3o6.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6mk_k_c9.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpywkfifuj.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmphu9ci5b1.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmphu9ci5b1.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsmudl00f.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpsmudl00f.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpsmudl00f.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpsmudl00f.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptdeef0f4.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmptdeef0f4.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmptdeef0f4.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmptdeef0f4.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjjdz677n.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcuvtcump.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpcuvtcump.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpcuvtcump.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpcuvtcump.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwm0_0aq7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpwm0_0aq7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpwm0_0aq7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpwm0_0aq7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj4zeek9z.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpj4zeek9z.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpj4zeek9z.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpj4zeek9z.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv28m1axl.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr0cgy5vu.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpr0cgy5vu.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpr0cgy5vu.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpr0cgy5vu.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg1fn71yu.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpg1fn71yu.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpg1fn71yu.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpg1fn71yu.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbm35o9ma.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpbm35o9ma.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpbm35o9ma.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpbm35o9ma.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmprhnn3dzm.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprhnn3dzm.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm3ml3r3d.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpm3ml3r3d.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpm3ml3r3d.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpm3ml3r3d.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpklt29czr.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpklt29czr.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpklt29czr.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpklt29czr.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp1lk94zhb.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1lk94zhb.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == 'A' || s[i]\
    \ == 'a' {\n            i += 1;\n        } else if s[i] == 'B' || s[i] == 'b'\
    \ {\n            i += 1;\n        } else if s[i] == 'C' || s[i] == 'c' {\n   \
    \         i += 1;\n        } else if s[i] == 'D' || s[i] == 'd' {\n          \
    \  i += 1;\n        } else if s[i] == 'E' || s[i] == 'e' {\n            i += 1;\n\
    \        } else if s[i] == 'F' || s[i] == 'f' {\n            i += 1;\n       \
    \ } else if s[i] == 'G' || s[i] == 'g' {\n            i += 1;\n        } else\
    \ if s[i] == 'H' || s[i] == 'h' {\n            i += 1;\n        } else if s[i]\
    \ == 'I' || s[i] == 'i' {\n            i += 1;\n        } else if s[i] == 'J'\
    \ || s[i] == 'j' {\n            i += 1;\n        } else if s[i] == 'K' || s[i]\
    \ == 'k' {\n            i += 1;\n        } else if s[i] == 'L' || s[i] == 'l'\
    \ {\n            i += 1;\n        } else if s[i] == 'M' || s[i] == 'm' {\n   \
    \         i += 1;\n        } else if s[i] == 'N' || s[i] == 'n' {\n          \
    \  i += 1;\n        } else if s[i] == 'O' || s[i] == 'o' {\n            i += 1;\n\
    \        } else if s[i] == 'P' || s[i] == 'p' {\n            i += 1;\n       \
    \ } else if s[i] == 'Q' || s[i] == 'q' {\n            i += 1;\n        } else\
    \ if s[i] == 'R' || s[i] == 'r' {\n            i += 1;\n        } else if s[i]\
    \ == 'S' || s[i] == 's' {\n            i += 1;\n        } else if s[i] == 'T'\
    \ || s[i] == 't' {\n            i += 1;\n        } else if s[i] == 'U' || s[i]\
    \ == 'u' {\n            i += 1;\n        } else if s[i] == 'V' || s[i] == 'v'\
    \ {\n            i += 1;\n        } else if s[i] == 'W' || s[i] == 'w' {\n   \
    \         i += 1;\n        } else if s[i] == 'X' || s[i] == 'x' {\n          \
    \  i += 1;\n        } else if s[i] == 'Y' || s[i] == 'y' {\n            i += 1;\n\
    \        } else if s[i] == 'Z' || s[i] == 'z' {\n            i += 1;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n \
    \   let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp3xpmppze.rs:9:12\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp3xpmppze.rs:9:27\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |                       \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3xpmppze.rs:11:19\n\
    \   |\n11 |         } else if s[i] == 'B' || s[i] == 'b' {\n   |             \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv__l8c27.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpv__l8c27.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpv__l8c27.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv__l8c27.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmggzpcd1.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv754tr4g.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmprqe2x89q.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprqe2x89q.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf5sxgh11.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw4_qcw2e.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnu4na122.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1riy60du.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpl_wmd3no.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 ==\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpl_wmd3no.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo2dliset.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpo2dliset.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpo2dliset.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo2dliset.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2ed__j6n.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2ed__j6n.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp2ed__j6n.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2ed__j6n.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp44x97nu2.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp44x97nu2.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp44x97nu2.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp44x97nu2.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdcx0az5p.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv_bik8u5.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpyznfm7km.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpyznfm7km.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpirgww609.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdlejh_rb.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqqumfyq3.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdtwuxlct.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphrlxxhfz.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz7_ya76g.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpz7_ya76g.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpz7_ya76g.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz7_ya76g.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpljeai75s.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1tkpyd06.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnh_44tus.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfw5t1epx.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmp0yk2byau.rs:7:57\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp0yk2byau.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmptt3h1cdg.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmptt3h1cdg.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpydijaayy.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxl3c0m60.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxl3c0m60.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpxl3c0m60.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxl3c0m60.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpe61a1s5l.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpe61a1s5l.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqyvbqt1_.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp57w1o3u_.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp29xfw6mn.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp29xfw6mn.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp29xfw6mn.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp29xfw6mn.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq48pnva7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpq48pnva7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpq48pnva7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq48pnva7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == 'A' || s[i]\
    \ == 'a' {\n            i += 1;\n        } else if s[i] == 'B' || s[i] == 'b'\
    \ {\n            i += 1;\n        } else if s[i] == 'C' || s[i] == 'c' {\n   \
    \         i += 1;\n        } else if s[i] == 'D' || s[i] == 'd' {\n          \
    \  i += 1;\n        } else if s[i] == 'E' || s[i] == 'e' {\n            i += 1;\n\
    \        } else if s[i] == 'F' || s[i] == 'f' {\n            i += 1;\n       \
    \ } else if s[i] == 'G' || s[i] == 'g' {\n            i += 1;\n        } else\
    \ if s[i] == 'H' || s[i] == 'h' {\n            i += 1;\n        } else if s[i]\
    \ == 'I' || s[i] == 'i' {\n            i += 1;\n        } else if s[i] == 'J'\
    \ || s[i] == 'j' {\n            i += 1;\n        } else if s[i] == 'K' || s[i]\
    \ == 'k' {\n            i += 1;\n        } else if s[i] == 'L' || s[i] == 'l'\
    \ {\n            i += 1;\n        } else if s[i] == 'M' || s[i] == 'm' {\n   \
    \         i += 1;\n        } else if s[i] == 'N' || s[i] == 'n' {\n          \
    \  i += 1;\n        } else if s[i] == 'O' || s[i] == 'o' {\n            i += 1;\n\
    \        } else if s[i] == 'P' || s[i] == 'p' {\n            i += 1;\n       \
    \ } else if s[i] == 'Q' || s[i] == 'q' {\n            i += 1;\n        } else\
    \ if s[i] == 'R' || s[i] == 'r' {\n            i += 1;\n        } else if s[i]\
    \ == 'S' || s[i] == 's' {\n            i += 1;\n        } else if s[i] == 'T'\
    \ || s[i] == 't' {\n            i += 1;\n        } else if s[i] == 'U' || s[i]\
    \ == 'u' {\n            i += 1;\n        } else if s[i] == 'V' || s[i] == 'v'\
    \ {\n            i += 1;\n        } else if s[i] == 'W' || s[i] == 'w' {\n   \
    \         i += 1;\n        } else if s[i] == 'X' || s[i] == 'x' {\n          \
    \  i += 1;\n        } else if s[i] == 'Y' || s[i] == 'y' {\n            i += 1;\n\
    \        } else if s[i] == 'Z' || s[i] == 'z' {\n            i += 1;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n \
    \   let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpjwbaaln8.rs:9:12\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpjwbaaln8.rs:9:27\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |                       \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjwbaaln8.rs:11:19\n\
    \   |\n11 |         } else if s[i] == 'B' || s[i] == 'b' {\n   |             \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp822v4w65.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmp07b3bbbn.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp07b3bbbn.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut count = 0;\n    for &c in s.chars() {\n        if c.is_upper()\
    \ {\n            count += 1;\n        }\n        if c.is_lower() {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq7rm5tt9.rs:8:9\n  |\n8 |\
    \     for &c in s.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpszh12yck.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpszh12yck.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpszh12yck.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpszh12yck.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxiptkh15.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxiptkh15.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpxiptkh15.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxiptkh15.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpik9gz0b_.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu6tkp1z8.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqdkpxulf.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpd3gnim5s.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpd3gnim5s.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph_3g1r_i.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmph_3g1r_i.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmph_3g1r_i.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmph_3g1r_i.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm__ykeo6.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpm__ykeo6.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpm__ykeo6.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpm__ykeo6.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0gryb__p.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps5qij26q.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmps5qij26q.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmps5qij26q.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmps5qij26q.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdq6w37wb.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmpzo0m4q2z.rs:7:57\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpzo0m4q2z.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnm6e7j2v.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpnm6e7j2v.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpnm6e7j2v.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpnm6e7j2v.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprbjo35pu.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8bpwf_uj.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8bpwf_uj.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp8bpwf_uj.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp8bpwf_uj.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpic6gzztg.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo9t17eir.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp1kzktlsv.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1kzktlsv.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7cxi1non.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyl6tli8k.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpyl6tli8k.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpyl6tli8k.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpyl6tli8k.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3tka2js2.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1aazcu7m.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqnvfwrxv.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqnvfwrxv.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpqnvfwrxv.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpqnvfwrxv.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk3jrt4p7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpk3jrt4p7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpk3jrt4p7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpk3jrt4p7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpe0i4hu8h.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpe0i4hu8h.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkfb4k75v.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmppzqegsab.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmppzqegsab.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpvlub6rbu.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpvlub6rbu.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqgabva05.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqgabva05.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpqgabva05.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpqgabva05.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpl6ly9faz.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpl6ly9faz.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmjg46jcg.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpextw5enl.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpextw5enl.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpextw5enl.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpextw5enl.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    let mut count = 0;\n    while i < s.len() {\n   \
    \     if s[i..].chars().any(|c| c.is_uppercase()) {\n            i += 1;\n   \
    \     } else {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgmhnocm_.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpgmhnocm_.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpgmhnocm_.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgmhnocm_.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpax4o9qbv.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1wz1o9lt.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpemzagkl8.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpemzagkl8.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpemzagkl8.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpemzagkl8.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzi7plh9r.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzi7plh9r.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpzi7plh9r.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpzi7plh9r.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\
    \ / s.len()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgn93jukl.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count() / s.len()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     (s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count() / s.len()).try_into().unwrap()\n\
    \  |     +                                                                   \
    \              +++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzqf6v_ks.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzqf6v_ks.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpzqf6v_ks.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpzqf6v_ks.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == 'A' || s[i]\
    \ == 'a' {\n            i += 1;\n        } else if s[i] == 'B' || s[i] == 'b'\
    \ {\n            i += 1;\n        } else if s[i] == 'C' || s[i] == 'c' {\n   \
    \         i += 1;\n        } else if s[i] == 'D' || s[i] == 'd' {\n          \
    \  i += 1;\n        } else if s[i] == 'E' || s[i] == 'e' {\n            i += 1;\n\
    \        } else if s[i] == 'F' || s[i] == 'f' {\n            i += 1;\n       \
    \ } else if s[i] == 'G' || s[i] == 'g' {\n            i += 1;\n        } else\
    \ if s[i] == 'H' || s[i] == 'h' {\n            i += 1;\n        } else if s[i]\
    \ == 'I' || s[i] == 'i' {\n            i += 1;\n        } else if s[i] == 'J'\
    \ || s[i] == 'j' {\n            i += 1;\n        } else if s[i] == 'K' || s[i]\
    \ == 'k' {\n            i += 1;\n        } else if s[i] == 'L' || s[i] == 'l'\
    \ {\n            i += 1;\n        } else if s[i] == 'M' || s[i] == 'm' {\n   \
    \         i += 1;\n        } else if s[i] == 'N' || s[i] == 'n' {\n          \
    \  i += 1;\n        } else if s[i] == 'O' || s[i] == 'o' {\n            i += 1;\n\
    \        } else if s[i] == 'P' || s[i] == 'p' {\n            i += 1;\n       \
    \ } else if s[i] == 'Q' || s[i] == 'q' {\n            i += 1;\n        } else\
    \ if s[i] == 'R' || s[i] == 'r' {\n            i += 1;\n        } else if s[i]\
    \ == 'S' || s[i] == 's' {\n            i += 1;\n        } else if s[i] == 'T'\
    \ || s[i] == 't' {\n            i += 1;\n        } else if s[i] == 'U' || s[i]\
    \ == 'u' {\n            i += 1;\n        } else if s[i] == 'V' || s[i] == 'v'\
    \ {\n            i += 1;\n        } else if s[i] == 'W' || s[i] == 'w' {\n   \
    \         i += 1;\n        } else if s[i] == 'X' || s[i] == 'x' {\n          \
    \  i += 1;\n        } else if s[i] == 'Y' || s[i] == 'y' {\n            i += 1;\n\
    \        } else if s[i] == 'Z' || s[i] == 'z' {\n            i += 1;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n \
    \   let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpxwhz3gij.rs:9:12\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpxwhz3gij.rs:9:27\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'a' {\n  |                       \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwhz3gij.rs:11:19\n\
    \   |\n11 |         } else if s[i] == 'B' || s[i] == 'b' {\n   |             \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpig_4yonb.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpig_4yonb.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpig_4yonb.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpig_4yonb.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsydrxj24.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprm80gfmu.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmphw_naycj.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmphw_naycj.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb0dx9vy1.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpb0dx9vy1.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpb0dx9vy1.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpb0dx9vy1.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpucs23fod.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpucs23fod.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnschi3mg.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpnschi3mg.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpnschi3mg.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpnschi3mg.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuwblcyzb.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpuwblcyzb.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpuwblcyzb.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpuwblcyzb.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpemive8ur.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpemive8ur.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpemive8ur.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpemive8ur.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp34c4tpcz.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp34c4tpcz.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp34c4tpcz.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp34c4tpcz.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1snpc1qt.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplsiv7yjv.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbyb1t7l5.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpirqmmbyt.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpywhdvwgx.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpay1edpva.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpay1edpva.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpay1edpva.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpay1edpva.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpfx93u6gz.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpfx93u6gz.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmpmqgv0b1p.rs:7:57\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpmqgv0b1p.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnlfzwgq7.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpnlfzwgq7.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpnlfzwgq7.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpnlfzwgq7.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp07pymcae.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3x1z7u1d.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp449pftd2.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp449pftd2.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp449pftd2.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp449pftd2.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn5gskbbf.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpn5gskbbf.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpn5gskbbf.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpn5gskbbf.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp93qkg1se.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp93qkg1se.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp93qkg1se.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp93qkg1se.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsyxwgw56.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpzwcqjind.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpzwcqjind.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpmpasltak.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 ==\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpmpasltak.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5tx9ncon.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv1p6c3m0.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx5r_q7ta.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpx5r_q7ta.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpx5r_q7ta.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpx5r_q7ta.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2uudz2ql.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2uudz2ql.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp2uudz2ql.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2uudz2ql.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2p1z8qrd.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2p1z8qrd.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp2p1z8qrd.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2p1z8qrd.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgihixqb2.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpgihixqb2.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpgihixqb2.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgihixqb2.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpimmyazgb.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz6fs8eb2.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpz6fs8eb2.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpz6fs8eb2.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz6fs8eb2.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph9tvih52.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr3yioyi2.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpavryegbl.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaiccgnjp.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9u9zjsm4.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps_8y0zo1.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7tejad6f.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7tejad6f.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp7tejad6f.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp7tejad6f.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyamb1v4t.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxyzgju47.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4uxbcgy8.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpycvo3jji.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpycvo3jji.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpycvo3jji.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpycvo3jji.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7iuyttso.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7iuyttso.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp7iuyttso.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp7iuyttso.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvdjhav93.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvdjhav93.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpvdjhav93.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpvdjhav93.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmp9yn42_nk.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp9yn42_nk.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpvvln9h6v.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpvvln9h6v.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\
    \ % 2 == 0\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppz7w2sna.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count() % 2 == 0\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpok_7dmwj.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpok_7dmwj.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppmrw9atb.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8r4255ob.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8r4255ob.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp8r4255ob.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp8r4255ob.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx2q7mq0n.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps5126bqf.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmrl8pyxq.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpmrl8pyxq.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpmrl8pyxq.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpmrl8pyxq.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjfohphqr.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpztr_ijc0.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4ommrc89.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp4ommrc89.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp4ommrc89.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp4ommrc89.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxmy7oe53.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpytnxifze.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpytnxifze.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpif20j131.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpif20j131.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpif20j131.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpif20j131.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkdrag_5l.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7ulm4mrz.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpk41boc23.rs:7:57\n\
    \  |\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpk41boc23.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpivl3_a2h.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpivl3_a2h.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpivl3_a2h.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpivl3_a2h.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbva2s82j.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr1c03r67.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9xjvvp3l.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpne3bm7u1.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpne3bm7u1.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpne3bm7u1.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpne3bm7u1.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut count = 0;\n    for i in 0..s.len() {\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp9k2yc8s7.rs:9:12\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |            ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp9k2yc8s7.rs:9:27\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |                           ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp9k2yc8s7.rs:9:42\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwf2av2i7.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == 'A' || s[i]\
    \ == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            i += 1;\n\
    \        } else {\n            i += 2;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpoz0qcet7.rs:9:12\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |            ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmpoz0qcet7.rs:9:27\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |                           ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpoz0qcet7.rs:9:42\n\
    \  |\n9 |         if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n  |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n --> /tmp/tmpkxrifky5.rs:7:64\n\
    \  |\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 !=\
    \ 0).count()\n  |                                                            \
    \ -- ^ - {integer}\n  |                                                      \
    \       |\n  |                                                             char\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpkxrifky5.rs:7:5\n  |\n6 | fn count_upper(s:\
    \ String) -> isize {\n  |                              ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 != 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \  |                                                                         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3xnikmyy.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp3xnikmyy.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp3xnikmyy.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3xnikmyy.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvseo5gay.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvseo5gay.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpvseo5gay.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpvseo5gay.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0x91ix21.rs:7:31\n  |\n7 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp0x91ix21.rs:7:43\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp0x91ix21.rs:7:61\n\
    \  |\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp0x91ix21.rs:7:5\n  |\n6 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n7 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |                                                                          \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoy99mlzl.rs:7:5\n  |\n6 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n7 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut n = 0;\n    for &c in s.chars() {\n        if c.is_uppercase()\
    \ {\n            if c.is_even() {\n                n += 1;\n            }\n  \
    \      }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_upper;\n \
    \   assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb5uwvhxh.rs:8:9\n  |\n8 |\
    \     for &c in s.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// count_upper('aBCdEf') returns 1\n/// count_upper('abcdefg')\
    \ returns 0\n/// count_upper('dBBE') returns 0\nfn count_upper(s: String) -> isize\
    \ {\n    let mut i = 0;\n    let mut upper = 0;\n    while i < s.len() {\n   \
    \     if s[i].is_uppercase() {\n            i += 1;\n        } else {\n      \
    \      i += 2;\n        }\n        upper += 1;\n    }\n    upper\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1kp9e3zv.rs:10:12\n\
    \   |\n10 |         if s[i].is_uppercase() {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
