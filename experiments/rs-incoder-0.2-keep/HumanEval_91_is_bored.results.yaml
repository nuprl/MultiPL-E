name: HumanEval_91_is_bored
language: rust
results:
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpb_83ufvk.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpqwxumej8.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpqwxumej8.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpw1gh0c9q.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpw1gh0c9q.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpco554lyg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut boredom_counter = 0;\n    let mut boredom_words\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::new();\n    let mut boredom_word = Vec::new();\n    let mut boredom_sentences\
    \ = Vec::new();\n    let mut boredom_sentence = Vec::new();\n    let mut boredom_word\
    \ = Vec::new();\n    let mut boredom_sentences = Vec::new();\n    let mut boredom_sentence\
    \ = Vec::\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpcrsm068d.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_word_count: Vec<usize> = vec![];\n    let mut boredom_word_length:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count: Vec<usize> = vec![];\n\
    \    let mut boredom_word_length_total: Vec<usize> = vec![];\n    let mut boredom_word_length_total_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum: Vec<usize>\
    \ = vec![];\n    let mut boredom_word_length_total_sum_count: Vec<usize> = vec![];\n\
    \    let mut boredom_word_length_total_sum_sum: Vec<usize> = vec![];\n    let\
    \ mut boredom_word_length_total_sum_sum_count: Vec<usize> = vec![];\n    let mut\
    \ boredom_word_length_total_sum_sum_sum: Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `(`, `+`, `,`, `::`, `:`, `<`, `=`, or `>`,\
    \ found `}`\n  --> /tmp/tmpg8_r815i.rs:33:1\n   |\n32 |     let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize\n   |         -------------------------------------------------------------------\
    \           - expected one of 9 possible tokens\n   |         |\n   |        \
    \ while parsing the type for `mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count`\n\
    33 | }\n   | ^ unexpected token\n   |\nhelp: you might have meant to end the type\
    \ parameters here\n   |\n32 |     let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize>\n   |                                                           \
    \                            +\nhelp: use `=` if you meant to assign\n   |\n32\
    \ |     let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count\
    \ = Vec<usize\n   |                                                          \
    \                   ~\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpg8_r815i.rs:32:87\n\
    \   |\n32 |     let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize\n   |                                                            \
    \                           ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmpg8_r815i.rs:32:78\n\
    \    |\n32  |       let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize\n    |                                                           \
    \                     ^^^ help: use struct literal syntax instead: `Vec { buf:\
    \ val, len: val }`\n\nerror[E0423]: expected value, found builtin type `usize`\n\
    \  --> /tmp/tmpg8_r815i.rs:32:82\n   |\n32 |     let mut boredom_word_length_total_sum_sum_sum_sum_sum_sum_sum_sum_count:\
    \ Vec<usize\n   |                                                            \
    \                      ^^^^^ not a value\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpg8_r815i.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n  |  \
    \  --------               ^^^^^ expe"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp24agi_y9.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpy9wykcdo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    let mut i = 0;\n\
    \    while i < words.len() {\n        if words[i] == \"I\" {\n            i +=\
    \ 1;\n            bored += 1;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp3_58lpxr.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp3_58lpxr.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmptvbuv9wy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzy1bl8lh.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzy1bl8lh.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzy1bl8lh.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut boredom_counter = 0;\n    let mut boredom_counter2\
    \ = 0;\n    let mut boredom_counter3 = 0;\n    let mut boredom_counter4 = 0;\n\
    \    let mut boredom_counter5 = 0;\n    let mut boredom_counter6 = 0;\n    let\
    \ mut boredom_counter7 = 0;\n    let mut boredom_counter8 = 0;\n    let mut boredom_counter9\
    \ = 0;\n    let mut boredom_counter10 = 0;\n    let mut boredom_counter11 = 0;\n\
    \    let mut boredom_counter12 = 0;\n    let mut boredom_counter13 = 0;\n    let\
    \ mut boredom_counter14 = 0;\n    let mut boredom_counter15 = 0;\n    let mut\
    \ boredom_counter16 = 0;\n    let mut boredom_counter17 = 0;\n    let mut boredom_counter18\
    \ = 0;\n    let mut boredom_counter19 = 0;\n    let mut boredom_counter20 = 0;\n\
    \    let mut boredom_counter21 = 0;\n    let mut boredom_counter22 = 0;\n    let\
    \ mut boredom_counter23 = 0;\n    let mut boredom_counter24 = 0;\n    let mut\
    \ boredom_counter25 = 0;\n    let mut boredom_counter26 = 0;\n    let mut boredom_counter27\
    \ = 0;\n    let mut boredom_counter28 = 0;\n    let mut boredom_counter29 = 0;\n\
    \    let mut boredom_counter30 = 0;\n    let mut boredom_counter31 = 0;\n    let\
    \ mut boredom_counter32 = 0;\n    let mut boredom_counter33 = 0;\n    let mut\
    \ boredom_counter34 = 0;\n    let mut boredom_counter35 = 0;\n    let mut boredom_counter36\
    \ = 0;\n    let mut boredom_counter37 = 0;\n    let mut boredom_counter38 = 0;\n\
    \    let mut boredom_counter39 = 0;\n    let mut boredom_counter40 = 0;\n    let\
    \ mut boredom_counter41 = 0;\n    let mut boredom_counter42 = 0;\n    let mut\
    \ boredom_counter43 = 0;\n    let mut boredom_counter44 = 0;\n    let mut boredom_counter45\
    \ = 0;\n    let mut boredom_counter46 = 0;\n    let mut boredom_counter47 = 0;\n\
    \    let mut boredom_counter48 = 0;\n    let mut boredom_counter49 = 0;\n    let\
    \ mut boredom_counter50 = 0;\n    let mut bore\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpimx8ujlx.rs:61:17\n   |\n\
    61 |     let mut bore\n   |                 ^ help: add `;` here\n62 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpimx8ujlx.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp1v4xbm_m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpojzviela.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmptnemlqaa.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut boredom_counter = 0;\n    let mut boredom_words\
    \ = vec![];\n    let mut boredom_word_counter = 0;\n    let mut boredom_sentences\
    \ = vec![];\n    let mut boredom_sentence_counter = 0;\n    let mut boredom_sentence\
    \ = String::new();\n    let mut boredom_sentence_words = vec![];\n    let mut\
    \ boredom_sentence_word_counter = 0;\n    let mut boredom_sentence_boredoms =\
    \ vec![];\n    let mut boredom_sentence_boredom_counter = 0;\n    let mut boredom_sentence_boredom_words\
    \ = vec![];\n    let mut boredom_sentence_boredom_word_counter = 0;\n    let mut\
    \ boredom_sentence_boredom_boredoms = vec![];\n    let mut boredom_sentence_boredom_boredom_counter\
    \ = 0;\n    let mut boredom_sentence_boredom_boredom_words = vec![];\n    let\
    \ mut boredom_sentence_boredom_boredom_word_counter = 0;\n    let mut boredom_sentence_boredom_boredom_boredoms\
    \ = vec![];\n    let mut boredom_sentence_boredom_boredom_boredom_counter = 0;\n\
    \    let mut boredom_sentence_boredom_boredom_boredom_words = vec![];\n    let\
    \ mut boredom_sentence_boredom_boredom_boredom_word_counter = 0;\n    let mut\
    \ boredom_sentence_boredom_boredom_boredom_boredoms = vec![];\n    let mut boredom_sentence_boredom_boredom_boredom_boredom_counter\
    \ = 0;\n    let mut boredom_sentence_boredom_boredom_boredom_boredom_words = vec![];\n\
    \    let mut boredom_sentence_boredom_boredom_boredom_boredom_word_counter = 0;\n\
    \    let mut boredom_sentence_boredom_boredom_boredom_boredom_boredoms = vec![];\n\
    \    let mut boredom_sentence_boredom_boredom_boredom_boredom_boredom_counter\
    \ = 0;\n    let mut boredom_sentence_boredom_boredom_boredom_boredom_boredom_words\
    \ = vec![];\n    let mut boredom_sentence_boredom_boredom_boredom_boredom_boredom_word_counter\
    \ = 0;\n    let mut boredom_sentence_bo\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdxnm0q7o.rs:39:32\n   |\n\
    39 |     let mut boredom_sentence_bo\n   |                                ^ help:\
    \ add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpdxnm0q7o.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n \
    \ |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        let c = s[i];\n        if c == '.' || c == '?'\
    \ || c == '!' {\n            i += 1;\n        } else {\n            if c == 'I'\
    \ {\n                i += 1;\n                boredoms += 1;\n            }\n\
    \            i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplu08ua2g.rs:14:17\n\
    \   |\n14 |         let c = s[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp_q8sugtx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    while !s.is_empty()\
    \ {\n        let mut i = s.find('i');\n        if i == s.len() {\n           \
    \ break;\n        }\n        if s.starts_with(\"I\") {\n            boredoms +=\
    \ 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp42wyqajk.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp42wyqajk.rs:20:14\n\
    \   |\n20 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp42wyqajk.rs:20:13\n\
    \   |\n11 |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n20 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n20 -         s = &s[i..];\n20 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp64ckhg03.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp64ckhg03.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppgatb1we.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppgatb1we.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjobyzh0i.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp8rl16dd8.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp8rl16dd8.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp8rl16dd8.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i + 1]);\n            i += 2;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpxeda1wpl.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpxeda1wpl.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpxeda1wpl.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxeda1wpl.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut sentence: Vec<&str> = vec![];\n    let mut sentence_words: Vec<&str> = vec![];\n\
    \    let mut sentence_length: usize = 0;\n    let mut sentence_length2: usize\
    \ = 0;\n    let mut sentence_length3: usize = 0;\n    let mut sentence_length4:\
    \ usize = 0;\n    let mut sentence_length5: usize = 0;\n    let mut sentence_length6:\
    \ usize = 0;\n    let mut sentence_length7: usize = 0;\n    let mut sentence_length8:\
    \ usize = 0;\n    let mut sentence_length9: usize = 0;\n    let mut sentence_length10:\
    \ usize = 0;\n    let mut sentence_length11: usize = 0;\n    let mut sentence_length12:\
    \ usize = 0;\n    let mut sentence_length13: usize = 0;\n    let mut sentence_length14:\
    \ usize = 0;\n    let mut sentence_length15: usize = 0;\n    let mut sentence_length16:\
    \ usize = 0;\n    let mut sentence_length17: usize = 0;\n    let mut sentence_length18:\
    \ usize = 0;\n    let mut sentence_length19: usize = 0;\n    let mut sentence_length20:\
    \ usize = 0;\n    let mut sentence_length21: usize = 0;\n    let mut sentence_length22:\
    \ usize = 0;\n    let mut sentence_length23: usize = 0;\n    let mut sentence_length24:\
    \ usize = 0;\n    let mut sentence_length25: usize = 0;\n    let mut sentence_length26:\
    \ usize = 0;\n    let mut sentence_length27: usize = 0;\n    let mut sentence_length28:\
    \ usize = 0;\n    let mut sentence_length29: usize = 0;\n    let mut sentence_length30:\
    \ usize = 0;\n    let mut sentence_length31: usize = 0;\n    let mut sentence_length32:\
    \ usize = 0;\n    let mut sentence_length33: usize = 0;\n    let mut sentence_length34:\
    \ usize = 0;\n    let mut sentence_length35: usize = 0;\n    let mut sentence_length36:\
    \ usize = 0;\n    let mut sentence_length37: usize = 0;\n    let mut sentence_length38:\
    \ usize = 0;\n    let mut sentence_length39: usize = 0;\n    let mut sentence_length40:\
    \ usize = 0;\n    let mut sentence_length41: usize = 0;\n    let mut sentence_length42\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu1ad79pk.rs:55:30\n   |\n\
    55 |     let mut sentence_length42\n   |                              ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpu1ad79pk.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n \
    \ |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&s| s.len()\
    \ > 1).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpyoj2wrdt.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpyoj2wrdt.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpyoj2wrdt.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpsmci97u3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_word_index: usize\
    \ = 0;\n    let mut boredom_sentence_index: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_sentence_length: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_sentence_start_index: usize = 0;\n    let mut\
    \ boredom_word_end_index: usize = 0;\n    let mut boredom_sentence_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_char: usize = 0;\n    let mut boredom_sentence_start_char:\
    \ usize = 0;\n    let mut boredom_word_end_char: usize = 0;\n    let mut boredom_sentence_end_char:\
    \ usize = 0;\n    let mut boredom_word_start_char_index: usize = 0;\n    let mut\
    \ boredom_sentence_start_char_index: usize = 0;\n    let mut boredom_word_end_char_index:\
    \ usize = 0;\n    let mut boredom_sentence_end_char_index: usize = 0;\n    let\
    \ mut boredom_word_start_char_index: usize = 0;\n    let mut boredom_sentence_start_char_index:\
    \ usize = 0;\n    let mut boredom_word_end_char_index: usize = 0;\n    let mut\
    \ boredom_sentence_end_char_index: usize = 0;\n    let mut boredom_word_start_char_index:\
    \ usize = 0;\n    let mut boredom_sentence_start_char_index: usize = 0;\n    let\
    \ mut boredom_word_end_char_index: usize = 0;\n    let mut boredom_sentence_end_char_index:\
    \ usize = 0;\n    let mut boredom_word_start_char_index: usize = 0;\n    let mut\
    \ boredom_sentence_start_char_index: usize = 0;\n    let mut boredom_word_end_char_index:\
    \ usize = 0;\n    let mut boredom_sentence_end_char_index: usize = 0;\n    let\
    \ mut boredom_word_start_char_index: usize = 0;\n    let mut boredom_sentence_start_char_index:\
    \ usize = 0;\n    let mut boredom_word_end_char_index: usize = 0;\n    let mut\
    \ boredom_sentence_end_char_index: usize = 0;\n    let mut boredom_\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxzvsztqq.rs:45:21\n   |\n\
    45 |     let mut boredom_\n   |                     ^ help: add `;` here\n46 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxzvsztqq.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4ww15tau.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = Vec::new();\n \
    \   let mut sentence: Vec<&str> = Vec::new();\n    let mut sentence_words: Vec<&str>\
    \ = Vec::new();\n    let mut sentence_length: usize = 0;\n    let mut sentence_length2:\
    \ usize = 0;\n    let mut sentence_length3: usize = 0;\n    let mut sentence_length4:\
    \ usize = 0;\n    let mut sentence_length5: usize = 0;\n    let mut sentence_length6:\
    \ usize = 0;\n    let mut sentence_length7: usize = 0;\n    let mut sentence_length8:\
    \ usize = 0;\n    let mut sentence_length9: usize = 0;\n    let mut sentence_length10:\
    \ usize = 0;\n    let mut sentence_length11: usize = 0;\n    let mut sentence_length12:\
    \ usize = 0;\n    let mut sentence_length13: usize = 0;\n    let mut sentence_length14:\
    \ usize = 0;\n    let mut sentence_length15: usize = 0;\n    let mut sentence_length16:\
    \ usize = 0;\n    let mut sentence_length17: usize = 0;\n    let mut sentence_length18:\
    \ usize = 0;\n    let mut sentence_length19: usize = 0;\n    let mut sentence_length20:\
    \ usize = 0;\n    let mut sentence_length21: usize = 0;\n    let mut sentence_length22:\
    \ usize = 0;\n    let mut sentence_length23: usize = 0;\n    let mut sentence_length24:\
    \ usize = 0;\n    let mut sentence_length25: usize = 0;\n    let mut sentence_length26:\
    \ usize = 0;\n    let mut sentence_length27: usize = 0;\n    let mut sentence_length28:\
    \ usize = 0;\n    let mut sentence_length29: usize = 0;\n    let mut sentence_length30:\
    \ usize = 0;\n    let mut sentence_length31: usize = 0;\n    let mut sentence_length32:\
    \ usize = 0;\n    let mut sentence_length33: usize = 0;\n    let mut sentence_length34:\
    \ usize = 0;\n    let mut sentence_length35: usize = 0;\n    let mut sentence_length36:\
    \ usize = 0;\n    let mut sentence_length37: usize = 0;\n    let mut sentence_length38:\
    \ usize = 0;\n    let mut sentence_length39: usize = 0;\n    let mut sentence_length40:\
    \ usize = 0;\n    let mut sentence_length41: usize = 0;\n    let mut \n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmphduo3175.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmphwrn18wq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut bored_chars = S.chars();\n    let mut bored_chars_iter\
    \ = bored_chars.iter();\n    let mut bored_chars_next = bored_chars_iter.next();\n\
    \    while let Some(bored_char) = bored_chars_next {\n        if bored_char ==\
    \ ' ' || bored_char == '.' || bored_char == '?' || bored_char == '!' {\n     \
    \       bored += 1;\n        }\n        bored_chars_next = bored_chars_iter.next();\n\
    \    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpwqrnyhbd.rs:12:44\n   |\n12 |     let mut bored_chars_iter\
    \ = bored_chars.iter();\n   |                                            ^^^^\
    \ private field, not a method\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpum8fahwg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmps9z_wb_h.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms.push(words[i]);\n            i += 1;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpze3zlib8.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpze3zlib8.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpze3zlib8.rs:15:27\n   |\n15 |             boredoms.push(words[i]);\n\
    \   |                           ^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpze3zlib8.rs:21:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    let mut i = 0;\n\
    \    while i < words.len() {\n        if words[i] == \"I\" {\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n            bored += 1;\n       \
    \ }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpvz3qp9zh.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpvz3qp9zh.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpn6ud4z1_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxeob1__d.rs:17:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n17 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut boredom_count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredom_count += 1;\n \
    \       }\n        if word.ends_with(\".\") || word.ends_with(\"?\") || word.ends_with(\"\
    !\") {\n            boredoms.push(word);\n        }\n    }\n    boredom_count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmptpzz0fp5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ mut j = i;\n        while j < S.len() {\n            if S[j] == S[i] {\n   \
    \             boredoms.push(S[j..]);\n                break;\n            }\n\
    \            j += 1\n        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&s|\
    \ s.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoo8pbkzq.rs:15:16\n\
    \   |\n15 |             if S[j] == S[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoo8pbkzq.rs:15:24\n   |\n15 |             if S[j] == S[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpoo8pbkzq.rs:16:31\n    |\n16  |                 boredoms.push(S[j..]);\n\
    \    |                          ---- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                          |\n    |                          required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpoo8pbkzq.rs:10:24\n    |\n10  |     let mut boredoms =\
    \ vec![];\n    |                        ^^^^^^ doesn't have a size known "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_sentence_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_word_is_boredom: usize = 0;\n    let mut boredom_word_is_boredom_word:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence: usize = 0;\n    let\
    \ mut boredom_word_is_boredom_sentence_index: usize = 0;\n    let mut boredom_word_is_boredom_sentence_length:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom: usize =\
    \ 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_word: usize = 0;\n\
    \    let mut boredom_word_is_boredom_sentence_is_boredom_sentence: usize = 0;\n\
    \    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_index: usize\
    \ = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_length:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_word:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence_index:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence_length:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence_is_boredom:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence_is_boredom_word:\
    \ usize = 0;\n    let mut boredom_word_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence_is_boredom_sentence:\
    \ usize = 0;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo_czn503.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpva1qfox4.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmplkyc_n20.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpbm_36f_z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i]\
    \ == 'i' {\n            i += 1;\n            continue;\n        }\n        if\
    \ sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n         \
    \   i += 1;\n            continue;\n        }\n        boredoms += 1;\n      \
    \  i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0tcdz7g0.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp0tcdz7g0.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp0tcdz7g0.rs:18:12\n   |\n18 |    \
    \     if sentence[i] == 'i' {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp0tcdz7g0.rs:22:12\n\
    \   |\n22 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmp0tcdz7g0.rs:22:34\n   |\n22 | \
    \        if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n\
    \   |                                  ^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp0tcdz7g0.rs:22:56\n\
    \   |\n22 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |                                                        ^^^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5qizu923.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp5qizu923.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpu0_5miy3.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpu0_5miy3.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(1);\n        } else {\n            boredoms.push(0);\n\
    \        }\n    }\n    boredoms.iter().sum()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpus3o_zc0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for s in sentence {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8yrfaa2c.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            boredoms += 1;\n        }\n    \
    \    i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuokikguv.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuokikguv.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuokikguv.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_08ijqd0.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_08ijqd0.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vgw1ylq.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpoqqgb4qg.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpoqqgb4qg.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpfkmhnn11.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpeorwlwxd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo4uec6_w.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphshecidv.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmphshecidv.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for word in sentence {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ofirrbg.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut boredom_counter = 0;\n    let mut boredom_words\
    \ = vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredom_counter = boredom_counter + 1;\n            boredoms.push(boredom_counter);\n\
    \            boredom_counter = 0;\n            boredom_words.push(word);\n   \
    \     } else {\n            boredom_counter = boredom_counter + 1;\n         \
    \   boredom_words.push(word);\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj8p6tyuq.rs:24:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n24 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n24 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr1qv0xuc.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr1qv0xuc.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr1qv0xuc.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp7o_bnb_7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp46da1k91.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp46da1k91.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ j = i;\n        while j < S.len() && S[j] != '.' && S[j] != '?' && S[j] != '!'\
    \ {\n            j += 1\n        }\n        boredoms.push(S.split_whitespace()[j].to_string());\n\
    \        i = j + 1\n    }\n    boredoms.iter().filter(|x| x.starts_with(\"I\"\
    )).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjnmg8c0n.rs:14:30\n\
    \   |\n14 |         while j < S.len() && S[j] != '.' && S[j] != '?' && S[j] !=\
    \ '!' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjnmg8c0n.rs:14:45\n   |\n14 |         while j < S.len() && S[j]\
    \ != '.' && S[j] != '?' && S[j] != '!' {\n   |                               \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjnmg8c0n.rs:14:60\n   |\n14 |         while j < S.len() && S[j]\
    \ != '.' && S[j] != '?' && S[j] != '!' {\n   |                               \
    \                             ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n         "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(1);\n        } else {\n            boredoms.push(0);\n\
    \        }\n    }\n    boredoms.iter().sum()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpqv514swp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<String> = S.split_whitespace();\n\
    \    for s in sentence {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqp3am7po.rs:11:37\n   |\n\
    11 |     let mut sentence: Vec<String> = S.split_whitespace();\n   |         \
    \              -----------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `SplitWhitespace`\n   |                       |\n   |               \
    \        expected due to this\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    let mut i = 0;\n\
    \    while i < words.len() {\n        if words[i] == \"I\" {\n            i +=\
    \ 1;\n            bored += 1;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpn9221n2e.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpn9221n2e.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    for\
    \ word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n     \
    \       boredoms += 1;\n            boredom_words.push(word);\n        }\n   \
    \ }\n    boredoms += boredom_words.iter().filter(|w| w.starts_with(\"I\")).count();\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf16bta3r.rs:18:17\n   |\n\
    18 |     boredoms += boredom_words.iter().filter(|w| w.starts_with(\"I\")).count();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to\
    \ `isize`\n  --> /tmp/tmpf16bta3r.rs:18:14\n   |\n18 |     boredoms += boredom_words.iter().filter(|w|\
    \ w.starts_with(\"I\")).count();\n   |              ^^ no implementation for `isize\
    \ += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpw67c16nj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_word_len: usize = 0;\n    let mut boredom_word_start: usize = 0;\n\
    \    let mut boredom_word_end: usize = 0;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_word_found = false;\n\
    \    let mut boredom_word_found = false;\n    let mut boredom_\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsregir11.rs:59:21\n   |\n\
    59 |     let mut boredom_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsregir11.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmps2fj3e89.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut bored_words: Vec<&str> = vec![];\n    let mut bored_sentences:\
    \ Vec<&str> = vec![];\n    let mut bored_sentences_words: Vec<&str> = vec![];\n\
    \    let mut bored_sentences_words_count: Vec<usize> = vec![];\n    let mut bored_sentences_words_count_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored: Vec<usize>\
    \ = vec![];\n    let mut bored_sentences_words_count_not_bored_bored: Vec<usize>\
    \ = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored: Vec<usize>\
    \ = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored_bored:\
    \ Vec<usize> = vec![];\n    let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored:\
    \ Vec<\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmpbcuy1y0v.rs:29:1\n   |\n28 |     let mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored:\
    \ Vec<\n   |         -----------------------------------------------------------------------------------------------------\
    \      - expected one of `>`, a const expression, lifetime, or type\n   |    \
    \     |\n   |         while parsing the type for `mut bored_sentences_words_count_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored_not_bored`\n\
    29 | }\n   | ^ unexpected token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppp_t0w70.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppp_t0w70.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppp_t0w70.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = Vec::new();\n \
    \   let mut boredom_sentences: Vec<&str> = Vec::new();\n    let mut boredom_sentence:\
    \ Vec<&str> = Vec::new();\n    let mut boredom_word: Vec<&str> = Vec::new();\n\
    \    let mut boredom_word_count: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_index:\
    \ Vec<usize> = Vec::new();\n    let mut boredom_word_index: Vec<usize> = Vec::new();\n\
    \    let mut boredom_word_index: Vec<usize> = Vec::new();\n    let mut boredom_word_\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8ll_qdws.rs:37:26\n   |\n\
    37 |     let mut boredom_word_\n   |                          ^ help: add `;`\
    \ here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8ll_qdws.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n  |  \
    \  --------               ^^^^^ expected `isize`, found `()`\n  |    |\n  |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp4t9_1r1_.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp4t9_1r1_.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i].as_str() == \"i\" {\n                boredoms\
    \ += 1;\n            }\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqd0l7ti5.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `is_ascii_lowercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpqd0l7ti5.rs:14:24\n\
    \   |\n14 |         if sentence[i].is_ascii_lowercase() {\n   |              \
    \          ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `as_str` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpqd0l7ti5.rs:15:28\n   |\n\
    15 |             if sentence[i].as_str() == \"i\" {\n   |                    \
    \       -^^^^^^-- help: remove this method call\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    loop {\n\
    \        let mut word = words.next().unwrap();\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        if !words.next().unwrap().is_empty()\
    \ {\n            break;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpubpp4d72.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsbveuicx.rs:13:12\n\
    \   |\n13 |         if S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsbveuicx.rs:13:27\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsbveuicx.rs:13:42\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                                          ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpne4xhfi1.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp30imlxex.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp30imlxex.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp30imlxex.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp11_x5yy2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpa4nzq_bg.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut boredom_count = 0;\n    let mut boredom_word\
    \ = \"\";\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredom_count += 1;\n            boredom_word = word;\n  \
    \      } else {\n            boredoms.push(boredom_word);\n            boredom_count\
    \ = 0;\n            boredom_word = word;\n        }\n    }\n    boredoms.push(boredom_word);\n\
    \    boredoms.iter().filter(|&b| b.starts_with(\"I\")).count()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0v8qqe3.rs:24:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n24 |     boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n24 |     boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count().try_into().unwrap()\n   |                    \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            boredoms += 1;\n        }\n    \
    \    i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1m15tuk8.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1m15tuk8.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1m15tuk8.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ mut j = i;\n        while j < S.len() {\n            if S[j] == S[i] {\n   \
    \             boredoms.push(S[j..]);\n                j = j + 1;\n           \
    \ } else {\n                break;\n            }\n        }\n        i = i +\
    \ 1;\n    }\n    boredoms.iter().filter(|s| s.starts_with(\"I\")).count()\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaxldtnph.rs:15:16\n\
    \   |\n15 |             if S[j] == S[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpaxldtnph.rs:15:24\n   |\n15 |             if S[j] == S[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpaxldtnph.rs:16:31\n    |\n16  |                 boredoms.push(S[j..]);\n\
    \    |                          ---- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                          |\n    |                          required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpaxldtnph.rs:10:24\n    |\n10  |     let mut boredoms =\
    \ vec![];\n    |                        ^^^^^^ doesn't have a size known "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<String> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj33gnm4c.rs:11:37\n   |\n\
    11 |     let mut sentence: Vec<String> = S.split_whitespace();\n   |         \
    \              -----------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `SplitWhitespace`\n   |                       |\n   |               \
    \        expected due to this\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpu061un10.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpu061un10.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    let mut i = 0;\n\
    \    while i < words.len() {\n        if words[i] == \"I\" {\n            i +=\
    \ 1;\n            bored += 1;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp08sd4ck6.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp08sd4ck6.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    loop {\n\
    \        if let Some(word) = words.next() {\n            if word == \"I\" {\n\
    \                boredoms += 1;\n            } else {\n                break;\n\
    \            }\n        } else {\n            break;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpx688pm32.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpkabl99fe.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut boredom_counter = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \            boredom_counter += 1;\n        }\n    }\n    boredom_counter\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp7_kho3wi.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    loop {\n\
    \        if words.next().unwrap().is_none() {\n            break;\n        }\n\
    \        let word = words.next().unwrap().unwrap();\n        if word == \"I\"\
    \ {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_none` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpbaiewc3j.rs:13:34\n   |\n13 |         if words.next().unwrap().is_none()\
    \ {\n   |                                  ^^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `unwrap` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpbaiewc3j.rs:16:42\n   |\n16 |         let word = words.next().unwrap().unwrap();\n\
    \   |                                          ^^^^^^ method not found in `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for word in sentence {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqzqz1gdc.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwlmsmzdy.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms += 1;\n  \
    \      }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxpl1vzh3.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxpl1vzh3.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxpl1vzh3.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index: usize = 0;\n    let mut sentence_length: usize =\
    \ 0;\n    let mut sentence_word: &str;\n    while sentence_index < sentence.len()\
    \ {\n        sentence_word = sentence[sentence_index];\n        if sentence_word\
    \ == \"I\" {\n            boredoms += 1;\n        }\n        sentence_index +=\
    \ 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5q_ygkpq.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp6gz69h42.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzgcd4ezx.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzgcd4ezx.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzgcd4ezx.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for word in sentence {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7m6uj_ij.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpizlk3lz8.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpizlk3lz8.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpizlk3lz8.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    while s.len() > 0\
    \ {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb2t4z_p2.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb2t4z_p2.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb2t4z_p2.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5wv5m2ka.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5wv5m2ka.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5wv5m2ka.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    let mut i = 0;\n\
    \    while i < words.len() {\n        if words[i] == \"I\" {\n            i +=\
    \ 1;\n            bored += 1;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpluqc57f2.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpluqc57f2.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for word in sentence {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6vnghyn.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index = 0;\n    let mut sentence_length: usize = 0;\n  \
    \  while sentence_index < sentence.len() {\n        let mut sentence_word: &str\
    \ = sentence[sentence_index];\n        if sentence_word == \"I\" {\n         \
    \   boredoms += 1;\n        }\n        sentence_index += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy05djsja.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpjyik_ec4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpvthdg7q3.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpvthdg7q3.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpvthdg7q3.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    while s.len() > 0\
    \ {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace().collect();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4hbm_4vj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpigu_ib_q.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpigu_ib_q.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpigu_ib_q.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpq4nn0qf_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpbhus_5cd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i + 1]);\n            i += 2;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppo30uou6.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppo30uou6.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmppo30uou6.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppo30uou6.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_word_index: usize\
    \ = 0;\n    let mut boredom_sentence_index: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_sentence_length: usize = 0;\n    let mut boredom_word_start:\
    \ usize = 0;\n    let mut boredom_sentence_start: usize = 0;\n    let mut boredom_word_end:\
    \ usize = 0;\n    let mut boredom_sentence_end: usize = 0;\n    let mut boredom_word_word_start:\
    \ usize = 0;\n    let mut boredom_sentence_word_start: usize = 0;\n    let mut\
    \ boredom_word_word_end: usize = 0;\n    let mut boredom_sentence_word_end: usize\
    \ = 0;\n    let mut boredom_word_word_word_start: usize = 0;\n    let mut boredom_sentence_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_end: usize = 0;\n    let mut\
    \ boredom_sentence_word_word_end: usize = 0;\n    let mut boredom_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_sentence_word_word_word_start: usize = 0;\n\
    \    let mut boredom_word_word_word_word_end: usize = 0;\n    let mut boredom_sentence_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_start: usize = 0;\n\
    \    let mut boredom_sentence_word_word_word_word_start: usize = 0;\n    let mut\
    \ boredom_word_word_word_word_word_end: usize = 0;\n    let mut boredom_sentence_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_start: usize =\
    \ 0;\n    let mut boredom_sentence_word_word_word_word_word_start: usize = 0;\n\
    \    let mut boredom_word_word_word_word_word_word_end: usize = 0;\n    let mut\
    \ boredom_sentence_word_word_word_word_word_end: usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_sentence_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_end: usize\
    \ = 0;\n    let mut boredom_sentence_word_word_word_word_word_\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgux3dybr.rs:44:55\n   |\n\
    44 |     let mut boredom_sentence_word_word_word_word_word_\n   |            \
    \                                           ^ help: add `;` here\n45 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgux3dybr.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for word in sentence {\n        if word.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbkb6f1u0.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpruesoxs6.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpruesoxs6.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpruesoxs6.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmphruftbye.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmphwsg7dtd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut boredom_counter = 0;\n    let mut boredom_counter2\
    \ = 0;\n    let mut boredom_counter3 = 0;\n    let mut boredom_counter4 = 0;\n\
    \    let mut boredom_counter5 = 0;\n    let mut boredom_counter6 = 0;\n    let\
    \ mut boredom_counter7 = 0;\n    let mut boredom_counter8 = 0;\n    let mut boredom_counter9\
    \ = 0;\n    let mut boredom_counter10 = 0;\n    let mut boredom_counter11 = 0;\n\
    \    let mut boredom_counter12 = 0;\n    let mut boredom_counter13 = 0;\n    let\
    \ mut boredom_counter14 = 0;\n    let mut boredom_counter15 = 0;\n    let mut\
    \ boredom_counter16 = 0;\n    let mut boredom_counter17 = 0;\n    let mut boredom_counter18\
    \ = 0;\n    let mut boredom_counter19 = 0;\n    let mut boredom_counter20 = 0;\n\
    \    let mut boredom_counter21 = 0;\n    let mut boredom_counter22 = 0;\n    let\
    \ mut boredom_counter23 = 0;\n    let mut boredom_counter24 = 0;\n    let mut\
    \ boredom_counter25 = 0;\n    let mut boredom_counter26 = 0;\n    let mut boredom_counter27\
    \ = 0;\n    let mut boredom_counter28 = 0;\n    let mut boredom_counter29 = 0;\n\
    \    let mut boredom_counter30 = 0;\n    let mut boredom_counter31 = 0;\n    let\
    \ mut boredom_counter32 = 0;\n    let mut boredom_counter33 = 0;\n    let mut\
    \ boredom_counter34 = 0;\n    let mut boredom_counter35 = 0;\n    let mut boredom_counter36\
    \ = 0;\n    let mut boredom_counter37 = 0;\n    let mut boredom_counter38 = 0;\n\
    \    let mut boredom_counter39 = 0;\n    let mut boredom_counter40 = 0;\n    let\
    \ mut boredom_counter41 = 0;\n    let mut boredom_counter42 = 0;\n    let mut\
    \ boredom_counter43 = 0;\n    let mut boredom_counter44 = 0;\n    let mut boredom_counter45\
    \ = 0;\n    let mut boredom_counter46 = 0;\n    let mut boredom_counter47 = 0;\n\
    \    let mut boredom_counter48 = 0;\n    let mut boredom_counter49 = 0;\n    let\
    \ mut boredom_counter50 = 0;\n    let mut bore\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6sdc9oko.rs:61:17\n   |\n\
    61 |     let mut bore\n   |                 ^ help: add `;` here\n62 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6sdc9oko.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_sentence: Vec<&str> = vec![];\n    let mut boredom_word_index: usize\
    \ = 0;\n    let mut boredom_sentence_index: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_sentence_length: usize = 0;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut boredom_sentence_found = false;\n    let mut boredom_word_found\
    \ = false;\n    let mut bo\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpusiiyo62.rs:58:15\n   |\n\
    58 |     let mut bo\n   |               ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpusiiyo62.rs:9:27\n  |\n\
    9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index: usize = 0;\n    let mut sentence_length: usize =\
    \ 0;\n    let mut sentence_word: &str;\n    let mut sentence_word_index: usize\
    \ = 0;\n    let mut sentence_word_length: usize = 0;\n    let mut sentence_word_is_bored:\
    \ &str;\n\n    while sentence_index < sentence.len() {\n        sentence_word\
    \ = &sentence[sentence_index];\n        sentence_word_index = sentence_index;\n\
    \        sentence_word_length = sentence_word.len();\n        sentence_word_is_bored\
    \ = &sentence[sentence_index];\n\n        while sentence_word_index < sentence_word_length\
    \ {\n            if sentence_word_is_bored == \"I\" {\n                boredoms\
    \ += 1;\n            }\n            sentence_word_index += 1;\n        }\n   \
    \     sentence_index += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77s78u53.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmppda4npba.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i: usize = 0;\n    while i < sentence.len() {\n        if sentence[i]\
    \ == \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_sv1rpx.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpdcw4yp66.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    loop {\n\
    \        let mut word = words.next().unwrap();\n        if word == \"I\" {\n \
    \           boredoms += 1;\n        }\n        if word == \".\" || word == \"\
    ?\" || word == \"!\" {\n            break;\n        }\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmptbv4u_07.rs:13:37\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpiqj76e0b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpysgv2lyp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i: usize = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzgatv502.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmptb8xmgca.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpttzh_chb.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpttzh_chb.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpttzh_chb.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index = 0;\n    let mut word_index = 0;\n    while word_index\
    \ < sentence.len() {\n        if sentence[word_index].starts_with(\"I\") {\n \
    \           boredoms += 1;\n        }\n        word_index += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zo9otso.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            boredoms += 1;\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7o2dkyoo.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7o2dkyoo.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7o2dkyoo.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg4vxfqob.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg4vxfqob.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg4vxfqob.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplkb_sl_v.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplkb_sl_v.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplkb_sl_v.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace().collect();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpm9euqcsf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if S[i] ==\
    \ '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        } else {\n\
    \            bored += 1;\n        }\n        i += 1;\n    }\n    bored\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34z4yyjg.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp34z4yyjg.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp34z4yyjg.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjqjhbcs6.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjqjhbcs6.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjqjhbcs6.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1ztsxdd7.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1ztsxdd7.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1ztsxdd7.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7qc176a_.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7qc176a_.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7qc176a_.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] == \"I\"\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpc7caju8v.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpc7caju8v.rs:14:12\n   |\n14 |         if sentence[i] == \"I\" {\n  \
    \ |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo0twlo1v.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpjraklp4s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut boredoms_cnt = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \            boredoms_cnt += 1;\n        }\n    }\n    boredoms_cnt\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpgknmvflp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpjbdl95be.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ c = S[i];\n        if c == '.' || c == '?' || c == '!' {\n            boredoms.push(i);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy6jn7qw8.rs:13:17\n\
    \   |\n13 |         let c = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy6jn7qw8.rs:19:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n19 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n19 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            boredoms += 1;\n        }\n    \
    \    i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpewpc9a0_.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpewpc9a0_.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpewpc9a0_.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmijeqao.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            i += 1;\n        } else {\n    \
    \        boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd06iu1q1.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd06iu1q1.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd06iu1q1.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppy2l03ek.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppy2l03ek.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpjnkl0uep.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvxlyj9ar.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvxlyj9ar.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvxlyj9ar.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn27e39oy.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpe7w_f_7w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45uf0t16.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpnhokdt62.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp7lzrqq26.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms.push(words[i + 1]);\n            i += 2;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpuoslwrgw.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpuoslwrgw.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpuoslwrgw.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuoslwrgw.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    while s.len() > 0\
    \ {\n        let mut i = s.find('i');\n        if i == s.len() {\n           \
    \ break;\n        }\n        if s.starts_with(\"I\") {\n            boredoms +=\
    \ 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkt76c6ac.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpkt76c6ac.rs:20:14\n\
    \   |\n20 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkt76c6ac.rs:20:13\n\
    \   |\n11 |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n20 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n20 -         s = &s[i..];\n20 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0gjdpt2q.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0gjdpt2q.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0gjdpt2q.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpljpulan4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for w in\
    \ words {\n        if w == \"I\" {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpyvp6255k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpj_fsbiay.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpj_fsbiay.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpj_fsbiay.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms += 1;\n  \
    \      }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3synq7y4.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3synq7y4.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3synq7y4.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpchv738vm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = String::new();\n    let mut words\
    \ = S.split_whitespace();\n    for word in words {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n        sentence += &word + &\"\
    .\";\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&&str` to `&&str`\n  --> /tmp/tmpbsotw6p6.rs:17:27\n\
    \   |\n17 |         sentence += &word + &\".\";\n   |                     -----\
    \ ^ ---- &&str\n   |                     |\n   |                     &&str\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmps2h6dql5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpj2gptk3l.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpj2gptk3l.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    loop {\n        if\
    \ words.next().unwrap().is_empty() {\n            break;\n        }\n        if\
    \ words.next().unwrap().starts_with(\"I\") {\n            bored += 1;\n      \
    \  }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmphhn82akj.rs:13:25\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpd8dzwb4g.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpd8dzwb4g.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpsljesquq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2p2omkc3.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2p2omkc3.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2p2omkc3.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index: usize = 0;\n    let mut sentence_length: usize =\
    \ 0;\n    let mut sentence_words: Vec<&str> = Vec::new();\n    let mut sentence_word_index:\
    \ usize = 0;\n    let mut sentence_word_length: usize = 0;\n    let mut sentence_word_length2:\
    \ usize = 0;\n    let mut sentence_word_length3: usize = 0;\n    let mut sentence_word_length4:\
    \ usize = 0;\n    let mut sentence_word_length5: usize = 0;\n    let mut sentence_word_length6:\
    \ usize = 0;\n    let mut sentence_word_length7: usize = 0;\n    let mut sentence_word_length8:\
    \ usize = 0;\n    let mut sentence_word_length9: usize = 0;\n    let mut sentence_word_length10:\
    \ usize = 0;\n    let mut sentence_word_length11: usize = 0;\n    let mut sentence_word_length12:\
    \ usize = 0;\n    let mut sentence_word_length13: usize = 0;\n    let mut sentence_word_length14:\
    \ usize = 0;\n    let mut sentence_word_length15: usize = 0;\n    let mut sentence_word_length16:\
    \ usize = 0;\n    let mut sentence_word_length17: usize = 0;\n    let mut sentence_word_length18:\
    \ usize = 0;\n    let mut sentence_word_length19: usize = 0;\n    let mut sentence_word_length20:\
    \ usize = 0;\n    let mut sentence_word_length21: usize = 0;\n    let mut sentence_word_length22:\
    \ usize = 0;\n    let mut sentence_word_length23: usize = 0;\n    let mut sentence_word_length24:\
    \ usize = 0;\n    let mut sentence_word_length25: usize = 0;\n    let mut sentence_word_length26:\
    \ usize = 0;\n    let mut sentence_word_length27: usize = 0;\n    let mut sentence_word_length28:\
    \ usize = 0;\n    let mut sentence_word_length29: usize = 0;\n    let mut sentence_word_length30:\
    \ usize = 0;\n    let mut sentence_word_length31: usize = 0;\n    let mut sentence_word_length32:\
    \ usize = 0;\n    let mut sentence_word_length33: usize = 0;\n    let mut sentence_word_length34:\
    \ usize = 0;\n    let mut sentence_word_length35: usize = 0;\n    let mut sentence_word_length36:\
    \ usize = 0;\n    let mut sentence_word_length37: usize = 0;\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkb45vcck.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpkb45vcck.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n \
    \ |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ mut j = i;\n        while j < S.len() {\n            if S[j] == ' ' {\n    \
    \            break;\n            }\n            j += 1\n        }\n        if\
    \ j == i {\n            boredoms += 1;\n        }\n        i = j;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl4fiu301.rs:15:16\n\
    \   |\n15 |             if S[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut sentence_index: usize = 0;\n    for word in sentence {\n        if\
    \ word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n        sentence_index\
    \ += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpum3veoi5.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3z1xd3af.rs:13:12\n\
    \   |\n13 |         if S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3z1xd3af.rs:13:27\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3z1xd3af.rs:13:42\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                                          ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut word: &str = sentence.first().unwrap();\n    while let Some(word)\
    \ = sentence.next() {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntmkgye9.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `next`\
    \ found for struct `Vec<&str>` in the current scope\n  --> /tmp/tmpntmkgye9.rs:13:37\n\
    \   |\n13 |     while let Some(word) = sentence.next() {\n   |               \
    \                      ^^^^ method not found in `Vec<&str>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpelape7af.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpelape7af.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpelape7af.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0kfgh9bq.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp0kfgh9bq.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpgwjvpk59.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqccfs1iw.rs:13:12\n\
    \   |\n13 |         if S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqccfs1iw.rs:13:27\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqccfs1iw.rs:13:42\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                                          ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i..].iter().cloned().collect::<Vec<_>>());\n        \
    \    i += 3;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|x|\
    \ x.len() == 1).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpwln9l2gm.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpwln9l2gm.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpwln9l2gm.rs:15:27\n   |\n15 |             boredoms.push(words[i..].iter().cloned().collect::<Vec<_>>());\n\
    \   |                           ^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0k1zvuco.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp0k1zvuco.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpkwukc3wx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpnqqz118c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = vec![];\n    let mut words = S.split_whitespace();\n    let mut i\
    \ = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n        \
    \    boredoms.push(words[i + 1]);\n            i += 2;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpnyf8og_k.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpnyf8og_k.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpnyf8og_k.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnyf8og_k.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    while s.len() > 0\
    \ {\n        let mut i = s.find('i');\n        if i == s.len() {\n           \
    \ break;\n        }\n        if s.starts_with(\"i\") {\n            boredoms +=\
    \ 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl2t4l2dq.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpl2t4l2dq.rs:20:14\n\
    \   |\n20 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2t4l2dq.rs:20:13\n\
    \   |\n11 |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n20 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n20 -         s = &s[i..];\n20 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_symbol()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxwln814v.rs:133:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n...\n13  |     while i < sentence.len() {\n \
    \   |                              - this delimiter might not be properly closed...\n\
    ...\n123 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n133 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpxwln814v.rs:123:1\n\
    \    |\n122 |         if sentence[i].is_ascii_\n    |         -- this `if` expression\
    \ has a condition, but no block\n123 | }\n    | ^ expected `{`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpxwln814v.rs:13:24\n   |\n13 |     while i < sentence.len() {\n\
    \   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpxwln814v.rs:14:12\n\
    \   |\n14 |         if sentence[i].is_ascii_lowercase() {\n   |            ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpxwln814v.rs:18:12\n   |\n18 |         if sentence[i].is_ascii_uppercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpxwln814v.rs:22:12\n   |\n22 |    \
    \     if sentence[i].is_ascii_punctuation() {\n   |            ^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpxwln814v.rs:26:12\n\
    \   |\n26 |         if sentence[i].is_ascii_digit() {\n   |            ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpxwln814v.rs:30:12\n   |\n30 |         if sentence[i].is_ascii_symbol()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpxwln814v.rs:34:12\n   |\n34 |    \
    \     if sentence[i].is_ascii_punctuation() {\n   |            ^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            i += 1;\n        } else {\n    \
    \        boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqmc4dp_s.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqmc4dp_s.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqmc4dp_s.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut s = S.to_string();\n    let mut i = 0;\n \
    \   while i < s.len() {\n        if s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdwcuz4fz.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdwcuz4fz.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdwcuz4fz.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let\
    \ mut boredom_word_count: Vec<usize> = vec![];\n    let mut boredom_word_length:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count: Vec<usize> = vec![];\n\
    \    let mut boredom_word_length_count2: Vec<usize> = vec![];\n    let mut boredom_word_length_count3:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count4: Vec<usize> = vec![];\n\
    \    let mut boredom_word_length_count5: Vec<usize> = vec![];\n    let mut boredom_word_length_count6:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count7: Vec<usize> = vec![];\n\
    \    let mut boredom_word_length_count8: Vec<usize> = vec![];\n    let mut boredom_word_length_count9:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count10: Vec<usize> =\
    \ vec![];\n    let mut boredom_word_length_count11: Vec<usize> = vec![];\n   \
    \ let mut boredom_word_length_count12: Vec<usize> = vec![];\n    let mut boredom_word_length_count13:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count14: Vec<usize> =\
    \ vec![];\n    let mut boredom_word_length_count15: Vec<usize> = vec![];\n   \
    \ let mut boredom_word_length_count16: Vec<usize> = vec![];\n    let mut boredom_word_length_count17:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count18: Vec<usize> =\
    \ vec![];\n    let mut boredom_word_length_count19: Vec<usize> = vec![];\n   \
    \ let mut boredom_word_length_count20: Vec<usize> = vec![];\n    let mut boredom_word_length_count21:\
    \ Vec<usize> = vec![];\n    let mut boredom_word_length_count22\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpessnk6co.rs:35:40\n   |\n\
    35 |     let mut boredom_word_length_count22\n   |                           \
    \             ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpessnk6co.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut words = S.split_whitespace();\n    for w in words {\n\
    \        if w == \"I\" {\n            bored += 1;\n        }\n    }\n    bored\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpgxf8_yk5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9tta8ir9.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9tta8ir9.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9tta8ir9.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpfddua11d.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpfddua11d.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n    let\
    \ mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjhsjx3eo.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpjhsjx3eo.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpjhsjx3eo.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence = S.to_string();\n    let mut i =\
    \ 0;\n    while i < sentence.len() {\n        if sentence[i] == '.' || sentence[i]\
    \ == '?' || sentence[i] == '!' {\n            i += 1;\n        } else {\n    \
    \        boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptdw5oba0.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptdw5oba0.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptdw5oba0.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpbcepjmv5.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if words[i] == \"I\" {\n      \
    \      boredoms.push(words[i]);\n        }\n        i += 1;\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpd9vgu8ey.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpd9vgu8ey.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpd9vgu8ey.rs:15:27\n   |\n15 |             boredoms.push(words[i]);\n\
    \   |                           ^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpd9vgu8ey.rs:19:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n19 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    for s in sentence {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1om91so.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n    for word\
    \ in words {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpyg1uc4rm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        if\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2_rqtix_.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2_rqtix_.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2_rqtix_.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  exit_code: 1
  status: SyntaxError
